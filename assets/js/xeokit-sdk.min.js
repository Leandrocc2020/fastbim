class Map$1 { constructor(e, t) { this.items = e || [], this._lastUniqueId = (t || 0) + 1 } addItem() { let e; if (2 === arguments.length) { var t = arguments[0]; if (e = arguments[1], this.items[t]) throw "ID clash: '" + t + "'"; return this.items[t] = e, t } for (e = arguments[0] || {}; ;) { var i = this._lastUniqueId++; if (!this.items[i]) return this.items[i] = e, i } } removeItem(e) { var t = this.items[e]; return delete this.items[e], t } } const idMap$1 = new Map$1; class Menu { constructor(e) { this.id = e, this.parentItem = null, this.groups = [], this.menuElement = null, this.shown = !1, this.mouseOver = 0 } } class Group { constructor() { this.items = [] } } class Item { constructor(e, t, i, s, r) { this.id = e, this.getTitle = t, this.doAction = i, this.getEnabled = s, this.getShown = r, this.itemElement = null, this.subMenu = null, this.enabled = !0 } } class ContextMenu { constructor(e = {}) { this._id = idMap$1.addItem(), this._context = null, this._enabled = !1, this._itemsCfg = [], this._rootMenu = null, this._menuList = [], this._menuMap = {}, this._itemList = [], this._itemMap = {}, this._shown = !1, this._nextId = 0, !(this._eventSubs = {}) !== e.hideOnMouseDown && (document.addEventListener("mousedown", (e => { e.target.classList.contains("xeokit-context-menu-item") || this.hide() })), document.addEventListener("touchstart", this._canvasTouchStartHandler = e => { e.target.classList.contains("xeokit-context-menu-item") || this.hide() })), e.items && (this.items = e.items), this.context = e.context, this.enabled = !1 !== e.enabled, this.hide() } on(e, t) { let i = this._eventSubs[e]; i || (i = [], this._eventSubs[e] = i), i.push(t) } fire(e, t) { var i = this._eventSubs[e]; if (i) for (let e = 0, s = i.length; e < s; e++)i[e](t) } set items(e) { this._clear(), this._itemsCfg = e || [], this._parseItems(e), this._createUI() } get items() { return this._itemsCfg } set enabled(e) { (e = !!e) === this._enabled || (this._enabled = e, this._enabled) || this.hide() } get enabled() { return this._enabled } set context(e) { this._context = e } get context() { return this._context } show(e, t) { this._context ? this._enabled && !this._shown && (this._hideAllMenus(), this._updateItemsTitles(), this._updateItemsEnabledStatus(), this._showMenu(this._rootMenu.id, e, t), this._shown = !0, this.fire("shown", {})) : console.error("ContextMenu cannot be shown without a context - set context first") } get shown() { return this._shown } hide() { this._enabled && this._shown && (this._hideAllMenus(), this._shown = !1, this.fire("hidden", {})) } destroy() { this._context = null, this._clear(), null !== this._id && (idMap$1.removeItem(this._id), this._id = null) } _clear() { for (let t = 0, i = this._menuList.length; t < i; t++) { var e = this._menuList[t].menuElement; e.parentElement.removeChild(e) } this._itemsCfg = [], this._rootMenu = null, this._menuList = [], this._menuMap = {}, this._itemList = [], this._itemMap = {} } _parseItems(e) { const t = e => { var i = this._getNextId(), s = new Menu(i); for (let i = 0, d = e.length; i < d; i++) { var r = e[i], a = new Group; s.groups.push(a); for (let e = 0, i = r.length; e < i; e++) { const i = r[e]; var o = i.items, n = o && 0 < o.length, h = this._getNextId(), l = i.getTitle || (() => i.title || ""), c = i.doAction || i.callback || (() => { }), u = i.getEnabled || (() => !0), p = i.getShown || (() => !0); (h = new Item(h, l, c, u, p)).parentMenu = s, a.items.push(h), n && (l = t(o), (h.subMenu = l).parentItem = h), this._itemList.push(h), this._itemMap[h.id] = h } } return this._menuList.push(s), this._menuMap[s.id] = s }; this._rootMenu = t(e) } _getNextId() { return "ContextMenu_" + this._id + this._nextId++ } _createUI() { const e = t => { this._createMenuUI(t); var i = t.groups; for (let t = 0, a = i.length; t < a; t++) { var s = i[t].items; for (let t = 0, i = s.length; t < i; t++) { var r = s[t].subMenu; r && e(r) } } }; e(this._rootMenu) } _createMenuUI(e) { var t = e.groups, i = []; if (i.push('<div class="xeokit-context-menu ' + e.id + '" style="z-index:300000; position: absolute;">'), i.push("<ul>"), t) for (let e = 0, l = t.length; e < l; e++) { var s = e, r = l, a = t[e].items; if (a) for (let e = 0, t = a.length; e < t; e++) { var o = a[e], n = o.subMenu, h = o.title || ""; i.push(n ? '<li id="' + o.id + '" class="xeokit-context-menu-item" style="' + (s === r - 1 || e < t - 1 ? "border-bottom: 0" : "border-bottom: 1px solid black") + '">' + h + " [MORE]</li>" : '<li id="' + o.id + '" class="xeokit-context-menu-item" style="' + (s === r - 1 || e < t - 1 ? "border-bottom: 0" : "border-bottom: 1px solid black") + '">' + h + "</li>") } } i.push("</ul>"), i.push("</div>"); var l = i.join(""); document.body.insertAdjacentHTML("beforeend", l), l = document.querySelector("." + e.id); (e.menuElement = l).style["border-radius"] = "4px", l.style.display = "none", l.style["z-index"] = 3e5, l.style.background = "white", l.style.border = "1px solid black", l.style["box-shadow"] = "0 4px 5px 0 gray", l.oncontextmenu = e => { e.preventDefault() }; const c = this; let u = null; if (t) for (let e = 0, i = t.length; e < i; e++) { var p = t[e].items; if (p) for (let e = 0, t = p.length; e < t; e++) { const t = p[e]; var d = t.subMenu; t.itemElement = document.getElementById(t.id), t.itemElement ? (t.itemElement.addEventListener("mouseenter", (e => { var i, s; e.preventDefault(), (e = t.subMenu) ? (u && u.id !== e.id && (c._hideMenu(u.id), u = null), !1 !== t.enabled && (s = t.itemElement, i = e.menuElement, s = s.getBoundingClientRect(), i.getBoundingClientRect(), s.right + 200 > window.innerWidth ? c._showMenu(e.id, s.left - 200, s.top - 1) : c._showMenu(e.id, s.right - 5, s.top - 1), u = e)) : u && (c._hideMenu(u.id), u = null) })), d || (t.itemElement.addEventListener("click", (e => { e.preventDefault(), c.hide(), c._context && !1 !== t.enabled && t.doAction && t.doAction(c._context) })), t.itemElement.addEventListener("mouseenter", (e => { e.preventDefault(), !1 !== t.enabled && t.doHover && t.doHover(c._context) })))) : console.error("ContextMenu item element not found: " + t.id) } } } _updateItemsTitles() { if (this._context) for (let s = 0, r = this._itemList.length; s < r; s++) { var e, t = this._itemList[s], i = t.itemElement; i && (e = t.getShown) && e(this._context) && (e = t.getTitle(this._context), t.subMenu, i.innerText = e) } } _updateItemsEnabledStatus() { if (this._context) for (let r = 0, a = this._itemList.length; r < a; r++) { var e, t, i = this._itemList[r], s = i.itemElement; s && (e = i.getEnabled) && (t = i.getShown) && (t = t(this._context), (i.shown = t) ? (s.style.visibility = "visible", s.style.height = "auto", s.style.padding = null, t = e(this._context), (i.enabled = t) ? s.classList.remove("disabled") : s.classList.add("disabled")) : (s.style.visibility = "hidden", s.style.height = "0", s.style.padding = "0")) } } _showMenu(e, t, i) { var s, r = this._menuMap[e]; r ? r.shown || (s = r.menuElement) && (this._showMenuElement(s, t, i), r.shown = !0) : console.error("Menu not found: " + e) } _hideMenu(e) { var t, i = this._menuMap[e]; i ? i.shown && (t = i.menuElement) && (this._hideMenuElement(t), i.shown = !1) : console.error("Menu not found: " + e) } _hideAllMenus() { for (let t = 0, i = this._menuList.length; t < i; t++) { var e = this._menuList[t]; this._hideMenu(e.id) } } _showMenuElement(e, t, i) { e.style.display = "block"; var s = e.offsetHeight, r = e.offsetWidth; i + s > window.innerHeight && (i = window.innerHeight - s), t + r > window.innerWidth && (t = window.innerWidth - r), e.style.left = t + "px", e.style.top = i + "px" } _hideMenuElement(e) { e.style.display = "none" } } class Queue { constructor() { this._head = [], this._headLength = 0, this._tail = [], this._index = 0, this._length = 0 } get length() { return this._length } shift() { if (this._index >= this._headLength) { var e = this._head; if (e.length = 0, this._head = this._tail, this._tail = e, this._index = 0, this._headLength = this._head.length, !this._headLength) return } return e = this._head[this._index], this._index < 0 ? delete this._head[this._index++] : this._head[this._index++] = void 0, this._length--, e } push(e) { return this._length++, this._tail.push(e), this } unshift(e) { return this._head[--this._index] = e, this._length++, this } } const stats = { build: { version: "0.8" }, client: { browser: navigator && navigator.userAgent ? navigator.userAgent : "n/a" }, components: { scenes: 0, models: 0, meshes: 0, objects: 0 }, memory: { meshes: 0, positions: 0, colors: 0, normals: 0, uvs: 0, indices: 0, textures: 0, transforms: 0, materials: 0, programs: 0 }, frame: { frameCount: 0, fps: 0, useProgram: 0, bindTexture: 0, bindArray: 0, drawElements: 0, drawArrays: 0, tasksRun: 0, tasksScheduled: 0 } }; function xmlToJson(e, t) { if (e.nodeType === e.TEXT_NODE) { var i = e.nodeValue; if (null === i.match(/^\s+$/)) return i } else if (e.nodeType === e.ELEMENT_NODE || e.nodeType === e.DOCUMENT_NODE) { var s = { type: e.nodeName, children: [] }; if (e.nodeType === e.ELEMENT_NODE) for (var r = 0; r < e.attributes.length; r++) { var a = e.attributes[r]; s[t[a.nodeName] || a.nodeName] = a.nodeValue } for (var o = 0; o < e.childNodes.length; o++)(r = xmlToJson(e.childNodes[o], t)) && s.children.push(r); return s } } function clone(e) { return JSON.parse(JSON.stringify(e)) } var guidChars = [["0", 10], ["A", 26], ["a", 26], ["_", 1], ["$", 1]].map((function (e) { for (var t = [], i = e[0].charCodeAt(0), s = i + e[1], r = i; r < s; ++r)t.push(r); return String.fromCharCode.apply(null, t) })).join(""); function b64(e, t) { return (t && 4 !== t ? [0, 6] : [0, 6, 12, 18]).map((function (t) { return guidChars.substr(parseInt(e / (1 << t)) % 64, 1) })).reverse().join("") } function compressGuid(e) { var t = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map((function (t) { return parseInt(e.substr(t, 2), 16) })); return b64(t[0], 2) + [1, 4, 7, 10, 13].map((function (e) { return b64((t[e] << 16) + (t[e + 1] << 8) + t[e + 2]) })).join("") } function findNodeOfType(e, t) { var i = []; return function e(s) { s.type === t && i.push(s), (s.children || []).forEach((function (t) { e(t) })) }(e), i } function timeout(e) { return new Promise((function (t, i) { setTimeout(t, e) })) } function httpRequest(e) { return new Promise((function (t, i) { var s = new XMLHttpRequest; s.open(e.method || "GET", e.url, !0), s.onload = function (r) { console.log(e.url, s.readyState, s.status), 4 === s.readyState && (200 === s.status ? t(s.responseXML) : i(s.statusText)) }, s.send(null) })) } const queryString = function () { for (var e = {}, t = window.location.search.substring(1).split("&"), i = 0; i < t.length; i++) { var s, r = t[i].split("="); void 0 === e[r[0]] ? e[r[0]] = decodeURIComponent(r[1]) : "string" == typeof e[r[0]] ? (s = [e[r[0]], decodeURIComponent(r[1])], e[r[0]] = s) : e[r[0]].push(decodeURIComponent(r[1])) } return e }(); function loadJSON(e, t, i) { var s = e => { }; t = t || s, i = i || s, (s = new XMLHttpRequest).overrideMimeType("application/json"), s.open("GET", e, !0), s.addEventListener("load", (function (e) { var s, r = e.target.response; if (200 === this.status) { try { s = JSON.parse(r) } catch (e) { i("utils.loadJSON(): Failed to parse JSON response - " + e) } t(s) } else if (0 === this.status) { console.warn("loadFile: HTTP Status 0 received."); try { t(JSON.parse(r)) } catch (e) { i("utils.loadJSON(): Failed to parse JSON response - " + e) } } else i(e) }), !1), s.addEventListener("error", (function (e) { i(e) }), !1), s.send(null) } function loadArraybuffer$1(e, t, i) { var s = e => { }; if (t = t || s, i = i || s, s = e.match(/^data:(.*?)(;base64)?,(.*)$/)) { var r = !!s[2], a = s[3]; a = window.decodeURIComponent(a); r && (a = window.atob(a)); try { const e = new ArrayBuffer(a.length); for (var o = new Uint8Array(e), n = 0; n < a.length; n++)o[n] = a.charCodeAt(n); window.setTimeout((function () { t(e) }), 0) } catch (e) { window.setTimeout((function () { i(e) }), 0) } } else { const s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onreadystatechange = function () { 4 === s.readyState && (200 === s.status ? t(s.response) : i("loadArrayBuffer error : " + s.response)) }, s.send(null) } } function isArray(e) { return e && !e.propertyIsEnumerable("length") && "object" == typeof e && "number" == typeof e.length } function isString(e) { return "string" == typeof e || e instanceof String } function isNumeric(e) { return !isNaN(parseFloat(e)) && isFinite(e) } function isID(e) { return utils.isString(e) || utils.isNumeric(e) } function isSameComponent(e, t) { return !(!e || !t) && (utils.isNumeric(e) || utils.isString(e) ? "" + e : e.id) === (utils.isNumeric(t) || utils.isString(t) ? "" + t : t.id) } function isFunction$1(e) { return "function" == typeof e } function isObject$1(e) { return !!e && e.constructor === {}.constructor } function copy(e) { return utils.apply(e, {}) } function apply(e, t) { for (const i in e) e.hasOwnProperty(i) && (t[i] = e[i]); return t } function apply2(e, t) { for (const i in e) e.hasOwnProperty(i) && void 0 !== e[i] && null !== e[i] && (t[i] = e[i]); return t } function applyIf(e, t) { for (const i in e) !e.hasOwnProperty(i) || void 0 !== t[i] && null !== t[i] || (t[i] = e[i]); return t } function isEmptyObject$1(e) { for (const t in e) if (e.hasOwnProperty(t)) return !1; return !0 } function inQuotes(e) { return utils.isNumeric(e) ? "" + e : `'${e}'` } function concat(e, t) { var i = new e.constructor(e.length + t.length); return i.set(e), i.set(t, e.length), i } function flattenParentChildHierarchy(e) { var t = []; return function e(i) { i.id = i.uuid, delete i.oid, t.push(i); var s = i.children; if (s) for (var r = 0, a = s.length; r < a; r++)s[r].parent = i.id, e(s[r]); i.children = [] }(e), t } const utils = { xmlToJson: xmlToJson, clone: clone, compressGuid: compressGuid, findNodeOfType: findNodeOfType, timeout: timeout, httpRequest: httpRequest, loadJSON: loadJSON, loadArraybuffer: loadArraybuffer$1, queryString: queryString, isArray: isArray, isString: isString, isNumeric: isNumeric, isID: isID, isSameComponent: isSameComponent, isFunction: isFunction$1, isObject: isObject$1, copy: copy, apply: apply, apply2: apply2, applyIf: applyIf, isEmptyObject: isEmptyObject$1, inQuotes: inQuotes, concat: concat, flattenParentChildHierarchy: flattenParentChildHierarchy }, scenesRenderInfo = {}, sceneIDMap = new Map$1, taskQueue = new Queue, tickEvent = { sceneId: null, time: null, startTime: null, prevTime: null, deltaTime: null }, taskBudget = 10, fpsSamples = [], numFPSSamples = 30; let elapsedTime, lastTime = 0, totalFPS = 0; function Core() { this.version = "1.0.0", this.scenes = {}, this._superTypes = {}, this._addScene = function (e) { if (e.id) { if (core.scenes[e.id]) return void console.error(`[ERROR] Scene ${utils.inQuotes(e.id)} already exists`) } else e.id = sceneIDMap.addItem({}); var t = (core.scenes[e.id] = e).ticksPerOcclusionTest, i = e.ticksPerRender; scenesRenderInfo[e.id] = { ticksPerOcclusionTest: t, ticksPerRender: i, renderCountdown: i }, stats.components.scenes++, e.once("destroyed", (() => { sceneIDMap.removeItem(e.id), delete core.scenes[e.id], delete scenesRenderInfo[e.id], stats.components.scenes-- })) }, this.clear = function () { var e; for (const t in core.scenes) core.scenes.hasOwnProperty(t) && (e = core.scenes[t], "default.scene" === t ? e.clear() : (e.destroy(), delete core.scenes[e.id])) }, this.scheduleTask = function (e, t) { taskQueue.push(e), taskQueue.push(t) }, this.runTasks = function (e = -1) { let t = (new Date).getTime(); var i, s; let r = 0; for (; 0 < taskQueue.length && (e < 0 || t < e);)i = taskQueue.shift(), (s = taskQueue.shift()) ? i.call(s) : i(), t = (new Date).getTime(), r++; return r }, this.getNumTasks = function () { return taskQueue.length } } const core = new Core, frame = function () { var e, t = Date.now(); 0 < lastTime && (e = 1e3 / (elapsedTime = t - lastTime), totalFPS += e, fpsSamples.push(e), fpsSamples.length >= 30 && (totalFPS -= fpsSamples.shift()), stats.frame.fps = Math.round(totalFPS / fpsSamples.length)), runTasks(t), fireTickEvents(t), renderScenes(), lastTime = t, void 0 !== window.requestPostAnimationFrame ? window.requestPostAnimationFrame(frame) : requestAnimationFrame(frame) }; function runTasks(e) { e = core.runTasks(e + 10); var t = core.getNumTasks(); stats.frame.tasksRun = e, stats.frame.tasksScheduled = t, stats.frame.tasksBudget = 10 } function fireTickEvents(e) { for (var t in tickEvent.time = e, core.scenes) { var i; core.scenes.hasOwnProperty(t) && (i = core.scenes[t], tickEvent.sceneId = t, tickEvent.startTime = i.startTime, tickEvent.deltaTime = null != tickEvent.prevTime ? tickEvent.time - tickEvent.prevTime : 0, i.fire("tick", tickEvent, !0)) } tickEvent.prevTime = e } function renderScenes() { var e, t, i = core.scenes; let s, r; for (r in i) i.hasOwnProperty(r) && (e = i[r], s = (s = scenesRenderInfo[r]) || (scenesRenderInfo[r] = {}), t = e.ticksPerOcclusionTest, s.ticksPerOcclusionTest !== t && (s.ticksPerOcclusionTest = t, s.renderCountdown = t), --e.occlusionTestCountdown <= 0 && (e.doOcclusionTest(), e.occlusionTestCountdown = t), t = e.ticksPerRender, s.ticksPerRender !== t && (s.ticksPerRender = t, s.renderCountdown = t), 0 == --s.renderCountdown) && (e.render(!1), s.renderCountdown = t) } void 0 !== window.requestPostAnimationFrame ? window.requestPostAnimationFrame(frame) : requestAnimationFrame(frame); class Component { get type() { return "Component" } get isComponent() { return !0 } constructor(e = null, t = {}) { if (this.scene = null, "Scene" === this.type) (this.scene = this).viewer = t.viewer; else { if ("Scene" === e.type) this.scene = e; else { if (!(e instanceof Component)) throw "Invalid param: owner must be a Component"; this.scene = e.scene } this._owner = e, this._renderer = this.scene._renderer } this._dontClear = !!t.dontClear, this._renderer = this.scene._renderer, this.meta = t.meta || {}, this.id = t.id, this.destroyed = !1, this._attached = {}, this._attachments = null, this._subIdMap = null, this._subIdEvents = null, this._eventSubs = null, this._eventSubsNum = null, this._events = null, this._eventCallDepth = 0, this._ownedComponents = null, this !== this.scene && this.scene._addComponent(this), this._updateScheduled = !1, e && e._own(this) } glRedraw() { this._renderer && (this._renderer.imageDirty(), this.castsShadow) && this._renderer.shadowsDirty() } glResort() { this._renderer && this._renderer.needStateSort() } get owner() { return this._owner } isType(e) { return this.type === e } fire(e, t, i) { this._events || (this._events = {}), this._eventSubs || (this._eventSubs = {}, this._eventSubsNum = {}), !0 !== i && (this._events[e] = t || !0); var s, r = this._eventSubs[e]; if (r) for (const i in r) r.hasOwnProperty(i) && (s = r[i], this._eventCallDepth++, this._eventCallDepth < 300 ? s.callback.call(s.scope, t) : this.error("fire: potential stack overflow from recursive event '" + e + "' - dropping this event"), this._eventCallDepth--) } on(e, t, i) { this._events || (this._events = {}), this._subIdMap || (this._subIdMap = new Map$1), this._subIdEvents || (this._subIdEvents = {}), this._eventSubs || (this._eventSubs = {}), this._eventSubsNum || (this._eventSubsNum = {}); let s = this._eventSubs[e]; s ? this._eventSubsNum[e]++ : (s = {}, this._eventSubs[e] = s, this._eventSubsNum[e] = 1); var r = this._subIdMap.addItem(); return s[r] = { callback: t, scope: i || this }, this._subIdEvents[r] = e, void 0 !== (e = this._events[e]) && t.call(i || this, e), r } off(e) { var t, i; null != e && this._subIdEvents && (t = this._subIdEvents[e]) && (delete this._subIdEvents[e], (i = this._eventSubs[t]) && (delete i[e], this._eventSubsNum[t]--), this._subIdMap.removeItem(e)) } once(e, t, i) { const s = this, r = this.on(e, (function (e) { s.off(r), t.call(i || this, e) }), i) } hasSubs(e) { return this._eventSubsNum && 0 < this._eventSubsNum[e] } log(e) { e = "[LOG]" + this._message(e), window.console.log(e), this.scene.fire("log", e) } _message(e) { return " [" + this.type + " " + utils.inQuotes(this.id) + "]: " + e } warn(e) { e = "[WARN]" + this._message(e), window.console.warn(e), this.scene.fire("warn", e) } error(e) { e = "[ERROR]" + this._message(e), window.console.error(e), this.scene.fire("error", e) } _attach(e) { var t = e.name; if (t) { let d = e.component; var i = e.sceneDefault, s = e.sceneSingleton, r = e.type, a = e.on, o = !1 !== e.recompiles; if (d && (utils.isNumeric(d) || utils.isString(d))) { var n = d; if (!(d = this.scene.components[n])) return void this.error("Component not found: " + utils.inQuotes(n)) } if (!d) if (!0 === s) { var h = this.scene.types[r]; for (const e in h) if (h.hasOwnProperty) { d = h[e]; break } if (!d) return this.error("Scene has no default component for '" + t + "'"), null } else if (!0 === i && !(d = this.scene[t])) return this.error("Scene has no default component for '" + t + "'"), null; if (d) { if (d.scene.id !== this.scene.id) return void this.error("Not in same scene: " + d.type + " " + utils.inQuotes(d.id)); if (r && !d.isType(r)) return void this.error("Expected a " + r + " type or subtype: " + d.type + " " + utils.inQuotes(d.id)) } this._attachments || (this._attachments = {}); var l, c, u = this._attached[t]; let m; if (u) { if (d && u.id === d.id) return; var p = (n = this._attachments[u.id]).subs; for (m = 0, l = p.length; m < l; m++)u.off(p[m]); delete this._attached[t], delete this._attachments[u.id], (s = n.params.onDetached) && (utils.isFunction(s) ? s(u) : s.scope ? s.callback.call(s.scope, u) : s.callback(u)), n.managingLifecycle && u.destroy() } if (d) { const s = { params: e, component: d, subs: [], managingLifecycle: !1 }; if (s.subs.push(d.once("destroyed", (function () { s.params.component = null, this._attach(s.params) }), this)), o && s.subs.push(d.on("dirty", (function () { this.fire("dirty", this) }), this)), this._attached[t] = d, this._attachments[d.id] = s, (i = e.onAttached) && (utils.isFunction(i) ? i(d) : i.scope ? i.callback.call(i.scope, d) : i.callback(d)), a) { let e, t, i; for (e in a) a.hasOwnProperty(e) && (c = a[e], i = utils.isFunction(c) ? (t = c, null) : (t = c.callback, c.scope), t) && s.subs.push(d.on(e, t, i)) } } return o && this.fire("dirty", this), this.fire(t, d), d } this.error("Component 'name' expected") } _checkComponent(e, t) { if (!t.isComponent) { if (!utils.isID(t)) return void this.error("Expected a Component or ID"); var i = t; if (!(t = this.scene.components[i])) return void this.error("Component not found: " + i) } if (e !== t.type) this.error("Expected a " + e + " Component"); else { if (t.scene.id === this.scene.id) return t; this.error("Not in same scene: " + t.type) } } _checkComponent2(e, t) { if (!t.isComponent) { if (!utils.isID(t)) return void this.error("Expected a Component or ID"); var i = t; if (!(t = this.scene.components[i])) return void this.error("Component not found: " + i) } if (t.scene.id === this.scene.id) { for (var s = 0, r = e.length; s < r; s++)if (e[s] === t.type) return t; return this.error("Expected component types: " + e), null } this.error("Not in same scene: " + t.type) } _own(e) { this._ownedComponents || (this._ownedComponents = {}), this._ownedComponents[e.id] || (this._ownedComponents[e.id] = e), e.once("destroyed", (() => { delete this._ownedComponents[e.id] }), this) } _needUpdate(e) { this._updateScheduled || (this._updateScheduled = !0, 0 === e ? this._doUpdate() : core.scheduleTask(this._doUpdate, this)) } _doUpdate() { this._updateScheduled && (this._updateScheduled = !1, this._update) && this._update() } _update() { } clear() { if (this._ownedComponents) for (var e in this._ownedComponents) this._ownedComponents.hasOwnProperty(e) && (this._ownedComponents[e].destroy(), delete this._ownedComponents[e]) } destroy() { if (!this.destroyed) { let s; var e, t, i; let r, a; if (this.fire("destroyed", this.destroyed = !0), this._attachments) for (s in this._attachments) if (this._attachments.hasOwnProperty(s)) { for (r = (e = this._attachments[s]).component, a = 0, i = (t = e.subs).length; a < i; a++)r.off(t[a]); e.managingLifecycle && r.destroy() } if (this._ownedComponents) for (s in this._ownedComponents) this._ownedComponents.hasOwnProperty(s) && ((r = this._ownedComponents[s]).destroy(), delete this._ownedComponents[s]); this.scene._removeComponent(this), this._attached = {}, this._attachments = null, this._subIdMap = null, this._subIdEvents = null, this._eventSubs = null, this._events = null, this._eventCallDepth = 0, this._ownedComponents = null, this._updateScheduled = !1 } } } let doublePrecision = !0, FloatArrayType = doublePrecision ? Float64Array : Float32Array; const tempMat1 = new FloatArrayType(16), tempMat2 = new FloatArrayType(16), tempVec4$8 = new FloatArrayType(4), math = { setDoublePrecisionEnabled(e) { doublePrecision = e, FloatArrayType = doublePrecision ? Float64Array : Float32Array }, getDoublePrecisionEnabled: () => doublePrecision, MIN_DOUBLE: -Number.MAX_SAFE_INTEGER, MAX_DOUBLE: Number.MAX_SAFE_INTEGER, DEGTORAD: .0174532925, RADTODEG: 57.295779513, unglobalizeObjectId(e, t) { var i = t.indexOf("#"); return i === e.length && t.startsWith(e) ? t.substring(i + 1) : t }, globalizeObjectId: (e, t) => e + "#" + t, vec2: e => new FloatArrayType(e || 2), vec3: e => new FloatArrayType(e || 3), vec4: e => new FloatArrayType(e || 4), mat3: e => new FloatArrayType(e || 9), mat3ToMat4: (e, t = new FloatArrayType(16)) => (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = 0, t[4] = e[3], t[5] = e[4], t[6] = e[5], t[7] = 0, t[8] = e[6], t[9] = e[7], t[10] = e[8], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t), mat4: e => new FloatArrayType(e || 16), mat4ToMat3(e, t) { }, doublesToFloats(e, t, i) { var s = new FloatArrayType(2); for (let r = 0, a = e.length; r < a; r++)math.splitDouble(e[r], s), t[r] = s[0], i[r] = s[1] }, splitDouble(e, t) { var i = FloatArrayType.from([e])[0]; e -= i; t[0] = i, t[1] = e }, createUUID: (() => { const e = []; for (let t = 0; t < 256; t++)e[t] = (t < 16 ? "0" : "") + t.toString(16); return () => { var t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, s = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return `${e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255]}-${e[255 & i]}${e[i >> 8 & 255]}-${e[i >> 16 & 15 | 64]}${e[i >> 24 & 255]}-${e[63 & s | 128]}${e[s >> 8 & 255]}-` + e[s >> 16 & 255] + e[s >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255] } })(), clamp: (e, t, i) => Math.max(t, Math.min(i, e)), fmod(e, t) { if (e < t) console.error("math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring"); else for (; t <= e;)e -= t; return e }, compareVec3: (e, t) => e[0] === t[0] && e[1] === t[1] && e[2] === t[2], negateVec3: (e, t) => ((t = t || e)[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t), negateVec4: (e, t) => ((t = t || e)[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t), addVec4: (e, t, i) => ((i = i || e)[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i[3] = e[3] + t[3], i), addVec4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] + t, i[1] = e[1] + t, i[2] = e[2] + t, i[3] = e[3] + t, i), addVec3: (e, t, i) => ((i = i || e)[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i), addVec3Scalar: (e, t, i) => ((i = i || e)[0] = e[0] + t, i[1] = e[1] + t, i[2] = e[2] + t, i), subVec4: (e, t, i) => ((i = i || e)[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i[3] = e[3] - t[3], i), subVec3: (e, t, i) => ((i = i || e)[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i), subVec2: (e, t, i) => ((i = i || e)[0] = e[0] - t[0], i[1] = e[1] - t[1], i), geometricMeanVec2(...e) { var t = new FloatArrayType(e[0]); for (let i = 1; i < e.length; i++)t[0] += e[i][0], t[1] += e[i][1]; return t[0] /= e.length, t[1] /= e.length, t }, subVec4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] - t, i[1] = e[1] - t, i[2] = e[2] - t, i[3] = e[3] - t, i), subScalarVec4: (e, t, i) => ((i = i || e)[0] = t - e[0], i[1] = t - e[1], i[2] = t - e[2], i[3] = t - e[3], i), mulVec4: (e, t, i) => ((i = i || e)[0] = e[0] * t[0], i[1] = e[1] * t[1], i[2] = e[2] * t[2], i[3] = e[3] * t[3], i), mulVec4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i), mulVec3Scalar: (e, t, i) => ((i = i || e)[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i), mulVec2Scalar: (e, t, i) => ((i = i || e)[0] = e[0] * t, i[1] = e[1] * t, i), divVec3: (e, t, i) => ((i = i || e)[0] = e[0] / t[0], i[1] = e[1] / t[1], i[2] = e[2] / t[2], i), divVec4: (e, t, i) => ((i = i || e)[0] = e[0] / t[0], i[1] = e[1] / t[1], i[2] = e[2] / t[2], i[3] = e[3] / t[3], i), divScalarVec3: (e, t, i) => ((i = i || t)[0] = e / t[0], i[1] = e / t[1], i[2] = e / t[2], i), divVec3Scalar: (e, t, i) => ((i = i || e)[0] = e[0] / t, i[1] = e[1] / t, i[2] = e[2] / t, i), divVec4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] / t, i[1] = e[1] / t, i[2] = e[2] / t, i[3] = e[3] / t, i), divScalarVec4: (e, t, i) => ((i = i || t)[0] = e / t[0], i[1] = e / t[1], i[2] = e / t[2], i[3] = e / t[3], i), dotVec4: (e, t) => e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3], cross3Vec4(e, t) { var i = e[0], s = e[1], r = (e = e[2], t[0]), a = t[1]; return [s * (t = t[2]) - e * a, e * r - i * t, i * a - s * r, 0] }, cross3Vec3(e, t, i) { var s = e[0], r = e[1], a = e[2], o = t[0], n = t[1]; t = t[2]; return (i = i || e)[0] = r * t - a * n, i[1] = a * o - s * t, i[2] = s * n - r * o, i }, sqLenVec4: e => math.dotVec4(e, e), lenVec4: e => Math.sqrt(math.sqLenVec4(e)), dotVec3: (e, t) => e[0] * t[0] + e[1] * t[1] + e[2] * t[2], dotVec2: (e, t) => e[0] * t[0] + e[1] * t[1], sqLenVec3: e => math.dotVec3(e, e), sqLenVec2: e => math.dotVec2(e, e), lenVec3: e => Math.sqrt(math.sqLenVec3(e)), distVec3: (() => { const e = new FloatArrayType(3); return (t, i) => math.lenVec3(math.subVec3(t, i, e)) })(), lenVec2: e => Math.sqrt(math.sqLenVec2(e)), distVec2: (() => { const e = new FloatArrayType(2); return (t, i) => math.lenVec2(math.subVec2(t, i, e)) })(), rcpVec3: (e, t) => math.divScalarVec3(1, e, t), normalizeVec4(e, t) { var i = 1 / math.lenVec4(e); return math.mulVec4Scalar(e, i, t) }, normalizeVec3(e, t) { var i = 1 / math.lenVec3(e); return math.mulVec3Scalar(e, i, t) }, normalizeVec2(e, t) { var i = 1 / math.lenVec2(e); return math.mulVec2Scalar(e, i, t) }, angleVec3: (e, t) => (e = (e = math.dotVec3(e, t) / Math.sqrt(math.sqLenVec3(e) * math.sqLenVec3(t))) < -1 ? -1 : 1 < e ? 1 : e, Math.acos(e)), vec3FromMat4Scale: (() => { const e = new FloatArrayType(3); return (t, i) => (e[0] = t[0], e[1] = t[1], e[2] = t[2], i[0] = math.lenVec3(e), e[0] = t[4], e[1] = t[5], e[2] = t[6], i[1] = math.lenVec3(e), e[0] = t[8], e[1] = t[9], e[2] = t[10], i[2] = math.lenVec3(e), i) })(), vecToArray: e => { for (let i = 0, s = (e = Array.prototype.slice.call(e)).length; i < s; i++)e[i] = (t = e[i], Math.round(1e5 * t) / 1e5); var t; return e }, xyzArrayToObject: e => ({ x: e[0], y: e[1], z: e[2] }), xyzObjectToArray: (e, t) => ((t = t || math.vec3())[0] = e.x, t[1] = e.y, t[2] = e.z, t), dupMat4: e => e.slice(0, 16), mat4To3: e => [e[0], e[1], e[2], e[4], e[5], e[6], e[8], e[9], e[10]], m4s: e => [e, e, e, e, e, e, e, e, e, e, e, e, e, e, e, e], setMat4ToZeroes: () => math.m4s(0), setMat4ToOnes: () => math.m4s(1), diagonalMat4v: e => new FloatArrayType([e[0], 0, 0, 0, 0, e[1], 0, 0, 0, 0, e[2], 0, 0, 0, 0, e[3]]), diagonalMat4c: (e, t, i, s) => math.diagonalMat4v([e, t, i, s]), diagonalMat4s: e => math.diagonalMat4c(e, e, e, e), identityMat4: (e = new FloatArrayType(16)) => (e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e), identityMat3: (e = new FloatArrayType(9)) => (e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e), isIdentityMat4: e => 1 === e[0] && 0 === e[1] && 0 === e[2] && 0 === e[3] && 0 === e[4] && 1 === e[5] && 0 === e[6] && 0 === e[7] && 0 === e[8] && 0 === e[9] && 1 === e[10] && 0 === e[11] && 0 === e[12] && 0 === e[13] && 0 === e[14] && 1 === e[15], negateMat4: (e, t) => ((t = t || e)[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t[9] = -e[9], t[10] = -e[10], t[11] = -e[11], t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = -e[15], t), addMat4: (e, t, i) => ((i = i || e)[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i[3] = e[3] + t[3], i[4] = e[4] + t[4], i[5] = e[5] + t[5], i[6] = e[6] + t[6], i[7] = e[7] + t[7], i[8] = e[8] + t[8], i[9] = e[9] + t[9], i[10] = e[10] + t[10], i[11] = e[11] + t[11], i[12] = e[12] + t[12], i[13] = e[13] + t[13], i[14] = e[14] + t[14], i[15] = e[15] + t[15], i), addMat4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] + t, i[1] = e[1] + t, i[2] = e[2] + t, i[3] = e[3] + t, i[4] = e[4] + t, i[5] = e[5] + t, i[6] = e[6] + t, i[7] = e[7] + t, i[8] = e[8] + t, i[9] = e[9] + t, i[10] = e[10] + t, i[11] = e[11] + t, i[12] = e[12] + t, i[13] = e[13] + t, i[14] = e[14] + t, i[15] = e[15] + t, i), addScalarMat4: (e, t, i) => math.addMat4Scalar(t, e, i), subMat4: (e, t, i) => ((i = i || e)[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i[3] = e[3] - t[3], i[4] = e[4] - t[4], i[5] = e[5] - t[5], i[6] = e[6] - t[6], i[7] = e[7] - t[7], i[8] = e[8] - t[8], i[9] = e[9] - t[9], i[10] = e[10] - t[10], i[11] = e[11] - t[11], i[12] = e[12] - t[12], i[13] = e[13] - t[13], i[14] = e[14] - t[14], i[15] = e[15] - t[15], i), subMat4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] - t, i[1] = e[1] - t, i[2] = e[2] - t, i[3] = e[3] - t, i[4] = e[4] - t, i[5] = e[5] - t, i[6] = e[6] - t, i[7] = e[7] - t, i[8] = e[8] - t, i[9] = e[9] - t, i[10] = e[10] - t, i[11] = e[11] - t, i[12] = e[12] - t, i[13] = e[13] - t, i[14] = e[14] - t, i[15] = e[15] - t, i), subScalarMat4: (e, t, i) => ((i = i || t)[0] = e - t[0], i[1] = e - t[1], i[2] = e - t[2], i[3] = e - t[3], i[4] = e - t[4], i[5] = e - t[5], i[6] = e - t[6], i[7] = e - t[7], i[8] = e - t[8], i[9] = e - t[9], i[10] = e - t[10], i[11] = e - t[11], i[12] = e - t[12], i[13] = e - t[13], i[14] = e - t[14], i[15] = e - t[15], i), mulMat4(e, t, i) { var s = e[0], r = e[1], a = e[2], o = e[3], n = e[4], h = e[5], l = e[6], c = e[7], u = e[8], p = e[9], d = e[10], m = e[11], f = e[12], g = e[13], _ = e[14], v = e[15], y = t[0], T = t[1], I = t[2], E = t[3], C = t[4], P = t[5], b = t[6], A = t[7], D = t[8], R = t[9], F = t[10], w = t[11], M = t[12], S = t[13], x = t[14]; t = t[15]; return (i = i || e)[0] = y * s + T * n + I * u + E * f, i[1] = y * r + T * h + I * p + E * g, i[2] = y * a + T * l + I * d + E * _, i[3] = y * o + T * c + I * m + E * v, i[4] = C * s + P * n + b * u + A * f, i[5] = C * r + P * h + b * p + A * g, i[6] = C * a + P * l + b * d + A * _, i[7] = C * o + P * c + b * m + A * v, i[8] = D * s + R * n + F * u + w * f, i[9] = D * r + R * h + F * p + w * g, i[10] = D * a + R * l + F * d + w * _, i[11] = D * o + R * c + F * m + w * v, i[12] = M * s + S * n + x * u + t * f, i[13] = M * r + S * h + x * p + t * g, i[14] = M * a + S * l + x * d + t * _, i[15] = M * o + S * c + x * m + t * v, i }, mulMat3(e, t, i) { i = i || new FloatArrayType(9); var s = e[0], r = e[3], a = e[6], o = e[1], n = e[4], h = e[7], l = e[2], c = e[5], u = (e = e[8], t[0]), p = t[3], d = t[6], m = t[1], f = t[4], g = t[7], _ = t[2], v = t[5]; t = t[8]; return i[0] = s * u + r * m + a * _, i[3] = s * p + r * f + a * v, i[6] = s * d + r * g + a * t, i[1] = o * u + n * m + h * _, i[4] = o * p + n * f + h * v, i[7] = o * d + n * g + h * t, i[2] = l * u + c * m + e * _, i[5] = l * p + c * f + e * v, i[8] = l * d + c * g + e * t, i }, mulMat4Scalar: (e, t, i) => ((i = i || e)[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i[4] = e[4] * t, i[5] = e[5] * t, i[6] = e[6] * t, i[7] = e[7] * t, i[8] = e[8] * t, i[9] = e[9] * t, i[10] = e[10] * t, i[11] = e[11] * t, i[12] = e[12] * t, i[13] = e[13] * t, i[14] = e[14] * t, i[15] = e[15] * t, i), mulMat4v4(e, t, i = math.vec4()) { var s = t[0], r = t[1], a = t[2]; t = t[3]; return i[0] = e[0] * s + e[4] * r + e[8] * a + e[12] * t, i[1] = e[1] * s + e[5] * r + e[9] * a + e[13] * t, i[2] = e[2] * s + e[6] * r + e[10] * a + e[14] * t, i[3] = e[3] * s + e[7] * r + e[11] * a + e[15] * t, i }, transposeMat4(e, t) { var i, s, r, a, o, n = e[4], h = e[14], l = e[8], c = e[13], u = e[12], p = e[9]; return t && e !== t ? (t[0] = e[0], t[1] = n, t[2] = l, t[3] = u, t[4] = e[1], t[5] = e[5], t[6] = p, t[7] = c, t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = h, t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15], t) : (t = e[1], i = e[2], s = e[3], r = e[6], a = e[7], o = e[11], e[1] = n, e[2] = l, e[3] = u, e[4] = t, e[6] = p, e[7] = c, e[8] = i, e[9] = r, e[11] = h, e[12] = s, e[13] = a, e[14] = o, e) }, transposeMat3(e, t) { var i, s, r; return t === e ? (i = e[1], s = e[2], r = e[5], t[1] = e[3], t[2] = e[6], t[3] = i, t[5] = e[7], t[6] = s, t[7] = r) : (t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8]), t }, determinantMat4(e) { var t = e[0], i = e[1], s = e[2], r = e[3], a = e[4], o = e[5], n = e[6], h = e[7], l = e[8], c = e[9], u = e[10], p = e[11], d = e[12], m = e[13], f = e[14]; return d * c * n * r - l * m * n * r - d * o * u * r + a * m * u * r + l * o * f * r - a * c * f * r - d * c * s * h + l * m * s * h + d * i * u * h - t * m * u * h - l * i * f * h + t * c * f * h + d * o * s * p - a * m * s * p - d * i * n * p + t * m * n * p + a * i * f * p - t * o * f * p - l * o * s * (e = e[15]) + a * c * s * e + l * i * n * e - t * c * n * e - a * i * u * e + t * o * u * e }, inverseMat4(e, t) { var i = e[0], s = e[1], r = e[2], a = e[3], o = e[4], n = e[5], h = e[6], l = e[7], c = e[8], u = e[9], p = e[10], d = e[11], m = e[12], f = e[13], g = e[14], _ = e[15], v = i * n - s * o, y = i * h - r * o, T = i * l - a * o, I = s * h - r * n, E = s * l - a * n, C = r * l - a * h, P = c * f - u * m, b = c * g - p * m, A = c * _ - d * m, D = u * g - p * f, R = u * _ - d * f, F = p * _ - d * g, w = 1 / (v * F - y * R + T * D + I * A - E * b + C * P); return (t = t || e)[0] = (n * F - h * R + l * D) * w, t[1] = (-s * F + r * R - a * D) * w, t[2] = (f * C - g * E + _ * I) * w, t[3] = (-u * C + p * E - d * I) * w, t[4] = (-o * F + h * A - l * b) * w, t[5] = (i * F - r * A + a * b) * w, t[6] = (-m * C + g * T - _ * y) * w, t[7] = (c * C - p * T + d * y) * w, t[8] = (o * R - n * A + l * P) * w, t[9] = (-i * R + s * A - a * P) * w, t[10] = (m * E - f * T + _ * v) * w, t[11] = (-c * E + u * T - d * v) * w, t[12] = (-o * D + n * b - h * P) * w, t[13] = (i * D - s * b + r * P) * w, t[14] = (-m * I + f * y - g * v) * w, t[15] = (c * I - u * y + p * v) * w, t }, traceMat4: e => e[0] + e[5] + e[10] + e[15], translationMat4v: (e, t) => ((t = t || math.identityMat4())[12] = e[0], t[13] = e[1], t[14] = e[2], t), translationMat3v: (e, t) => ((t = t || math.identityMat3())[6] = e[0], t[7] = e[1], t), translationMat4c: (() => { const e = new FloatArrayType(3); return (t, i, s, r) => (e[0] = t, e[1] = i, e[2] = s, math.translationMat4v(e, r)) })(), translationMat4s: (e, t) => math.translationMat4c(e, e, e, t), translateMat4v: (e, t) => math.translateMat4c(e[0], e[1], e[2], t), translateMat4c(e, t, i, s) { var r = s[3]; s[0] += r * e, s[1] += r * t, s[2] += r * i, r = s[7], s[4] += r * e, s[5] += r * t, s[6] += r * i, r = s[11], s[8] += r * e, s[9] += r * t, s[10] += r * i, r = s[15]; return s[12] += r * e, s[13] += r * t, s[14] += r * i, s }, setMat4Translation: (e, t, i) => (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = t[0], i[13] = t[1], i[14] = t[2], i[15] = e[15], i), rotationMat4v(e, t, i) { t = math.normalizeVec4([t[0], t[1], t[2], 0], []); var s = Math.sin(e), r = 1 - (e = Math.cos(e)), a = t[0], o = t[1], n = a * o, h = o * (t = t[2]), l = t * a, c = a * s, u = o * s; s *= t; return (i = i || math.mat4())[0] = r * a * a + e, i[1] = r * n + s, i[2] = r * l - u, i[3] = 0, i[4] = r * n - s, i[5] = r * o * o + e, i[6] = r * h + c, i[7] = 0, i[8] = r * l + u, i[9] = r * h - c, i[10] = r * t * t + e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i }, rotationMat4c: (e, t, i, s, r) => math.rotationMat4v(e, [t, i, s], r), scalingMat4v: (e, t = math.identityMat4()) => (t[0] = e[0], t[5] = e[1], t[10] = e[2], t), scalingMat3v: (e, t = math.identityMat3()) => (t[0] = e[0], t[4] = e[1], t), scalingMat4c: (() => { const e = new FloatArrayType(3); return (t, i, s, r) => (e[0] = t, e[1] = i, e[2] = s, math.scalingMat4v(e, r)) })(), scaleMat4c: (e, t, i, s) => (s[0] *= e, s[4] *= t, s[8] *= i, s[1] *= e, s[5] *= t, s[9] *= i, s[2] *= e, s[6] *= t, s[10] *= i, s[3] *= e, s[7] *= t, s[11] *= i, s), scaleMat4v(e, t) { var i = e[0], s = e[1]; e = e[2]; return t[0] *= i, t[4] *= s, t[8] *= e, t[1] *= i, t[5] *= s, t[9] *= e, t[2] *= i, t[6] *= s, t[10] *= e, t[3] *= i, t[7] *= s, t[11] *= e, t }, scalingMat4s: e => math.scalingMat4c(e, e, e), rotationTranslationMat4(e, t, i = math.mat4()) { var s = e[0], r = e[1], a = e[2], o = a + a, n = s * (c = s + s), h = s * (u = r + r), l = (s = s * o, r * u), c = (r = r * o, (e = e[3]) * c), u = e * u; e *= o; return i[0] = 1 - (l + (a *= o)), i[1] = h + e, i[2] = s - u, i[3] = 0, i[4] = h - e, i[5] = 1 - (n + a), i[6] = r + c, i[7] = 0, i[8] = s + u, i[9] = r - c, i[10] = 1 - (n + l), i[11] = 0, i[12] = t[0], i[13] = t[1], i[14] = t[2], i[15] = 1, i }, mat4ToEuler(e, t, i = math.vec4()) { var s = math.clamp, r = e[0], a = e[4], o = e[8], n = e[1], h = e[5], l = e[9], c = e[2], u = e[6]; e = e[10]; return "XYZ" === t ? (i[1] = Math.asin(s(o, -1, 1)), Math.abs(o) < .99999 ? (i[0] = Math.atan2(-l, e), i[2] = Math.atan2(-a, r)) : (i[0] = Math.atan2(u, h), i[2] = 0)) : "YXZ" === t ? (i[0] = Math.asin(-s(l, -1, 1)), Math.abs(l) < .99999 ? (i[1] = Math.atan2(o, e), i[2] = Math.atan2(n, h)) : (i[1] = Math.atan2(-c, r), i[2] = 0)) : "ZXY" === t ? (i[0] = Math.asin(s(u, -1, 1)), Math.abs(u) < .99999 ? (i[1] = Math.atan2(-c, e), i[2] = Math.atan2(-a, h)) : (i[1] = 0, i[2] = Math.atan2(n, r))) : "ZYX" === t ? (i[1] = Math.asin(-s(c, -1, 1)), Math.abs(c) < .99999 ? (i[0] = Math.atan2(u, e), i[2] = Math.atan2(n, r)) : (i[0] = 0, i[2] = Math.atan2(-a, h))) : "YZX" === t ? (i[2] = Math.asin(s(n, -1, 1)), Math.abs(n) < .99999 ? (i[0] = Math.atan2(-l, h), i[1] = Math.atan2(-c, r)) : (i[0] = 0, i[1] = Math.atan2(o, e))) : "XZY" === t && (i[2] = Math.asin(-s(a, -1, 1)), Math.abs(a) < .99999 ? (i[0] = Math.atan2(u, h), i[1] = Math.atan2(o, r)) : (i[0] = Math.atan2(-l, e), i[1] = 0)), i }, composeMat4: (e, t, i, s = math.mat4()) => (math.quaternionToRotationMat4(t, s), math.scaleMat4v(i, s), math.translateMat4v(e, s), s), decomposeMat4: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(16); return function (i, s, r, a) { e[0] = i[0], e[1] = i[1], e[2] = i[2]; let o = math.lenVec3(e); e[0] = i[4], e[1] = i[5], e[2] = i[6]; var n = math.lenVec3(e), h = (e[8] = i[8], e[9] = i[9], e[10] = i[10], math.lenVec3(e)), l = (s = (math.determinantMat4(i) < 0 && (o = -o), s[0] = i[12], s[1] = i[13], s[2] = i[14], t.set(i), 1 / o), i = 1 / n, 1 / h); return t[0] *= s, t[1] *= s, t[2] *= s, t[4] *= i, t[5] *= i, t[6] *= i, t[8] *= l, t[9] *= l, t[10] *= l, math.mat4ToQuaternion(t, r), a[0] = o, a[1] = n, a[2] = h, this } })(), getColMat4: (e, t) => [e[t *= 4], e[1 + t], e[2 + t], e[3 + t]], setRowMat4(e, t, i) { e[t] = i[0], e[t + 4] = i[1], e[t + 8] = i[2], e[t + 12] = i[3] }, lookAtMat4v(e, t, i, s) { s = s || math.mat4(); var r = e[0], a = e[1], o = (e = e[2], i[0]), n = i[1], h = (i = i[2], t[0]), l = t[1]; t = t[2]; if (r === h && a === l && e === t) return math.identityMat4(); let c, u, p, d, m, f, g; return h = r - h, l = a - l, t = e - t, h *= g = 1 / Math.sqrt(h * h + l * l + t * t), c = n * (t *= g) - i * (l *= g), u = i * h - o * t, p = o * l - n * h, (g = Math.sqrt(c * c + u * u + p * p)) ? (g = 1 / g, c *= g, u *= g, p *= g) : (c = 0, u = 0, p = 0), d = l * p - t * u, m = t * c - h * p, f = h * u - l * c, (g = Math.sqrt(d * d + m * m + f * f)) ? (g = 1 / g, d *= g, m *= g, f *= g) : (d = 0, m = 0, f = 0), s[0] = c, s[1] = d, s[2] = h, s[3] = 0, s[4] = u, s[5] = m, s[6] = l, s[7] = 0, s[8] = p, s[9] = f, s[10] = t, s[11] = 0, s[12] = -(c * r + u * a + p * e), s[13] = -(d * r + m * a + f * e), s[14] = -(h * r + l * a + t * e), s[15] = 1, s }, lookAtMat4c: (e, t, i, s, r, a, o, n, h) => math.lookAtMat4v([e, t, i], [s, r, a], [o, n, h], []), orthoMat4c(e, t, i, s, r, a, o) { var n = t - e, h = s - i, l = a - r; return (o = o || math.mat4())[0] = 2 / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 / h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -2 / l, o[11] = 0, o[12] = -(e + t) / n, o[13] = -(s + i) / h, o[14] = -(a + r) / l, o[15] = 1, o }, frustumMat4v(e, t, i) { i = i || math.mat4(); e = [e[0], e[1], e[2], 0], t = [t[0], t[1], t[2], 0], math.addVec4(t, e, tempMat1), math.subVec4(t, e, tempMat2), e = 2 * e[2]; var s = tempMat2[0], r = tempMat2[1], a = tempMat2[2]; return i[0] = e / s, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e / r, i[6] = 0, i[7] = 0, i[8] = tempMat1[0] / s, i[9] = tempMat1[1] / r, i[10] = -tempMat1[2] / a, i[11] = -1, i[12] = 0, i[13] = 0, i[14] = -e * t[2] / a, i[15] = 0, i }, frustumMat4(e, t, i, s, r, a, o) { var n = t - e, h = s - i, l = a - r; return (o = o || math.mat4())[0] = 2 * r / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * r / h, o[6] = 0, o[7] = 0, o[8] = (t + e) / n, o[9] = (s + i) / h, o[10] = -(a + r) / l, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = -a * r * 2 / l, o[15] = 0, o }, perspectiveMat4(e, t, i, s, r) { var a = [], o = []; return a[2] = i, o[2] = s, o[1] = a[2] * Math.tan(e / 2), a[1] = -o[1], o[0] = o[1] * t, a[0] = -o[0], math.frustumMat4v(a, o, r) }, compareMat4: (e, t) => e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15], transformPoint3(e, t, i = math.vec3()) { var s = t[0], r = t[1]; t = t[2]; return i[0] = e[0] * s + e[4] * r + e[8] * t + e[12], i[1] = e[1] * s + e[5] * r + e[9] * t + e[13], i[2] = e[2] * s + e[6] * r + e[10] * t + e[14], i }, transformPoint4: (e, t, i = math.vec4()) => (i[0] = e[0] * t[0] + e[4] * t[1] + e[8] * t[2] + e[12] * t[3], i[1] = e[1] * t[0] + e[5] * t[1] + e[9] * t[2] + e[13] * t[3], i[2] = e[2] * t[0] + e[6] * t[1] + e[10] * t[2] + e[14] * t[3], i[3] = e[3] * t[0] + e[7] * t[1] + e[11] * t[2] + e[15] * t[3], i), transformPoints3(e, t, i) { var s, r, a, o, n = i || [], h = t.length, l = e[0], c = e[1], u = e[2], p = e[3], d = e[4], m = e[5], f = e[6], g = e[7], _ = e[8], v = e[9], y = e[10], T = e[11], I = e[12], E = e[13], C = e[14], P = e[15]; for (let e = 0; e < h; ++e)s = (a = t[e])[0], r = a[1], a = a[2], (o = n[e] || (n[e] = [0, 0, 0]))[0] = l * s + d * r + _ * a + I, o[1] = c * s + m * r + v * a + E, o[2] = u * s + f * r + y * a + C, o[3] = p * s + g * r + T * a + P; return n.length = h, n }, transformPositions3(e, t, i = t) { let s; var r, a, o, n = t.length, h = e[0], l = e[1], c = e[2], u = (e[3], e[4]), p = e[5], d = e[6], m = (e[7], e[8]), f = e[9], g = e[10], _ = (e[11], e[12]), v = e[13], y = e[14]; for (e[15], s = 0; s < n; s += 3)r = t[s + 0], a = t[s + 1], o = t[s + 2], i[s + 0] = h * r + u * a + m * o + _, i[s + 1] = l * r + p * a + f * o + v, i[s + 2] = c * r + d * a + g * o + y; return i }, transformPositions4(e, t, i = t) { let s; var r, a, o, n = t.length, h = e[0], l = e[1], c = e[2], u = e[3], p = e[4], d = e[5], m = e[6], f = e[7], g = e[8], _ = e[9], v = e[10], y = e[11], T = e[12], I = e[13], E = e[14], C = e[15]; for (s = 0; s < n; s += 4)r = t[s + 0], a = t[s + 1], o = t[s + 2], i[s + 0] = h * r + p * a + g * o + T, i[s + 1] = l * r + d * a + _ * o + I, i[s + 2] = c * r + m * a + v * o + E, i[s + 3] = u * r + f * a + y * o + C; return i }, transformVec3(e, t, i) { var s = t[0], r = t[1]; t = t[2]; return (i = i || this.vec3())[0] = e[0] * s + e[4] * r + e[8] * t, i[1] = e[1] * s + e[5] * r + e[9] * t, i[2] = e[2] * s + e[6] * r + e[10] * t, i }, transformVec4(e, t, i) { var s = t[0], r = t[1], a = t[2]; t = t[3]; return (i = i || math.vec4())[0] = e[0] * s + e[4] * r + e[8] * a + e[12] * t, i[1] = e[1] * s + e[5] * r + e[9] * a + e[13] * t, i[2] = e[2] * s + e[6] * r + e[10] * a + e[14] * t, i[3] = e[3] * s + e[7] * r + e[11] * a + e[15] * t, i }, rotateVec2(e, t, i, s = e) { var r = Math.cos(i), a = (i = Math.sin(i), e[0] - t[0]), o = e[1] - t[1]; return s[0] = a * r - o * i + t[0], s[1] = a * i + o * r + t[1], e }, rotateVec3X(e, t, i, s) { var r = [], a = []; return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[0], a[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), a[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), s[0] = a[0] + t[0], s[1] = a[1] + t[1], s[2] = a[2] + t[2], s }, rotateVec3Y(e, t, i, s) { var r = [], a = []; return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), a[1] = r[1], a[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), s[0] = a[0] + t[0], s[1] = a[1] + t[1], s[2] = a[2] + t[2], s }, rotateVec3Z(e, t, i, s) { var r = [], a = []; return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), a[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), a[2] = r[2], s[0] = a[0] + t[0], s[1] = a[1] + t[1], s[2] = a[2] + t[2], s }, projectVec4(e, t) { var i = 1 / e[3]; return (t = t || math.vec2())[0] = e[0] * i, t[1] = e[1] * i, t }, unprojectVec3: (() => { const e = new FloatArrayType(16), t = new FloatArrayType(16), i = new FloatArrayType(16); return function (s, r, a, o) { return this.transformVec3(this.mulMat4(this.inverseMat4(r, e), this.inverseMat4(a, t), i), s, o) } })(), lerpVec3: (e, t, i, s, r, a) => ((a = a || math.vec3())[0] = s[0] + (e = (e - t) / (i - t)) * (r[0] - s[0]), a[1] = s[1] + e * (r[1] - s[1]), a[2] = s[2] + e * (r[2] - s[2]), a), lerpMat4: (e, t, i, s, r, a) => ((a = a || math.mat4())[0] = s[0] + (e = (e - t) / (i - t)) * (r[0] - s[0]), a[1] = s[1] + e * (r[1] - s[1]), a[2] = s[2] + e * (r[2] - s[2]), a[3] = s[3] + e * (r[3] - s[3]), a[4] = s[4] + e * (r[4] - s[4]), a[5] = s[5] + e * (r[5] - s[5]), a[6] = s[6] + e * (r[6] - s[6]), a[7] = s[7] + e * (r[7] - s[7]), a[8] = s[8] + e * (r[8] - s[8]), a[9] = s[9] + e * (r[9] - s[9]), a[10] = s[10] + e * (r[10] - s[10]), a[11] = s[11] + e * (r[11] - s[11]), a[12] = s[12] + e * (r[12] - s[12]), a[13] = s[13] + e * (r[13] - s[13]), a[14] = s[14] + e * (r[14] - s[14]), a[15] = s[15] + e * (r[15] - s[15]), a), flatten(e) { var t, i, s, r = []; let a, o; for (a = 0, t = e.length; a < t; a++)for (o = 0, i = (s = e[a]).length; o < i; o++)r.push(s[o]); return r }, identityQuaternion: (e = math.vec4()) => (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e), eulerToQuaternion(e, t, i = math.vec4()) { var s = e[0] * math.DEGTORAD / 2, r = e[1] * math.DEGTORAD / 2, a = (e = e[2] * math.DEGTORAD / 2, Math.cos(s)), o = Math.cos(r), n = Math.cos(e); s = Math.sin(s), r = Math.sin(r), e = Math.sin(e); return "XYZ" === t ? (i[0] = s * o * n + a * r * e, i[1] = a * r * n - s * o * e, i[2] = a * o * e + s * r * n, i[3] = a * o * n - s * r * e) : "YXZ" === t ? (i[0] = s * o * n + a * r * e, i[1] = a * r * n - s * o * e, i[2] = a * o * e - s * r * n, i[3] = a * o * n + s * r * e) : "ZXY" === t ? (i[0] = s * o * n - a * r * e, i[1] = a * r * n + s * o * e, i[2] = a * o * e + s * r * n, i[3] = a * o * n - s * r * e) : "ZYX" === t ? (i[0] = s * o * n - a * r * e, i[1] = a * r * n + s * o * e, i[2] = a * o * e - s * r * n, i[3] = a * o * n + s * r * e) : "YZX" === t ? (i[0] = s * o * n + a * r * e, i[1] = a * r * n + s * o * e, i[2] = a * o * e - s * r * n, i[3] = a * o * n - s * r * e) : "XZY" === t && (i[0] = s * o * n - a * r * e, i[1] = a * r * n - s * o * e, i[2] = a * o * e + s * r * n, i[3] = a * o * n + s * r * e), i }, mat4ToQuaternion(e, t = math.vec4()) { var i = e[0], s = e[4], r = e[8], a = e[1], o = e[5], n = e[9], h = e[2], l = e[6]; let c; var u = i + o + (e = e[10]); return 0 < u ? (c = .5 / Math.sqrt(u + 1), t[3] = .25 / c, t[0] = (l - n) * c, t[1] = (r - h) * c, t[2] = (a - s) * c) : o < i && e < i ? (c = 2 * Math.sqrt(1 + i - o - e), t[3] = (l - n) / c, t[0] = .25 * c, t[1] = (s + a) / c, t[2] = (r + h) / c) : e < o ? (c = 2 * Math.sqrt(1 + o - i - e), t[3] = (r - h) / c, t[0] = (s + a) / c, t[1] = .25 * c, t[2] = (n + l) / c) : (c = 2 * Math.sqrt(1 + e - i - o), t[3] = (a - s) / c, t[0] = (r + h) / c, t[1] = (n + l) / c, t[2] = .25 * c), t }, vec3PairToQuaternion(e, t, i = math.vec4()) { var s = Math.sqrt(math.dotVec3(e, e) * math.dotVec3(t, t)); let r = s + math.dotVec3(e, t); return r < 1e-8 * s ? (r = 0, Math.abs(e[0]) > Math.abs(e[2]) ? (i[0] = -e[1], i[1] = e[0], i[2] = 0) : (i[0] = 0, i[1] = -e[2], i[2] = e[1])) : math.cross3Vec3(e, t, i), i[3] = r, math.normalizeQuaternion(i) }, angleAxisToQuaternion(e, t = math.vec4()) { var i = e[3] / 2, s = Math.sin(i); return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = Math.cos(i), t }, quaternionToEuler: (() => { const e = new FloatArrayType(16); return (t, i, s) => (s = s || math.vec3(), math.quaternionToRotationMat4(t, e), math.mat4ToEuler(e, i, s), s) })(), mulQuaternions(e, t, i = math.vec4()) { var s = e[0], r = e[1], a = e[2], o = (e = e[3], t[0]), n = t[1], h = t[2]; t = t[3]; return i[0] = e * o + s * t + r * h - a * n, i[1] = e * n + r * t + a * o - s * h, i[2] = e * h + a * t + s * n - r * o, i[3] = e * t - s * o - r * n - a * h, i }, vec3ApplyQuaternion(e, t, i = math.vec3()) { var s = t[0], r = t[1], a = (t = t[2], e[0]), o = e[1], n = e[2], h = (e = e[3]) * s + o * t - n * r, l = e * r + n * s - a * t, c = e * t + a * r - o * s; return i[0] = h * e + (s = -a * s - o * r - n * t) * -a + l * -n - c * -o, i[1] = l * e + s * -o + c * -a - h * -n, i[2] = c * e + s * -n + h * -o - l * -a, i }, quaternionToMat4(e, t) { t = math.identityMat4(t); var i = e[0], s = e[1], r = e[2], a = 2 * r, o = (h = 2 * i) * (e = e[3]), n = (c = 2 * s) * e, h = (e = a * e, h * i), l = c * i, c = (i = a * i, c * s); s *= a; return t[0] = 1 - (c + (a *= r)), t[1] = l + e, t[2] = i - n, t[4] = l - e, t[5] = 1 - (h + a), t[6] = s + o, t[8] = i + n, t[9] = s - o, t[10] = 1 - (h + c), t }, quaternionToRotationMat4(e, t) { var i = e[0], s = e[1], r = e[2], a = r + r, o = i * (l = i + i), n = i * (c = s + s), h = (i = i * a, s * c), l = (s = s * a, (e = e[3]) * l), c = e * c; e *= a; return t[0] = 1 - (h + (r *= a)), t[4] = n - e, t[8] = i + c, t[1] = n + e, t[5] = 1 - (o + r), t[9] = s - l, t[2] = i - c, t[6] = s + l, t[10] = 1 - (o + h), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, normalizeQuaternion(e, t = e) { var i = math.lenVec4([e[0], e[1], e[2], e[3]]); return t[0] = e[0] / i, t[1] = e[1] / i, t[2] = e[2] / i, t[3] = e[3] / i, t }, conjugateQuaternion: (e, t = e) => (t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t), inverseQuaternion: (e, t) => math.normalizeQuaternion(math.conjugateQuaternion(e, t)), quaternionToAngleAxis(e, t = math.vec4()) { var i = (e = math.normalizeQuaternion(e, tempVec4$8))[3], s = 2 * Math.acos(i); return (i = Math.sqrt(1 - i * i)) < .001 ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = e[0] / i, t[1] = e[1] / i, t[2] = e[2] / i), t[3] = s, t }, AABB3: e => new FloatArrayType(e || 6), AABB2: e => new FloatArrayType(e || 4), OBB3: e => new FloatArrayType(e || 32), OBB2: e => new FloatArrayType(e || 16), Sphere3: (e, t, i, s) => new FloatArrayType([e, t, i, s]), transformOBB3(e, t, i = t) { let s; var r, a, o, n = t.length, h = e[0], l = e[1], c = e[2], u = e[3], p = e[4], d = e[5], m = e[6], f = e[7], g = e[8], _ = e[9], v = e[10], y = e[11], T = e[12], I = e[13], E = e[14], C = e[15]; for (s = 0; s < n; s += 4)r = t[s + 0], a = t[s + 1], o = t[s + 2], i[s + 0] = h * r + p * a + g * o + T, i[s + 1] = l * r + d * a + _ * o + I, i[s + 2] = c * r + m * a + v * o + E, i[s + 3] = u * r + f * a + y * o + C; return i }, containsAABB3: function (e, t) { return e[0] <= t[0] && t[3] <= e[3] && e[1] <= t[1] && t[4] <= e[4] && e[2] <= t[2] && t[5] <= e[5] }, getAABB3Diag: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3); return s => (e[0] = s[0], e[1] = s[1], e[2] = s[2], t[0] = s[3], t[1] = s[4], t[2] = s[5], math.subVec3(t, e, i), Math.abs(math.lenVec3(i))) })(), getAABB3DiagPoint: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3); return (s, r) => { e[0] = s[0], e[1] = s[1], e[2] = s[2], t[0] = s[3], t[1] = s[4], t[2] = s[5]; var a = math.subVec3(t, e, i), o = r[0] - s[0], n = s[3] - r[0], h = r[1] - s[1], l = s[4] - r[1], c = r[2] - s[2]; s = s[5] - r[2]; return a[0] += n < o ? o : n, a[1] += l < h ? h : l, a[2] += s < c ? c : s, Math.abs(math.lenVec3(a)) } })(), getAABB3Area: e => (e[3] - e[0]) * (e[4] - e[1]) * (e[5] - e[2]), getAABB3Center: (e, t) => ((t = t || math.vec3())[0] = (e[0] + e[3]) / 2, t[1] = (e[1] + e[4]) / 2, t[2] = (e[2] + e[5]) / 2, t), getAABB2Center: (e, t) => ((t = t || math.vec2())[0] = (e[2] + e[0]) / 2, t[1] = (e[3] + e[1]) / 2, t), collapseAABB3: (e = math.AABB3()) => (e[0] = math.MAX_DOUBLE, e[1] = math.MAX_DOUBLE, e[2] = math.MAX_DOUBLE, e[3] = math.MIN_DOUBLE, e[4] = math.MIN_DOUBLE, e[5] = math.MIN_DOUBLE, e), AABB3ToOBB3: (e, t = math.OBB3()) => (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = 1, t[4] = e[3], t[5] = e[1], t[6] = e[2], t[7] = 1, t[8] = e[3], t[9] = e[4], t[10] = e[2], t[11] = 1, t[12] = e[0], t[13] = e[4], t[14] = e[2], t[15] = 1, t[16] = e[0], t[17] = e[1], t[18] = e[5], t[19] = 1, t[20] = e[3], t[21] = e[1], t[22] = e[5], t[23] = 1, t[24] = e[3], t[25] = e[4], t[26] = e[5], t[27] = 1, t[28] = e[0], t[29] = e[4], t[30] = e[5], t[31] = 1, t), positions3ToAABB3: (() => { const e = new FloatArrayType(3); return (t, i, s) => { i = i || math.AABB3(); let r, a, o, n = math.MAX_DOUBLE, h = math.MAX_DOUBLE, l = math.MAX_DOUBLE, c = math.MIN_DOUBLE, u = math.MIN_DOUBLE, p = math.MIN_DOUBLE; for (let i = 0, d = t.length; i < d; i += 3)o = s ? (e[0] = t[i + 0], e[1] = t[i + 1], e[2] = t[i + 2], math.decompressPosition(e, s, e), r = e[0], a = e[1], e[2]) : (r = t[i + 0], a = t[i + 1], t[i + 2]), r < n && (n = r), a < h && (h = a), o < l && (l = o), r > c && (c = r), a > u && (u = a), o > p && (p = o); return i[0] = n, i[1] = h, i[2] = l, i[3] = c, i[4] = u, i[5] = p, i } })(), OBB3ToAABB3(e, t = math.AABB3()) { let i = math.MAX_DOUBLE, s = math.MAX_DOUBLE, r = math.MAX_DOUBLE, a = math.MIN_DOUBLE, o = math.MIN_DOUBLE, n = math.MIN_DOUBLE; var h, l, c; for (let t = 0, u = e.length; t < u; t += 4)(h = e[t + 0]) < i && (i = h), (l = e[t + 1]) < s && (s = l), (c = e[t + 2]) < r && (r = c), h > a && (a = h), l > o && (o = l), c > n && (n = c); return t[0] = i, t[1] = s, t[2] = r, t[3] = a, t[4] = o, t[5] = n, t }, points3ToAABB3(e, t = math.AABB3()) { let i = math.MAX_DOUBLE, s = math.MAX_DOUBLE, r = math.MAX_DOUBLE, a = math.MIN_DOUBLE, o = math.MIN_DOUBLE, n = math.MIN_DOUBLE; var h, l, c; for (let t = 0, u = e.length; t < u; t++)(h = e[t][0]) < i && (i = h), (l = e[t][1]) < s && (s = l), (c = e[t][2]) < r && (r = c), h > a && (a = h), l > o && (o = l), c > n && (n = c); return t[0] = i, t[1] = s, t[2] = r, t[3] = a, t[4] = o, t[5] = n, t }, points3ToSphere3: (() => { const e = new FloatArrayType(3); return (t, i) => { i = i || math.vec4(); let s, r = 0, a = 0, o = 0; var n, h = t.length; for (s = 0; s < h; s++)r += t[s][0], a += t[s][1], o += t[s][2]; i[0] = r / h, i[1] = a / h, i[2] = o / h; let l = 0; for (s = 0; s < h; s++)(n = Math.abs(math.lenVec3(math.subVec3(t[s], i, e)))) > l && (l = n); return i[3] = l, i } })(), positions3ToSphere3: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3); return (i, s) => { s = s || math.vec4(); let r, a = 0, o = 0, n = 0; var h = i.length; let l = 0; for (r = 0; r < h; r += 3)a += i[r], o += i[r + 1], n += i[r + 2]; var c, u = h / 3; for (s[0] = a / u, s[1] = o / u, s[2] = n / u, r = 0; r < h; r += 3)e[0] = i[r], e[1] = i[r + 1], e[2] = i[r + 2], (c = Math.abs(math.lenVec3(math.subVec3(e, s, t)))) > l && (l = c); return s[3] = l, s } })(), OBB3ToSphere3: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3); return (i, s) => { s = s || math.vec4(); let r, a = 0, o = 0, n = 0; var h, l = i.length, c = l / 4; for (r = 0; r < l; r += 4)a += i[r + 0], o += i[r + 1], n += i[r + 2]; s[0] = a / c, s[1] = o / c, s[2] = n / c; let u = 0; for (r = 0; r < l; r += 4)e[0] = i[r + 0], e[1] = i[r + 1], e[2] = i[r + 2], (h = Math.abs(math.lenVec3(math.subVec3(e, s, t)))) > u && (u = h); return s[3] = u, s } })(), getSphere3Center: (e, t = math.vec3()) => (t[0] = e[0], t[1] = e[1], t[2] = e[2], t), getPositionsCenter(e, t = math.vec3()) { let i = 0, s = 0, r = 0; for (var a = 0, o = e.length; a < o; a += 3)i += e[a + 0], s += e[a + 1], r += e[a + 2]; var n = e.length / 3; return t[0] = i / n, t[1] = s / n, t[2] = r / n, t }, expandAABB3: (e, t) => (e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] > t[2] && (e[2] = t[2]), e[3] < t[3] && (e[3] = t[3]), e[4] < t[4] && (e[4] = t[4]), e[5] < t[5] && (e[5] = t[5]), e), expandAABB3Point3: (e, t) => (e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] > t[2] && (e[2] = t[2]), e[3] < t[0] && (e[3] = t[0]), e[4] < t[1] && (e[4] = t[1]), e[5] < t[2] && (e[5] = t[2]), e), expandAABB3Points3(e, t) { for (var i, s, r, a = 0, o = t.length; a < o; a += 3)i = t[a], s = t[a + 1], r = t[a + 2], e[0] > i && (e[0] = i), e[1] > s && (e[1] = s), e[2] > r && (e[2] = r), e[3] < i && (e[3] = i), e[4] < s && (e[4] = s), e[5] < r && (e[5] = r); return e }, collapseAABB2: (e = math.AABB2()) => (e[0] = math.MAX_DOUBLE, e[1] = math.MAX_DOUBLE, e[2] = math.MIN_DOUBLE, e[3] = math.MIN_DOUBLE, e), point3AABB3Intersect: (e, t) => e[0] > t[0] || e[3] < t[0] || e[1] > t[1] || e[4] < t[1] || e[2] > t[2] || e[5] < t[2], planeAABB3Intersect(e, t, i) { let s, r; return r = 0 < e[0] ? (s = e[0] * i[0], e[0] * i[3]) : (s = e[0] * i[3], e[0] * i[0]), 0 < e[1] ? (s += e[1] * i[1], r += e[1] * i[4]) : (s += e[1] * i[4], r += e[1] * i[1]), 0 < e[2] ? (s += e[2] * i[2], r += e[2] * i[5]) : (s += e[2] * i[5], r += e[2] * i[2]), s <= -t && r <= -t ? -1 : s >= -t && r >= -t ? 1 : 0 }, OBB3ToAABB2(e, t = math.AABB2()) { let i = math.MAX_DOUBLE, s = math.MAX_DOUBLE, r = math.MIN_DOUBLE, a = math.MIN_DOUBLE; var o, n, h; for (let t = 0, l = e.length; t < l; t += 4)o = e[t + 0], n = e[t + 1], n *= h = 1 / (e[t + 3] || 1), (o *= h) < i && (i = o), n < s && (s = n), o > r && (r = o), n > a && (a = n); return t[0] = i, t[1] = s, t[2] = r, t[3] = a, t }, expandAABB2: (e, t) => (e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[2] && (e[2] = t[2]), e[3] < t[3] && (e[3] = t[3]), e), expandAABB2Point2: (e, t) => (e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]), e), AABB2ToCanvas(e, t, i, s = e) { var r = .5 * (e[0] + 1), a = .5 * (e[1] + 1), o = .5 * (e[2] + 1), n = .5 * (e[3] + 1); return s[0] = Math.floor(r * t), s[1] = i - Math.floor(n * i), s[2] = Math.floor(o * t), s[3] = i - Math.floor(a * i), s }, tangentQuadraticBezier: (e, t, i, s) => 2 * (1 - e) * (i - t) + 2 * e * (s - i), tangentQuadraticBezier3: (e, t, i, s, r) => -3 * t * (1 - e) * (1 - e) + 3 * i * (1 - e) * (1 - e) - 6 * e * i * (1 - e) + 6 * e * s * (1 - e) - 3 * e * e * s + 3 * e * e * r, tangentSpline: e => 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e), catmullRomInterpolate(e, t, i, s, r) { var a = r * r; return (2 * t - 2 * i + (e = .5 * (i - e)) + (s = .5 * (s - t))) * (r * a) + (-3 * t + 3 * i - 2 * e - s) * a + e * r + t }, b2p0: (e, t) => (e = 1 - e) * e * t, b2p1: (e, t) => 2 * (1 - e) * e * t, b2p2: (e, t) => e * e * t, b2(e, t, i, s) { return this.b2p0(e, t) + this.b2p1(e, i) + this.b2p2(e, s) }, b3p0: (e, t) => (e = 1 - e) * e * e * t, b3p1(e, t) { var i = 1 - e; return 3 * i * i * e * t }, b3p2: (e, t) => 3 * (1 - e) * e * e * t, b3p3: (e, t) => e * e * e * t, b3(e, t, i, s, r) { return this.b3p0(e, t) + this.b3p1(e, i) + this.b3p2(e, s) + this.b3p3(e, r) }, triangleNormal(e, t, i, s = math.vec3()) { var r = t[0] - e[0], a = t[1] - e[1], o = (t = t[2] - e[2], i[0] - e[0]), n = i[1] - e[1]; e = a * (i = i[2] - e[2]) - t * n, t = t * o - r * i, i = r * n - a * o; return 0 === (r = Math.sqrt(e * e + t * t + i * i)) ? (s[0] = 0, s[1] = 0, s[2] = 0) : (s[0] = e / r, s[1] = t / r, s[2] = i / r), s }, rayTriangleIntersect: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3), s = new FloatArrayType(3), r = new FloatArrayType(3); return (a, o, n, h, l, c) => { c = c || math.vec3(); h = math.subVec3(h, n, e), l = math.subVec3(l, n, t); var u = math.cross3Vec3(o, l, i), p = math.dotVec3(h, u); return p < 1e-6 || (n = math.subVec3(a, n, s), (u = math.dotVec3(n, u)) < 0) || p < u || (n = math.cross3Vec3(n, h, r), (h = math.dotVec3(o, n)) < 0) || p < u + h ? null : (u = math.dotVec3(l, n) / p, c[0] = a[0] + u * o[0], c[1] = a[1] + u * o[1], c[2] = a[2] + u * o[2], c) } })(), rayPlaneIntersect: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3), s = new FloatArrayType(3); return (r, a, o, n, h, l) => (l = l || math.vec3(), a = math.normalizeVec3(a, e), n = math.subVec3(n, o, t), h = math.subVec3(h, o, i), n = math.cross3Vec3(n, h, s), math.normalizeVec3(n, n), h = -math.dotVec3(o, n), o = -(math.dotVec3(r, n) + h) / math.dotVec3(a, n), l[0] = r[0] + o * a[0], l[1] = r[1] + o * a[1], l[2] = r[2] + o * a[2], l) })(), cartesianToBarycentric: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3); return (s, r, a, o, n) => { o = math.subVec3(o, r, e), a = math.subVec3(a, r, t), s = math.subVec3(s, r, i), r = math.dotVec3(o, o); var h = math.dotVec3(o, a), l = (o = math.dotVec3(o, s), math.dotVec3(a, a)); a = math.dotVec3(a, s); return 0 == (s = r * l - h * h) ? null : (n[0] = 1 - (s = (l * o - h * a) * (l = 1 / s)) - (r = (r * a - h * o) * l), n[1] = r, n[2] = s, n) } })(), barycentricInsideTriangle(e) { var t = e[1]; return 0 <= (e = e[2]) && 0 <= t && e + t < 1 }, barycentricToCartesian(e, t, i, s, r = math.vec3()) { var a = e[0], o = e[1]; e = e[2]; return r[0] = t[0] * a + i[0] * o + s[0] * e, r[1] = t[1] * a + i[1] * o + s[1] * e, r[2] = t[2] * a + i[2] * o + s[2] * e, r }, mergeVertices(e, t, i, s) { var r, a, o, n, h = {}, l = [], c = [], u = t ? [] : null, p = i ? [] : null, d = []; let m, f, g = 0; for (m = 0, f = e.length; m < f; m += 3)r = e[m], a = e[m + 1], o = e[m + 2], void 0 === h[n = `${Math.round(1e4 * r)}_${Math.round(1e4 * a)}_` + Math.round(1e4 * o)] && (h[n] = c.length / 3, c.push(r), c.push(a), c.push(o), t && (u.push(t[m]), u.push(t[m + 1]), u.push(t[m + 2])), i) && (p.push(i[g]), p.push(i[g + 1])), l[m / 3] = h[n], g += 2; for (m = 0, f = s.length; m < f; m++)d[m] = l[s[m]]; var _ = { positions: c, indices: d }; return u && (_.normals = u), p && (_.uv = p), _ }, buildNormals: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3), s = new FloatArrayType(3), r = new FloatArrayType(3), a = new FloatArrayType(3); return (o, n, h) => { let l, c; var u, p, d, m, f = new Array(o.length / 3); for (l = 0, c = n.length; l < c; l += 3) { u = n[l], p = n[l + 1], d = n[l + 2], e[0] = o[3 * u], e[1] = o[3 * u + 1], e[2] = o[3 * u + 2], t[0] = o[3 * p], t[1] = o[3 * p + 1], t[2] = o[3 * p + 2], i[0] = o[3 * d], i[1] = o[3 * d + 1], i[2] = o[3 * d + 2], math.subVec3(t, e, s), math.subVec3(i, e, r); var g = math.vec3(); math.normalizeVec3(math.cross3Vec3(s, r, a), g), f[u] || (f[u] = []), f[p] || (f[p] = []), f[d] || (f[d] = []), f[u].push(g), f[p].push(g), f[d].push(g) } let _, v, y; for (h = h && h.length === o.length ? h : new Float32Array(o.length), l = 0, c = f.length; l < c; l++) { m = f[l].length, _ = 0, v = 0; for (let e = y = 0; e < m; e++)_ += f[l][e][0], v += f[l][e][1], y += f[l][e][2]; h[3 * l] = _ / m, h[3 * l + 1] = v / m, h[3 * l + 2] = y / m } return h } })(), buildTangents: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3), i = new FloatArrayType(3), s = new FloatArrayType(3), r = new FloatArrayType(3), a = new FloatArrayType(3), o = new FloatArrayType(3); return (n, h, l) => { var c = new Float32Array(n.length); for (let y = 0; y < h.length; y += 3) { var u, p = h[y], d = n.subarray(3 * p, 3 * p + 3), m = l.subarray(2 * p, 2 * p + 2), f = (p = h[y + 1], n.subarray(3 * p, 3 * p + 3)), g = l.subarray(2 * p, 2 * p + 2), _ = (p = h[y + 2], n.subarray(3 * p, 3 * p + 3)), v = (p = l.subarray(2 * p, 2 * p + 2), f = math.subVec3(f, d, e), _ = math.subVec3(_, d, t), d = math.subVec2(g, m, i), g = math.subVec2(p, m, s), p = 1 / (d[0] * g[1] - d[1] * g[0]), math.mulVec3Scalar(math.subVec3(math.mulVec3Scalar(f, g[1], r), math.mulVec3Scalar(_, d[1], a), o), p, a)); for (let e = 0; e < 3; e++)c[u = 3 * h[y + e]] += v[0], c[1 + u] += v[1], c[2 + u] += v[2] } return c } })(), buildPickTriangles(e, t, i) { var s, r, a, o, n, h = t.length, l = new (i ? Uint16Array : Float32Array)(9 * h), c = new Uint8Array(12 * h); let u = 0, p = 0, d = 0; for (let i = 0; i < h; i += 3)n = u >> 24 & 255, o = u >> 16 & 255, a = u >> 8 & 255, r = 255 & u, s = 3 * t[i], l[p++] = e[s], l[p++] = e[1 + s], l[p++] = e[2 + s], c[d++] = r, c[d++] = a, c[d++] = o, c[d++] = n, s = 3 * t[i + 1], l[p++] = e[s], l[p++] = e[1 + s], l[p++] = e[2 + s], c[d++] = r, c[d++] = a, c[d++] = o, c[d++] = n, s = 3 * t[i + 2], l[p++] = e[s], l[p++] = e[1 + s], l[p++] = e[2 + s], c[d++] = r, c[d++] = a, c[d++] = o, c[d++] = n, u++; return { positions: l, colors: c } }, faceToVertexNormals(e, t, i = {}) { var s, r, a, o = i.smoothNormalsAngleThreshold || 20, n = {}, h = [], l = {}; let c, u, p, d, m; for (p = 0, m = e.length; p < m; p += 3) { a = p / 3, f = e[p], s = e[p + 1], r = e[p + 2], void 0 === n[u = `${Math.round(1e4 * f)}_${Math.round(1e4 * s)}_` + Math.round(1e4 * r)] ? n[u] = [a] : n[u].push(a); var f = math.normalizeVec3([t[p], t[p + 1], t[p + 2]]); h[a] = f, c = math.vec4([f[0], f[1], f[2], 1]), l[a] = c } for (u in n) if (n.hasOwnProperty(u)) { var g = n[u], _ = g.length; for (p = 0; p < _; p++) { var v, y, T = g[p]; for (c = l[T], d = 0; d < _; d++)p !== d && (y = g[d], v = h[T], y = h[y], Math.abs(math.angleVec3(v, y) / math.DEGTORAD) < o) && (c[0] += y[0], c[1] += y[1], c[2] += y[2], c[3] += 1) } } for (p = 0, m = t.length; p < m; p += 3)c = l[p / 3], t[p + 0] = c[0] / c[3], t[p + 1] = c[1] / c[3], t[p + 2] = c[2] / c[3] }, transformRay: (() => { const e = new FloatArrayType(4), t = new FloatArrayType(4); return (i, s, r, a, o) => { e[0] = s[0], e[1] = s[1], e[2] = s[2], e[3] = 1, math.transformVec4(i, e, t), a[0] = t[0], a[1] = t[1], a[2] = t[2], e[0] = r[0], e[1] = r[1], e[2] = r[2], math.transformVec3(i, e, t), math.normalizeVec3(t), o[0] = t[0], o[1] = t[1], o[2] = t[2] } })(), canvasPosToWorldRay: (() => { const e = new FloatArrayType(16), t = new FloatArrayType(16), i = new FloatArrayType(4), s = new FloatArrayType(4), r = new FloatArrayType(4), a = new FloatArrayType(4); return (o, n, h, l, c, u) => { h = math.mulMat4(h, n, e), n = math.inverseMat4(h, t), h = o.width, o = o.height, h = (l[0] - h / 2) / (h / 2), l = -(l[1] - o / 2) / (o / 2), i[0] = h, i[1] = l, i[2] = -1, i[3] = 1, math.transformVec4(n, i, s), math.mulVec4Scalar(s, 1 / s[3]), r[0] = h, r[1] = l, r[2] = 1, r[3] = 1, math.transformVec4(n, r, a), math.mulVec4Scalar(a, 1 / a[3]), c[0] = a[0], c[1] = a[1], c[2] = a[2], math.subVec3(a, s, u), math.normalizeVec3(u) } })(), canvasPosToLocalRay: (() => { const e = new FloatArrayType(3), t = new FloatArrayType(3); return (i, s, r, a, o, n, h) => { math.canvasPosToWorldRay(i, s, r, o, e, t), math.worldRayToLocalRay(a, e, t, n, h) } })(), worldRayToLocalRay: (() => { const e = new FloatArrayType(16), t = new FloatArrayType(4), i = new FloatArrayType(4); return (s, r, a, o, n) => { s = math.inverseMat4(s, e), t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = 1, math.transformVec4(s, t, i), o[0] = i[0], o[1] = i[1], o[2] = i[2], math.transformVec3(s, a, n) } })(), buildKDTree: (() => { const e = new Float32Array; return (t, i) => { var s = t.length / 3, r = new Array(s); for (let e = 0; e < s; ++e)r[e] = e; return function t(i, s, r, a) { var o = new FloatArrayType(6), n = { triangles: null, left: null, right: null, leaf: !1, splitDim: 0, aabb: o }; let h, l; for (o[0] = o[1] = o[2] = Number.POSITIVE_INFINITY, o[3] = o[4] = o[5] = Number.NEGATIVE_INFINITY, h = 0, l = i.length; h < l; ++h) { var c = 3 * i[h]; for (let e = 0; e < 3; ++e) { var u = 3 * s[c + e]; r[u] < o[0] && (o[0] = r[u]), r[u] > o[3] && (o[3] = r[u]), r[1 + u] < o[1] && (o[1] = r[1 + u]), r[1 + u] > o[4] && (o[4] = r[1 + u]), r[2 + u] < o[2] && (o[2] = r[2 + u]), r[2 + u] > o[5] && (o[5] = r[2 + u]) } } if (i.length < 20 || 10 < a) n.triangles = i, n.leaf = !0; else { e[0] = o[3] - o[0], e[1] = o[4] - o[1], e[2] = o[5] - o[2]; let u = 0; e[1] > e[u] && (u = 1), e[2] > e[u] && (u = 2); var p = (o[n.splitDim = u] + o[u + 3]) / 2, d = new Array(i.length); let v = 0; var m = new Array(i.length); let y = 0; for (h = 0, l = i.length; h < l; ++h) { var f = s[c = 3 * i[h]], g = s[c + 1], _ = s[c + 2]; r[3 * f + u] <= p || r[3 * g + u] <= p || r[3 * _ + u] <= p ? d[v++] = i[h] : m[y++] = i[h] } d.length = v, m.length = y, n.left = t(d, s, r, a + 1), n.right = t(m, s, r, a + 1) } return n }(r, t, i, 0) } })(), decompressPosition(e, t, i) { (i = i || e)[0] = e[0] * t[0] + t[12], i[1] = e[1] * t[5] + t[13], i[2] = e[2] * t[10] + t[14] }, decompressPositions(e, t, i = new Float32Array(e.length)) { for (let s = 0, r = e.length; s < r; s += 3)i[s + 0] = e[s + 0] * t[0] + t[12], i[s + 1] = e[s + 1] * t[5] + t[13], i[s + 2] = e[s + 2] * t[10] + t[14]; return i }, decompressUV(e, t, i) { i[0] = e[0] * t[0] + t[6], i[1] = e[1] * t[4] + t[7] }, decompressUVs(e, t, i = new Float32Array(e.length)) { for (let s = 0, r = e.length; s < r; s += 3)i[s + 0] = e[s + 0] * t[0] + t[6], i[s + 1] = e[s + 1] * t[4] + t[7]; return i }, octDecodeVec2(e, t) { let i = e[0], s = e[1]; i = (2 * i + 1) / 255, s = (2 * s + 1) / 255, (e = 1 - Math.abs(i) - Math.abs(s)) < 0 && (i = (1 - Math.abs(s)) * (0 <= i ? 1 : -1), s = (1 - Math.abs(i)) * (0 <= s ? 1 : -1)); var r = Math.sqrt(i * i + s * s + e * e); return t[0] = i / r, t[1] = s / r, t[2] = e / r, t }, octDecodeVec2s(e, t) { for (let r = 0, a = 0, o = e.length; r < o; r += 2) { let o = e[r + 0], n = e[r + 1]; o = (2 * o + 1) / 255, n = (2 * n + 1) / 255; var i = 1 - Math.abs(o) - Math.abs(n), s = (i < 0 && (o = (1 - Math.abs(n)) * (0 <= o ? 1 : -1), n = (1 - Math.abs(o)) * (0 <= n ? 1 : -1)), Math.sqrt(o * o + n * n + i * i)); t[a + 0] = o / s, t[a + 1] = n / s, t[a + 2] = i / s, a += 3 } return t } }; math.buildEdgeIndices = function () { const e = [], t = [], i = [], s = [], r = []; let a = 0; const o = new Uint16Array(3), n = new Uint16Array(3), h = new Uint16Array(3), l = math.vec3(), c = math.vec3(), u = math.vec3(), p = math.vec3(), d = math.vec3(), m = math.vec3(), f = math.vec3(); return function (g, _, v, y) { { var T, I, E, C, P = g, b = _, A = {}, D = Math.pow(10, 4); let r, a, o = 0; for (r = 0, a = P.length; r < a; r += 3)T = P[r], I = P[r + 1], E = P[r + 2], void 0 === A[C = Math.round(T * D) + "_" + Math.round(I * D) + "_" + Math.round(E * D)] && (A[C] = o / 3, e[o++] = T, e[o++] = I, e[o++] = E), t[r / 3] = A[C]; for (r = 0, a = b.length; r < a; r++)s[r] = t[b[r]], i[s[r]] = b[r] } g = _.length; var R = v; for (let t = a = 0, i = g; t < i; t += 3) { var F = 3 * s[t], w = 3 * s[t + 1], M = 3 * s[t + 2]; R ? (o[0] = e[F], o[1] = e[1 + F], o[2] = e[2 + F], n[0] = e[w], n[1] = e[1 + w], n[2] = e[2 + w], h[0] = e[M], h[1] = e[1 + M], h[2] = e[2 + M], math.decompressPosition(o, R, l), math.decompressPosition(n, R, c), math.decompressPosition(h, R, u)) : (l[0] = e[F], l[1] = e[1 + F], l[2] = e[2 + F], c[0] = e[w], c[1] = e[1 + w], c[2] = e[2 + w], u[0] = e[M], u[1] = e[1 + M], u[2] = e[2 + M]), math.subVec3(u, c, p), math.subVec3(l, c, d), math.cross3Vec3(p, d, m), math.normalizeVec3(m, f), (F = r[a] || (r[a] = { normal: math.vec3() })).normal[0] = f[0], F.normal[1] = f[1], F.normal[2] = f[2], a++ } var S, x, L, O, N, B, G = [], U = Math.cos(math.DEGTORAD * y), k = {}; let V, H = !1; for (let e = 0, t = _.length; e < t; e += 3) { var j = e / 3; for (let t = 0; t < 3; t++)L = s[e + t], S = s[e + (t + 1) % 3], void 0 === k[V = (x = Math.min(L, S)) + "," + (L = Math.max(L, S))] ? k[V] = { index1: x, index2: L, face1: j, face2: void 0 } : k[V].face2 = j } for (V in k) void 0 !== (O = k[V]).face2 && (N = r[O.face1].normal, B = r[O.face2].normal, U < math.dotVec3(N, B)) || (N = i[O.index1], B = i[O.index2], (!H && 65535 < N || 65535 < B) && (H = !0), G.push(N), G.push(B)); return new (H ? Uint32Array : Uint16Array)(G) } }(); class Curve extends Component { constructor(e, t = {}) { super(e, t), this.t = t.t } set t(e) { this._t = (e = e || 0) < 0 ? 0 : 1 < e ? 1 : e } get t() { return this._t } get tangent() { return this.getTangent(this._t) } get length() { var e = this._getLengths(); return e[e.length - 1] } getTangent(e) { var t = (e = void 0 === e ? this._t : e) - 1e-4; 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t < 0 ? 0 : t), e = this.getPoint(e), e = math.subVec3(e, t, []); return math.normalizeVec3(e, []) } getPointAt(e) { return e = this.getUToTMapping(e), this.getPoint(e) } getPoints(e) { e = e || 5; for (var t = [], i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t } _getLengths(e) { if (e = e || this.__arcLengthDivisions || 200, this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var t, i, s = [], r = this.getPoint(0), a = 0; for (s.push(0), i = 1; i <= e; i++)t = this.getPoint(i / e), a += math.lenVec3(math.subVec3(t, r, [])), s.push(a), r = t; return this.cacheArcLengths = s } _updateArcLengths() { this.needsUpdate = !0, this._getLengths() } getUToTMapping(e, t) { for (var i, s = this._getLengths(), r = 0, a = s.length, o = t || e * s[a - 1], n = 0, h = a - 1; n <= h;)if ((i = s[r = Math.floor(n + (h - n) / 2)] - o) < 0) n = r + 1; else { if (!(0 < i)) { h = r; break } h = r - 1 } return s[r = h] === o ? r / (a - 1) : (r + (o - (t = s[r])) / (s[r + 1] - t)) / (a - 1) } } class SplineCurve extends Curve { constructor(e, t = {}) { super(e, t), this.points = t.points, this.t = t.t } set points(e) { this._points = e || [] } get points() { return this._points } set t(e) { this._t = (e = e || 0) < 0 ? 0 : 1 < e ? 1 : e } get t() { return this._t } get point() { return this.getPoint(this._t) } getPoint(e) { var t, i, s, r, a = this.points; if (!(a.length < 3)) return t = (e = (a.length - 1) * e) - (e = Math.floor(e)), i = a[0 === e ? e : e - 1], s = a[e], r = a[e > a.length - 2 ? a.length - 1 : e + 1], a = a[e > a.length - 3 ? a.length - 1 : e + 2], (e = math.vec3())[0] = math.catmullRomInterpolate(i[0], s[0], r[0], a[0], t), e[1] = math.catmullRomInterpolate(i[1], s[1], r[1], a[1], t), e[2] = math.catmullRomInterpolate(i[2], s[2], r[2], a[2], t), e; this.error("Can't sample point from SplineCurve - not enough points on curve - returning [0,0,0].") } getJSON() { return { points: points, t: this._t } } } const tempVec3a$14 = math.vec3(); class CameraPath extends Component { get type() { return "CameraPath" } constructor(e, t = {}) { super(e, t), this._frames = [], this._eyeCurve = new SplineCurve(this), this._lookCurve = new SplineCurve(this), this._upCurve = new SplineCurve(this), t.frames && (this.addFrames(t.frames), this.smoothFrameTimes(1)) } get frames() { return this._frames } get eyeCurve() { return this._eyeCurve } get lookCurve() { return this._lookCurve } get upCurve() { return this._upCurve } saveFrame(e) { var t = this.scene.camera; this.addFrame(e, t.eye, t.look, t.up) } addFrame(e, t, i, s) { e = { t: e, eye: t.slice(0), look: i.slice(0), up: s.slice(0) }, this._frames.push(e), this._eyeCurve.points.push(e.eye), this._lookCurve.points.push(e.look), this._upCurve.points.push(e.up) } addFrames(e) { var t; for (let i = 0, s = e.length; i < s; i++)t = e[i], this.addFrame(t.t || 0, t.eye, t.look, t.up) } loadFrame(e) { var t = this.scene.camera; e /= this._frames[this._frames.length - 1].t - this._frames[0].t, t.eye = this._eyeCurve.getPoint(e = e < 0 ? 0 : 1 < e ? 1 : e, tempVec3a$14), t.look = this._lookCurve.getPoint(e, tempVec3a$14), t.up = this._upCurve.getPoint(e, tempVec3a$14) } sampleFrame(e, t, i, s) { this._eyeCurve.getPoint(e = e < 0 ? 0 : 1 < e ? 1 : e, t), this._lookCurve.getPoint(e, i), this._upCurve.getPoint(e, s) } smoothFrameTimes(e) { if (0 !== this._frames.length) { var t = math.vec3(), i = 0, s = (this._frames[0].t = 0, []); for (let e = 1, a = this._frames.length; e < a; e++) { var r = math.lenVec3(math.subVec3(this._frames[e].eye, this._frames[e - 1].eye, t)); i += s[e] = r } for (let t = 1, r = this._frames.length; t < r; t++) { var a = s[t] / i * e; this._frames[t].t = this._frames[t - 1].t + a } } } clearFrames() { this._frames = [], this._eyeCurve.points = [], this._lookCurve.points = [], this._upCurve.points = [] } } const tempVec3$5 = math.vec3(), newLook = math.vec3(), newEye = math.vec3(), newUp = math.vec3(), newLookEyeVec = math.vec3(); class CameraFlightAnimation extends Component { get type() { return "CameraFlightAnimation" } constructor(e, t = {}) { super(e, t), this._look1 = math.vec3(), this._eye1 = math.vec3(), this._up1 = math.vec3(), this._look2 = math.vec3(), this._eye2 = math.vec3(), this._up2 = math.vec3(), this._orthoScale1 = 1, this._orthoScale2 = 1, this._flying = !1, this._flyEyeLookUp = !1, this._flyingEye = !1, this._flyingLook = !1, this._callback = null, this._callbackScope = null, this._time1 = null, this._time2 = null, this.easing = !1 !== t.easing, this.duration = t.duration, this.fit = t.fit, this.fitFOV = t.fitFOV, this.trail = t.trail } flyTo(e, t, i) { e = e || this.scene, this._flying && this.stop(), this._flying = !1, this._flyingEye = !1, this._flyingLook = !1, this._flyingEyeLookUp = !1, this._callback = t, this._callbackScope = i; var s = this.scene.camera, r = !!e.projection && e.projection !== s.projection; let a, o, n, h; if (this._eye1[0] = s.eye[0], this._eye1[1] = s.eye[1], this._eye1[2] = s.eye[2], this._look1[0] = s.look[0], this._look1[1] = s.look[1], this._look1[2] = s.look[2], this._up1[0] = s.up[0], this._up1[1] = s.up[1], this._up1[2] = s.up[2], this._orthoScale1 = s.ortho.scale, this._orthoScale2 = e.orthoScale || this._orthoScale1, e.aabb) a = e.aabb; else if (6 === e.length) a = e; else if (e.eye && e.look || e.up) o = e.eye, n = e.look, h = e.up; else if (e.eye) o = e.eye; else if (e.look) n = e.look; else { let s = e; if ((utils.isNumeric(s) || utils.isString(s)) && (l = s, !(s = this.scene.components[l]))) return this.error("Component not found: " + utils.inQuotes(l)), void (t && (i ? t.call(i) : t())); r || (a = s.aabb || this.scene.aabb) } var l = e.poi; if (a) { if (a[3] < a[0] || a[4] < a[1] || a[5] < a[2]) return; if (a[3] === a[0] && a[4] === a[1] && a[5] === a[2]) return; a = a.slice(), i = math.getAABB3Center(a), this._look2 = l || i, t = math.subVec3(this._eye1, this._look1, tempVec3$5), i = math.normalizeVec3(t), t = l ? math.getAABB3DiagPoint(a, l) : math.getAABB3Diag(a), l = e.fitFOV || this._fitFOV, l = Math.abs(t / Math.tan(l * math.DEGTORAD)), this._orthoScale2 = 1.1 * t, this._eye2[0] = this._look2[0] + i[0] * l, this._eye2[1] = this._look2[1] + i[1] * l, this._eye2[2] = this._look2[2] + i[2] * l, this._up2[0] = this._up1[0], this._up2[1] = this._up1[1], this._up2[2] = this._up1[2], this._flyingEyeLookUp = !0 } else (o || n || h) && (this._flyingEyeLookUp = !!o && !!n && !!h, this._flyingEye = !!o && !n, this._flyingLook = !!n && !o, o && (this._eye2[0] = o[0], this._eye2[1] = o[1], this._eye2[2] = o[2]), n && (this._look2[0] = n[0], this._look2[1] = n[1], this._look2[2] = n[2]), h) && (this._up2[0] = h[0], this._up2[1] = h[1], this._up2[2] = h[2]); r ? ("ortho" === e.projection && "ortho" !== s.projection && (this._projection2 = "ortho", this._projMatrix1 = s.projMatrix.slice(), this._projMatrix2 = s.ortho.matrix.slice(), s.projection = "customProjection"), "perspective" === e.projection && "perspective" !== s.projection && (this._projection2 = "perspective", this._projMatrix1 = s.projMatrix.slice(), this._projMatrix2 = s.perspective.matrix.slice(), s.projection = "customProjection")) : this._projection2 = null, this.fire("started", e, !0), this._time1 = Date.now(), this._time2 = this._time1 + (e.duration ? 1e3 * e.duration : this._duration), this._flying = !0, core.scheduleTask(this._update, this) } jumpTo(e) { this._jumpTo(e) } _jumpTo(e) { this._flying && this.stop(); var t, i, s = this.scene.camera; if (e.aabb) a = e.aabb; else if (6 === e.length) a = e; else if (e.eye || e.look || e.up) t = e.eye, n = e.look, i = e.up; else { let t = e; if ((utils.isNumeric(t) || utils.isString(t)) && (r = t, !(t = this.scene.components[r]))) return void this.error("Component not found: " + utils.inQuotes(r)); a = t.aabb || this.scene.aabb } var r = e.poi; if (a) { if (a[3] <= a[0] || a[4] <= a[1] || a[5] <= a[2]) return; var a, o = r ? math.getAABB3DiagPoint(a, r) : math.getAABB3Diag(a), n = r || math.getAABB3Center(a, n); this._trail ? math.subVec3(s.look, n, newLookEyeVec) : math.subVec3(s.eye, s.look, newLookEyeVec), math.normalizeVec3(newLookEyeVec), a = (r = void 0 !== e.fit ? e.fit : this._fit) ? Math.abs(o / Math.tan((e.fitFOV || this._fitFOV) * math.DEGTORAD)) : math.lenVec3(math.subVec3(s.eye, s.look, tempVec3$5)), math.mulVec3Scalar(newLookEyeVec, a), s.eye = math.addVec3(n, newLookEyeVec, tempVec3$5), s.look = n, this.scene.camera.ortho.scale = 1.1 * o } else (t || n || i) && (t && (s.eye = t), n && (s.look = n), i) && (s.up = i); e.projection && (s.projection = e.projection) } _update() { if (this._flying) { let s = (Date.now() - this._time1) / (this._time2 - this._time1); var e = 1 <= s, t = (1 < s && (s = 1), this.easing ? CameraFlightAnimation._ease(s, 0, 1, 1) : s), i = this.scene.camera; this._flyingEye || this._flyingLook ? this._flyingEye ? (math.subVec3(i.eye, i.look, newLookEyeVec), i.eye = math.lerpVec3(t, 0, 1, this._eye1, this._eye2, newEye), i.look = math.subVec3(newEye, newLookEyeVec, newLook)) : this._flyingLook && (i.look = math.lerpVec3(t, 0, 1, this._look1, this._look2, newLook), i.up = math.lerpVec3(t, 0, 1, this._up1, this._up2, newUp)) : this._flyingEyeLookUp && (i.eye = math.lerpVec3(t, 0, 1, this._eye1, this._eye2, newEye), i.look = math.lerpVec3(t, 0, 1, this._look1, this._look2, newLook), i.up = math.lerpVec3(t, 0, 1, this._up1, this._up2, newUp)), this._projection2 ? (t = "ortho" === this._projection2 ? CameraFlightAnimation._easeOutExpo(s, 0, 1, 1) : CameraFlightAnimation._easeInCubic(s, 0, 1, 1), i.customProjection.matrix = math.lerpMat4(t, 0, 1, this._projMatrix1, this._projMatrix2)) : i.ortho.scale = this._orthoScale1 + s * (this._orthoScale2 - this._orthoScale1), e ? (i.ortho.scale = this._orthoScale2, this.stop()) : core.scheduleTask(this._update, this) } } static _ease(e, t, i, s) { return -i * (e /= s) * (e - 2) + t } static _easeInCubic(e, t, i, s) { return i * (e /= s) * e * e + t } static _easeOutExpo(e, t, i, s) { return i * (1 - Math.pow(2, -10 * e / s)) + t } stop() { var e; this._flying && (this._flying = !1, this._time1 = null, this._time2 = null, this._projection2 && (this.scene.camera.projection = this._projection2), (e = this._callback) && (this._callback = null, this._callbackScope ? e.call(this._callbackScope) : e()), this.fire("stopped", !0, !0)) } cancel() { this._flying && (this._flying = !1, this._time1 = null, this._time2 = null, this._callback && (this._callback = null), this.fire("canceled", !0, !0)) } set duration(e) { this._duration = e ? 1e3 * e : 500, this.stop() } get duration() { return this._duration / 1e3 } set fit(e) { this._fit = !1 !== e } get fit() { return this._fit } set fitFOV(e) { this._fitFOV = e || 45 } get fitFOV() { return this._fitFOV } set trail(e) { this._trail = !!e } get trail() { return this._trail } destroy() { this.stop(), super.destroy() } } class CameraPathAnimation extends Component { get type() { return "CameraPathAnimation" } constructor(e, t = {}) { super(e, t), this._cameraFlightAnimation = new CameraFlightAnimation(this), this._t = 0, this.state = CameraPathAnimation.SCRUBBING, this._playingFromT = 0, this._playingToT = 0, this._playingRate = t.playingRate || 1, this._playingDir = 1, this._lastTime = null, this.cameraPath = t.cameraPath, this._tick = this.scene.on("tick", this._updateT, this) } _updateT() { var e, t = this._cameraPath; if (t) { let r; var i = performance.now(), s = this._lastTime ? .001 * (i - this._lastTime) : 0; if (this._lastTime = i, 0 != s) switch (this.state) { case CameraPathAnimation.SCRUBBING: return; case CameraPathAnimation.PLAYING: this._t += this._playingRate * s, 0 === (e = this._cameraPath.frames.length) || this._playingDir < 0 && this._t <= 0 || 0 < this._playingDir && this._t >= this._cameraPath.frames[e - 1].t ? (this.state = CameraPathAnimation.SCRUBBING, this._t = this._cameraPath.frames[e - 1].t, this.fire("stopped")) : t.loadFrame(this._t); break; case CameraPathAnimation.PLAYING_TO: r = this._t + this._playingRate * s * this._playingDir, (this._playingDir < 0 && r <= this._playingToT || 0 < this._playingDir && r >= this._playingToT) && (r = this._playingToT, this.state = CameraPathAnimation.SCRUBBING, this.fire("stopped")), this._t = r, t.loadFrame(this._t) } } } _ease(e, t, i, s) { return -i * (e /= s) * (e - 2) + t } set cameraPath(e) { this._cameraPath = e } get cameraPath() { return this._cameraPath } set rate(e) { this._playingRate = e } get rate() { return this._playingRate } play() { this._cameraPath && (this._lastTime = null, this.state = CameraPathAnimation.PLAYING) } playToT(e) { this._cameraPath && (this._playingFromT = this._t, this._playingToT = e, this._playingDir = this._playingToT - this._playingFromT < 0 ? -1 : 1, this._lastTime = null, this.state = CameraPathAnimation.PLAYING_TO) } playToFrame(e) { var t = this._cameraPath; t && ((t = t.frames[e]) ? this.playToT(t.t) : this.error("playToFrame - frame index out of range: " + e)) } flyToFrame(e, t) { var i = this._cameraPath; i && ((i = i.frames[e]) ? (this.state = CameraPathAnimation.SCRUBBING, this._cameraFlightAnimation.flyTo(i, t)) : this.error("flyToFrame - frame index out of range: " + e)) } scrubToT(e) { var t = this._cameraPath; t && this.scene.camera && (this._t = e, t.loadFrame(this._t), this.state = CameraPathAnimation.SCRUBBING) } scrubToFrame(e) { var t = this._cameraPath; t && this.scene.camera && (t.frames[e] ? (t.loadFrame(this._t), this.state = CameraPathAnimation.SCRUBBING) : this.error("playToFrame - frame index out of range: " + e)) } stop() { this.state = CameraPathAnimation.SCRUBBING, this.fire("stopped") } destroy() { super.destroy(), this.scene.off(this._tick) } } CameraPathAnimation.STOPPED = 0, CameraPathAnimation.SCRUBBING = 1, CameraPathAnimation.PLAYING = 2, CameraPathAnimation.PLAYING_TO = 3; class Geometry extends Component { get type() { return "Geometry" } get isGeometry() { return !0 } constructor(e, t = {}) { super(e, t), stats.memory.meshes++ } destroy() { super.destroy(), stats.memory.meshes-- } } const ids$4 = new Map$1({}); class RenderState { constructor(e) { this.id = ids$4.addItem({}); for (const t in e) e.hasOwnProperty(t) && (this[t] = e[t]) } destroy() { ids$4.removeItem(this.id) } } class ArrayBuf { constructor(e, t, i, s, r, a, o, n, h) { switch (this._gl = e, this.type = t, this.allocated = !1, i.constructor) { case Uint8Array: this.itemType = e.UNSIGNED_BYTE, this.itemByteSize = 1; break; case Int8Array: this.itemType = e.BYTE, this.itemByteSize = 1; break; case Uint16Array: this.itemType = e.UNSIGNED_SHORT, this.itemByteSize = 2; break; case Int16Array: this.itemType = e.SHORT, this.itemByteSize = 2; break; case Uint32Array: this.itemType = e.UNSIGNED_INT, this.itemByteSize = 4; break; case Int32Array: this.itemType = e.INT, this.itemByteSize = 4; break; default: this.itemType = e.FLOAT, this.itemByteSize = 4 }this.usage = a, this.length = 0, this.dataLength = s, this.numItems = 0, this.itemSize = r, this.normalized = !!o, this.stride = n || 0, this.offset = h || 0, this._allocate(i) } _allocate(e) { if (this.allocated = !1, this._handle = this._gl.createBuffer(), !this._handle) throw "Failed to allocate WebGL ArrayBuffer"; this._handle && (this._gl.bindBuffer(this.type, this._handle), this._gl.bufferData(this.type, e.length > this.dataLength ? e.slice(0, this.dataLength) : e, this.usage), this._gl.bindBuffer(this.type, null), this.length = e.length, this.numItems = this.length / this.itemSize, this.allocated = !0) } setData(e, t) { this.allocated && (e.length + (t || 0) > this.length ? (this.destroy(), this._allocate(e)) : (this._gl.bindBuffer(this.type, this._handle), t || 0 === t ? this._gl.bufferSubData(this.type, t * this.itemByteSize, e) : this._gl.bufferData(this.type, e, this.usage), this._gl.bindBuffer(this.type, null))) } bind() { this.allocated && this._gl.bindBuffer(this.type, this._handle) } unbind() { this.allocated && this._gl.bindBuffer(this.type, null) } destroy() { this.allocated && (this._gl.deleteBuffer(this._handle), this._handle = null, this.allocated = !1) } } var buildEdgeIndices = function () { const e = [], t = [], i = [], s = [], r = []; let a = 0; const o = new Uint16Array(3), n = new Uint16Array(3), h = new Uint16Array(3), l = math.vec3(), c = math.vec3(), u = math.vec3(), p = math.vec3(), d = math.vec3(), m = math.vec3(), f = math.vec3(); return function (g, _, v, y) { { var T, I, E, C, P = g, b = _, A = {}, D = Math.pow(10, 4); let r, a, o = 0; for (r = 0, a = P.length; r < a; r += 3)T = P[r], I = P[r + 1], E = P[r + 2], void 0 === A[C = Math.round(T * D) + "_" + Math.round(I * D) + "_" + Math.round(E * D)] && (A[C] = o / 3, e[o++] = T, e[o++] = I, e[o++] = E), t[r / 3] = A[C]; for (r = 0, a = b.length; r < a; r++)s[r] = t[b[r]], i[s[r]] = b[r] } g = _.length; var R = v; for (let t = a = 0, i = g; t < i; t += 3) { var F = 3 * s[t], w = 3 * s[t + 1], M = 3 * s[t + 2]; R ? (o[0] = e[F], o[1] = e[1 + F], o[2] = e[2 + F], n[0] = e[w], n[1] = e[1 + w], n[2] = e[2 + w], h[0] = e[M], h[1] = e[1 + M], h[2] = e[2 + M], math.decompressPosition(o, R, l), math.decompressPosition(n, R, c), math.decompressPosition(h, R, u)) : (l[0] = e[F], l[1] = e[1 + F], l[2] = e[2 + F], c[0] = e[w], c[1] = e[1 + w], c[2] = e[2 + w], u[0] = e[M], u[1] = e[1 + M], u[2] = e[2 + M]), math.subVec3(u, c, p), math.subVec3(l, c, d), math.cross3Vec3(p, d, m), math.normalizeVec3(m, f), (F = r[a] || (r[a] = { normal: math.vec3() })).normal[0] = f[0], F.normal[1] = f[1], F.normal[2] = f[2], a++ } var S, x, L, O, N, B, G = [], U = Math.cos(math.DEGTORAD * y), k = {}; let V, H = !1; for (let e = 0, t = _.length; e < t; e += 3) { var j = e / 3; for (let t = 0; t < 3; t++)L = s[e + t], S = s[e + (t + 1) % 3], void 0 === k[V = (x = Math.min(L, S)) + "," + (L = Math.max(L, S))] ? k[V] = { index1: x, index2: L, face1: j, face2: void 0 } : k[V].face2 = j } for (V in k) void 0 !== (O = k[V]).face2 && (N = r[O.face1].normal, B = r[O.face2].normal, U < math.dotVec3(N, B)) || (N = i[O.index1], B = i[O.index2], (!H && 65535 < N || 65535 < B) && (H = !0), G.push(N), G.push(B)); return new (H ? Uint32Array : Uint16Array)(G) } }(); function getPositionsBounds(e) { var t = new Float32Array(3), i = new Float32Array(3); let s, r; for (s = 0; s < 3; s++)t[s] = Number.MAX_VALUE, i[s] = -Number.MAX_VALUE; for (s = 0; s < e.length; s += 3)for (r = 0; r < 3; r++)t[r] = Math.min(t[r], e[s + r]), i[r] = Math.max(i[r], e[s + r]); return { min: t, max: i } } const createPositionsDecodeMatrix = function () { const e = math.mat4(), t = math.mat4(); return function (i, s) { s = s || math.mat4(); var r = i[0], a = i[1], o = i[2]; r = i[3] - r, a = i[4] - a, o = i[5] - o; return math.identityMat4(e), math.translationMat4v(i, e), math.identityMat4(t), math.scalingMat4v([r / 65535, a / 65535, o / 65535], t), math.mulMat4(e, t, s), s } }(); var compressPositions = function () { const e = math.mat4(), t = math.mat4(); return function (i, s, r) { var a = new Uint16Array(i.length), o = new Float32Array([r[0] !== s[0] ? 65535 / (r[0] - s[0]) : 0, r[1] !== s[1] ? 65535 / (r[1] - s[1]) : 0, r[2] !== s[2] ? 65535 / (r[2] - s[2]) : 0]); let n; for (n = 0; n < i.length; n += 3)a[n + 0] = Math.max(0, Math.min(65535, Math.floor((i[n + 0] - s[0]) * o[0]))), a[n + 1] = Math.max(0, Math.min(65535, Math.floor((i[n + 1] - s[1]) * o[1]))), a[n + 2] = Math.max(0, Math.min(65535, Math.floor((i[n + 2] - s[2]) * o[2]))); return math.identityMat4(e), math.translationMat4v(s, e), math.identityMat4(t), math.scalingMat4v([(r[0] - s[0]) / 65535, (r[1] - s[1]) / 65535, (r[2] - s[2]) / 65535], t), { quantized: a, decodeMatrix: math.mulMat4(e, t, math.identityMat4()) } } }(); function compressPosition(e, t, i) { var s = new Float32Array([t[3] !== t[0] ? 65535 / (t[3] - t[0]) : 0, t[4] !== t[1] ? 65535 / (t[4] - t[1]) : 0, t[5] !== t[2] ? 65535 / (t[5] - t[2]) : 0]); i[0] = Math.max(0, Math.min(65535, Math.floor((e[0] - t[0]) * s[0]))), i[1] = Math.max(0, Math.min(65535, Math.floor((e[1] - t[1]) * s[1]))), i[2] = Math.max(0, Math.min(65535, Math.floor((e[2] - t[2]) * s[2]))) } function decompressPosition(e, t, i) { return i[0] = e[0] * t[0] + t[12], i[1] = e[1] * t[5] + t[13], i[2] = e[2] * t[10] + t[14], i } function decompressAABB(e, t, i = e) { return i[0] = e[0] * t[0] + t[12], i[1] = e[1] * t[5] + t[13], i[2] = e[2] * t[10] + t[14], i[3] = e[3] * t[0] + t[12], i[4] = e[4] * t[5] + t[13], i[5] = e[5] * t[10] + t[14], i } function decompressPositions(e, t, i = new Float32Array(e.length)) { for (let s = 0, r = e.length; s < r; s += 3)i[s + 0] = e[s + 0] * t[0] + t[12], i[s + 1] = e[s + 1] * t[5] + t[13], i[s + 2] = e[s + 2] * t[10] + t[14]; return i } function getUVBounds(e) { var t = new Float32Array(2), i = new Float32Array(2); let s, r; for (s = 0; s < 2; s++)t[s] = Number.MAX_VALUE, i[s] = -Number.MAX_VALUE; for (s = 0; s < e.length; s += 2)for (r = 0; r < 2; r++)t[r] = Math.min(t[r], e[s + r]), i[r] = Math.max(i[r], e[s + r]); return { min: t, max: i } } var compressUVs = function () { const e = math.mat3(), t = math.mat3(); return function (i, s, r) { var a = new Uint16Array(i.length), o = new Float32Array([65535 / (r[0] - s[0]), 65535 / (r[1] - s[1])]); let n; for (n = 0; n < i.length; n += 2)a[n + 0] = Math.max(0, Math.min(65535, Math.floor((i[n + 0] - s[0]) * o[0]))), a[n + 1] = Math.max(0, Math.min(65535, Math.floor((i[n + 1] - s[1]) * o[1]))); return math.identityMat3(e), math.translationMat3v(s, e), math.identityMat3(t), math.scalingMat3v([(r[0] - s[0]) / 65535, (r[1] - s[1]) / 65535], t), { quantized: a, decodeMatrix: math.mulMat3(e, t, math.identityMat3()) } } }(); function compressNormals(e) { var t = new Int8Array(e.length); let i, s, r, a, o; for (let n = 0; n < e.length; n += 3)r = i = octEncodeVec3$1(e, n, "floor", "floor"), s = octDecodeVec2$1(i), o = dot$1(e, n, s), s = octDecodeVec2$1(i = octEncodeVec3$1(e, n, "ceil", "floor")), (a = dot$1(e, n, s)) > o && (r = i, o = a), s = octDecodeVec2$1(i = octEncodeVec3$1(e, n, "floor", "ceil")), (a = dot$1(e, n, s)) > o && (r = i, o = a), s = octDecodeVec2$1(i = octEncodeVec3$1(e, n, "ceil", "ceil")), (a = dot$1(e, n, s)) > o && (r = i, o = a), t[n] = r[0], t[n + 1] = r[1]; return t } function octEncodeVec3$1(e, t, i, s) { let r = e[t] / (Math.abs(e[t]) + Math.abs(e[t + 1]) + Math.abs(e[t + 2])), a = e[t + 1] / (Math.abs(e[t]) + Math.abs(e[t + 1]) + Math.abs(e[t + 2])); return e[t + 2] < 0 && (e = (1 - Math.abs(a)) * (0 <= r ? 1 : -1), t = (1 - Math.abs(r)) * (0 <= a ? 1 : -1), r = e, a = t), new Int8Array([Math[i](127.5 * r + (r < 0 ? -1 : 0)), Math[s](127.5 * a + (a < 0 ? -1 : 0))]) } function octDecodeVec2$1(e) { let t = e[0], i = e[1]; t /= t < 0 ? 127 : 128, i /= i < 0 ? 127 : 128, (e = 1 - Math.abs(t) - Math.abs(i)) < 0 && (t = (1 - Math.abs(i)) * (0 <= t ? 1 : -1), i = (1 - Math.abs(t)) * (0 <= i ? 1 : -1)); var s = Math.sqrt(t * t + i * i + e * e); return [t / s, i / s, e / s] } function dot$1(e, t, i) { return e[t] * i[0] + e[t + 1] * i[1] + e[t + 2] * i[2] } function decompressUV(e, t, i) { i[0] = e[0] * t[0] + t[6], i[1] = e[1] * t[4] + t[7] } function decompressUVs(e, t, i = new Float32Array(e.length)) { for (let s = 0, r = e.length; s < r; s += 3)i[s + 0] = e[s + 0] * t[0] + t[6], i[s + 1] = e[s + 1] * t[4] + t[7]; return i } function decompressNormal(e, t) { let i = e[0], s = e[1]; i = (2 * i + 1) / 255, s = (2 * s + 1) / 255, (e = 1 - Math.abs(i) - Math.abs(s)) < 0 && (i = (1 - Math.abs(s)) * (0 <= i ? 1 : -1), s = (1 - Math.abs(i)) * (0 <= s ? 1 : -1)); var r = Math.sqrt(i * i + s * s + e * e); return t[0] = i / r, t[1] = s / r, t[2] = e / r, t } function decompressNormals(e, t) { for (let r = 0, a = 0, o = e.length; r < o; r += 2) { let o = e[r + 0], n = e[r + 1]; o = (2 * o + 1) / 255, n = (2 * n + 1) / 255; var i = 1 - Math.abs(o) - Math.abs(n), s = (i < 0 && (o = (1 - Math.abs(n)) * (0 <= o ? 1 : -1), n = (1 - Math.abs(o)) * (0 <= n ? 1 : -1)), Math.sqrt(o * o + n * n + i * i)); t[a + 0] = o / s, t[a + 1] = n / s, t[a + 2] = i / s, a += 3 } return t } const geometryCompressionUtils = { getPositionsBounds: getPositionsBounds, createPositionsDecodeMatrix: createPositionsDecodeMatrix, compressPositions: compressPositions, compressPosition: compressPosition, decompressPositions: decompressPositions, decompressPosition: decompressPosition, decompressAABB: decompressAABB, getUVBounds: getUVBounds, compressUVs: compressUVs, decompressUVs: decompressUVs, decompressUV: decompressUV, compressNormals: compressNormals, decompressNormals: decompressNormals, decompressNormal: decompressNormal }, memoryStats$1 = stats.memory, tempAABB$2 = math.AABB3(); class ReadableGeometry extends Geometry { get type() { return "ReadableGeometry" } get isReadableGeometry() { return !0 } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ compressGeometry: !!t.compressGeometry, primitive: null, primitiveName: null, positions: null, normals: null, colors: null, uv: null, indices: null, positionsDecodeMatrix: null, uvDecodeMatrix: null, positionsBuf: null, normalsBuf: null, colorsbuf: null, uvBuf: null, indicesBuf: null, hash: "" }), this._numTriangles = 0, this._edgeThreshold = t.edgeThreshold || 10, this._edgeIndicesBuf = null, this._pickTrianglePositionsBuf = null, this._pickTriangleColorsBuf = null, this._aabbDirty = !0, this._boundingSphere = !0, this._aabb = null, this._aabbDirty = !0, this._obb = null, this._obbDirty = !0; var i = this._state, s = this.scene.canvas.gl; switch (t.primitive = t.primitive || "triangles", t.primitive) { case "points": i.primitive = s.POINTS, i.primitiveName = t.primitive; break; case "lines": i.primitive = s.LINES, i.primitiveName = t.primitive; break; case "line-loop": i.primitive = s.LINE_LOOP, i.primitiveName = t.primitive; break; case "line-strip": i.primitive = s.LINE_STRIP, i.primitiveName = t.primitive; break; case "triangles": i.primitive = s.TRIANGLES, i.primitiveName = t.primitive; break; case "triangle-strip": i.primitive = s.TRIANGLE_STRIP, i.primitiveName = t.primitive; break; case "triangle-fan": i.primitive = s.TRIANGLE_FAN, i.primitiveName = t.primitive; break; default: this.error("Unsupported value for 'primitive': '" + t.primitive + "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'."), i.primitive = s.TRIANGLES, i.primitiveName = t.primitive }t.positions && (this._state.compressGeometry ? (e = geometryCompressionUtils.getPositionsBounds(t.positions), e = geometryCompressionUtils.compressPositions(t.positions, e.min, e.max), i.positions = e.quantized, i.positionsDecodeMatrix = e.decodeMatrix) : i.positions = t.positions.constructor === Float32Array ? t.positions : new Float32Array(t.positions)), t.colors && (i.colors = t.colors.constructor === Float32Array ? t.colors : new Float32Array(t.colors)), t.uv && (this._state.compressGeometry ? (e = geometryCompressionUtils.getUVBounds(t.uv), e = geometryCompressionUtils.compressUVs(t.uv, e.min, e.max), i.uv = e.quantized, i.uvDecodeMatrix = e.decodeMatrix) : i.uv = t.uv.constructor === Float32Array ? t.uv : new Float32Array(t.uv)), t.normals && (this._state.compressGeometry ? i.normals = geometryCompressionUtils.compressNormals(t.normals) : i.normals = t.normals.constructor === Float32Array ? t.normals : new Float32Array(t.normals)), t.indices && (i.indices = t.indices.constructor === Uint32Array || t.indices.constructor === Uint16Array ? t.indices : new Uint32Array(t.indices), "triangles" === this._state.primitiveName) && (this._numTriangles = t.indices.length / 3), this._buildHash(), memoryStats$1.meshes++, this._buildVBOs() } _buildVBOs() { var e, t = this._state, i = this.scene.canvas.gl; t.indices && (t.indicesBuf = new ArrayBuf(i, i.ELEMENT_ARRAY_BUFFER, t.indices, t.indices.length, 1, i.STATIC_DRAW), memoryStats$1.indices += t.indicesBuf.numItems), t.positions && (t.positionsBuf = new ArrayBuf(i, i.ARRAY_BUFFER, t.positions, t.positions.length, 3, i.STATIC_DRAW), memoryStats$1.positions += t.positionsBuf.numItems), t.normals && (e = t.compressGeometry, t.normalsBuf = new ArrayBuf(i, i.ARRAY_BUFFER, t.normals, t.normals.length, 3, i.STATIC_DRAW, e), memoryStats$1.normals += t.normalsBuf.numItems), t.colors && (t.colorsBuf = new ArrayBuf(i, i.ARRAY_BUFFER, t.colors, t.colors.length, 4, i.STATIC_DRAW), memoryStats$1.colors += t.colorsBuf.numItems), t.uv && (t.uvBuf = new ArrayBuf(i, i.ARRAY_BUFFER, t.uv, t.uv.length, 2, i.STATIC_DRAW), memoryStats$1.uvs += t.uvBuf.numItems) } _buildHash() { var e = this._state, t = ["/g"]; t.push("/" + e.primitive + ";"), e.positions && t.push("p"), e.colors && t.push("c"), (e.normals || e.autoVertexNormals) && t.push("n"), e.uv && t.push("u"), e.compressGeometry && t.push("cp"), t.push(";"), e.hash = t.join("") } _getEdgeIndices() { return this._edgeIndicesBuf || this._buildEdgeIndices(), this._edgeIndicesBuf } _getPickTrianglePositions() { return this._pickTrianglePositionsBuf || this._buildPickTriangleVBOs(), this._pickTrianglePositionsBuf } _getPickTriangleColors() { return this._pickTriangleColorsBuf || this._buildPickTriangleVBOs(), this._pickTriangleColorsBuf } _buildEdgeIndices() { var e, t = this._state; t.positions && t.indices && (e = this.scene.canvas.gl, t = buildEdgeIndices(t.positions, t.indices, t.positionsDecodeMatrix, this._edgeThreshold), this._edgeIndicesBuf = new ArrayBuf(e, e.ELEMENT_ARRAY_BUFFER, t, t.length, 1, e.STATIC_DRAW), memoryStats$1.indices += this._edgeIndicesBuf.numItems) } _buildPickTriangleVBOs() { var e, t, i = this._state; i.positions && i.indices && (e = this.scene.canvas.gl, t = (i = math.buildPickTriangles(i.positions, i.indices, i.compressGeometry)).positions, i = i.colors, this._pickTrianglePositionsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, t, t.length, 3, e.STATIC_DRAW), this._pickTriangleColorsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, i, i.length, 4, e.STATIC_DRAW, !0), memoryStats$1.positions += this._pickTrianglePositionsBuf.numItems, memoryStats$1.colors += this._pickTriangleColorsBuf.numItems) } _buildPickVertexVBOs() { } _webglContextLost() { this._sceneVertexBufs && this._sceneVertexBufs.webglContextLost() } _webglContextRestored() { this._sceneVertexBufs && this._sceneVertexBufs.webglContextRestored(), this._buildVBOs(), this._edgeIndicesBuf = null, this._pickVertexPositionsBuf = null, this._pickTrianglePositionsBuf = null, this._pickTriangleColorsBuf = null, this._pickVertexPositionsBuf = null, this._pickVertexColorsBuf = null } get primitive() { return this._state.primitiveName } get compressGeometry() { return this._state.compressGeometry } get positions() { return this._state.positions ? this._state.compressGeometry ? (this._decompressedPositions || (this._decompressedPositions = new Float32Array(this._state.positions.length), geometryCompressionUtils.decompressPositions(this._state.positions, this._state.positionsDecodeMatrix, this._decompressedPositions)), this._decompressedPositions) : this._state.positions : null } set positions(e) { var t, i = this._state, s = i.positions; s ? s.length !== e.length ? this.error("can't update geometry positions - new positions are wrong length") : (this._state.compressGeometry && (t = geometryCompressionUtils.getPositionsBounds(e), e = (t = geometryCompressionUtils.compressPositions(e, t.min, t.max)).quantized, i.positionsDecodeMatrix = t.decodeMatrix), s.set(e), i.positionsBuf && i.positionsBuf.setData(s), this._setAABBDirty(), this.glRedraw()) : this.error("can't update geometry positions - geometry has no positions") } get normals() { var e; if (this._state.normals) return this._state.compressGeometry ? (this._decompressedNormals || (e = this._state.normals.length, this._decompressedNormals = new Float32Array(e + e / 2), geometryCompressionUtils.decompressNormals(this._state.normals, this._decompressedNormals)), this._decompressedNormals) : this._state.normals } set normals(e) { var t, i; this._state.compressGeometry ? this.error("can't update geometry normals - quantized geometry is immutable") : (i = (t = this._state).normals) ? i.length !== e.length ? this.error("can't update geometry normals - new normals are wrong length") : (i.set(e), t.normalsBuf && t.normalsBuf.setData(i), this.glRedraw()) : this.error("can't update geometry normals - geometry has no normals") } get uv() { return this._state.uv ? this._state.compressGeometry ? (this._decompressedUV || (this._decompressedUV = new Float32Array(this._state.uv.length), geometryCompressionUtils.decompressUVs(this._state.uv, this._state.uvDecodeMatrix, this._decompressedUV)), this._decompressedUV) : this._state.uv : null } set uv(e) { var t, i; this._state.compressGeometry ? this.error("can't update geometry UVs - quantized geometry is immutable") : (i = (t = this._state).uv) ? i.length !== e.length ? this.error("can't update geometry UVs - new UVs are wrong length") : (i.set(e), t.uvBuf && t.uvBuf.setData(i), this.glRedraw()) : this.error("can't update geometry UVs - geometry has no UVs") } get colors() { return this._state.colors } set colors(e) { var t, i; this._state.compressGeometry ? this.error("can't update geometry colors - quantized geometry is immutable") : (i = (t = this._state).colors) ? i.length !== e.length ? this.error("can't update geometry colors - new colors are wrong length") : (i.set(e), t.colorsBuf && t.colorsBuf.setData(i), this.glRedraw()) : this.error("can't update geometry colors - geometry has no colors") } get indices() { return this._state.indices } get aabb() { return this._aabbDirty && (this._aabb || (this._aabb = math.AABB3()), math.positions3ToAABB3(this._state.positions, this._aabb, this._state.positionsDecodeMatrix), this._aabbDirty = !1), this._aabb } get obb() { return this._obbDirty && (this._obb || (this._obb = math.OBB3()), math.positions3ToAABB3(this._state.positions, tempAABB$2, this._state.positionsDecodeMatrix), math.AABB3ToOBB3(tempAABB$2, this._obb), this._obbDirty = !1), this._obb } get numTriangles() { return this._numTriangles } _setAABBDirty() { this._aabbDirty || (this._aabbDirty = !0, this._aabbDirty = !0, this._obbDirty = !0) } _getState() { return this._state } destroy() { super.destroy(); var e = this._state; e.indicesBuf && e.indicesBuf.destroy(), e.positionsBuf && e.positionsBuf.destroy(), e.normalsBuf && e.normalsBuf.destroy(), e.uvBuf && e.uvBuf.destroy(), e.colorsBuf && e.colorsBuf.destroy(), this._edgeIndicesBuf && this._edgeIndicesBuf.destroy(), this._pickTrianglePositionsBuf && this._pickTrianglePositionsBuf.destroy(), this._pickTriangleColorsBuf && this._pickTriangleColorsBuf.destroy(), this._pickVertexPositionsBuf && this._pickVertexPositionsBuf.destroy(), this._pickVertexColorsBuf && this._pickVertexColorsBuf.destroy(), e.destroy(), memoryStats$1.meshes-- } } const memoryStats = stats.memory, tempAABB$1 = math.AABB3(); class VBOGeometry extends Geometry { get type() { return "VBOGeometry" } get isVBOGeometry() { return !0 } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ compressGeometry: !0, primitive: null, primitiveName: null, positionsDecodeMatrix: null, uvDecodeMatrix: null, positionsBuf: null, normalsBuf: null, colorsbuf: null, uvBuf: null, indicesBuf: null, hash: "" }), this._numTriangles = 0, this._edgeThreshold = t.edgeThreshold || 10, this._aabb = null, this._obb = math.OBB3(); var i, s, r = this._state, a = this.scene.canvas.gl; switch (t.primitive = t.primitive || "triangles", t.primitive) { case "points": r.primitive = a.POINTS, r.primitiveName = t.primitive; break; case "lines": r.primitive = a.LINES, r.primitiveName = t.primitive; break; case "line-loop": r.primitive = a.LINE_LOOP, r.primitiveName = t.primitive; break; case "line-strip": r.primitive = a.LINE_STRIP, r.primitiveName = t.primitive; break; case "triangles": r.primitive = a.TRIANGLES, r.primitiveName = t.primitive; break; case "triangle-strip": r.primitive = a.TRIANGLE_STRIP, r.primitiveName = t.primitive; break; case "triangle-fan": r.primitive = a.TRIANGLE_FAN, r.primitiveName = t.primitive; break; default: this.error("Unsupported value for 'primitive': '" + t.primitive + "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'."), r.primitive = a.TRIANGLES, r.primitiveName = t.primitive }t.positions ? t.indices ? (t.positionsDecodeMatrix || (e = geometryCompressionUtils.getPositionsBounds(t.positions), i = (e = geometryCompressionUtils.compressPositions(t.positions, e.min, e.max)).quantized, r.positionsDecodeMatrix = e.decodeMatrix, r.positionsBuf = new ArrayBuf(a, a.ARRAY_BUFFER, i, i.length, 3, a.STATIC_DRAW), memoryStats.positions += r.positionsBuf.numItems, math.positions3ToAABB3(t.positions, this._aabb), math.positions3ToAABB3(i, tempAABB$1, r.positionsDecodeMatrix), math.AABB3ToOBB3(tempAABB$1, this._obb)), t.colors && (e = t.colors.constructor === Float32Array ? t.colors : new Float32Array(t.colors), r.colorsBuf = new ArrayBuf(a, a.ARRAY_BUFFER, e, e.length, 4, a.STATIC_DRAW), memoryStats.colors += r.colorsBuf.numItems), t.uv && (e = geometryCompressionUtils.getUVBounds(t.uv), s = (e = geometryCompressionUtils.compressUVs(t.uv, e.min, e.max)).quantized, r.uvDecodeMatrix = e.decodeMatrix, r.uvBuf = new ArrayBuf(a, a.ARRAY_BUFFER, s, s.length, 2, a.STATIC_DRAW), memoryStats.uvs += r.uvBuf.numItems), t.normals && (e = geometryCompressionUtils.compressNormals(t.normals), s = r.compressGeometry, r.normalsBuf = new ArrayBuf(a, a.ARRAY_BUFFER, e, e.length, 3, a.STATIC_DRAW, s), memoryStats.normals += r.normalsBuf.numItems), e = t.indices.constructor === Uint32Array || t.indices.constructor === Uint16Array ? t.indices : new Uint32Array(t.indices), r.indicesBuf = new ArrayBuf(a, a.ELEMENT_ARRAY_BUFFER, e, e.length, 1, a.STATIC_DRAW), memoryStats.indices += r.indicesBuf.numItems, s = buildEdgeIndices(i, e, r.positionsDecodeMatrix, this._edgeThreshold), this._edgeIndicesBuf = new ArrayBuf(a, a.ELEMENT_ARRAY_BUFFER, s, s.length, 1, a.STATIC_DRAW), "triangles" === this._state.primitiveName && (this._numTriangles = t.indices.length / 3), this._buildHash(), memoryStats.meshes++) : this.error("Config expected: indices") : this.error("Config expected: positions") } _buildHash() { var e = this._state, t = ["/g"]; t.push("/" + e.primitive + ";"), e.positionsBuf && t.push("p"), e.colorsBuf && t.push("c"), (e.normalsBuf || e.autoVertexNormals) && t.push("n"), e.uvBuf && t.push("u"), t.push("cp"), t.push(";"), e.hash = t.join("") } _getEdgeIndices() { return this._edgeIndicesBuf } get primitive() { return this._state.primitiveName } get aabb() { return this._aabb } get obb() { return this._obb } get numTriangles() { return this._numTriangles } _getState() { return this._state } destroy() { super.destroy(); var e = this._state; e.indicesBuf && e.indicesBuf.destroy(), e.positionsBuf && e.positionsBuf.destroy(), e.normalsBuf && e.normalsBuf.destroy(), e.uvBuf && e.uvBuf.destroy(), e.colorsBuf && e.colorsBuf.destroy(), this._edgeIndicesBuf && this._edgeIndicesBuf.destroy(), e.destroy(), memoryStats.meshes-- } } var K3D = {}; function load3DSGeometry(e, t = {}) { return new Promise((function (i, s) { t.src || (console.error("load3DSGeometry: Parameter expected: src"), s()); var r = e.canvas.spinner; r.processes++, utils.loadArraybuffer(t.src, (function (e) { e.byteLength || (console.error("load3DSGeometry: no data loaded"), r.processes--, s()); var a = (e = K3D.parse.from3DS(e).edit.objects[0].mesh).vertices, o = e.uvt; e = e.indices; r.processes--, i(utils.apply(t, { primitive: "triangles", positions: a, normals: null, uv: o, indices: e })) }), (function (e) { console.error("load3DSGeometry: " + e), r.processes--, s() })) })) } function loadOBJGeometry(e, t = {}) { return new Promise((function (i, s) { t.src || (console.error("loadOBJGeometry: Parameter expected: src"), s()); var r = e.canvas.spinner; r.processes++, utils.loadArraybuffer(t.src, (function (e) { e.byteLength || (console.error("loadOBJGeometry: no data loaded"), r.processes--, s()); for (var a = K3D.parse.fromOBJ(e), o = (e = K3D.edit.unwrap(a.i_verts, a.c_verts, 3), K3D.edit.unwrap(a.i_norms, a.c_norms, 3)), n = K3D.edit.unwrap(a.i_uvt, a.c_uvt, 2), h = new Int32Array(a.i_verts.length), l = 0; l < a.i_verts.length; l++)h[l] = l; r.processes--, i(utils.apply(t, { primitive: "triangles", positions: e, normals: 0 < o.length ? o : null, autoNormals: 0 === o.length, uv: n, indices: h })) }), (function (e) { console.error("loadOBJGeometry: " + e), r.processes--, s() })) })) } function buildBoxGeometry(e = {}) { let t = e.xSize || 1, i = (t < 0 && (console.error("negative xSize not allowed - will invert"), t *= -1), e.ySize || 1), s = (i < 0 && (console.error("negative ySize not allowed - will invert"), i *= -1), e.zSize || 1); s < 0 && (console.error("negative zSize not allowed - will invert"), s *= -1); var r = -t + (n = (l = e.center) ? l[0] : 0), a = -i + (h = l ? l[1] : 0), o = -s + (l = l ? l[2] : 0), n = t + n, h = i + h, l = s + l; return utils.apply(e, { positions: [n, h, l, r, h, l, r, a, l, n, a, l, n, h, l, n, a, l, n, a, o, n, h, o, n, h, l, n, h, o, r, h, o, r, h, l, r, h, l, r, h, o, r, a, o, r, a, l, r, a, o, n, a, o, n, a, l, r, a, l, n, a, o, r, a, o, r, h, o, n, h, o], normals: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1], uv: [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0], indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23] }) } function buildBoxLinesGeometry(e = {}) { let t = e.xSize || 1, i = (t < 0 && (console.error("negative xSize not allowed - will invert"), t *= -1), e.ySize || 1), s = (i < 0 && (console.error("negative ySize not allowed - will invert"), i *= -1), e.zSize || 1); s < 0 && (console.error("negative zSize not allowed - will invert"), s *= -1); var r = -t + (n = (l = e.center) ? l[0] : 0), a = -i + (h = l ? l[1] : 0), o = -s + (l = l ? l[2] : 0), n = t + n, h = i + h, l = s + l; return utils.apply(e, { primitive: "lines", positions: [r, a, o, r, a, l, r, h, o, r, h, l, n, a, o, n, a, l, n, h, o, n, h, l], indices: [0, 1, 1, 3, 3, 2, 2, 0, 4, 5, 5, 7, 7, 6, 6, 4, 0, 4, 1, 5, 2, 6, 3, 7] }) } function buildCylinderGeometry(e = {}) { let t = e.radiusTop || 1, i = (t < 0 && (console.error("negative radiusTop not allowed - will invert"), t *= -1), e.radiusBottom || 1), s = (i < 0 && (console.error("negative radiusBottom not allowed - will invert"), i *= -1), e.height || 1), r = (s < 0 && (console.error("negative height not allowed - will invert"), s *= -1), e.radialSegments || 32), a = (r < 0 && (console.error("negative radialSegments not allowed - will invert"), r *= -1), r < 3 && (r = 3), e.heightSegments || 1); a < 0 && (console.error("negative heightSegments not allowed - will invert"), a *= -1), a < 1 && (a = 1); var o = !!e.openEnded; let n = e.center; var h, l, c, u = n ? n[0] : 0, p = n ? n[1] : 0, d = n ? n[2] : 0, m = s / 2, f = s / a, g = 2 * Math.PI / r, _ = 1 / r, v = (t - i) / a, y = [], T = [], I = [], E = []; let C, P, b, A, D, R, F, w; var M = (90 - 180 * Math.atan(s / (i - t)) / Math.PI) / 90; for (C = 0; C <= a; C++)for (h = t - C * v, l = m - C * f, P = 0; P <= r; P++)b = Math.sin(P * g), A = Math.cos(P * g), T.push(h * b), T.push(M), T.push(h * A), I.push(P * _), I.push(+C / a), y.push(h * b + u), y.push(l + p), y.push(h * A + d); for (C = 0; C < a; C++)for (P = 0; P <= r; P++)c = (D = C * (r + 1) + P) + r, E.push(D), E.push(c), E.push(c + 1), E.push(D), E.push(c + 1), E.push(D + 1); if (!o && 0 < t) { for (R = y.length / 3, T.push(0), T.push(1), T.push(0), I.push(.5), I.push(.5), y.push(0 + u), y.push(m + p), y.push(0 + d), P = 0; P <= r; P++)b = Math.sin(P * g), A = Math.cos(P * g), F = .5 * Math.sin(P * g) + .5, w = .5 * Math.cos(P * g) + .5, T.push(t * b), T.push(1), T.push(t * A), I.push(F), I.push(w), y.push(t * b + u), y.push(m + p), y.push(t * A + d); for (P = 0; P < r; P++)n = R, D = R + 1 + P, E.push(D), E.push(D + 1), E.push(n) } if (!o && 0 < i) { for (R = y.length / 3, T.push(0), T.push(-1), T.push(0), I.push(.5), I.push(.5), y.push(0 + u), y.push(0 - m + p), y.push(0 + d), P = 0; P <= r; P++)b = Math.sin(P * g), A = Math.cos(P * g), F = .5 * Math.sin(P * g) + .5, w = .5 * Math.cos(P * g) + .5, T.push(i * b), T.push(-1), T.push(i * A), I.push(F), I.push(w), y.push(i * b + u), y.push(0 - m + p), y.push(i * A + d); for (P = 0; P < r; P++)n = R, D = R + 1 + P, E.push(n), E.push(D + 1), E.push(D) } return utils.apply(e, { positions: y, normals: T, uv: I, indices: E }) } function buildGridGeometry(e = {}) { let t = e.size || 1, i = (t < 0 && (console.error("negative size not allowed - will invert"), t *= -1), e.divisions || 1); i < 0 && (console.error("negative divisions not allowed - will invert"), i *= -1), i < 1 && (i = 1), t = t || 10, i = i || 10; var s = t / i, r = t / 2, a = [], o = []; let n = 0; for (let e = 0, t = -r; e <= i; e++, t += s)a.push(-r), a.push(0), a.push(t), a.push(r), a.push(0), a.push(t), a.push(t), a.push(0), a.push(-r), a.push(t), a.push(0), a.push(r), o.push(n++), o.push(n++), o.push(n++), o.push(n++); return utils.apply(e, { primitive: "lines", positions: a, indices: o }) } function buildPlaneGeometry(e = {}) { let t = e.xSize || 1, i = (t < 0 && (console.error("negative xSize not allowed - will invert"), t *= -1), e.zSize || 1), s = (i < 0 && (console.error("negative zSize not allowed - will invert"), i *= -1), e.xSegments || 1), r = (s < 0 && (console.error("negative xSegments not allowed - will invert"), s *= -1), s < 1 && (s = 1), e.xSegments || 1); r < 0 && (console.error("negative zSegments not allowed - will invert"), r *= -1), r < 1 && (r = 1); var a, o, n, h, l, c = e.center, u = c ? c[0] : 0, p = c ? c[1] : 0, d = c ? c[2] : 0, m = t / 2, f = i / 2, g = Math.floor(s) || 1, _ = Math.floor(r) || 1, v = g + 1, y = _ + 1, T = t / g, I = i / _, E = new Float32Array(v * y * 3), C = new Float32Array(v * y * 3), P = new Float32Array(v * y * 2); let b, A, D = 0, R = 0; for (b = 0; b < y; b++) { var F = b * I - f; for (A = 0; A < v; A++)a = A * T - m, E[D] = a + u, E[D + 1] = p, E[D + 2] = -F + d, C[D + 2] = -1, P[R] = A / g, P[R + 1] = (_ - b) / _, D += 3, R += 2 } D = 0; var w = new (65535 < E.length / 3 ? Uint32Array : Uint16Array)(g * _ * 6); for (b = 0; b < _; b++)for (A = 0; A < g; A++)o = A + v * b, n = A + v * (b + 1), h = A + 1 + v * (b + 1), l = A + 1 + v * b, w[D] = l, w[D + 1] = n, w[D + 2] = o, w[D + 3] = l, w[D + 4] = h, w[D + 5] = n, D += 6; return utils.apply(e, { positions: E, normals: C, uv: P, indices: w }) } function buildSphereGeometry(e = {}) { var t = e.lod || 1, i = e.center ? e.center[0] : 0, s = e.center ? e.center[1] : 0, r = e.center ? e.center[2] : 0; let a = e.radius || 1, o = (a < 0 && (console.error("negative radius not allowed - will invert"), a *= -1), e.heightSegments || 18), n = (o < 0 && (console.error("negative heightSegments not allowed - will invert"), o *= -1), (o = Math.floor(t * o)) < 18 && (o = 18), e.widthSegments || 18); n < 0 && (console.error("negative widthSegments not allowed - will invert"), n *= -1), (n = Math.floor(t * n)) < 18 && (n = 18); var h, l, c, u, p, d, m, f, g, _, v = [], y = [], T = [], I = []; let E, C; for (E = 0; E <= o; E++)for (h = E * Math.PI / o, l = Math.sin(h), c = Math.cos(h), C = 0; C <= n; C++)u = 2 * C * Math.PI / n, d = Math.sin(u), u = Math.cos(u) * l, p = c, d *= l, m = 1 - C / n, f = E / o, y.push(u), y.push(p), y.push(d), T.push(m), T.push(f), v.push(i + a * u), v.push(s + a * p), v.push(r + a * d); for (E = 0; E < o; E++)for (C = 0; C < n; C++)_ = (g = E * (n + 1) + C) + n + 1, I.push(g + 1), I.push(_ + 1), I.push(_), I.push(g + 1), I.push(_), I.push(g); return utils.apply(e, { positions: v, normals: y, uv: T, indices: I }) } function buildTorusGeometry(e = {}) { let t = e.radius || 1, i = (t < 0 && (console.error("negative radius not allowed - will invert"), t *= -1), t *= .5, e.tube || .3), s = (i < 0 && (console.error("negative tube not allowed - will invert"), i *= -1), e.radialSegments || 32), r = (s < 0 && (console.error("negative radialSegments not allowed - will invert"), s *= -1), s < 4 && (s = 4), e.tubeSegments || 24), a = (r < 0 && (console.error("negative tubeSegments not allowed - will invert"), r *= -1), r < 4 && (r = 4), e.arc || 2 * Math.PI); a < 0 && (console.warn("negative arc not allowed - will invert"), a *= -1), 360 < a && (a = 360); var o, n, h, l, c, u, p, d, m, f = e.center, g = (f && f[0], f && f[1], f ? f[2] : 0), _ = [], v = [], y = [], T = []; let I, E; for (E = 0; E <= r; E++)for (I = 0; I <= s; I++)h = I / s * a, l = .785398 + E / r * Math.PI * 2, o = t * Math.cos(h), n = t * Math.sin(h), c = (t + i * Math.cos(l)) * Math.cos(h), h = (t + i * Math.cos(l)) * Math.sin(h), l = i * Math.sin(l), _.push(c + o), _.push(h + n), _.push(l + g), y.push(1 - I / s), y.push(E / r), c = math.normalizeVec3(math.subVec3([c, h, l], [o, n, g], []), []), v.push(c[0]), v.push(c[1]), v.push(c[2]); for (E = 1; E <= r; E++)for (I = 1; I <= s; I++)u = (s + 1) * E + I - 1, p = (s + 1) * (E - 1) + I - 1, d = (s + 1) * (E - 1) + I, m = (s + 1) * E + I, T.push(u), T.push(p), T.push(d), T.push(d), T.push(m), T.push(u); return utils.apply(e, { positions: _, normals: v, uv: y, indices: T }) } K3D.load = function (e, t) { var i = new XMLHttpRequest; i.open("GET", e, !0), i.responseType = "arraybuffer", i.onload = function (e) { t(e.target.response) }, i.send() }, K3D.save = function (e, t) { e = "data:application/octet-stream;base64," + btoa(K3D.parse._buffToStr(e)), window.location.href = e }, K3D.clone = function (e) { return JSON.parse(JSON.stringify(e)) }, K3D.bin = {}, K3D.bin.f = new Float32Array(1), K3D.bin.fb = new Uint8Array(K3D.bin.f.buffer), K3D.bin.rf = function (e, t) { for (var i = K3D.bin.f, s = K3D.bin.fb, r = 0; r < 4; r++)s[r] = e[t + r]; return i[0] }, K3D.bin.rsl = function (e, t) { return e[t] | e[t + 1] << 8 }, K3D.bin.ril = function (e, t) { return e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24 }, K3D.bin.rASCII0 = function (e, t) { for (var i = ""; 0 != e[t];)i += String.fromCharCode(e[t++]); return i }, K3D.bin.wf = function (e, t, i) { new Float32Array(e.buffer, t, 1)[0] = i }, K3D.bin.wsl = function (e, t, i) { e[t] = i, e[t + 1] = i >> 8 }, K3D.bin.wil = function (e, t, i) { e[t] = i, e[t + 1] = i >> 8, e[t + 2] = i >> 16, e[t + 3] }, K3D.parse = {}, K3D.parse._buffToStr = function (e) { for (var t = new Uint8Array(e), i = "", s = 0; s < t.length; s++)i = i.concat(String.fromCharCode(t[s])); return i }, K3D.parse._strToBuff = function (e) { for (var t = new ArrayBuffer(e.length), i = new Uint8Array(t), s = 0; s < e.length; s++)i[s] = e.charCodeAt(s); return t }, K3D.parse._readLine = function (e, t) { for (var i = ""; 10 != e[t];)i += String.fromCharCode(e[t++]); return i }, K3D.parse.fromJSON = function (e) { return JSON.parse(K3D.parse._buffToStr(e)) }, K3D.parse.toJSON = function (e) { return e = JSON.stringify(e), K3D.parse._strToBuff(e) }, K3D.parse.fromOBJ = function (e) { for (var t = { groups: {}, c_verts: [], c_uvt: [], c_norms: [], i_verts: [], i_uvt: [], i_norms: [] }, i = { from: 0, to: 0 }, s = 0, r = new Uint8Array(e); s < r.length;) { var a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T = K3D.parse._readLine(r, s); s += T.length + 1, "g" == (T = (T = (T = T.replace(/ +(?= )/g, "")).replace(/(^\s+|\s+$)/g, "")).split(" "))[0] && (i.to = t.i_verts.length, null == t.groups[T[1]] && (t.groups[T[1]] = { from: t.i_verts.length, to: 0 }), i = t.groups[T[1]]), "v" == T[0] && (a = parseFloat(T[1]), o = parseFloat(T[2]), n = parseFloat(T[3]), t.c_verts.push(a, o, n)), "vt" == T[0] && (a = parseFloat(T[1]), o = 1 - parseFloat(T[2]), t.c_uvt.push(a, o)), "vn" == T[0] && (a = parseFloat(T[1]), o = parseFloat(T[2]), n = parseFloat(T[3]), t.c_norms.push(a, o, n)), "f" == T[0] && (p = T[1].split("/"), y = T[2].split("/"), d = T[3].split("/"), h = parseInt(p[0]) - 1, _ = parseInt(y[0]) - 1, l = parseInt(d[0]) - 1, c = parseInt(p[1]) - 1, v = parseInt(y[1]) - 1, u = parseInt(d[1]) - 1, p = parseInt(p[2]) - 1, y = parseInt(y[2]) - 1, d = parseInt(d[2]) - 1, m = t.c_verts.length / 3, f = t.c_uvt.length / 2, g = t.c_norms.length / 3, h < 0 && (h = m + h + 1), _ < 0 && (_ = m + _ + 1), l < 0 && (l = m + l + 1), c < 0 && (c = f + c + 1), v < 0 && (v = f + v + 1), u < 0 && (u = f + u + 1), p < 0 && (p = g + p + 1), y < 0 && (y = g + y + 1), d < 0 && (d = g + d + 1), t.i_verts.push(h, _, l), t.i_uvt.push(c, v, u), t.i_norms.push(p, y, d), 5 == T.length) && (_ = T[4].split("/"), (v = parseInt(_[0]) - 1) < 0 && (v = m + v + 1), (y = parseInt(_[1]) - 1) < 0 && (y = f + y + 1), (T = parseInt(_[2]) - 1) < 0 && (T = g + T + 1), t.i_verts.push(h, l, v), t.i_uvt.push(c, u, y), t.i_norms.push(p, d, T)) } return i.to = t.i_verts.length, t }, K3D.parse.fromMD2 = function (e) { e = new Uint8Array(e); var t = {}, i = {}, s = (i.ident = K3D.bin.ril(e, 0), i.version = K3D.bin.ril(e, 4), i.skinwidth = K3D.bin.ril(e, 8), i.skinheight = K3D.bin.ril(e, 12), i.framesize = K3D.bin.ril(e, 16), i.num_skins = K3D.bin.ril(e, 20), i.num_vertices = K3D.bin.ril(e, 24), i.num_st = K3D.bin.ril(e, 28), i.num_tris = K3D.bin.ril(e, 32), i.num_glcmds = K3D.bin.ril(e, 36), i.num_frames = K3D.bin.ril(e, 40), i.offset_skins = K3D.bin.ril(e, 44), i.offset_st = K3D.bin.ril(e, 48), i.offset_tris = K3D.bin.ril(e, 52), i.offset_frames = K3D.bin.ril(e, 56), i.offset_glcmds = K3D.bin.ril(e, 60), i.offset_end = K3D.bin.ril(e, 64), i.offset_st); t.c_uvt = []; for (var r = 0; r < i.num_st; r++) { var a = K3D.bin.rsl(e, s) / i.skinwidth, o = K3D.bin.rsl(e, s + 2) / i.skinheight; t.c_uvt.push(a, o), s += 4 } s = i.offset_tris; var n = [], h = []; for (t.i_verts = n, t.i_uvt = h, r = 0; r < i.num_tris; r++)n.push(K3D.bin.rsl(e, s), K3D.bin.rsl(e, s + 2), K3D.bin.rsl(e, s + 4)), h.push(K3D.bin.rsl(e, s + 6), K3D.bin.rsl(e, s + 8), K3D.bin.rsl(e, s + 10)), s += 12; for (s = i.offset_skins, t.skins = [], r = 0; r < i.num_skins; r++)t.skins.push(K3D.bin.rASCII0(e, s)), s += 64; s = i.offset_frames; var l = (t.frames = [], K3D.parse.fromMD2._normals); for (r = 0; r < i.num_frames; r++) { var c = {}, u = K3D.bin.rf(e, s), p = K3D.bin.rf(e, s + 4), d = K3D.bin.rf(e, s + 8), m = (s += 12, K3D.bin.rf(e, s)), f = K3D.bin.rf(e, s + 4), g = K3D.bin.rf(e, s + 8); s += 12, c.name = K3D.bin.rASCII0(e, s), s += 16, c.verts = [], c.norms = []; for (var _ = 0; _ < i.num_vertices; _++)c.verts.push(e[s] * u + m, e[s + 1] * p + f, e[s + 2] * d + g), c.norms.push(l[3 * e[s + 3]], l[3 * e[s + 3] + 1], l[3 * e[s + 3] + 2]), s += 4; t.frames.push(c) } return t }, K3D.parse.fromMD2._normals = [-.525731, 0, .850651, -.442863, .238856, .864188, -.295242, 0, .955423, -.309017, .5, .809017, -.16246, .262866, .951056, 0, 0, 1, 0, .850651, .525731, -.147621, .716567, .681718, .147621, .716567, .681718, 0, .525731, .850651, .309017, .5, .809017, .525731, 0, .850651, .295242, 0, .955423, .442863, .238856, .864188, .16246, .262866, .951056, -.681718, .147621, .716567, -.809017, .309017, .5, -.587785, .425325, .688191, -.850651, .525731, 0, -.864188, .442863, .238856, -.716567, .681718, .147621, -.688191, .587785, .425325, -.5, .809017, .309017, -.238856, .864188, .442863, -.425325, .688191, .587785, -.716567, .681718, -.147621, -.5, .809017, -.309017, -.525731, .850651, 0, 0, .850651, -.525731, -.238856, .864188, -.442863, 0, .955423, -.295242, -.262866, .951056, -.16246, 0, 1, 0, 0, .955423, .295242, -.262866, .951056, .16246, .238856, .864188, .442863, .262866, .951056, .16246, .5, .809017, .309017, .238856, .864188, -.442863, .262866, .951056, -.16246, .5, .809017, -.309017, .850651, .525731, 0, .716567, .681718, .147621, .716567, .681718, -.147621, .525731, .850651, 0, .425325, .688191, .587785, .864188, .442863, .238856, .688191, .587785, .425325, .809017, .309017, .5, .681718, .147621, .716567, .587785, .425325, .688191, .955423, .295242, 0, 1, 0, 0, .951056, .16246, .262866, .850651, -.525731, 0, .955423, -.295242, 0, .864188, -.442863, .238856, .951056, -.16246, .262866, .809017, -.309017, .5, .681718, -.147621, .716567, .850651, 0, .525731, .864188, .442863, -.238856, .809017, .309017, -.5, .951056, .16246, -.262866, .525731, 0, -.850651, .681718, .147621, -.716567, .681718, -.147621, -.716567, .850651, 0, -.525731, .809017, -.309017, -.5, .864188, -.442863, -.238856, .951056, -.16246, -.262866, .147621, .716567, -.681718, .309017, .5, -.809017, .425325, .688191, -.587785, .442863, .238856, -.864188, .587785, .425325, -.688191, .688191, .587785, -.425325, -.147621, .716567, -.681718, -.309017, .5, -.809017, 0, .525731, -.850651, -.525731, 0, -.850651, -.442863, .238856, -.864188, -.295242, 0, -.955423, -.16246, .262866, -.951056, 0, 0, -1, .295242, 0, -.955423, .16246, .262866, -.951056, -.442863, -.238856, -.864188, -.309017, -.5, -.809017, -.16246, -.262866, -.951056, 0, -.850651, -.525731, -.147621, -.716567, -.681718, .147621, -.716567, -.681718, 0, -.525731, -.850651, .309017, -.5, -.809017, .442863, -.238856, -.864188, .16246, -.262866, -.951056, .238856, -.864188, -.442863, .5, -.809017, -.309017, .425325, -.688191, -.587785, .716567, -.681718, -.147621, .688191, -.587785, -.425325, .587785, -.425325, -.688191, 0, -.955423, -.295242, 0, -1, 0, .262866, -.951056, -.16246, 0, -.850651, .525731, 0, -.955423, .295242, .238856, -.864188, .442863, .262866, -.951056, .16246, .5, -.809017, .309017, .716567, -.681718, .147621, .525731, -.850651, 0, -.238856, -.864188, -.442863, -.5, -.809017, -.309017, -.262866, -.951056, -.16246, -.850651, -.525731, 0, -.716567, -.681718, -.147621, -.716567, -.681718, .147621, -.525731, -.850651, 0, -.5, -.809017, .309017, -.238856, -.864188, .442863, -.262866, -.951056, .16246, -.864188, -.442863, .238856, -.809017, -.309017, .5, -.688191, -.587785, .425325, -.681718, -.147621, .716567, -.442863, -.238856, .864188, -.587785, -.425325, .688191, -.309017, -.5, .809017, -.147621, -.716567, .681718, -.425325, -.688191, .587785, -.16246, -.262866, .951056, .442863, -.238856, .864188, .16246, -.262866, .951056, .309017, -.5, .809017, .147621, -.716567, .681718, 0, -.525731, .850651, .425325, -.688191, .587785, .587785, -.425325, .688191, .688191, -.587785, .425325, -.955423, .295242, 0, -.951056, .16246, .262866, -1, 0, 0, -.850651, 0, .525731, -.955423, -.295242, 0, -.951056, -.16246, .262866, -.864188, .442863, -.238856, -.951056, .16246, -.262866, -.809017, .309017, -.5, -.864188, -.442863, -.238856, -.951056, -.16246, -.262866, -.809017, -.309017, -.5, -.681718, .147621, -.716567, -.681718, -.147621, -.716567, -.850651, 0, -.525731, -.688191, .587785, -.425325, -.587785, .425325, -.688191, -.425325, .688191, -.587785, -.425325, -.688191, -.587785, -.587785, -.425325, -.688191, -.688191, -.587785, -.425325], K3D.parse.fromCollada = function (e) { e = K3D.parse._buffToStr(e); var t = {}, i = (e = (e = (new DOMParser).parseFromString(e, "text/xml")).childNodes[0]).getElementsByTagName("asset")[0], s = e.getElementsByTagName("library_geometries")[0], r = e.getElementsByTagName("library_images")[0], a = e.getElementsByTagName("library_materials")[0]; e = e.getElementsByTagName("library_effects")[0]; return i && (t.asset = K3D.parse.fromCollada._asset(i)), s && (t.geometries = K3D.parse.fromCollada._libGeometries(s)), r && (t.images = K3D.parse.fromCollada._libImages(r)), a && (t.materials = K3D.parse.fromCollada._libMaterials(a)), e && (t.effects = K3D.parse.fromCollada._libEffects(e)), t }, K3D.parse.fromCollada._asset = function (e) { return { created: e.getElementsByTagName("created")[0].textContent, modified: e.getElementsByTagName("modified")[0].textContent, up_axis: e.getElementsByTagName("up_axis")[0].textContent } }, K3D.parse.fromCollada._libGeometries = function (e) { e = e.getElementsByTagName("geometry"); for (var t = [], i = 0; i < e.length; i++) { var s = e[i]; s = K3D.parse.fromCollada._getMesh(s.getElementsByTagName("mesh")[0]); t.push(s) } return t }, K3D.parse.fromCollada._getMesh = function (e) { for (var t = {}, i = e.getElementsByTagName("source"), s = t.sources = {}, r = 0; r < i.length; r++) { for (var a = i[r].getElementsByTagName("float_array")[0].textContent.split(" "), o = a.length - ("" == a[a.length - 1] ? 1 : 0), n = new Array(o), h = 0; h < o; h++)n[h] = parseFloat(a[h]); s[i[r].getAttribute("id")] = n } t.triangles = []; var l = e.getElementsByTagName("triangles"); if (null != l) for (r = 0; r < l.length; r++) { var c = {}, u = l[r], p = (c.material = u.getAttribute("material"), u.getElementsByTagName("input")), d = []; for (h = 0; h < p.length; h++) { var m = p[h], f = (n = [], d[parseInt(m.getAttribute("offset"))] = n, m.getAttribute("semantic")); c["s_" + f] = ("VERTEX" == f ? e.getElementsByTagName("vertices")[0].getElementsByTagName("input")[0] : m).getAttribute("source").substring(1), c["i_" + f] = n, s[c["s_" + f]] } var g = u.getElementsByTagName("p")[0].textContent.split(" "), _ = 3 * Math.floor(g.length / 3); for (h = 0; h < _; h++)d[h % p.length].push(parseInt(g[h])); t.triangles.push(c) } return t }, K3D.parse.fromCollada._libImages = function (e) { e = e.getElementsByTagName("image"); for (var t = {}, i = 0; i < e.length; i++)t[e[i].getAttribute("id")] = e[i].getElementsByTagName("init_from")[0].textContent; return t }, K3D.parse.fromCollada._libMaterials = function (e) { e = e.getElementsByTagName("material"); for (var t = {}, i = 0; i < e.length; i++)t[e[i].getAttribute("name")] = e[i].getElementsByTagName("instance_effect")[0].getAttribute("url").substring(1); return t }, K3D.parse.fromCollada._libEffects = function (e) { e = e.getElementsByTagName("effect"); for (var t = {}, i = 0; i < e.length; i++) { for (var s = {}, r = e[i].getElementsByTagName("newparam"), a = 0; a < r.length; a++) { var o = r[a].getElementsByTagName("surface")[0]; o && (s.surface = o.getElementsByTagName("init_from")[0].textContent) } t[e[i].getAttribute("id")] = s } return t }, K3D.parse.from3DS = function (e) { e = new Uint8Array(e); var t = {}; if (19789 != K3D.bin.rsl(e, 0)) return null; for (var i = K3D.bin.ril(e, 2), s = 6; s < i;) { var r = K3D.bin.rsl(e, s), a = K3D.bin.ril(e, s + 2); 15677 == r && (t.edit = K3D.parse.from3DS._edit3ds(e, s, a)), 45056 == r && (t.keyf = K3D.parse.from3DS._keyf3ds(e, s, a)), s += a } return t }, K3D.parse.from3DS._edit3ds = function (e, t, i) { for (var s = {}, r = t + 6; r < t + i;) { var a = K3D.bin.rsl(e, r), o = K3D.bin.ril(e, r + 2); 16384 == a && (null == s.objects && (s.objects = []), s.objects.push(K3D.parse.from3DS._edit_object(e, r, o))), r += o } return s }, K3D.parse.from3DS._keyf3ds = function (e, t, i) { for (var s = {}, r = t + 6; r < t + i;) { var a = K3D.bin.rsl(e, r), o = K3D.bin.ril(e, r + 2); 45058 == a && (null == s.desc && (s.desc = []), s.desc.push(K3D.parse.from3DS._keyf_objdes(e, r, o))), r += o } return s }, K3D.parse.from3DS._keyf_objdes = function (e, t, i) { for (var s = {}, r = t + 6; r < t + i;) { var a = K3D.bin.rsl(e, r), o = K3D.bin.ril(e, r + 2); 45072 == a && (s.hierarchy = K3D.parse.from3DS._keyf_objhierarch(e, r, o)), 45073 == a && (s.dummy_name = K3D.bin.rASCII0(e, r + 6)), r += o } return s }, K3D.parse.from3DS._keyf_objhierarch = function (e, t, i) { var s = {}; t += 6; return s.name = K3D.bin.rASCII0(e, t), t += s.name.length + 1, s.hierarchy = K3D.bin.rsl(e, t + 4), s }, K3D.parse.from3DS._edit_object = function (e, t, i) { var s = {}, r = t + 6; for (s.name = K3D.bin.rASCII0(e, r), r += s.name.length + 1; r < t + i;) { var a = K3D.bin.rsl(e, r), o = K3D.bin.ril(e, r + 2); 16640 == a && (s.mesh = K3D.parse.from3DS._obj_trimesh(e, r, o)), r += o } return s }, K3D.parse.from3DS._obj_trimesh = function (e, t, i) { for (var s = {}, r = t + 6; r < t + i;) { var a = K3D.bin.rsl(e, r), o = K3D.bin.ril(e, r + 2); 16656 == a && (s.vertices = K3D.parse.from3DS._tri_vertexl(e, r, o)), 16672 == a && (s.indices = K3D.parse.from3DS._tri_facel1(e, r, o)), 16704 == a && (s.uvt = K3D.parse.from3DS._tri_mappingcoors(e, r, o)), 16736 == a && (s.local = K3D.parse.from3DS._tri_local(e, r, o)), r += o } return s }, K3D.parse.from3DS._tri_vertexl = function (e, t, i) { var s = [], r = t + 6, a = K3D.bin.rsl(e, r); r += 2; for (var o = 0; o < a; o++)s.push(K3D.bin.rf(e, r)), s.push(K3D.bin.rf(e, r + 4)), s.push(K3D.bin.rf(e, r + 8)), r += 12; return s }, K3D.parse.from3DS._tri_facel1 = function (e, t, i) { var s = [], r = t + 6, a = K3D.bin.rsl(e, r); r += 2; for (var o = 0; o < a; o++)s.push(K3D.bin.rsl(e, r)), s.push(K3D.bin.rsl(e, r + 2)), s.push(K3D.bin.rsl(e, r + 4)), r += 8; return s }, K3D.parse.from3DS._tri_mappingcoors = function (e, t, i) { var s = [], r = t + 6, a = K3D.bin.rsl(e, r); r += 2; for (var o = 0; o < a; o++)s.push(K3D.bin.rf(e, r)), s.push(1 - K3D.bin.rf(e, r + 4)), r += 8; return s }, K3D.parse.from3DS._tri_local = function (e, t, i) { var s = {}; t += 6; return s.X = [K3D.bin.rf(e, t), K3D.bin.rf(e, t + 4), K3D.bin.rf(e, t + 8)], s.Y = [K3D.bin.rf(e, t += 12), K3D.bin.rf(e, t + 4), K3D.bin.rf(e, t + 8)], s.Z = [K3D.bin.rf(e, t += 12), K3D.bin.rf(e, t + 4), K3D.bin.rf(e, t + 8)], s.C = [K3D.bin.rf(e, t += 12), K3D.bin.rf(e, t + 4), K3D.bin.rf(e, t + 8)], s }, K3D.parse.fromBIV = function (e) { e = new Uint8Array(e); var t = {}, i = {}; return i.id = K3D.bin.ril(e, 0), i.verS = K3D.bin.ril(e, 4), i.texS = K3D.bin.ril(e, 8), i.indS = K3D.bin.ril(e, 12), i.verO = K3D.bin.ril(e, 16), i.verL = K3D.bin.ril(e, 20), i.texO = K3D.bin.ril(e, 24), i.texL = K3D.bin.ril(e, 28), i.indO = K3D.bin.ril(e, 32), i.indL = K3D.bin.ril(e, 36), 0 != i.verO && (t.vertices = K3D.parse.fromBIV._readFloats(e, i.verO, i.verL)), 0 != i.texO && (t.uvt = K3D.parse.fromBIV._readFloats(e, i.texO, i.texL)), 0 != i.indO && (t.indices = K3D.parse.fromBIV._readInts(e, i.indO, i.indL, i.indS)), t }, K3D.parse.toBIV = function (e) { for (var t = 0, i = 0; i < e.indices.length; i++)t = Math.max(t, e.indices[i]); var s = 32, r = (t <= 65535 && (s = 16), 40), a = (r = (e.vertices && (r += 4 * e.vertices.length), e.uvt && (r += 4 * e.uvt.length), e.indices && (r += e.indices.length * s / 8), new Uint8Array(r)), K3D.bin.wil(r, 0, 1769365870), K3D.bin.wil(r, 4, 32), K3D.bin.wil(r, 8, 32), K3D.bin.wil(r, 12, s), 40); return e.vertices && (K3D.bin.wil(r, 16, a), K3D.bin.wil(r, 20, 4 * e.vertices.length), K3D.parse.fromBIV._writeFloats(r, a, e.vertices), a += 4 * e.vertices.length), e.uvt && (K3D.bin.wil(r, 24, a), K3D.bin.wil(r, 28, 4 * e.uvt.length), K3D.parse.fromBIV._writeFloats(r, a, e.uvt), a += 4 * e.uvt.length), e.indices && (K3D.bin.wil(r, 32, a), K3D.bin.wil(r, 36, 4 * e.indices.length), K3D.parse.fromBIV._writeInts(r, a, e.indices, s)), r.buffer }, K3D.parse.fromBIV._readFloats = function (e, t, i) { for (var s = [], r = 0; r < i / 4; r++)s.push(K3D.bin.rf(e, t + 4 * r)); return s }, K3D.parse.fromBIV._writeFloats = function (e, t, i) { for (var s = 0; s < i.length; s++)K3D.bin.wf(e, t + 4 * s, i[s]) }, K3D.parse.fromBIV._readInts = function (e, t, i, s) { for (var r = [], a = 0; a < i / 4; a++)16 == s && r.push(K3D.bin.rsl(e, t + 2 * a)), 32 == s && r.push(K3D.bin.ril(e, t + 4 * a)); return r }, K3D.parse.fromBIV._writeInts = function (e, t, i, s) { for (var r = 0; r < i.length; r++)16 == s && K3D.bin.wsl(e, t + 2 * r, i[r]), 32 == s && K3D.bin.wil(e, t + 4 * r, i[r]) }, K3D.gen = {}, K3D.gen.Plane = function (e, t, i, s) { i = i || 1, s = s || 1; for (var r = { verts: [], inds: [], uvt: [] }, a = e + 1, o = t + 1, n = 0; n < o; n++)for (var h = 0; h < a; h++)r.verts.push(h * (2 / e) - 1, n * (2 / t) - 1, 0), r.uvt.push(i * h / e, s * n / t), n < t && h < e && r.inds.push(n * a + h, n * a + h + 1, (n + 1) * a + h, n * a + h + 1, (n + 1) * a + h, (n + 1) * a + h + 1); return r }, K3D.gen.Cube = function () { return { verts: [-1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1], inds: [0, 1, 2, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 17, 18, 17, 18, 19, 20, 21, 22, 21, 22, 23], uvt: [.25, .25, .5, .25, .25, .5, .5, .5, 1, .25, .75, .25, 1, .5, .75, .5, 0, .25, .25, .25, 0, .5, .25, .5, .75, .25, .5, .25, .75, .5, .5, .5, .25, .25, .5, .25, .25, 0, .5, 0, .25, .5, .5, .5, .25, .75, .5, .75] } }, K3D.gen.Sphere = function (e, t) { for (var i = { verts: [], inds: [], uvt: [] }, s = e + 1, r = t + 1, a = 0; a < r; a++)for (var o = 0; o < s; o++) { var n = -Math.PI / 2 + a * Math.PI / t, h = 2 * o * Math.PI / e, l = Math.cos(n) * Math.cos(h), c = Math.sin(n); n = Math.cos(n) * Math.sin(h); i.verts.push(l, c, n), i.uvt.push(o / e, a / t), a < t && o < e && i.inds.push(s * a + o, s * a + o + 1, s * (a + 1) + o, s * a + o + 1, s * (a + 1) + o, s * (a + 1) + o + 1) } return i }, K3D.mat = {}, K3D.mat.scale = function (e, t, i) { return [e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1] }, K3D.mat.translate = function (e, t, i) { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1] }, K3D.mat.rotateDeg = function (e, t, i) { var s = Math.PI / 180; return K3D.mat.rotate(e * s, t * s, i * s) }, K3D.mat.rotate = function (e, t, i) { var s = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], r = Math.cos(e), a = Math.cos(t), o = Math.cos(i); e = Math.sin(e), t = Math.sin(t), i = Math.sin(i); return s[0] = a * o, s[1] = -a * i, s[2] = t, s[4] = r * i + e * t * o, s[5] = r * o - e * t * i, s[6] = -e * a, s[8] = e * i - r * t * o, s[9] = e * o + r * t * i, s[10] = r * a, s }, K3D.edit = {}, K3D.edit.interpolate = function (e, t, i, s) { for (var r = 0; r < e.length; r++)i[r] = e[r] + s * (t[r] - e[r]) }, K3D.edit.transform = function (e, t) { for (var i = 0; i < e.length; i += 3) { var s = e[i], r = e[i + 1], a = e[i + 2]; e[i + 0] = t[0] * s + t[4] * r + t[8] * a + t[12], e[i + 1] = t[1] * s + t[5] * r + t[9] * a + t[13], e[i + 2] = t[2] * s + t[6] * r + t[10] * a + t[14] } }, K3D.edit.unwrap = function (e, t, i) { for (var s = new Array(Math.floor(e.length / 3) * i), r = 0; r < e.length; r++)for (var a = 0; a < i; a++)s[r * i + a] = t[e[r] * i + a]; return s }, K3D.edit.remap = function (e, t, i, s) { for (var r = new Array(i.length), a = 0; a < e.length; a++)for (var o = 0; o < s; o++)r[t[a] * s + o] = i[e[a] * s + o]; return r }, K3D.utils = {}, K3D.utils.getAABB = function (e) { for (var t, i, s, r, a = t = i = 999999999, o = s = r = -a, n = 0; n < e.length; n += 3) { var h = e[n + 0], l = e[n + 1], c = e[n + 2]; h < a && (a = h), o < h && (o = h), l < t && (t = l), s < l && (s = l), c < i && (i = c), r < l && (r = c) } return { min: { x: a, y: t, z: i }, max: { x: o, y: s, z: r } } }; const letters = { " ": { width: 16, points: [] }, "!": { width: 10, points: [[5, 21], [5, 7], [-1, -1], [5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, '"': { width: 16, points: [[4, 21], [4, 14], [-1, -1], [12, 21], [12, 14]] }, "#": { width: 21, points: [[11, 25], [4, -7], [-1, -1], [17, 25], [10, -7], [-1, -1], [4, 12], [18, 12], [-1, -1], [3, 6], [17, 6]] }, $: { width: 20, points: [[8, 25], [8, -4], [-1, -1], [12, 25], [12, -4], [-1, -1], [17, 18], [15, 20], [12, 21], [8, 21], [5, 20], [3, 18], [3, 16], [4, 14], [5, 13], [7, 12], [13, 10], [15, 9], [16, 8], [17, 6], [17, 3], [15, 1], [12, 0], [8, 0], [5, 1], [3, 3]] }, "%": { width: 24, points: [[21, 21], [3, 0], [-1, -1], [8, 21], [10, 19], [10, 17], [9, 15], [7, 14], [5, 14], [3, 16], [3, 18], [4, 20], [6, 21], [8, 21], [10, 20], [13, 19], [16, 19], [19, 20], [21, 21], [-1, -1], [17, 7], [15, 6], [14, 4], [14, 2], [16, 0], [18, 0], [20, 1], [21, 3], [21, 5], [19, 7], [17, 7]] }, "&": { width: 26, points: [[23, 12], [23, 13], [22, 14], [21, 14], [20, 13], [19, 11], [17, 6], [15, 3], [13, 1], [11, 0], [7, 0], [5, 1], [4, 2], [3, 4], [3, 6], [4, 8], [5, 9], [12, 13], [13, 14], [14, 16], [14, 18], [13, 20], [11, 21], [9, 20], [8, 18], [8, 16], [9, 13], [11, 10], [16, 3], [18, 1], [20, 0], [22, 0], [23, 1], [23, 2]] }, "'": { width: 10, points: [[5, 19], [4, 20], [5, 21], [6, 20], [6, 18], [5, 16], [4, 15]] }, "(": { width: 14, points: [[11, 25], [9, 23], [7, 20], [5, 16], [4, 11], [4, 7], [5, 2], [7, -2], [9, -5], [11, -7]] }, ")": { width: 14, points: [[3, 25], [5, 23], [7, 20], [9, 16], [10, 11], [10, 7], [9, 2], [7, -2], [5, -5], [3, -7]] }, "*": { width: 16, points: [[8, 21], [8, 9], [-1, -1], [3, 18], [13, 12], [-1, -1], [13, 18], [3, 12]] }, "+": { width: 26, points: [[13, 18], [13, 0], [-1, -1], [4, 9], [22, 9]] }, ",": { width: 10, points: [[6, 1], [5, 0], [4, 1], [5, 2], [6, 1], [6, -1], [5, -3], [4, -4]] }, "-": { width: 26, points: [[4, 9], [22, 9]] }, ".": { width: 10, points: [[5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, "/": { width: 22, points: [[20, 25], [2, -7]] }, 0: { width: 20, points: [[9, 21], [6, 20], [4, 17], [3, 12], [3, 9], [4, 4], [6, 1], [9, 0], [11, 0], [14, 1], [16, 4], [17, 9], [17, 12], [16, 17], [14, 20], [11, 21], [9, 21]] }, 1: { width: 20, points: [[6, 17], [8, 18], [11, 21], [11, 0]] }, 2: { width: 20, points: [[4, 16], [4, 17], [5, 19], [6, 20], [8, 21], [12, 21], [14, 20], [15, 19], [16, 17], [16, 15], [15, 13], [13, 10], [3, 0], [17, 0]] }, 3: { width: 20, points: [[5, 21], [16, 21], [10, 13], [13, 13], [15, 12], [16, 11], [17, 8], [17, 6], [16, 3], [14, 1], [11, 0], [8, 0], [5, 1], [4, 2], [3, 4]] }, 4: { width: 20, points: [[13, 21], [3, 7], [18, 7], [-1, -1], [13, 21], [13, 0]] }, 5: { width: 20, points: [[15, 21], [5, 21], [4, 12], [5, 13], [8, 14], [11, 14], [14, 13], [16, 11], [17, 8], [17, 6], [16, 3], [14, 1], [11, 0], [8, 0], [5, 1], [4, 2], [3, 4]] }, 6: { width: 20, points: [[16, 18], [15, 20], [12, 21], [10, 21], [7, 20], [5, 17], [4, 12], [4, 7], [5, 3], [7, 1], [10, 0], [11, 0], [14, 1], [16, 3], [17, 6], [17, 7], [16, 10], [14, 12], [11, 13], [10, 13], [7, 12], [5, 10], [4, 7]] }, 7: { width: 20, points: [[17, 21], [7, 0], [-1, -1], [3, 21], [17, 21]] }, 8: { width: 20, points: [[8, 21], [5, 20], [4, 18], [4, 16], [5, 14], [7, 13], [11, 12], [14, 11], [16, 9], [17, 7], [17, 4], [16, 2], [15, 1], [12, 0], [8, 0], [5, 1], [4, 2], [3, 4], [3, 7], [4, 9], [6, 11], [9, 12], [13, 13], [15, 14], [16, 16], [16, 18], [15, 20], [12, 21], [8, 21]] }, 9: { width: 20, points: [[16, 14], [15, 11], [13, 9], [10, 8], [9, 8], [6, 9], [4, 11], [3, 14], [3, 15], [4, 18], [6, 20], [9, 21], [10, 21], [13, 20], [15, 18], [16, 14], [16, 9], [15, 4], [13, 1], [10, 0], [8, 0], [5, 1], [4, 3]] }, ":": { width: 10, points: [[5, 14], [4, 13], [5, 12], [6, 13], [5, 14], [-1, -1], [5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, ";": { width: 10, points: [[5, 14], [4, 13], [5, 12], [6, 13], [5, 14], [-1, -1], [6, 1], [5, 0], [4, 1], [5, 2], [6, 1], [6, -1], [5, -3], [4, -4]] }, "<": { width: 24, points: [[20, 18], [4, 9], [20, 0]] }, "=": { width: 26, points: [[4, 12], [22, 12], [-1, -1], [4, 6], [22, 6]] }, ">": { width: 24, points: [[4, 18], [20, 9], [4, 0]] }, "?": { width: 18, points: [[3, 16], [3, 17], [4, 19], [5, 20], [7, 21], [11, 21], [13, 20], [14, 19], [15, 17], [15, 15], [14, 13], [13, 12], [9, 10], [9, 7], [-1, -1], [9, 2], [8, 1], [9, 0], [10, 1], [9, 2]] }, "@": { width: 27, points: [[18, 13], [17, 15], [15, 16], [12, 16], [10, 15], [9, 14], [8, 11], [8, 8], [9, 6], [11, 5], [14, 5], [16, 6], [17, 8], [-1, -1], [12, 16], [10, 14], [9, 11], [9, 8], [10, 6], [11, 5], [-1, -1], [18, 16], [17, 8], [17, 6], [19, 5], [21, 5], [23, 7], [24, 10], [24, 12], [23, 15], [22, 17], [20, 19], [18, 20], [15, 21], [12, 21], [9, 20], [7, 19], [5, 17], [4, 15], [3, 12], [3, 9], [4, 6], [5, 4], [7, 2], [9, 1], [12, 0], [15, 0], [18, 1], [20, 2], [21, 3], [-1, -1], [19, 16], [18, 8], [18, 6], [19, 5]] }, A: { width: 18, points: [[9, 21], [1, 0], [-1, -1], [9, 21], [17, 0], [-1, -1], [4, 7], [14, 7]] }, B: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 15], [17, 13], [16, 12], [13, 11], [-1, -1], [4, 11], [13, 11], [16, 10], [17, 9], [18, 7], [18, 4], [17, 2], [16, 1], [13, 0], [4, 0]] }, C: { width: 21, points: [[18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5]] }, D: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [11, 21], [14, 20], [16, 18], [17, 16], [18, 13], [18, 8], [17, 5], [16, 3], [14, 1], [11, 0], [4, 0]] }, E: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [17, 21], [-1, -1], [4, 11], [12, 11], [-1, -1], [4, 0], [17, 0]] }, F: { width: 18, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [17, 21], [-1, -1], [4, 11], [12, 11]] }, G: { width: 21, points: [[18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [18, 8], [-1, -1], [13, 8], [18, 8]] }, H: { width: 22, points: [[4, 21], [4, 0], [-1, -1], [18, 21], [18, 0], [-1, -1], [4, 11], [18, 11]] }, I: { width: 8, points: [[4, 21], [4, 0]] }, J: { width: 16, points: [[12, 21], [12, 5], [11, 2], [10, 1], [8, 0], [6, 0], [4, 1], [3, 2], [2, 5], [2, 7]] }, K: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [18, 21], [4, 7], [-1, -1], [9, 12], [18, 0]] }, L: { width: 17, points: [[4, 21], [4, 0], [-1, -1], [4, 0], [16, 0]] }, M: { width: 24, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [12, 0], [-1, -1], [20, 21], [12, 0], [-1, -1], [20, 21], [20, 0]] }, N: { width: 22, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [18, 0], [-1, -1], [18, 21], [18, 0]] }, O: { width: 22, points: [[9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [19, 8], [19, 13], [18, 16], [17, 18], [15, 20], [13, 21], [9, 21]] }, P: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 14], [17, 12], [16, 11], [13, 10], [4, 10]] }, Q: { width: 22, points: [[9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [19, 8], [19, 13], [18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [-1, -1], [12, 4], [18, -2]] }, R: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 15], [17, 13], [16, 12], [13, 11], [4, 11], [-1, -1], [11, 11], [18, 0]] }, S: { width: 20, points: [[17, 18], [15, 20], [12, 21], [8, 21], [5, 20], [3, 18], [3, 16], [4, 14], [5, 13], [7, 12], [13, 10], [15, 9], [16, 8], [17, 6], [17, 3], [15, 1], [12, 0], [8, 0], [5, 1], [3, 3]] }, T: { width: 16, points: [[8, 21], [8, 0], [-1, -1], [1, 21], [15, 21]] }, U: { width: 22, points: [[4, 21], [4, 6], [5, 3], [7, 1], [10, 0], [12, 0], [15, 1], [17, 3], [18, 6], [18, 21]] }, V: { width: 18, points: [[1, 21], [9, 0], [-1, -1], [17, 21], [9, 0]] }, W: { width: 24, points: [[2, 21], [7, 0], [-1, -1], [12, 21], [7, 0], [-1, -1], [12, 21], [17, 0], [-1, -1], [22, 21], [17, 0]] }, X: { width: 20, points: [[3, 21], [17, 0], [-1, -1], [17, 21], [3, 0]] }, Y: { width: 18, points: [[1, 21], [9, 11], [9, 0], [-1, -1], [17, 21], [9, 11]] }, Z: { width: 20, points: [[17, 21], [3, 0], [-1, -1], [3, 21], [17, 21], [-1, -1], [3, 0], [17, 0]] }, "[": { width: 14, points: [[4, 25], [4, -7], [-1, -1], [5, 25], [5, -7], [-1, -1], [4, 25], [11, 25], [-1, -1], [4, -7], [11, -7]] }, "\\": { width: 14, points: [[0, 21], [14, -3]] }, "]": { width: 14, points: [[9, 25], [9, -7], [-1, -1], [10, 25], [10, -7], [-1, -1], [3, 25], [10, 25], [-1, -1], [3, -7], [10, -7]] }, "^": { width: 16, points: [[6, 15], [8, 18], [10, 15], [-1, -1], [3, 12], [8, 17], [13, 12], [-1, -1], [8, 17], [8, 0]] }, _: { width: 16, points: [[0, -2], [16, -2]] }, "`": { width: 10, points: [[6, 21], [5, 20], [4, 18], [4, 16], [5, 15], [6, 16], [5, 17]] }, a: { width: 19, points: [[15, 14], [15, 0], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, b: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 11], [6, 13], [8, 14], [11, 14], [13, 13], [15, 11], [16, 8], [16, 6], [15, 3], [13, 1], [11, 0], [8, 0], [6, 1], [4, 3]] }, c: { width: 18, points: [[15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, d: { width: 19, points: [[15, 21], [15, 0], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, e: { width: 18, points: [[3, 8], [15, 8], [15, 10], [14, 12], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, f: { width: 12, points: [[10, 21], [8, 21], [6, 20], [5, 17], [5, 0], [-1, -1], [2, 14], [9, 14]] }, g: { width: 19, points: [[15, 14], [15, -2], [14, -5], [13, -6], [11, -7], [8, -7], [6, -6], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, h: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0]] }, i: { width: 8, points: [[3, 21], [4, 20], [5, 21], [4, 22], [3, 21], [-1, -1], [4, 14], [4, 0]] }, j: { width: 10, points: [[5, 21], [6, 20], [7, 21], [6, 22], [5, 21], [-1, -1], [6, 14], [6, -3], [5, -6], [3, -7], [1, -7]] }, k: { width: 17, points: [[4, 21], [4, 0], [-1, -1], [14, 14], [4, 4], [-1, -1], [8, 8], [15, 0]] }, l: { width: 8, points: [[4, 21], [4, 0]] }, m: { width: 30, points: [[4, 14], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0], [-1, -1], [15, 10], [18, 13], [20, 14], [23, 14], [25, 13], [26, 10], [26, 0]] }, n: { width: 19, points: [[4, 14], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0]] }, o: { width: 19, points: [[8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3], [16, 6], [16, 8], [15, 11], [13, 13], [11, 14], [8, 14]] }, p: { width: 19, points: [[4, 14], [4, -7], [-1, -1], [4, 11], [6, 13], [8, 14], [11, 14], [13, 13], [15, 11], [16, 8], [16, 6], [15, 3], [13, 1], [11, 0], [8, 0], [6, 1], [4, 3]] }, q: { width: 19, points: [[15, 14], [15, -7], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, r: { width: 13, points: [[4, 14], [4, 0], [-1, -1], [4, 8], [5, 11], [7, 13], [9, 14], [12, 14]] }, s: { width: 17, points: [[14, 11], [13, 13], [10, 14], [7, 14], [4, 13], [3, 11], [4, 9], [6, 8], [11, 7], [13, 6], [14, 4], [14, 3], [13, 1], [10, 0], [7, 0], [4, 1], [3, 3]] }, t: { width: 12, points: [[5, 21], [5, 4], [6, 1], [8, 0], [10, 0], [-1, -1], [2, 14], [9, 14]] }, u: { width: 19, points: [[4, 14], [4, 4], [5, 1], [7, 0], [10, 0], [12, 1], [15, 4], [-1, -1], [15, 14], [15, 0]] }, v: { width: 16, points: [[2, 14], [8, 0], [-1, -1], [14, 14], [8, 0]] }, w: { width: 22, points: [[3, 14], [7, 0], [-1, -1], [11, 14], [7, 0], [-1, -1], [11, 14], [15, 0], [-1, -1], [19, 14], [15, 0]] }, x: { width: 17, points: [[3, 14], [14, 0], [-1, -1], [14, 14], [3, 0]] }, y: { width: 16, points: [[2, 14], [8, 0], [-1, -1], [14, 14], [8, 0], [6, -4], [4, -6], [2, -7], [1, -7]] }, z: { width: 17, points: [[14, 14], [3, 0], [-1, -1], [3, 14], [14, 14], [-1, -1], [3, 0], [14, 0]] }, "{": { width: 14, points: [[9, 25], [7, 24], [6, 23], [5, 21], [5, 19], [6, 17], [7, 16], [8, 14], [8, 12], [6, 10], [-1, -1], [7, 24], [6, 22], [6, 20], [7, 18], [8, 17], [9, 15], [9, 13], [8, 11], [4, 9], [8, 7], [9, 5], [9, 3], [8, 1], [7, 0], [6, -2], [6, -4], [7, -6], [-1, -1], [6, 8], [8, 6], [8, 4], [7, 2], [6, 1], [5, -1], [5, -3], [6, -5], [7, -6], [9, -7]] }, "|": { width: 8, points: [[4, 25], [4, -7]] }, "}": { width: 14, points: [[5, 25], [7, 24], [8, 23], [9, 21], [9, 19], [8, 17], [7, 16], [6, 14], [6, 12], [8, 10], [-1, -1], [7, 24], [8, 22], [8, 20], [7, 18], [6, 17], [5, 15], [5, 13], [6, 11], [10, 9], [6, 7], [5, 5], [5, 3], [6, 1], [7, 0], [8, -2], [8, -4], [7, -6], [-1, -1], [8, 8], [6, 6], [6, 4], [7, 2], [8, 1], [9, -1], [9, -3], [8, -5], [7, -6], [5, -7]] }, "~": { width: 24, points: [[3, 6], [3, 8], [4, 11], [6, 12], [8, 12], [10, 11], [14, 8], [16, 7], [18, 7], [20, 8], [21, 10], [-1, -1], [3, 8], [4, 10], [6, 11], [8, 11], [10, 10], [14, 7], [16, 6], [18, 6], [20, 7], [21, 10], [21, 12]] } }; function buildVectorTextGeometry(e = {}) { for (var t, i, s = (l = e.origin || [0, 0, 0])[0], r = l[1], a = l[2], o = e.size || 1, n = [], h = [], l = e.text, c = ((l = utils.isNumeric(l) ? "" + l : l) || "").split("\n"), u = 0, p = 0, d = 0; d < c.length; d++) { for (var m, f = 0, g = (m = c[d]).length, _ = 0; _ < g; _++)if (t = letters[m.charAt(_)]) { for (var v = 1, y = -1, T = -1, I = t.points.length, E = 0; E < I; E++)-1 === (i = t.points[E])[0] && -1 === i[1] ? v = 1 : (n.push(f + i[0] * o * .04 + s), n.push(p + i[1] * o * .04 + r), n.push(0 + a), -1 === y ? y = u : (-1 !== T && (y = T), T = u), u++, v ? v = !1 : (h.push(y), h.push(T))); f += .04 * t.width * o } p -= 35 * .04 * o } return utils.apply(e, { primitive: "lines", positions: n, indices: h }) } const angleAxis$1 = math.vec4(4), q1$1 = math.vec4(), q2$1 = math.vec4(), xAxis$1 = math.vec3([1, 0, 0]), yAxis$1 = math.vec3([0, 1, 0]), zAxis$1 = math.vec3([0, 0, 1]), veca$1 = math.vec3(3), vecb$1 = math.vec3(3), identityMat$1 = math.identityMat4(); class Node$1 extends Component { constructor(e, t = {}) { if (super(e, t), this._parentNode = null, this._children = [], this._aabb = null, this._aabbDirty = !0, this.scene._aabbDirty = !0, this._numTriangles = 0, this._scale = math.vec3(), this._quaternion = math.identityQuaternion(), this._rotation = math.vec3(), this._position = math.vec3(), this._offset = math.vec3(), this._localMatrix = math.identityMat4(), this._worldMatrix = math.identityMat4(), this._localMatrixDirty = !0, this._worldMatrixDirty = !0, t.matrix ? this.matrix = t.matrix : (this.scale = t.scale, this.position = t.position, t.quaternion || (this.rotation = t.rotation)), this._isModel = t.isModel, this._isModel && this.scene._registerModel(this), this._isObject = t.isObject, this._isObject && this.scene._registerObject(this), this.origin = t.origin, this.visible = t.visible, this.culled = t.culled, this.pickable = t.pickable, this.clippable = t.clippable, this.collidable = t.collidable, this.castsShadow = t.castsShadow, this.receivesShadow = t.receivesShadow, this.xrayed = t.xrayed, this.highlighted = t.highlighted, this.selected = t.selected, this.edges = t.edges, this.colorize = t.colorize, this.opacity = t.opacity, this.offset = t.offset, t.children) { var i = t.children; for (let e = 0, s = i.length; e < s; e++)this.addChild(i[e], t.inheritStates) } t.parentId ? (e = this.scene.components[t.parentId]) ? e.isNode ? e.addChild(this) : this.error("Parent is not a Node: '" + t.parentId + "'") : this.error("Parent not found: '" + t.parentId + "'") : t.parent && (t.parent.isNode || this.error("Parent is not a Node"), t.parent.addChild(this)) } get isEntity() { return !0 } get isModel() { return this._isModel } get isObject() { return this._isObject } get aabb() { return this._aabbDirty && this._updateAABB(), this._aabb } set origin(e) { e ? (this._origin || (this._origin = math.vec3()), this._origin.set(e)) : this._origin && (this._origin = null); for (let t = 0, i = this._children.length; t < i; t++)this._children[t].origin = e; this.glRedraw() } get origin() { return this._origin } set rtcCenter(e) { this.origin = e } get rtcCenter() { return this.origin } get numTriangles() { return this._numTriangles } set visible(e) { this._visible = e = !1 !== e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].visible = e; this._isObject && this.scene._objectVisibilityUpdated(this, e) } get visible() { return this._visible } set xrayed(e) { this._xrayed = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].xrayed = e; this._isObject && this.scene._objectXRayedUpdated(this, e) } get xrayed() { return this._xrayed } set highlighted(e) { this._highlighted = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].highlighted = e; this._isObject && this.scene._objectHighlightedUpdated(this, e) } get highlighted() { return this._highlighted } set selected(e) { this._selected = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].selected = e; this._isObject && this.scene._objectSelectedUpdated(this, e) } get selected() { return this._selected } set edges(e) { this._edges = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].edges = e } get edges() { return this._edges } set culled(e) { this._culled = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].culled = e } get culled() { return this._culled } set clippable(e) { this._clippable = e = !1 !== e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].clippable = e } get clippable() { return this._clippable } set collidable(e) { this._collidable = e = !1 !== e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].collidable = e } get collidable() { return this._collidable } set pickable(e) { this._pickable = e = !1 !== e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].pickable = e } get pickable() { return this._pickable } set colorize(e) { let t = this._colorize; t || ((t = this._colorize = new Float32Array(4))[3] = 1), e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1); for (let e = 0, i = this._children.length; e < i; e++)this._children[e].colorize = t; this._isObject && this.scene._objectColorizeUpdated(this, !!e) } get colorize() { return this._colorize.slice(0, 3) } set opacity(e) { let t = this._colorize; t || ((t = this._colorize = new Float32Array(4))[0] = 1, t[1] = 1, t[2] = 1), t[3] = null != e ? e : 1; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].opacity = e; this._isObject && this.scene._objectOpacityUpdated(this, null != e) } get opacity() { return this._colorize[3] } set castsShadow(e) { this._castsShadow = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].castsShadow = e } get castsShadow() { return this._castsShadow } set receivesShadow(e) { this._receivesShadow = e = !!e; for (let t = 0, i = this._children.length; t < i; t++)this._children[t].receivesShadow = e } get receivesShadow() { return this._receivesShadow } get saoEnabled() { return !1 } set offset(e) { e ? (this._offset[0] = e[0], this._offset[1] = e[1], this._offset[2] = e[2]) : (this._offset[0] = 0, this._offset[1] = 0, this._offset[2] = 0); for (let e = 0, t = this._children.length; e < t; e++)this._children[e].offset = this._offset; this._isObject && this.scene._objectOffsetUpdated(this, e) } get offset() { return this._offset } get isNode() { return !0 } _setLocalMatrixDirty() { this._localMatrixDirty = !0, this._setWorldMatrixDirty() } _setWorldMatrixDirty() { this._worldMatrixDirty = !0; for (let e = 0, t = this._children.length; e < t; e++)this._children[e]._setWorldMatrixDirty() } _buildWorldMatrix() { var e = this.matrix; if (this._parentNode) math.mulMat4(this._parentNode.worldMatrix, e, this._worldMatrix); else for (let t = 0, i = e.length; t < i; t++)this._worldMatrix[t] = e[t]; this._worldMatrixDirty = !1 } _setSubtreeAABBsDirty(e) { if (e._aabbDirty = !0, e._children) for (let t = 0, i = e._children.length; t < i; t++)this._setSubtreeAABBsDirty(e._children[t]) } _setAABBDirty() { if (this._setSubtreeAABBsDirty(this), this.collidable) for (let e = this; e; e = e._parentNode)e._aabbDirty = !0 } _updateAABB() { if (this.scene._aabbDirty = !0, this._aabb || (this._aabb = math.AABB3()), this._buildAABB) this._buildAABB(this.worldMatrix, this._aabb); else { var e; math.collapseAABB3(this._aabb); for (let t = 0, i = this._children.length; t < i; t++)(e = this._children[t]).collidable && math.expandAABB3(this._aabb, e.aabb) } this._aabbDirty = !1 } addChild(e, t) { if (utils.isNumeric(e) || utils.isString(e)) { var i = e; if (!(e = this.scene.component[i])) return void this.warn("Component not found: " + utils.inQuotes(i)); if (!e.isNode && !e.isMesh) return void this.error("Not a Node or Mesh: " + i) } else { if (!e.isNode && !e.isMesh) return void this.error("Not a Node or Mesh: " + e.id); if (e._parentNode) { if (e._parentNode.id === this.id) return void this.warn("Already a child: " + e.id); e._parentNode.removeChild(e) } } if (e.id, e.scene.id === this.scene.id) return this._children.push(e), e._parentNode = this, t && (e.visible = this.visible, e.culled = this.culled, e.xrayed = this.xrayed, e.highlited = this.highlighted, e.selected = this.selected, e.edges = this.edges, e.clippable = this.clippable, e.pickable = this.pickable, e.collidable = this.collidable, e.castsShadow = this.castsShadow, e.receivesShadow = this.receivesShadow, e.colorize = this.colorize, e.opacity = this.opacity, e.offset = this.offset), e._setWorldMatrixDirty(), e._setAABBDirty(), this._numTriangles += e.numTriangles, e; this.error("Child not in same Scene: " + e.id) } removeChild(e) { for (let t = 0, i = this._children.length; t < i; t++)if (this._children[t].id === e.id) return e._parentNode = null, this._children = this._children.splice(t, 1), e._setWorldMatrixDirty(), e._setAABBDirty(), this._setAABBDirty(), void (this._numTriangles -= e.numTriangles) } removeChildren() { var e; for (let t = 0, i = this._children.length; t < i; t++)(e = this._children[t])._parentNode = null, e._setWorldMatrixDirty(), e._setAABBDirty(), this._numTriangles -= e.numTriangles; this._children = [], this._setAABBDirty() } get numChildren() { return this._children.length } get children() { return this._children } set parent(e) { if (utils.isNumeric(e) || utils.isString(e)) { var t = e; if (!(e = this.scene.components[t])) return void this.warn("Node not found: " + utils.inQuotes(t)); if (!e.isNode) return void this.error("Not a Node: " + e.id) } e.scene.id !== this.scene.id ? this.error("Node not in same Scene: " + e.id) : this._parentNode && this._parentNode.id === e.id ? this.warn("Already a child of Node: " + e.id) : e.addChild(this) } get parent() { return this._parentNode } set position(e) { this._position.set(e || [0, 0, 0]), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get position() { return this._position } set rotation(e) { this._rotation.set(e || [0, 0, 0]), math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get rotation() { return this._rotation } set quaternion(e) { this._quaternion.set(e || [0, 0, 0, 1]), math.quaternionToEuler(this._quaternion, "XYZ", this._rotation), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get quaternion() { return this._quaternion } set scale(e) { this._scale.set(e || [1, 1, 1]), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get scale() { return this._scale } set matrix(e) { this._localMatrix || (this._localMatrix = math.identityMat4()), this._localMatrix.set(e || identityMat$1), math.decomposeMat4(this._localMatrix, this._position, this._quaternion, this._scale), this._localMatrixDirty = !1, this._setWorldMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get matrix() { return this._localMatrixDirty && (this._localMatrix || (this._localMatrix = math.identityMat4()), math.composeMat4(this._position, this._quaternion, this._scale, this._localMatrix), this._localMatrixDirty = !1), this._localMatrix } get worldMatrix() { return this._worldMatrixDirty && this._buildWorldMatrix(), this._worldMatrix } rotate(e, t) { return angleAxis$1[0] = e[0], angleAxis$1[1] = e[1], angleAxis$1[2] = e[2], angleAxis$1[3] = t * math.DEGTORAD, math.angleAxisToQuaternion(angleAxis$1, q1$1), math.mulQuaternions(this.quaternion, q1$1, q2$1), this.quaternion = q2$1, this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw(), this } rotateOnWorldAxis(e, t) { return angleAxis$1[0] = e[0], angleAxis$1[1] = e[1], angleAxis$1[2] = e[2], angleAxis$1[3] = t * math.DEGTORAD, math.angleAxisToQuaternion(angleAxis$1, q1$1), math.mulQuaternions(q1$1, this.quaternion, q1$1), this } rotateX(e) { return this.rotate(xAxis$1, e) } rotateY(e) { return this.rotate(yAxis$1, e) } rotateZ(e) { return this.rotate(zAxis$1, e) } translate(e, t) { return math.vec3ApplyQuaternion(this.quaternion, e, veca$1), math.mulVec3Scalar(veca$1, t, vecb$1), math.addVec3(this.position, vecb$1, this.position), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw(), this } translateX(e) { return this.translate(xAxis$1, e) } translateY(e) { return this.translate(yAxis$1, e) } translateZ(e) { return this.translate(zAxis$1, e) } get type() { return "Node" } destroy() { if (super.destroy(), this._parentNode && this._parentNode.removeChild(this), this._isObject && (this.scene._deregisterObject(this), this._visible && this.scene._objectVisibilityUpdated(this, !1), this._xrayed && this.scene._objectXRayedUpdated(this, !1), this._selected && this.scene._objectSelectedUpdated(this, !1), this._highlighted && this.scene._objectHighlightedUpdated(this, !1), this.scene._objectColorizeUpdated(this, !1), this.scene._objectOpacityUpdated(this, !1), this.scene._objectOffsetUpdated(this, !1)), this._isModel && this.scene._deregisterModel(this), this._children.length) { var e = this._children.splice(); for (let t = 0, i = e.length; t < i; t++)e[t].destroy() } this._children = [], this._setAABBDirty(), this.scene._aabbDirty = !0 } } const RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipMapNearestFilter = 1004, NearestMipmapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, LinearEncoding = 3e3, sRGBEncoding = 3001, GIFMediaType = 1e4, JPEGMediaType = 10001, PNGMediaType = 10002, CompressedMediaType = 10003, DrawShaderSource = function (e) { "LambertMaterial" === e._material._state.type ? (this.vertex = buildVertexLambert(e), this.fragment = buildFragmentLambert(e)) : (this.vertex = buildVertexDraw(e), this.fragment = buildFragmentDraw(e)) }, TEXTURE_DECODE_FUNCS$1 = {}; function getReceivesShadow(e) { if (e.receivesShadow) { var t = e.scene._lightsState.lights; if (t && 0 !== t.length) for (let e = 0, i = t.length; e < i; e++)if (t[e].castsShadow) return !0 } return !1 } function hasTextures(e) { return !!e._geometry._state.uvBuf && !!((e = e._material)._ambientMap || e._occlusionMap || e._baseColorMap || e._diffuseMap || e._alphaMap || e._specularMap || e._glossinessMap || e._specularGlossinessMap || e._emissiveMap || e._metallicMap || e._roughnessMap || e._metallicRoughnessMap || e._reflectivityMap || e._normalMap) } function hasNormals$1(e) { var t = e._geometry._state.primitiveName; return !(!e._geometry._state.autoVertexNormals && !e._geometry._state.normalsBuf || "triangles" !== t && "triangle-strip" !== t && "triangle-fan" !== t) } function buildVertexLambert(e) { var t = e.scene, i = e.scene._sectionPlanesState, s = e.scene._lightsState, r = e._geometry._state, a = e._state.billboard, o = (e = e._state.stationary, i = 0 < i.sectionPlanes.length, !!r.compressGeometry), n = []; if (n.push("#version 300 es"), n.push("// Lambertian drawing vertex shader"), n.push("in vec3 position;"), n.push("uniform mat4 modelMatrix;"), n.push("uniform mat4 viewMatrix;"), n.push("uniform mat4 projMatrix;"), n.push("uniform vec4 colorize;"), n.push("uniform vec3 offset;"), o && n.push("uniform mat4 positionsDecodeMatrix;"), t.logarithmicDepthBufferEnabled && (n.push("uniform float logDepthBufFC;"), n.push("out float vFragDepth;"), n.push("bool isPerspectiveMatrix(mat4 m) {"), n.push("    return (m[2][3] == - 1.0);"), n.push("}"), n.push("out float isPerspective;")), i && n.push("out vec4 vWorldPosition;"), n.push("uniform vec4 lightAmbient;"), n.push("uniform vec4 materialColor;"), n.push("uniform vec3 materialEmissive;"), r.normalsBuf) { n.push("in vec3 normal;"), n.push("uniform mat4 modelNormalMatrix;"), n.push("uniform mat4 viewNormalMatrix;"); for (let e = 0, t = s.lights.length; e < t; e++) { var h = s.lights[e]; "ambient" !== h.type && (n.push("uniform vec4 lightColor" + e + ";"), "dir" === h.type && n.push("uniform vec3 lightDir" + e + ";"), "point" === h.type && n.push("uniform vec3 lightPos" + e + ";"), "spot" === h.type) && (n.push("uniform vec3 lightPos" + e + ";"), n.push("uniform vec3 lightDir" + e + ";")) } o && (n.push("vec3 octDecode(vec2 oct) {"), n.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), n.push("    if (v.z < 0.0) {"), n.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), n.push("    }"), n.push("    return normalize(v);"), n.push("}")) } if (n.push("out vec4 vColor;"), "points" === r.primitiveName && n.push("uniform float pointSize;"), "spherical" !== a && "cylindrical" !== a || (n.push("void billboard(inout mat4 mat) {"), n.push("   mat[0][0] = 1.0;"), n.push("   mat[0][1] = 0.0;"), n.push("   mat[0][2] = 0.0;"), "spherical" === a && (n.push("   mat[1][0] = 0.0;"), n.push("   mat[1][1] = 1.0;"), n.push("   mat[1][2] = 0.0;")), n.push("   mat[2][0] = 0.0;"), n.push("   mat[2][1] = 0.0;"), n.push("   mat[2][2] =1.0;"), n.push("}")), n.push("void main(void) {"), n.push("vec4 localPosition = vec4(position, 1.0); "), n.push("vec4 worldPosition;"), o && n.push("localPosition = positionsDecodeMatrix * localPosition;"), r.normalsBuf && (n.push(o ? "vec4 localNormal = vec4(octDecode(normal.xy), 0.0); " : "vec4 localNormal = vec4(normal, 0.0); "), n.push("mat4 modelNormalMatrix2 = modelNormalMatrix;"), n.push("mat4 viewNormalMatrix2 = viewNormalMatrix;")), n.push("mat4 viewMatrix2 = viewMatrix;"), n.push("mat4 modelMatrix2 = modelMatrix;"), e && n.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;"), "spherical" === a || "cylindrical" === a ? (n.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), n.push("billboard(modelMatrix2);"), n.push("billboard(viewMatrix2);"), n.push("billboard(modelViewMatrix);"), r.normalsBuf && (n.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;"), n.push("billboard(modelNormalMatrix2);"), n.push("billboard(viewNormalMatrix2);"), n.push("billboard(modelViewNormalMatrix);")), n.push("worldPosition = modelMatrix2 * localPosition;"), n.push("worldPosition.xyz = worldPosition.xyz + offset;"), n.push("vec4 viewPosition = modelViewMatrix * localPosition;")) : (n.push("worldPosition = modelMatrix2 * localPosition;"), n.push("worldPosition.xyz = worldPosition.xyz + offset;"), n.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")), r.normalsBuf && n.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);"), n.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), n.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), n.push("float lambertian = 1.0;"), r.normalsBuf) for (let e = 0, t = s.lights.length; e < t; e++) { var l = s.lights[e]; if ("ambient" !== l.type) { if ("dir" === l.type) "view" === l.space ? n.push("viewLightDir = normalize(lightDir" + e + ");") : n.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === l.type) "view" === l.space ? n.push("viewLightDir = -normalize(lightPos" + e + " - viewPosition.xyz);") : n.push("viewLightDir = -normalize((viewMatrix2 * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== l.type) continue; "view" === l.space ? n.push("viewLightDir = normalize(lightDir" + e + ");") : n.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + e + ", 0.0)).xyz);") } n.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), n.push("reflectedColor += lambertian * (lightColor" + e + ".rgb * lightColor" + e + ".a);") } } return n.push("vColor = vec4((lightAmbient.rgb * lightAmbient.a * materialColor.rgb) + materialEmissive.rgb + (reflectedColor * materialColor.rgb), materialColor.a) * colorize;"), i && n.push("vWorldPosition = worldPosition;"), "points" === r.primitiveName && n.push("gl_PointSize = pointSize;"), n.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (n.push("vFragDepth = 1.0 + clipPos.w;"), n.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), n.push("gl_Position = clipPos;"), n.push("}"), n } function buildFragmentLambert(e) { var t = e.scene, i = t._sectionPlanesState, s = (e = (e._material._state, e._geometry._state), 0 < i.sectionPlanes.length), r = t.gammaOutput, a = []; if (a.push("#version 300 es"), a.push("// Lambertian drawing fragment shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), t.logarithmicDepthBufferEnabled && (a.push("in float isPerspective;"), a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), s) { a.push("in vec4 vWorldPosition;"), a.push("uniform bool clippable;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)a.push("uniform bool sectionPlaneActive" + e + ";"), a.push("uniform vec3 sectionPlanePos" + e + ";"), a.push("uniform vec3 sectionPlaneDir" + e + ";") } if (a.push("in vec4 vColor;"), r && (a.push("uniform float gammaFactor;"), a.push("    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), a.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), a.push("}")), a.push("out vec4 outColor;"), a.push("void main(void) {"), s) { a.push("if (clippable) {"), a.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)a.push("if (sectionPlaneActive" + e + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("  if (dist > 0.0) { discard; }"), a.push("}") } return "points" === e.primitiveName && (a.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), a.push("float r = dot(cxy, cxy);"), a.push("if (r > 1.0) {"), a.push("   discard;"), a.push("}")), t.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push(r ? "outColor = linearToGamma(vColor, gammaFactor);" : "outColor = vColor;"), a.push("}"), a } function buildVertexDraw(e) { var t = e.scene, i = (e._material, e._state), s = t._sectionPlanesState, r = e._geometry._state, a = t._lightsState; let o; var n = i.billboard, h = i.background, l = (i = i.stationary, hasTextures(e)), c = hasNormals$1(e), u = (s = 0 < s.sectionPlanes.length, e = getReceivesShadow(e), !!r.compressGeometry), p = []; if (p.push("#version 300 es"), p.push("// Drawing vertex shader"), p.push("in  vec3 position;"), u && p.push("uniform mat4 positionsDecodeMatrix;"), p.push("uniform  mat4 modelMatrix;"), p.push("uniform  mat4 viewMatrix;"), p.push("uniform  mat4 projMatrix;"), p.push("out  vec3 vViewPosition;"), p.push("uniform  vec3 offset;"), s && p.push("out vec4 vWorldPosition;"), t.logarithmicDepthBufferEnabled && (p.push("uniform float logDepthBufFC;"), p.push("out float vFragDepth;"), p.push("bool isPerspectiveMatrix(mat4 m) {"), p.push("    return (m[2][3] == - 1.0);"), p.push("}"), p.push("out float isPerspective;")), 0 < a.lightMaps.length && p.push("out    vec3 vWorldNormal;"), c) { p.push("in  vec3 normal;"), p.push("uniform    mat4 modelNormalMatrix;"), p.push("uniform    mat4 viewNormalMatrix;"), p.push("out    vec3 vViewNormal;"); for (let e = 0, t = a.lights.length; e < t; e++)"ambient" !== (o = a.lights[e]).type && ("dir" === o.type && p.push("uniform vec3 lightDir" + e + ";"), "point" === o.type && p.push("uniform vec3 lightPos" + e + ";"), "spot" === o.type && (p.push("uniform vec3 lightPos" + e + ";"), p.push("uniform vec3 lightDir" + e + ";")), "dir" !== o.type || "view" !== o.space) && p.push("out vec4 vViewLightReverseDirAndDist" + e + ";"); u && (p.push("vec3 octDecode(vec2 oct) {"), p.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), p.push("    if (v.z < 0.0) {"), p.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), p.push("    }"), p.push("    return normalize(v);"), p.push("}")) } if (l && (p.push("in vec2 uv;"), p.push("out vec2 vUV;"), u) && p.push("uniform mat3 uvDecodeMatrix;"), r.colors && (p.push("in vec4 color;"), p.push("out vec4 vColor;")), "points" === r.primitiveName && p.push("uniform float pointSize;"), "spherical" !== n && "cylindrical" !== n || (p.push("void billboard(inout mat4 mat) {"), p.push("   mat[0][0] = 1.0;"), p.push("   mat[0][1] = 0.0;"), p.push("   mat[0][2] = 0.0;"), "spherical" === n && (p.push("   mat[1][0] = 0.0;"), p.push("   mat[1][1] = 1.0;"), p.push("   mat[1][2] = 0.0;")), p.push("   mat[2][0] = 0.0;"), p.push("   mat[2][1] = 0.0;"), p.push("   mat[2][2] =1.0;"), p.push("}")), e) { p.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);"); for (let e = 0, t = a.lights.length; e < t; e++)a.lights[e].castsShadow && (p.push("uniform mat4 shadowViewMatrix" + e + ";"), p.push("uniform mat4 shadowProjMatrix" + e + ";"), p.push("out vec4 vShadowPosFromLight" + e + ";")) } if (p.push("void main(void) {"), p.push("vec4 localPosition = vec4(position, 1.0); "), p.push("vec4 worldPosition;"), u && p.push("localPosition = positionsDecodeMatrix * localPosition;"), c && (p.push(u ? "vec4 localNormal = vec4(octDecode(normal.xy), 0.0); " : "vec4 localNormal = vec4(normal, 0.0); "), p.push("mat4 modelNormalMatrix2    = modelNormalMatrix;"), p.push("mat4 viewNormalMatrix2     = viewNormalMatrix;")), p.push("mat4 viewMatrix2           = viewMatrix;"), p.push("mat4 modelMatrix2          = modelMatrix;"), i ? p.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;") : h && p.push("viewMatrix2[3] = vec4(0.0, 0.0, 0.0 ,1.0);"), "spherical" === n || "cylindrical" === n ? (p.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), p.push("billboard(modelMatrix2);"), p.push("billboard(viewMatrix2);"), p.push("billboard(modelViewMatrix);"), c && (p.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;"), p.push("billboard(modelNormalMatrix2);"), p.push("billboard(viewNormalMatrix2);"), p.push("billboard(modelViewNormalMatrix);")), p.push("worldPosition = modelMatrix2 * localPosition;"), p.push("worldPosition.xyz = worldPosition.xyz + offset;"), p.push("vec4 viewPosition = modelViewMatrix * localPosition;")) : (p.push("worldPosition = modelMatrix2 * localPosition;"), p.push("worldPosition.xyz = worldPosition.xyz + offset;"), p.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")), c) { p.push("vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; "), 0 < a.lightMaps.length && p.push("vWorldNormal = worldNormal;"), p.push("vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);"), p.push("vec3 tmpVec3;"), p.push("float lightDist;"); for (let e = 0, t = a.lights.length; e < t; e++)"ambient" !== (o = a.lights[e]).type && ("dir" === o.type && "world" === o.space && (p.push("tmpVec3 = vec3(viewMatrix2 * vec4(lightDir" + e + ", 0.0) ).xyz;"), p.push("vViewLightReverseDirAndDist" + e + " = vec4(-tmpVec3, 0.0);")), "point" === o.type) && ("world" === o.space ? p.push("tmpVec3 = (viewMatrix2 * vec4(lightPos" + e + ", 1.0)).xyz - viewPosition.xyz;") : p.push("tmpVec3 = lightPos" + e + ".xyz - viewPosition.xyz;"), p.push("lightDist = abs(length(tmpVec3));"), p.push("vViewLightReverseDirAndDist" + e + " = vec4(tmpVec3, lightDist);")) } if (l && p.push(u ? "vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;" : "vUV = uv;"), r.colors && p.push("vColor = color;"), "points" === r.primitiveName && p.push("gl_PointSize = pointSize;"), s && p.push("vWorldPosition = worldPosition;"), p.push("   vViewPosition = viewPosition.xyz;"), p.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (p.push("vFragDepth = 1.0 + clipPos.w;"), p.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), h && p.push("clipPos.z = clipPos.w;"), p.push("gl_Position = clipPos;"), e) { p.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);"), p.push("vec4 tempx; "); for (let e = 0, t = a.lights.length; e < t; e++)a.lights[e].castsShadow && p.push("vShadowPosFromLight" + e + " = texUnitConverter * shadowProjMatrix" + e + " * (shadowViewMatrix" + e + " * worldPosition); ") } return p.push("}"), p } function buildFragmentDraw(e) { var t = e.scene, i = (t.canvas.gl, e._material), s = e._geometry._state, r = e.scene._sectionPlanesState, a = e.scene._lightsState, o = e._material._state, n = 0 < r.sectionPlanes.length, h = hasNormals$1(e), l = s.uvBuf, c = "PhongMaterial" === o.type, u = "MetallicMaterial" === o.type, p = "SpecularMaterial" === o.type, d = getReceivesShadow(e), m = (e = (t.gammaInput, t.gammaOutput), []); if (m.push("#version 300 es"), m.push("// Drawing fragment shader"), m.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), m.push("precision highp float;"), m.push("precision highp int;"), m.push("#else"), m.push("precision mediump float;"), m.push("precision mediump int;"), m.push("#endif"), t.logarithmicDepthBufferEnabled && (m.push("in float isPerspective;"), m.push("uniform float logDepthBufFC;"), m.push("in float vFragDepth;")), d && (m.push("float unpackDepth (vec4 color) {"), m.push("  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));"), m.push("  return dot(color, bitShift);"), m.push("}")), m.push("uniform float gammaFactor;"), m.push("vec4 linearToLinear( in vec4 value ) {"), m.push("  return value;"), m.push("}"), m.push("vec4 sRGBToLinear( in vec4 value ) {"), m.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );"), m.push("}"), m.push("vec4 gammaToLinear( in vec4 value) {"), m.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );"), m.push("}"), e && (m.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), m.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), m.push("}")), n) { m.push("in vec4 vWorldPosition;"), m.push("uniform bool clippable;"); for (var f = 0; f < r.sectionPlanes.length; f++)m.push("uniform bool sectionPlaneActive" + f + ";"), m.push("uniform vec3 sectionPlanePos" + f + ";"), m.push("uniform vec3 sectionPlaneDir" + f + ";") } if (h && (0 < a.lightMaps.length && (m.push("uniform samplerCube lightMap;"), m.push("uniform mat4 viewNormalMatrix;")), 0 < a.reflectionMaps.length && m.push("uniform samplerCube reflectionMap;"), (0 < a.lightMaps.length || 0 < a.reflectionMaps.length) && m.push("uniform mat4 viewMatrix;"), m.push("#define PI 3.14159265359"), m.push("#define RECIPROCAL_PI 0.31830988618"), m.push("#define RECIPROCAL_PI2 0.15915494"), m.push("#define EPSILON 1e-6"), m.push("#define saturate(a) clamp( a, 0.0, 1.0 )"), m.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {"), m.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );"), m.push("}"), m.push("struct IncidentLight {"), m.push("   vec3 color;"), m.push("   vec3 direction;"), m.push("};"), m.push("struct ReflectedLight {"), m.push("   vec3 diffuse;"), m.push("   vec3 specular;"), m.push("};"), m.push("struct Geometry {"), m.push("   vec3 position;"), m.push("   vec3 viewNormal;"), m.push("   vec3 worldNormal;"), m.push("   vec3 viewEyeDir;"), m.push("};"), m.push("struct Material {"), m.push("   vec3    diffuseColor;"), m.push("   float   specularRoughness;"), m.push("   vec3    specularColor;"), m.push("   float   shine;"), m.push("};"), c && ((0 < a.lightMaps.length || 0 < a.reflectionMaps.length) && (m.push("void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), 0 < a.lightMaps.length && (m.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS$1[a.lightMaps[0].encoding] + "(texture(lightMap, geometry.worldNormal)).rgb;"), m.push("   irradiance *= PI;"), m.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);"), m.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;")), 0 < a.reflectionMaps.length && (m.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);"), m.push("   vec3 radiance               = texture(reflectionMap, reflectVec).rgb * 0.2;"), m.push("   radiance *= PI;"), m.push("   reflectedLight.specular     += radiance;")), m.push("}")), m.push("void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), m.push("   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));"), m.push("   vec3 irradiance = dotNL * directLight.color * PI;"), m.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);"), m.push("   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);"), m.push("}")), u || p) && (m.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {"), m.push("   float r = ggxRoughness + 0.0001;"), m.push("   return (2.0 / (r * r) - 2.0);"), m.push("}"), m.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {"), m.push("   float maxMIPLevelScalar = float( maxMIPLevel );"), m.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );"), m.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );"), m.push("}"), 0 < a.reflectionMaps.length && (m.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {"), m.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"), m.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS$1[a.reflectionMaps[0].encoding] + "(texture(reflectionMap, reflectVec, mipLevel)).rgb;"), m.push("  return envMapColor;"), m.push("}")), m.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {"), m.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );"), m.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;"), m.push("}"), m.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {"), m.push("   float a2 = ( alpha * alpha );"), m.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), m.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), m.push("   return 1.0 / ( gl * gv );"), m.push("}"), m.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {"), m.push("   float a2 = ( alpha * alpha );"), m.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), m.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), m.push("   return 0.5 / max( gv + gl, EPSILON );"), m.push("}"), m.push("float D_GGX(const in float alpha, const in float dotNH) {"), m.push("   float a2 = ( alpha * alpha );"), m.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;"), m.push("   return RECIPROCAL_PI * a2 / ( denom * denom);"), m.push("}"), m.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), m.push("   float alpha = ( roughness * roughness );"), m.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );"), m.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );"), m.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );"), m.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );"), m.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );"), m.push("   vec3  F = F_Schlick( specularColor, dotLH );"), m.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );"), m.push("   float D = D_GGX( alpha, dotNH );"), m.push("   return F * (G * D);"), m.push("}"), m.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), m.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));"), m.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);"), m.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);"), m.push("   vec4 r = roughness * c0 + c1;"), m.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;"), m.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;"), m.push("   return specularColor * AB.x + AB.y;"), m.push("}"), (0 < a.lightMaps.length || 0 < a.reflectionMaps.length) && (m.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), 0 < a.lightMaps.length && (m.push("   vec3 irradiance = sRGBToLinear(texture(lightMap, geometry.worldNormal)).rgb;"), m.push("   irradiance *= PI;"), m.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);"), m.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;")), 0 < a.reflectionMaps.length && (m.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);"), m.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);"), m.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);"), m.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);"), m.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);"), m.push("   reflectedLight.specular     += radiance * specularBRDFContrib;")), m.push("}")), m.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), m.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));"), m.push("   vec3 irradiance = dotNL * incidentLight.color * PI;"), m.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);"), m.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);"), m.push("}")), m.push("in vec3 vViewPosition;"), s.colors && m.push("in vec4 vColor;"), l && (h && i._normalMap || i._ambientMap || i._baseColorMap || i._diffuseMap || i._emissiveMap || i._metallicMap || i._roughnessMap || i._metallicRoughnessMap || i._specularMap || i._glossinessMap || i._specularGlossinessMap || i._occlusionMap || i._alphaMap) && m.push("in vec2 vUV;"), h && (0 < a.lightMaps.length && m.push("in vec3 vWorldNormal;"), m.push("in vec3 vViewNormal;")), o.ambient && m.push("uniform vec3 materialAmbient;"), o.baseColor && m.push("uniform vec3 materialBaseColor;"), void 0 !== o.alpha && null !== o.alpha && m.push("uniform vec4 materialAlphaModeCutoff;"), o.emissive && m.push("uniform vec3 materialEmissive;"), o.diffuse && m.push("uniform vec3 materialDiffuse;"), void 0 !== o.glossiness && null !== o.glossiness && m.push("uniform float materialGlossiness;"), void 0 !== o.shininess && null !== o.shininess && m.push("uniform float materialShininess;"), o.specular && m.push("uniform vec3 materialSpecular;"), void 0 !== o.metallic && null !== o.metallic && m.push("uniform float materialMetallic;"), void 0 !== o.roughness && null !== o.roughness && m.push("uniform float materialRoughness;"), void 0 !== o.specularF0 && null !== o.specularF0 && m.push("uniform float materialSpecularF0;"), l && i._ambientMap && (m.push("uniform sampler2D ambientMap;"), i._ambientMap._state.matrix) && m.push("uniform mat4 ambientMapMatrix;"), l && i._baseColorMap && (m.push("uniform sampler2D baseColorMap;"), i._baseColorMap._state.matrix) && m.push("uniform mat4 baseColorMapMatrix;"), l && i._diffuseMap && (m.push("uniform sampler2D diffuseMap;"), i._diffuseMap._state.matrix) && m.push("uniform mat4 diffuseMapMatrix;"), l && i._emissiveMap && (m.push("uniform sampler2D emissiveMap;"), i._emissiveMap._state.matrix) && m.push("uniform mat4 emissiveMapMatrix;"), h && l && i._metallicMap && (m.push("uniform sampler2D metallicMap;"), i._metallicMap._state.matrix) && m.push("uniform mat4 metallicMapMatrix;"), h && l && i._roughnessMap && (m.push("uniform sampler2D roughnessMap;"), i._roughnessMap._state.matrix) && m.push("uniform mat4 roughnessMapMatrix;"), h && l && i._metallicRoughnessMap && (m.push("uniform sampler2D metallicRoughnessMap;"), i._metallicRoughnessMap._state.matrix) && m.push("uniform mat4 metallicRoughnessMapMatrix;"), h && i._normalMap && (m.push("uniform sampler2D normalMap;"), i._normalMap._state.matrix && m.push("uniform mat4 normalMapMatrix;"), m.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {"), m.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );"), m.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );"), m.push("      vec2 st0 = dFdx( uv.st );"), m.push("      vec2 st1 = dFdy( uv.st );"), m.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );"), m.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );"), m.push("      vec3 N = normalize( surf_norm );"), m.push("      vec3 mapN = texture( normalMap, uv ).xyz * 2.0 - 1.0;"), m.push("      mat3 tsn = mat3( S, T, N );"), m.push("      return normalize( tsn * mapN );"), m.push("}")), l && i._occlusionMap && (m.push("uniform sampler2D occlusionMap;"), i._occlusionMap._state.matrix) && m.push("uniform mat4 occlusionMapMatrix;"), l && i._alphaMap && (m.push("uniform sampler2D alphaMap;"), i._alphaMap._state.matrix) && m.push("uniform mat4 alphaMapMatrix;"), h && l && i._specularMap && (m.push("uniform sampler2D specularMap;"), i._specularMap._state.matrix) && m.push("uniform mat4 specularMapMatrix;"), h && l && i._glossinessMap && (m.push("uniform sampler2D glossinessMap;"), i._glossinessMap._state.matrix) && m.push("uniform mat4 glossinessMapMatrix;"), h && l && i._specularGlossinessMap && (m.push("uniform sampler2D materialSpecularGlossinessMap;"), i._specularGlossinessMap._state.matrix) && m.push("uniform mat4 materialSpecularGlossinessMapMatrix;"), h && (i._diffuseFresnel || i._specularFresnel || i._alphaFresnel || i._emissiveFresnel || i._reflectivityFresnel) && (m.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {"), m.push("    float fr = abs(dot(eyeDir, normal));"), m.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);"), m.push("    return pow(finalFr, power);"), m.push("}"), i._diffuseFresnel && (m.push("uniform float  diffuseFresnelCenterBias;"), m.push("uniform float  diffuseFresnelEdgeBias;"), m.push("uniform float  diffuseFresnelPower;"), m.push("uniform vec3   diffuseFresnelCenterColor;"), m.push("uniform vec3   diffuseFresnelEdgeColor;")), i._specularFresnel && (m.push("uniform float  specularFresnelCenterBias;"), m.push("uniform float  specularFresnelEdgeBias;"), m.push("uniform float  specularFresnelPower;"), m.push("uniform vec3   specularFresnelCenterColor;"), m.push("uniform vec3   specularFresnelEdgeColor;")), i._alphaFresnel && (m.push("uniform float  alphaFresnelCenterBias;"), m.push("uniform float  alphaFresnelEdgeBias;"), m.push("uniform float  alphaFresnelPower;"), m.push("uniform vec3   alphaFresnelCenterColor;"), m.push("uniform vec3   alphaFresnelEdgeColor;")), i._reflectivityFresnel && (m.push("uniform float  materialSpecularF0FresnelCenterBias;"), m.push("uniform float  materialSpecularF0FresnelEdgeBias;"), m.push("uniform float  materialSpecularF0FresnelPower;"), m.push("uniform vec3   materialSpecularF0FresnelCenterColor;"), m.push("uniform vec3   materialSpecularF0FresnelEdgeColor;")), i._emissiveFresnel) && (m.push("uniform float  emissiveFresnelCenterBias;"), m.push("uniform float  emissiveFresnelEdgeBias;"), m.push("uniform float  emissiveFresnelPower;"), m.push("uniform vec3   emissiveFresnelCenterColor;"), m.push("uniform vec3   emissiveFresnelEdgeColor;")), m.push("uniform vec4   lightAmbient;"), h) for (let e = 0, t = a.lights.length; e < t; e++) { var g = a.lights[e]; "ambient" !== g.type && (m.push("uniform vec4 lightColor" + e + ";"), "point" === g.type && m.push("uniform vec3 lightAttenuation" + e + ";"), "dir" === g.type && "view" === g.space && m.push("uniform vec3 lightDir" + e + ";"), "point" === g.type && "view" === g.space ? m.push("uniform vec3 lightPos" + e + ";") : m.push("in vec4 vViewLightReverseDirAndDist" + e + ";")) } if (d) for (let e = 0, t = a.lights.length; e < t; e++)a.lights[e].castsShadow && (m.push("in vec4 vShadowPosFromLight" + e + ";"), m.push("uniform sampler2D shadowMap" + e + ";")); if (m.push("uniform vec4 colorize;"), m.push("out vec4 outColor;"), m.push("void main(void) {"), n) { for (m.push("if (clippable) {"), m.push("  float dist = 0.0;"), f = 0; f < r.sectionPlanes.length; f++)m.push("if (sectionPlaneActive" + f + ") {"), m.push("   dist += clamp(dot(-sectionPlaneDir" + f + ".xyz, vWorldPosition.xyz - sectionPlanePos" + f + ".xyz), 0.0, 1000.0);"), m.push("}"); m.push("  if (dist > 0.0) { discard; }"), m.push("}") } if ("points" === s.primitiveName && (m.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), m.push("float r = dot(cxy, cxy);"), m.push("if (r > 1.0) {"), m.push("   discard;"), m.push("}")), m.push("float occlusion = 1.0;"), o.ambient ? m.push("vec3 ambientColor = materialAmbient;") : m.push("vec3 ambientColor = vec3(1.0, 1.0, 1.0);"), o.diffuse ? m.push("vec3 diffuseColor = materialDiffuse;") : o.baseColor ? m.push("vec3 diffuseColor = materialBaseColor;") : m.push("vec3 diffuseColor = vec3(1.0, 1.0, 1.0);"), s.colors && m.push("diffuseColor *= vColor.rgb;"), o.emissive ? m.push("vec3 emissiveColor = materialEmissive;") : m.push("vec3  emissiveColor = vec3(0.0, 0.0, 0.0);"), o.specular ? m.push("vec3 specular = materialSpecular;") : m.push("vec3 specular = vec3(1.0, 1.0, 1.0);"), void 0 !== o.alpha ? m.push("float alpha = materialAlphaModeCutoff[0];") : m.push("float alpha = 1.0;"), s.colors && m.push("alpha *= vColor.a;"), void 0 !== o.glossiness ? m.push("float glossiness = materialGlossiness;") : m.push("float glossiness = 1.0;"), void 0 !== o.metallic ? m.push("float metallic = materialMetallic;") : m.push("float metallic = 1.0;"), void 0 !== o.roughness ? m.push("float roughness = materialRoughness;") : m.push("float roughness = 1.0;"), void 0 !== o.specularF0 ? m.push("float specularF0 = materialSpecularF0;") : m.push("float specularF0 = 1.0;"), l && (h && i._normalMap || i._ambientMap || i._baseColorMap || i._diffuseMap || i._occlusionMap || i._emissiveMap || i._metallicMap || i._roughnessMap || i._metallicRoughnessMap || i._specularMap || i._glossinessMap || i._specularGlossinessMap || i._alphaMap) && (m.push("vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);"), m.push("vec2 textureCoord;")), l && i._ambientMap && (i._ambientMap._state.matrix ? m.push("textureCoord = (ambientMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec4 ambientTexel = texture(ambientMap, textureCoord).rgb;"), m.push("ambientTexel = " + TEXTURE_DECODE_FUNCS$1[i._ambientMap._state.encoding] + "(ambientTexel);"), m.push("ambientColor *= ambientTexel.rgb;")), l && i._diffuseMap && (i._diffuseMap._state.matrix ? m.push("textureCoord = (diffuseMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec4 diffuseTexel = texture(diffuseMap, textureCoord);"), m.push("diffuseTexel = " + TEXTURE_DECODE_FUNCS$1[i._diffuseMap._state.encoding] + "(diffuseTexel);"), m.push("diffuseColor *= diffuseTexel.rgb;"), m.push("alpha *= diffuseTexel.a;")), l && i._baseColorMap && (i._baseColorMap._state.matrix ? m.push("textureCoord = (baseColorMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec4 baseColorTexel = texture(baseColorMap, textureCoord);"), m.push("baseColorTexel = " + TEXTURE_DECODE_FUNCS$1[i._baseColorMap._state.encoding] + "(baseColorTexel);"), m.push("diffuseColor *= baseColorTexel.rgb;"), m.push("alpha *= baseColorTexel.a;")), l && i._emissiveMap && (i._emissiveMap._state.matrix ? m.push("textureCoord = (emissiveMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec4 emissiveTexel = texture(emissiveMap, textureCoord);"), m.push("emissiveTexel = " + TEXTURE_DECODE_FUNCS$1[i._emissiveMap._state.encoding] + "(emissiveTexel);"), m.push("emissiveColor = emissiveTexel.rgb;")), l && i._alphaMap && (i._alphaMap._state.matrix ? m.push("textureCoord = (alphaMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("alpha *= texture(alphaMap, textureCoord).r;")), l && i._occlusionMap && (i._occlusionMap._state.matrix ? m.push("textureCoord = (occlusionMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("occlusion *= texture(occlusionMap, textureCoord).r;")), h && (0 < a.lights.length || 0 < a.lightMaps.length || 0 < a.reflectionMaps.length)) { l && i._normalMap ? (i._normalMap._state.matrix ? m.push("textureCoord = (normalMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );")) : m.push("vec3 viewNormal = normalize(vViewNormal);"), l && i._specularMap && (i._specularMap._state.matrix ? m.push("textureCoord = (specularMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("specular *= texture(specularMap, textureCoord).rgb;")), l && i._glossinessMap && (i._glossinessMap._state.matrix ? m.push("textureCoord = (glossinessMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("glossiness *= texture(glossinessMap, textureCoord).r;")), l && i._specularGlossinessMap && (i._specularGlossinessMap._state.matrix ? m.push("textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec4 specGlossRGB = texture(materialSpecularGlossinessMap, textureCoord).rgba;"), m.push("specular *= specGlossRGB.rgb;"), m.push("glossiness *= specGlossRGB.a;")), l && i._metallicMap && (i._metallicMap._state.matrix ? m.push("textureCoord = (metallicMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("metallic *= texture(metallicMap, textureCoord).r;")), l && i._roughnessMap && (i._roughnessMap._state.matrix ? m.push("textureCoord = (roughnessMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("roughness *= texture(roughnessMap, textureCoord).r;")), l && i._metallicRoughnessMap && (i._metallicRoughnessMap._state.matrix ? m.push("textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;") : m.push("textureCoord = texturePos.xy;"), m.push("vec3 metalRoughRGB = texture(metallicRoughnessMap, textureCoord).rgb;"), m.push("metallic *= metalRoughRGB.b;"), m.push("roughness *= metalRoughRGB.g;")), m.push("vec3 viewEyeDir = normalize(-vViewPosition);"), i._diffuseFresnel && (m.push("float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);"), m.push("diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);")), i._specularFresnel && (m.push("float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);"), m.push("specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);")), i._alphaFresnel && (m.push("float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);"), m.push("alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);")), i._emissiveFresnel && (m.push("float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);"), m.push("emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);")), m.push("if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {"), m.push("   discard;"), m.push("}"), m.push("IncidentLight  light;"), m.push("Material       material;"), m.push("Geometry       geometry;"), m.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));"), m.push("vec3           viewLightDir;"), c && (m.push("material.diffuseColor      = diffuseColor;"), m.push("material.specularColor     = specular;"), m.push("material.shine             = materialShininess;")), p && (m.push("float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);"), m.push("material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;"), m.push("material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );"), m.push("material.specularColor     = specular;")), u && (m.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;"), m.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);"), m.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);"), m.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);")), m.push("geometry.position      = vViewPosition;"), 0 < a.lightMaps.length && m.push("geometry.worldNormal   = normalize(vWorldNormal);"), m.push("geometry.viewNormal    = viewNormal;"), m.push("geometry.viewEyeDir    = viewEyeDir;"), c && (0 < a.lightMaps.length || 0 < a.reflectionMaps.length) && m.push("computePhongLightMapping(geometry, material, reflectedLight);"), (p || u) && (0 < a.lightMaps.length || 0 < a.reflectionMaps.length) && m.push("computePBRLightMapping(geometry, material, reflectedLight);"), m.push("float shadow = 1.0;"), m.push("float shadowAcneRemover = 0.007;"), m.push("vec3 fragmentDepth;"), m.push("float texelSize = 1.0 / 1024.0;"), m.push("float amountInLight = 0.0;"), m.push("vec3 shadowCoord;"), m.push("vec4 rgbaDepth;"), m.push("float depth;"); for (let e = 0, t = a.lights.length; e < t; e++) { var _ = a.lights[e]; "ambient" !== _.type && ("dir" === _.type && "view" === _.space ? m.push("viewLightDir = -normalize(lightDir" + e + ");") : "point" === _.type && "view" === _.space ? m.push("viewLightDir = normalize(lightPos" + e + " - vViewPosition);") : m.push("viewLightDir = normalize(vViewLightReverseDirAndDist" + e + ".xyz);"), d && _.castsShadow ? (m.push("shadow = 0.0;"), m.push("fragmentDepth = vShadowPosFromLight" + e + ".xyz;"), m.push("fragmentDepth.z -= shadowAcneRemover;"), m.push("for (int x = -3; x <= 3; x++) {"), m.push("  for (int y = -3; y <= 3; y++) {"), m.push("      float texelDepth = unpackDepth(texture(shadowMap" + e + ", fragmentDepth.xy + vec2(x, y) * texelSize));"), m.push("      if (fragmentDepth.z < texelDepth) {"), m.push("          shadow += 1.0;"), m.push("      }"), m.push("  }"), m.push("}"), m.push("shadow = shadow / 9.0;"), m.push("light.color =  lightColor" + e + ".rgb * (lightColor" + e + ".a * shadow);")) : m.push("light.color =  lightColor" + e + ".rgb * (lightColor" + e + ".a );"), m.push("light.direction = viewLightDir;"), c && m.push("computePhongLighting(light, geometry, material, reflectedLight);"), p || u) && m.push("computePBRLighting(light, geometry, material, reflectedLight);") } m.push(c ? "vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * diffuseColor) + ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;" : "vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (occlusion * reflectedLight.specular) + emissiveColor;") } else m.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);"), m.push("vec3 outgoingLight = emissiveColor + ambientColor;"); return m.push("vec4 fragColor = vec4(outgoingLight, alpha) * colorize;"), e && m.push("fragColor = linearToGamma(fragColor, gammaFactor);"), m.push("outColor = fragColor;"), t.logarithmicDepthBufferEnabled && m.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), m.push("}"), m } TEXTURE_DECODE_FUNCS$1[3e3] = "linearToLinear", TEXTURE_DECODE_FUNCS$1[sRGBEncoding] = "sRGBToLinear"; class Shader { constructor(e, t, i) { if (this.allocated = !1, this.compiled = !1, this.handle = e.createShader(t), this.handle) { if (this.allocated = !0, e.shaderSource(this.handle, i), e.compileShader(this.handle), this.compiled = e.getShaderParameter(this.handle, e.COMPILE_STATUS), !this.compiled && !e.isContextLost()) { var s = i.split("\n"), r = []; for (let e = 0; e < s.length; e++)r.push(e + 1 + ": " + s[e] + "\n"); this.errors = [], this.errors.push(""), this.errors.push(e.getShaderInfoLog(this.handle)), this.errors = this.errors.concat(r.join("")) } } else this.errors = ["Failed to allocate"] } destroy() { } } class Sampler { constructor(e, t) { this.bindTexture = function (i, s) { return !!i.bind(s) && (e.uniform1i(t, s), !0) } } } class Attribute { constructor(e, t) { this._gl = e, this.location = t } bindArrayBuffer(e) { e && (e.bind(), this._gl.enableVertexAttribArray(this.location), this._gl.vertexAttribPointer(this.location, e.itemSize, e.itemType, e.normalized, e.stride, e.offset)) } } const ids$3 = new Map$1({}); function joinSansComments(e) { var t, i = []; let s; for (let r = 0, a = e.length; r < a; r++)0 < (t = (s = e[r]).indexOf("/")) && "/" === s.charAt(t + 1) && (s = s.substring(0, t)), i.push(s); return i.join("\n") } function logErrors(e) { console.error(e.join("\n")) } class Program { constructor(e, t) { this.id = ids$3.addItem({}), this.source = t, this.init(e) } init(e) { if (this.gl = e, this.allocated = !1, this.compiled = !1, this.linked = !1, this.validated = !1, this.errors = null, this.uniforms = {}, this.samplers = {}, this.attributes = {}, this._vertexShader = new Shader(e, e.VERTEX_SHADER, joinSansComments(this.source.vertex)), this._fragmentShader = new Shader(e, e.FRAGMENT_SHADER, joinSansComments(this.source.fragment)), this._vertexShader.allocated) if (this._fragmentShader.allocated) if (this.allocated = !0, this._vertexShader.compiled) if (this._fragmentShader.compiled) { var t, i; let a, o, n; if (this.compiled = !0, this.handle = e.createProgram(), this.handle) if (e.attachShader(this.handle, this._vertexShader.handle), e.attachShader(this.handle, this._fragmentShader.handle), e.linkProgram(this.handle), this.linked = e.getProgramParameter(this.handle, e.LINK_STATUS), this.validated = !0, this.linked && this.validated) { var s = e.getProgramParameter(this.handle, e.ACTIVE_UNIFORMS); for (a = 0; a < s; ++a)(i = e.getActiveUniform(this.handle, a)) && ("\0" === (o = i.name)[o.length - 1] && (o = o.substr(0, o.length - 1)), n = e.getUniformLocation(this.handle, o), i.type === e.SAMPLER_2D || i.type === e.SAMPLER_CUBE || 35682 === i.type ? this.samplers[o] = new Sampler(e, n) : this.uniforms[o] = n); var r = e.getProgramParameter(this.handle, e.ACTIVE_ATTRIBUTES); for (a = 0; a < r; a++)(t = e.getActiveAttrib(this.handle, a)) && (n = e.getAttribLocation(this.handle, t.name), this.attributes[t.name] = new Attribute(e, n)); this.allocated = !0 } else this.errors = [], this.errors.push(""), this.errors.push(e.getProgramInfoLog(this.handle)), this.errors.push("\nVertex shader:\n"), this.errors = this.errors.concat(this.source.vertex), this.errors.push("\nFragment shader:\n"), this.errors = this.errors.concat(this.source.fragment), logErrors(this.errors); else this.errors = ["Failed to allocate program"] } else this.errors = ["Fragment shader failed to compile"].concat(this._fragmentShader.errors), logErrors(this.errors); else this.errors = ["Vertex shader failed to compile"].concat(this._vertexShader.errors), logErrors(this.errors); else this.errors = ["Fragment shader failed to allocate"].concat(this._fragmentShader.errors), logErrors(this.errors); else this.errors = ["Vertex shader failed to allocate"].concat(this._vertexShader.errors), logErrors(this.errors) } bind() { this.allocated && this.gl.useProgram(this.handle) } getLocation(e) { if (this.allocated) return this.uniforms[e] } getAttribute(e) { if (this.allocated) return this.attributes[e] } bindTexture(e, t, i) { return !!this.allocated && !!(e = this.samplers[e]) && e.bindTexture(t, i) } destroy() { this.allocated && (ids$3.removeItem(this.id), this.gl.deleteProgram(this.handle), this.gl.deleteShader(this._vertexShader.handle), this.gl.deleteShader(this._fragmentShader.handle), this.handle = null, this.attributes = null, this.uniforms = null, this.samplers = null, this.allocated = !1) } } const WEBGL_INFO = { WEBGL: !1, SUPPORTED_EXTENSIONS: {} }, canvas = document.createElement("canvas"); if (canvas) { const e = canvas.getContext("webgl", { antialias: !0 }) || canvas.getContext("experimental-webgl", { antialias: !0 }); WEBGL_INFO.WEBGL = !!e, WEBGL_INFO.WEBGL && (WEBGL_INFO.ANTIALIAS = e.getContextAttributes().antialias, e.getShaderPrecisionFormat ? 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "highp" : 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision ? WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "mediump" : WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "lowp" : WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "mediump", WEBGL_INFO.DEPTH_BUFFER_BITS = e.getParameter(e.DEPTH_BITS), WEBGL_INFO.MAX_TEXTURE_SIZE = e.getParameter(e.MAX_TEXTURE_SIZE), WEBGL_INFO.MAX_CUBE_MAP_SIZE = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), WEBGL_INFO.MAX_RENDERBUFFER_SIZE = e.getParameter(e.MAX_RENDERBUFFER_SIZE), WEBGL_INFO.MAX_TEXTURE_UNITS = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), WEBGL_INFO.MAX_VERTEX_ATTRIBS = e.getParameter(e.MAX_VERTEX_ATTRIBS), WEBGL_INFO.MAX_VERTEX_UNIFORM_VECTORS = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), WEBGL_INFO.MAX_FRAGMENT_UNIFORM_VECTORS = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), WEBGL_INFO.MAX_VARYING_VECTORS = e.getParameter(e.MAX_VARYING_VECTORS), e.getSupportedExtensions().forEach((function (e) { WEBGL_INFO.SUPPORTED_EXTENSIONS[e] = !0 }))) } const tempVec3a$13 = math.vec3(), createRTCViewMat = function () { const e = new Float32Array(16), t = new Float64Array(4), i = new Float64Array(4); return function (s, r, a) { return a = a || e, t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = 1, math.transformVec4(s, t, i), math.setMat4Translation(s, i, a), a } }(); function worldToRTCPos(e, t, i) { var s = Float32Array.from([e[0]])[0], r = e[0] - s, a = Float32Array.from([e[1]])[0], o = e[1] - a, n = Float32Array.from([e[2]])[0]; e = e[2] - n; t[0] = s, t[1] = a, t[2] = n, i[0] = r, i[1] = o, i[2] = e } function worldToRTCPositions(e, t, i, s = 1e3) { var r = math.getPositionsCenter(e, tempVec3a$13), a = Math.round(r[0] / s) * s, o = Math.round(r[1] / s) * s, n = Math.round(r[2] / s) * s; if (i[0] = a, i[1] = o, i[2] = n, r = 0 !== i[0] || 0 !== i[1] || 0 !== i[2]) for (let i = 0, s = e.length; i < s; i += 3)t[i + 0] = e[i + 0] - a, t[i + 1] = e[i + 1] - o, t[i + 2] = e[i + 2] - n; return r } function getPlaneRTCPos(e, t, i, s) { return i = math.dotVec3(t, i) + e, e = math.normalizeVec3(t, tempVec3a$13), math.mulVec3Scalar(e, -i, s), s } const tempVec3a$12 = math.vec3(), ids$2 = new Map$1({}), DrawRenderer = function (e, t) { this.id = ids$2.addItem({}), this._hash = e, this._scene = t.scene, this._useCount = 0, this._shaderSource = new DrawShaderSource(t), this._allocate(t) }, drawRenderers = {}; DrawRenderer.get = function (e) { var t = [(t = e.scene).canvas.canvas.id, (t.gammaInput ? "gi;" : ";") + (t.gammaOutput ? "go" : ""), t._lightsState.getHash(), t._sectionPlanesState.getHash(), e._geometry._state.hash, e._material._state.hash, e._state.drawHash].join(";"); let i = drawRenderers[t]; if (!i) { if ((i = new DrawRenderer(t, e)).errors) return console.log(i.errors.join("\n")), null; drawRenderers[t] = i, stats.memory.programs++ } return i._useCount++, i }, DrawRenderer.prototype.put = function () { 0 == --this._useCount && (ids$2.removeItem(this.id), this._program && this._program.destroy(), delete drawRenderers[this._hash], stats.memory.programs--) }, DrawRenderer.prototype.webglContextRestored = function () { this._program = null }, DrawRenderer.prototype.drawMesh = function (e, t) { this._program || this._allocate(t); var i = WEBGL_INFO.MAX_TEXTURE_UNITS, s = t.scene, r = t._material, a = s.canvas.gl, o = this._program, n = t._state, h = t._material._state, l = t._geometry._state, c = s.camera, u = t.origin, p = n.background; if (e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, p && a.depthFunc(a.LEQUAL), this._bindProgram(e)), a.uniformMatrix4fv(this._uViewMatrix, !1, u ? e.getRTCViewMatrix(n.originHash, u) : c.viewMatrix), a.uniformMatrix4fv(this._uViewNormalMatrix, !1, c.viewNormalMatrix), n.clippable) { var d = s._sectionPlanesState.sectionPlanes.length; if (0 < d) { var m = s._sectionPlanesState.sectionPlanes, f = t.renderFlags; for (let e = 0; e < d; e++) { var g, _ = this._uSectionPlanes[e]; _ && (g = f.sectionPlanesActivePerLayer[e], a.uniform1i(_.active, g ? 1 : 0), g) && (g = m[e], a.uniform3fv(_.pos, u ? getPlaneRTCPos(g.dist, g.dir, u, tempVec3a$12) : g.pos), a.uniform3fv(_.dir, g.dir)) } } } if (h.id !== this._lastMaterialId) { switch (e.textureUnit = this._baseTextureUnit, c = h.backfaces, e.backfaces !== c && (c ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), e.backfaces = c), s = h.frontface, e.frontface !== s && (s ? a.frontFace(a.CCW) : a.frontFace(a.CW), e.frontface = s), e.lineWidth !== h.lineWidth && (a.lineWidth(h.lineWidth), e.lineWidth = h.lineWidth), this._uPointSize && a.uniform1f(this._uPointSize, h.pointSize), h.type) { case "LambertMaterial": this._uMaterialAmbient && a.uniform3fv(this._uMaterialAmbient, h.ambient), this._uMaterialColor && a.uniform4f(this._uMaterialColor, h.color[0], h.color[1], h.color[2], h.alpha), this._uMaterialEmissive && a.uniform3fv(this._uMaterialEmissive, h.emissive); break; case "PhongMaterial": this._uMaterialShininess && a.uniform1f(this._uMaterialShininess, h.shininess), this._uMaterialAmbient && a.uniform3fv(this._uMaterialAmbient, h.ambient), this._uMaterialDiffuse && a.uniform3fv(this._uMaterialDiffuse, h.diffuse), this._uMaterialSpecular && a.uniform3fv(this._uMaterialSpecular, h.specular), this._uMaterialEmissive && a.uniform3fv(this._uMaterialEmissive, h.emissive), this._uAlphaModeCutoff && a.uniform4f(this._uAlphaModeCutoff, +h.alpha, 1 === h.alphaMode ? 1 : 0, h.alphaCutoff, 0), r._ambientMap && r._ambientMap._state.texture && this._uMaterialAmbientMap && (o.bindTexture(this._uMaterialAmbientMap, r._ambientMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uMaterialAmbientMapMatrix) && a.uniformMatrix4fv(this._uMaterialAmbientMapMatrix, !1, r._ambientMap._state.matrix), r._diffuseMap && r._diffuseMap._state.texture && this._uDiffuseMap && (o.bindTexture(this._uDiffuseMap, r._diffuseMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uDiffuseMapMatrix) && a.uniformMatrix4fv(this._uDiffuseMapMatrix, !1, r._diffuseMap._state.matrix), r._specularMap && r._specularMap._state.texture && this._uSpecularMap && (o.bindTexture(this._uSpecularMap, r._specularMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uSpecularMapMatrix) && a.uniformMatrix4fv(this._uSpecularMapMatrix, !1, r._specularMap._state.matrix), r._emissiveMap && r._emissiveMap._state.texture && this._uEmissiveMap && (o.bindTexture(this._uEmissiveMap, r._emissiveMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uEmissiveMapMatrix) && a.uniformMatrix4fv(this._uEmissiveMapMatrix, !1, r._emissiveMap._state.matrix), r._alphaMap && r._alphaMap._state.texture && this._uAlphaMap && (o.bindTexture(this._uAlphaMap, r._alphaMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uAlphaMapMatrix) && a.uniformMatrix4fv(this._uAlphaMapMatrix, !1, r._alphaMap._state.matrix), r._reflectivityMap && r._reflectivityMap._state.texture && this._uReflectivityMap && (o.bindTexture(this._uReflectivityMap, r._reflectivityMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, this._uReflectivityMapMatrix) && a.uniformMatrix4fv(this._uReflectivityMapMatrix, !1, r._reflectivityMap._state.matrix), r._normalMap && r._normalMap._state.texture && this._uNormalMap && (o.bindTexture(this._uNormalMap, r._normalMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uNormalMapMatrix) && a.uniformMatrix4fv(this._uNormalMapMatrix, !1, r._normalMap._state.matrix), r._occlusionMap && r._occlusionMap._state.texture && this._uOcclusionMap && (o.bindTexture(this._uOcclusionMap, r._occlusionMap._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uOcclusionMapMatrix) && a.uniformMatrix4fv(this._uOcclusionMapMatrix, !1, r._occlusionMap._state.matrix), r._diffuseFresnel && (this._uDiffuseFresnelEdgeBias && a.uniform1f(this._uDiffuseFresnelEdgeBias, r._diffuseFresnel.edgeBias), this._uDiffuseFresnelCenterBias && a.uniform1f(this._uDiffuseFresnelCenterBias, r._diffuseFresnel.centerBias), this._uDiffuseFresnelEdgeColor && a.uniform3fv(this._uDiffuseFresnelEdgeColor, r._diffuseFresnel.edgeColor), this._uDiffuseFresnelCenterColor && a.uniform3fv(this._uDiffuseFresnelCenterColor, r._diffuseFresnel.centerColor), this._uDiffuseFresnelPower) && a.uniform1f(this._uDiffuseFresnelPower, r._diffuseFresnel.power), r._specularFresnel && (this._uSpecularFresnelEdgeBias && a.uniform1f(this._uSpecularFresnelEdgeBias, r._specularFresnel.edgeBias), this._uSpecularFresnelCenterBias && a.uniform1f(this._uSpecularFresnelCenterBias, r._specularFresnel.centerBias), this._uSpecularFresnelEdgeColor && a.uniform3fv(this._uSpecularFresnelEdgeColor, r._specularFresnel.edgeColor), this._uSpecularFresnelCenterColor && a.uniform3fv(this._uSpecularFresnelCenterColor, r._specularFresnel.centerColor), this._uSpecularFresnelPower) && a.uniform1f(this._uSpecularFresnelPower, r._specularFresnel.power), r._alphaFresnel && (this._uAlphaFresnelEdgeBias && a.uniform1f(this._uAlphaFresnelEdgeBias, r._alphaFresnel.edgeBias), this._uAlphaFresnelCenterBias && a.uniform1f(this._uAlphaFresnelCenterBias, r._alphaFresnel.centerBias), this._uAlphaFresnelEdgeColor && a.uniform3fv(this._uAlphaFresnelEdgeColor, r._alphaFresnel.edgeColor), this._uAlphaFresnelCenterColor && a.uniform3fv(this._uAlphaFresnelCenterColor, r._alphaFresnel.centerColor), this._uAlphaFresnelPower) && a.uniform1f(this._uAlphaFresnelPower, r._alphaFresnel.power), r._reflectivityFresnel && (this._uReflectivityFresnelEdgeBias && a.uniform1f(this._uReflectivityFresnelEdgeBias, r._reflectivityFresnel.edgeBias), this._uReflectivityFresnelCenterBias && a.uniform1f(this._uReflectivityFresnelCenterBias, r._reflectivityFresnel.centerBias), this._uReflectivityFresnelEdgeColor && a.uniform3fv(this._uReflectivityFresnelEdgeColor, r._reflectivityFresnel.edgeColor), this._uReflectivityFresnelCenterColor && a.uniform3fv(this._uReflectivityFresnelCenterColor, r._reflectivityFresnel.centerColor), this._uReflectivityFresnelPower) && a.uniform1f(this._uReflectivityFresnelPower, r._reflectivityFresnel.power), r._emissiveFresnel && (this._uEmissiveFresnelEdgeBias && a.uniform1f(this._uEmissiveFresnelEdgeBias, r._emissiveFresnel.edgeBias), this._uEmissiveFresnelCenterBias && a.uniform1f(this._uEmissiveFresnelCenterBias, r._emissiveFresnel.centerBias), this._uEmissiveFresnelEdgeColor && a.uniform3fv(this._uEmissiveFresnelEdgeColor, r._emissiveFresnel.edgeColor), this._uEmissiveFresnelCenterColor && a.uniform3fv(this._uEmissiveFresnelCenterColor, r._emissiveFresnel.centerColor), this._uEmissiveFresnelPower) && a.uniform1f(this._uEmissiveFresnelPower, r._emissiveFresnel.power); break; case "MetallicMaterial": this._uBaseColor && a.uniform3fv(this._uBaseColor, h.baseColor), this._uMaterialMetallic && a.uniform1f(this._uMaterialMetallic, h.metallic), this._uMaterialRoughness && a.uniform1f(this._uMaterialRoughness, h.roughness), this._uMaterialSpecularF0 && a.uniform1f(this._uMaterialSpecularF0, h.specularF0), this._uMaterialEmissive && a.uniform3fv(this._uMaterialEmissive, h.emissive), this._uAlphaModeCutoff && a.uniform4f(this._uAlphaModeCutoff, +h.alpha, 1 === h.alphaMode ? 1 : 0, h.alphaCutoff, 0); var v = r._baseColorMap; v && v._state.texture && this._uBaseColorMap && (o.bindTexture(this._uBaseColorMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uBaseColorMapMatrix) && a.uniformMatrix4fv(this._uBaseColorMapMatrix, !1, v._state.matrix), (v = r._metallicMap) && v._state.texture && this._uMetallicMap && (o.bindTexture(this._uMetallicMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uMetallicMapMatrix) && a.uniformMatrix4fv(this._uMetallicMapMatrix, !1, v._state.matrix), (v = r._roughnessMap) && v._state.texture && this._uRoughnessMap && (o.bindTexture(this._uRoughnessMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uRoughnessMapMatrix) && a.uniformMatrix4fv(this._uRoughnessMapMatrix, !1, v._state.matrix), (v = r._metallicRoughnessMap) && v._state.texture && this._uMetallicRoughnessMap && (o.bindTexture(this._uMetallicRoughnessMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uMetallicRoughnessMapMatrix) && a.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix, !1, v._state.matrix), (v = r._emissiveMap) && v._state.texture && this._uEmissiveMap && (o.bindTexture(this._uEmissiveMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uEmissiveMapMatrix) && a.uniformMatrix4fv(this._uEmissiveMapMatrix, !1, v._state.matrix), (y = r._occlusionMap) && r._occlusionMap._state.texture && this._uOcclusionMap && (o.bindTexture(this._uOcclusionMap, y._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uOcclusionMapMatrix) && a.uniformMatrix4fv(this._uOcclusionMapMatrix, !1, y._state.matrix), (T = r._alphaMap) && T._state.texture && this._uAlphaMap && (o.bindTexture(this._uAlphaMap, T._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uAlphaMapMatrix) && a.uniformMatrix4fv(this._uAlphaMapMatrix, !1, T._state.matrix), (I = r._normalMap) && I._state.texture && this._uNormalMap && (o.bindTexture(this._uNormalMap, I._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uNormalMapMatrix) && a.uniformMatrix4fv(this._uNormalMapMatrix, !1, I._state.matrix); break; case "SpecularMaterial": this._uMaterialDiffuse && a.uniform3fv(this._uMaterialDiffuse, h.diffuse), this._uMaterialSpecular && a.uniform3fv(this._uMaterialSpecular, h.specular), this._uMaterialGlossiness && a.uniform1f(this._uMaterialGlossiness, h.glossiness), this._uMaterialReflectivity && a.uniform1f(this._uMaterialReflectivity, h.reflectivity), this._uMaterialEmissive && a.uniform3fv(this._uMaterialEmissive, h.emissive), this._uAlphaModeCutoff && a.uniform4f(this._uAlphaModeCutoff, +h.alpha, 1 === h.alphaMode ? 1 : 0, h.alphaCutoff, 0); var y, T, I, E = r._diffuseMap; E && E._state.texture && this._uDiffuseMap && (o.bindTexture(this._uDiffuseMap, E._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uDiffuseMapMatrix) && a.uniformMatrix4fv(this._uDiffuseMapMatrix, !1, E._state.matrix), (E = r._specularMap) && E._state.texture && this._uSpecularMap && (o.bindTexture(this._uSpecularMap, E._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uSpecularMapMatrix) && a.uniformMatrix4fv(this._uSpecularMapMatrix, !1, E._state.matrix), (E = r._glossinessMap) && E._state.texture && this._uGlossinessMap && (o.bindTexture(this._uGlossinessMap, E._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uGlossinessMapMatrix) && a.uniformMatrix4fv(this._uGlossinessMapMatrix, !1, E._state.matrix), (E = r._specularGlossinessMap) && E._state.texture && this._uSpecularGlossinessMap && (o.bindTexture(this._uSpecularGlossinessMap, E._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uSpecularGlossinessMapMatrix) && a.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix, !1, E._state.matrix), (v = r._emissiveMap) && v._state.texture && this._uEmissiveMap && (o.bindTexture(this._uEmissiveMap, v._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uEmissiveMapMatrix) && a.uniformMatrix4fv(this._uEmissiveMapMatrix, !1, v._state.matrix), (y = r._occlusionMap) && y._state.texture && this._uOcclusionMap && (o.bindTexture(this._uOcclusionMap, y._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uOcclusionMapMatrix) && a.uniformMatrix4fv(this._uOcclusionMapMatrix, !1, y._state.matrix), (T = r._alphaMap) && T._state.texture && this._uAlphaMap && (o.bindTexture(this._uAlphaMap, T._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uAlphaMapMatrix) && a.uniformMatrix4fv(this._uAlphaMapMatrix, !1, T._state.matrix), (I = r._normalMap) && I._state.texture && this._uNormalMap && (o.bindTexture(this._uNormalMap, I._state.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % i, e.bindTexture++, this._uNormalMapMatrix) && a.uniformMatrix4fv(this._uNormalMapMatrix, !1, I._state.matrix) }this._lastMaterialId = h.id } a.uniformMatrix4fv(this._uModelMatrix, a.FALSE, t.worldMatrix), this._uModelNormalMatrix && a.uniformMatrix4fv(this._uModelNormalMatrix, a.FALSE, t.worldNormalMatrix), this._uClippable && a.uniform1i(this._uClippable, n.clippable), this._uColorize && (c = n.colorize, (s = this._lastColorize)[0] === c[0] && s[1] === c[1] && s[2] === c[2] && s[3] === c[3] || (a.uniform4fv(this._uColorize, c), s[0] = c[0], s[1] = c[1], s[2] = c[2], s[3] = c[3])), a.uniform3fv(this._uOffset, n.offset), l.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._uUVDecodeMatrix && a.uniformMatrix3fv(this._uUVDecodeMatrix, !1, l.uvDecodeMatrix), this._aPosition && (this._aPosition.bindArrayBuffer(l.positionsBuf), e.bindArray++), this._aNormal && (this._aNormal.bindArrayBuffer(l.normalsBuf), e.bindArray++), this._aUV && (this._aUV.bindArrayBuffer(l.uvBuf), e.bindArray++), this._aColor && (this._aColor.bindArrayBuffer(l.colorsBuf), e.bindArray++), this._aFlags && (this._aFlags.bindArrayBuffer(l.flagsBuf), e.bindArray++), l.indicesBuf && (l.indicesBuf.bind(), e.bindArray++), this._lastGeometryId = l.id), l.indicesBuf ? (a.drawElements(l.primitive, l.indicesBuf.numItems, l.indicesBuf.itemType, 0), e.drawElements++) : l.positions && (a.drawArrays(a.TRIANGLES, 0, l.positions.numItems), e.drawArrays++), p && a.depthFunc(a.LESS) }, DrawRenderer.prototype._allocate = function (e) { var t = e.scene, i = t.canvas.gl, s = e._material, r = t._lightsState, a = t._sectionPlanesState; e = e._material._state; if (this._program = new Program(i, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { for (var o, n = this._program, h = (this._uPositionsDecodeMatrix = n.getLocation("positionsDecodeMatrix"), this._uUVDecodeMatrix = n.getLocation("uvDecodeMatrix"), this._uModelMatrix = n.getLocation("modelMatrix"), this._uModelNormalMatrix = n.getLocation("modelNormalMatrix"), this._uViewMatrix = n.getLocation("viewMatrix"), this._uViewNormalMatrix = n.getLocation("viewNormalMatrix"), this._uProjMatrix = n.getLocation("projMatrix"), this._uGammaFactor = n.getLocation("gammaFactor"), this._uLightAmbient = [], this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], this._uShadowViewMatrix = [], this._uShadowProjMatrix = [], t.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = n.getLocation("logDepthBufFC")), r.lights), l = 0, c = h.length; l < c; l++) { switch ((o = h[l]).type) { case "ambient": this._uLightAmbient[l] = n.getLocation("lightAmbient"); break; case "dir": this._uLightColor[l] = n.getLocation("lightColor" + l), this._uLightPos[l] = null, this._uLightDir[l] = n.getLocation("lightDir" + l); break; case "point": this._uLightColor[l] = n.getLocation("lightColor" + l), this._uLightPos[l] = n.getLocation("lightPos" + l), this._uLightDir[l] = null, this._uLightAttenuation[l] = n.getLocation("lightAttenuation" + l); break; case "spot": this._uLightColor[l] = n.getLocation("lightColor" + l), this._uLightPos[l] = n.getLocation("lightPos" + l), this._uLightDir[l] = n.getLocation("lightDir" + l), this._uLightAttenuation[l] = n.getLocation("lightAttenuation" + l) }o.castsShadow && (this._uShadowViewMatrix[l] = n.getLocation("shadowViewMatrix" + l), this._uShadowProjMatrix[l] = n.getLocation("shadowProjMatrix" + l)) } for (0 < r.lightMaps.length && (this._uLightMap = "lightMap"), 0 < r.reflectionMaps.length && (this._uReflectionMap = "reflectionMap"), this._uSectionPlanes = [], l = 0, c = a.sectionPlanes.length; l < c; l++)this._uSectionPlanes.push({ active: n.getLocation("sectionPlaneActive" + l), pos: n.getLocation("sectionPlanePos" + l), dir: n.getLocation("sectionPlaneDir" + l) }); switch (this._uPointSize = n.getLocation("pointSize"), e.type) { case "LambertMaterial": this._uMaterialColor = n.getLocation("materialColor"), this._uMaterialEmissive = n.getLocation("materialEmissive"), this._uAlphaModeCutoff = n.getLocation("materialAlphaModeCutoff"); break; case "PhongMaterial": this._uMaterialAmbient = n.getLocation("materialAmbient"), this._uMaterialDiffuse = n.getLocation("materialDiffuse"), this._uMaterialSpecular = n.getLocation("materialSpecular"), this._uMaterialEmissive = n.getLocation("materialEmissive"), this._uAlphaModeCutoff = n.getLocation("materialAlphaModeCutoff"), this._uMaterialShininess = n.getLocation("materialShininess"), s._ambientMap && (this._uMaterialAmbientMap = "ambientMap", this._uMaterialAmbientMapMatrix = n.getLocation("ambientMapMatrix")), s._diffuseMap && (this._uDiffuseMap = "diffuseMap", this._uDiffuseMapMatrix = n.getLocation("diffuseMapMatrix")), s._specularMap && (this._uSpecularMap = "specularMap", this._uSpecularMapMatrix = n.getLocation("specularMapMatrix")), s._emissiveMap && (this._uEmissiveMap = "emissiveMap", this._uEmissiveMapMatrix = n.getLocation("emissiveMapMatrix")), s._alphaMap && (this._uAlphaMap = "alphaMap", this._uAlphaMapMatrix = n.getLocation("alphaMapMatrix")), s._reflectivityMap && (this._uReflectivityMap = "reflectivityMap", this._uReflectivityMapMatrix = n.getLocation("reflectivityMapMatrix")), s._normalMap && (this._uNormalMap = "normalMap", this._uNormalMapMatrix = n.getLocation("normalMapMatrix")), s._occlusionMap && (this._uOcclusionMap = "occlusionMap", this._uOcclusionMapMatrix = n.getLocation("occlusionMapMatrix")), s._diffuseFresnel && (this._uDiffuseFresnelEdgeBias = n.getLocation("diffuseFresnelEdgeBias"), this._uDiffuseFresnelCenterBias = n.getLocation("diffuseFresnelCenterBias"), this._uDiffuseFresnelEdgeColor = n.getLocation("diffuseFresnelEdgeColor"), this._uDiffuseFresnelCenterColor = n.getLocation("diffuseFresnelCenterColor"), this._uDiffuseFresnelPower = n.getLocation("diffuseFresnelPower")), s._specularFresnel && (this._uSpecularFresnelEdgeBias = n.getLocation("specularFresnelEdgeBias"), this._uSpecularFresnelCenterBias = n.getLocation("specularFresnelCenterBias"), this._uSpecularFresnelEdgeColor = n.getLocation("specularFresnelEdgeColor"), this._uSpecularFresnelCenterColor = n.getLocation("specularFresnelCenterColor"), this._uSpecularFresnelPower = n.getLocation("specularFresnelPower")), s._alphaFresnel && (this._uAlphaFresnelEdgeBias = n.getLocation("alphaFresnelEdgeBias"), this._uAlphaFresnelCenterBias = n.getLocation("alphaFresnelCenterBias"), this._uAlphaFresnelEdgeColor = n.getLocation("alphaFresnelEdgeColor"), this._uAlphaFresnelCenterColor = n.getLocation("alphaFresnelCenterColor"), this._uAlphaFresnelPower = n.getLocation("alphaFresnelPower")), s._reflectivityFresnel && (this._uReflectivityFresnelEdgeBias = n.getLocation("reflectivityFresnelEdgeBias"), this._uReflectivityFresnelCenterBias = n.getLocation("reflectivityFresnelCenterBias"), this._uReflectivityFresnelEdgeColor = n.getLocation("reflectivityFresnelEdgeColor"), this._uReflectivityFresnelCenterColor = n.getLocation("reflectivityFresnelCenterColor"), this._uReflectivityFresnelPower = n.getLocation("reflectivityFresnelPower")), s._emissiveFresnel && (this._uEmissiveFresnelEdgeBias = n.getLocation("emissiveFresnelEdgeBias"), this._uEmissiveFresnelCenterBias = n.getLocation("emissiveFresnelCenterBias"), this._uEmissiveFresnelEdgeColor = n.getLocation("emissiveFresnelEdgeColor"), this._uEmissiveFresnelCenterColor = n.getLocation("emissiveFresnelCenterColor"), this._uEmissiveFresnelPower = n.getLocation("emissiveFresnelPower")); break; case "MetallicMaterial": this._uBaseColor = n.getLocation("materialBaseColor"), this._uMaterialMetallic = n.getLocation("materialMetallic"), this._uMaterialRoughness = n.getLocation("materialRoughness"), this._uMaterialSpecularF0 = n.getLocation("materialSpecularF0"), this._uMaterialEmissive = n.getLocation("materialEmissive"), this._uAlphaModeCutoff = n.getLocation("materialAlphaModeCutoff"), s._baseColorMap && (this._uBaseColorMap = "baseColorMap", this._uBaseColorMapMatrix = n.getLocation("baseColorMapMatrix")), s._metallicMap && (this._uMetallicMap = "metallicMap", this._uMetallicMapMatrix = n.getLocation("metallicMapMatrix")), s._roughnessMap && (this._uRoughnessMap = "roughnessMap", this._uRoughnessMapMatrix = n.getLocation("roughnessMapMatrix")), s._metallicRoughnessMap && (this._uMetallicRoughnessMap = "metallicRoughnessMap", this._uMetallicRoughnessMapMatrix = n.getLocation("metallicRoughnessMapMatrix")), s._emissiveMap && (this._uEmissiveMap = "emissiveMap", this._uEmissiveMapMatrix = n.getLocation("emissiveMapMatrix")), s._occlusionMap && (this._uOcclusionMap = "occlusionMap", this._uOcclusionMapMatrix = n.getLocation("occlusionMapMatrix")), s._alphaMap && (this._uAlphaMap = "alphaMap", this._uAlphaMapMatrix = n.getLocation("alphaMapMatrix")), s._normalMap && (this._uNormalMap = "normalMap", this._uNormalMapMatrix = n.getLocation("normalMapMatrix")); break; case "SpecularMaterial": this._uMaterialDiffuse = n.getLocation("materialDiffuse"), this._uMaterialSpecular = n.getLocation("materialSpecular"), this._uMaterialGlossiness = n.getLocation("materialGlossiness"), this._uMaterialReflectivity = n.getLocation("reflectivityFresnel"), this._uMaterialEmissive = n.getLocation("materialEmissive"), this._uAlphaModeCutoff = n.getLocation("materialAlphaModeCutoff"), s._diffuseMap && (this._uDiffuseMap = "diffuseMap", this._uDiffuseMapMatrix = n.getLocation("diffuseMapMatrix")), s._specularMap && (this._uSpecularMap = "specularMap", this._uSpecularMapMatrix = n.getLocation("specularMapMatrix")), s._glossinessMap && (this._uGlossinessMap = "glossinessMap", this._uGlossinessMapMatrix = n.getLocation("glossinessMapMatrix")), s._specularGlossinessMap && (this._uSpecularGlossinessMap = "materialSpecularGlossinessMap", this._uSpecularGlossinessMapMatrix = n.getLocation("materialSpecularGlossinessMapMatrix")), s._emissiveMap && (this._uEmissiveMap = "emissiveMap", this._uEmissiveMapMatrix = n.getLocation("emissiveMapMatrix")), s._occlusionMap && (this._uOcclusionMap = "occlusionMap", this._uOcclusionMapMatrix = n.getLocation("occlusionMapMatrix")), s._alphaMap && (this._uAlphaMap = "alphaMap", this._uAlphaMapMatrix = n.getLocation("alphaMapMatrix")), s._normalMap && (this._uNormalMap = "normalMap", this._uNormalMapMatrix = n.getLocation("normalMapMatrix")) }this._aPosition = n.getAttribute("position"), this._aNormal = n.getAttribute("normal"), this._aUV = n.getAttribute("uv"), this._aColor = n.getAttribute("color"), this._aFlags = n.getAttribute("flags"), this._uClippable = n.getLocation("clippable"), this._uColorize = n.getLocation("colorize"), this._uOffset = n.getLocation("offset"), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null, this._lastColorize = new Float32Array(4), this._baseTextureUnit = 0 } }, DrawRenderer.prototype._bindProgram = function (e) { var t = WEBGL_INFO.MAX_TEXTURE_UNITS, i = this._scene, s = i.canvas.gl, r = i._lightsState, a = i.camera.project, o = this._program; o.bind(), e.useProgram++, e.textureUnit = 0, this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null, this._lastColorize[0] = -1, this._lastColorize[1] = -1, this._lastColorize[2] = -1, this._lastColorize[3] = -1, s.uniformMatrix4fv(this._uProjMatrix, !1, a.matrix), i.logarithmicDepthBufferEnabled && (a = 2 / (Math.log(a.far + 1) / Math.LN2), s.uniform1f(this._uLogDepthBufFC, a)); for (var n = 0, h = r.lights.length; n < h; n++) { var l = r.lights[n]; this._uLightAmbient[n] ? s.uniform4f(this._uLightAmbient[n], l.color[0], l.color[1], l.color[2], l.intensity) : (this._uLightColor[n] && s.uniform4f(this._uLightColor[n], l.color[0], l.color[1], l.color[2], l.intensity), this._uLightPos[n] && (s.uniform3fv(this._uLightPos[n], l.pos), this._uLightAttenuation[n]) && s.uniform1f(this._uLightAttenuation[n], l.attenuation), this._uLightDir[n] && s.uniform3fv(this._uLightDir[n], l.dir), l.castsShadow && (this._uShadowViewMatrix[n] && s.uniformMatrix4fv(this._uShadowViewMatrix[n], !1, l.getShadowViewMatrix()), this._uShadowProjMatrix[n] && s.uniformMatrix4fv(this._uShadowProjMatrix[n], !1, l.getShadowProjMatrix()), l = l.getShadowRenderBuf()) && (o.bindTexture("shadowMap" + n, l.getTexture(), e.textureUnit), e.textureUnit = (e.textureUnit + 1) % t, e.bindTexture++)) } 0 < r.lightMaps.length && r.lightMaps[0].texture && this._uLightMap && (o.bindTexture(this._uLightMap, r.lightMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % t, e.bindTexture++), 0 < r.reflectionMaps.length && r.reflectionMaps[0].texture && this._uReflectionMap && (o.bindTexture(this._uReflectionMap, r.reflectionMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % t, e.bindTexture++), this._uGammaFactor && s.uniform1f(this._uGammaFactor, i.gammaFactor), this._baseTextureUnit = e.textureUnit }; class EmphasisFillShaderSource { constructor(e) { this.vertex = buildVertex$5(e), this.fragment = buildFragment$5(e) } } function buildVertex$5(e) { var t = e.scene, i = t._lightsState, s = hasNormals(e), r = 0 < t._sectionPlanesState.sectionPlanes.length, a = !!e._geometry._state.compressGeometry, o = e._state.billboard, n = e._state.stationary, h = []; if (h.push("#version 300 es"), h.push("// EmphasisFillShaderSource vertex shader"), h.push("in vec3 position;"), h.push("uniform mat4 modelMatrix;"), h.push("uniform mat4 viewMatrix;"), h.push("uniform mat4 projMatrix;"), h.push("uniform vec4 colorize;"), h.push("uniform vec3 offset;"), a && h.push("uniform mat4 positionsDecodeMatrix;"), t.logarithmicDepthBufferEnabled && (h.push("uniform float logDepthBufFC;"), h.push("out float vFragDepth;"), h.push("bool isPerspectiveMatrix(mat4 m) {"), h.push("    return (m[2][3] == - 1.0);"), h.push("}"), h.push("out float isPerspective;")), r && h.push("out vec4 vWorldPosition;"), h.push("uniform vec4   lightAmbient;"), h.push("uniform vec4   fillColor;"), s) { h.push("in vec3 normal;"), h.push("uniform mat4 modelNormalMatrix;"), h.push("uniform mat4 viewNormalMatrix;"); for (let e = 0, t = i.lights.length; e < t; e++) { var l = i.lights[e]; "ambient" !== l.type && (h.push("uniform vec4 lightColor" + e + ";"), "dir" === l.type && h.push("uniform vec3 lightDir" + e + ";"), "point" === l.type && h.push("uniform vec3 lightPos" + e + ";"), "spot" === l.type) && h.push("uniform vec3 lightPos" + e + ";") } a && (h.push("vec3 octDecode(vec2 oct) {"), h.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), h.push("    if (v.z < 0.0) {"), h.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), h.push("    }"), h.push("    return normalize(v);"), h.push("}")) } if (h.push("out vec4 vColor;"), "spherical" !== o && "cylindrical" !== o || (h.push("void billboard(inout mat4 mat) {"), h.push("   mat[0][0] = 1.0;"), h.push("   mat[0][1] = 0.0;"), h.push("   mat[0][2] = 0.0;"), "spherical" === o && (h.push("   mat[1][0] = 0.0;"), h.push("   mat[1][1] = 1.0;"), h.push("   mat[1][2] = 0.0;")), h.push("   mat[2][0] = 0.0;"), h.push("   mat[2][1] = 0.0;"), h.push("   mat[2][2] =1.0;"), h.push("}")), h.push("void main(void) {"), h.push("vec4 localPosition = vec4(position, 1.0); "), h.push("vec4 worldPosition;"), a && h.push("localPosition = positionsDecodeMatrix * localPosition;"), s && (h.push(a ? "vec4 localNormal = vec4(octDecode(normal.xy), 0.0); " : "vec4 localNormal = vec4(normal, 0.0); "), h.push("mat4 modelNormalMatrix2 = modelNormalMatrix;"), h.push("mat4 viewNormalMatrix2 = viewNormalMatrix;")), h.push("mat4 viewMatrix2 = viewMatrix;"), h.push("mat4 modelMatrix2 = modelMatrix;"), n && h.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;"), "spherical" === o || "cylindrical" === o ? (h.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), h.push("billboard(modelMatrix2);"), h.push("billboard(viewMatrix2);"), h.push("billboard(modelViewMatrix);"), s && (h.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;"), h.push("billboard(modelNormalMatrix2);"), h.push("billboard(viewNormalMatrix2);"), h.push("billboard(modelViewNormalMatrix);")), h.push("worldPosition = modelMatrix2 * localPosition;"), h.push("vec4 viewPosition = modelViewMatrix * localPosition;")) : (h.push("worldPosition = modelMatrix2 * localPosition;"), h.push("worldPosition.xyz = worldPosition.xyz + offset;"), h.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")), s && h.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);"), h.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), h.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), h.push("float lambertian = 1.0;"), s) for (let e = 0, t = i.lights.length; e < t; e++) { var c = i.lights[e]; if ("ambient" !== c.type) { if ("dir" === c.type) "view" === c.space ? h.push("viewLightDir = normalize(lightDir" + e + ");") : h.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + e + ", 0.0)).xyz);"); else { if ("point" !== c.type) continue; "view" === c.space ? h.push("viewLightDir = normalize(lightPos" + e + " - viewPosition.xyz);") : h.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos" + e + ", 0.0)).xyz);") } h.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), h.push("reflectedColor += lambertian * (lightColor" + e + ".rgb * lightColor" + e + ".a);") } } return h.push("vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);"), r && h.push("vWorldPosition = worldPosition;"), "points" === e._geometry._state.primitiveName && h.push("gl_PointSize = pointSize;"), h.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (h.push("vFragDepth = 1.0 + clipPos.w;"), h.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), h.push("gl_Position = clipPos;"), h.push("}"), h } function hasNormals(e) { var t = e._geometry._state.primitiveName; return !(!e._geometry._state.autoVertexNormals && !e._geometry._state.normalsBuf || "triangles" !== t && "triangle-strip" !== t && "triangle-fan" !== t) } function buildFragment$5(e) { var t = e.scene, i = e.scene._sectionPlanesState, s = e.scene.gammaOutput, r = 0 < i.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Lambertian drawing fragment shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), t.logarithmicDepthBufferEnabled && (a.push("in float isPerspective;"), a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), s && (a.push("uniform float gammaFactor;"), a.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), a.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), a.push("}")), r) { a.push("in vec4 vWorldPosition;"), a.push("uniform bool clippable;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)a.push("uniform bool sectionPlaneActive" + e + ";"), a.push("uniform vec3 sectionPlanePos" + e + ";"), a.push("uniform vec3 sectionPlaneDir" + e + ";") } if (a.push("in vec4 vColor;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), r) { a.push("if (clippable) {"), a.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)a.push("if (sectionPlaneActive" + e + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("  if (dist > 0.0) { discard; }"), a.push("}") } return "points" === e._geometry._state.primitiveName && (a.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), a.push("float r = dot(cxy, cxy);"), a.push("if (r > 1.0) {"), a.push("   discard;"), a.push("}")), t.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push(s ? "outColor = linearToGamma(vColor, gammaFactor);" : "outColor = vColor;"), a.push("}"), a } const ids$1 = new Map$1({}), tempVec3a$11 = math.vec3(), EmphasisFillRenderer = function (e, t) { this.id = ids$1.addItem({}), this._hash = e, this._scene = t.scene, this._useCount = 0, this._shaderSource = new EmphasisFillShaderSource(t), this._allocate(t) }, xrayFillRenderers = {}; EmphasisFillRenderer.get = function (e) { var t = [e.scene.id, e.scene.gammaOutput ? "go" : "", e.scene._sectionPlanesState.getHash(), e._geometry._state.normalsBuf ? "n" : "", e._geometry._state.compressGeometry ? "cp" : "", e._state.hash].join(";"); let i = xrayFillRenderers[t]; return i || (i = new EmphasisFillRenderer(t, e), xrayFillRenderers[t] = i, stats.memory.programs++), i._useCount++, i }, EmphasisFillRenderer.prototype.put = function () { 0 == --this._useCount && (ids$1.removeItem(this.id), this._program && this._program.destroy(), delete xrayFillRenderers[this._hash], stats.memory.programs--) }, EmphasisFillRenderer.prototype.webglContextRestored = function () { this._program = null }, EmphasisFillRenderer.prototype.drawMesh = function (e, t, i) { this._program || this._allocate(t); var s = this._scene, r = s.camera, a = s.canvas.gl, o = (i = (0 === i ? t._xrayMaterial : 1 === i ? t._highlightMaterial : t._selectedMaterial)._state, t._state), n = t._geometry._state, h = t.origin; if (e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), a.uniformMatrix4fv(this._uViewMatrix, !1, h ? e.getRTCViewMatrix(o.originHash, h) : r.viewMatrix), a.uniformMatrix4fv(this._uViewNormalMatrix, !1, r.viewNormalMatrix), o.clippable) { var l = s._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = s._sectionPlanesState.sectionPlanes, u = t.renderFlags; for (let e = 0; e < l; e++) { var p, d = this._uSectionPlanes[e]; d && (p = u.sectionPlanesActivePerLayer[e], a.uniform1i(d.active, p ? 1 : 0), p) && (p = c[e], a.uniform3fv(d.pos, h ? getPlaneRTCPos(p.dist, p.dir, h, tempVec3a$11) : p.pos), a.uniform3fv(d.dir, p.dir)) } } } i.id !== this._lastMaterialId && (r = i.fillColor, s = i.backfaces, e.backfaces !== s && (s ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), e.backfaces = s), a.uniform4f(this._uFillColor, r[0], r[1], r[2], i.fillAlpha), this._lastMaterialId = i.id), a.uniformMatrix4fv(this._uModelMatrix, a.FALSE, t.worldMatrix), this._uModelNormalMatrix && a.uniformMatrix4fv(this._uModelNormalMatrix, a.FALSE, t.worldNormalMatrix), this._uClippable && a.uniform1i(this._uClippable, o.clippable), a.uniform3fv(this._uOffset, o.offset), n.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, n.positionsDecodeMatrix), this._uUVDecodeMatrix && a.uniformMatrix3fv(this._uUVDecodeMatrix, !1, n.uvDecodeMatrix), this._aPosition && (this._aPosition.bindArrayBuffer(n.positionsBuf), e.bindArray++), this._aNormal && (this._aNormal.bindArrayBuffer(n.normalsBuf), e.bindArray++), n.indicesBuf ? (n.indicesBuf.bind(), e.bindArray++) : n.positionsBuf, this._lastGeometryId = n.id), n.indicesBuf ? (a.drawElements(n.primitive, n.indicesBuf.numItems, n.indicesBuf.itemType, 0), e.drawElements++) : n.positionsBuf && (a.drawArrays(a.TRIANGLES, 0, n.positionsBuf.numItems), e.drawArrays++) }, EmphasisFillRenderer.prototype._allocate = function (e) { var t = (e = e.scene)._lightsState, i = e._sectionPlanesState, s = e.canvas.gl; if (this._program = new Program(s, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { var r = this._program; this._uPositionsDecodeMatrix = r.getLocation("positionsDecodeMatrix"), this._uModelMatrix = r.getLocation("modelMatrix"), this._uModelNormalMatrix = r.getLocation("modelNormalMatrix"), this._uViewMatrix = r.getLocation("viewMatrix"), this._uViewNormalMatrix = r.getLocation("viewNormalMatrix"), this._uProjMatrix = r.getLocation("projMatrix"), this._uLightAmbient = [], this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = []; for (let e = 0, i = t.lights.length; e < i; e++)switch (t.lights[e].type) { case "ambient": this._uLightAmbient[e] = r.getLocation("lightAmbient"); break; case "dir": this._uLightColor[e] = r.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = r.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = r.getLocation("lightColor" + e), this._uLightPos[e] = r.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = r.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: r.getLocation("sectionPlaneActive" + e), pos: r.getLocation("sectionPlanePos" + e), dir: r.getLocation("sectionPlaneDir" + e) }); this._uFillColor = r.getLocation("fillColor"), this._aPosition = r.getAttribute("position"), this._aNormal = r.getAttribute("normal"), this._uClippable = r.getLocation("clippable"), this._uGammaFactor = r.getLocation("gammaFactor"), this._uOffset = r.getLocation("offset"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = r.getLocation("logDepthBufFC")), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null } }, EmphasisFillRenderer.prototype._bindProgram = function (e) { var t = this._scene, i = t.canvas.gl, s = t._lightsState, r = t.camera, a = r.project; this._program.bind(), e.useProgram++, e.textureUnit = 0, this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null, this._lastIndicesBufId = null, i.uniformMatrix4fv(this._uViewNormalMatrix, !1, r.normalMatrix), i.uniformMatrix4fv(this._uProjMatrix, !1, a.matrix), t.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(a.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, e)); for (let e = 0, t = s.lights.length; e < t; e++) { var o = s.lights[e]; this._uLightAmbient[e] ? i.uniform4f(this._uLightAmbient[e], o.color[0], o.color[1], o.color[2], o.intensity) : (this._uLightColor[e] && i.uniform4f(this._uLightColor[e], o.color[0], o.color[1], o.color[2], o.intensity), this._uLightPos[e] && (i.uniform3fv(this._uLightPos[e], o.pos), this._uLightAttenuation[e]) && i.uniform1f(this._uLightAttenuation[e], o.attenuation), this._uLightDir[e] && i.uniform3fv(this._uLightDir[e], o.dir)) } this._uGammaFactor && i.uniform1f(this._uGammaFactor, t.gammaFactor) }; class EmphasisEdgesShaderSource { constructor(e) { this.vertex = buildVertex$4(e), this.fragment = buildFragment$4(e) } } function buildVertex$4(e) { var t = e.scene, i = 0 < t._sectionPlanesState.sectionPlanes.length, s = !!e._geometry._state.compressGeometry, r = e._state.billboard, a = (e = e._state.stationary, []); return a.push("#version 300 es"), a.push("// Edges drawing vertex shader"), a.push("in vec3 position;"), a.push("uniform mat4 modelMatrix;"), a.push("uniform mat4 viewMatrix;"), a.push("uniform mat4 projMatrix;"), a.push("uniform vec4 edgeColor;"), a.push("uniform vec3 offset;"), s && a.push("uniform mat4 positionsDecodeMatrix;"), t.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("out float vFragDepth;"), a.push("bool isPerspectiveMatrix(mat4 m) {"), a.push("    return (m[2][3] == - 1.0);"), a.push("}"), a.push("out float isPerspective;")), i && a.push("out vec4 vWorldPosition;"), a.push("out vec4 vColor;"), "spherical" !== r && "cylindrical" !== r || (a.push("void billboard(inout mat4 mat) {"), a.push("   mat[0][0] = 1.0;"), a.push("   mat[0][1] = 0.0;"), a.push("   mat[0][2] = 0.0;"), "spherical" === r && (a.push("   mat[1][0] = 0.0;"), a.push("   mat[1][1] = 1.0;"), a.push("   mat[1][2] = 0.0;")), a.push("   mat[2][0] = 0.0;"), a.push("   mat[2][1] = 0.0;"), a.push("   mat[2][2] =1.0;"), a.push("}")), a.push("void main(void) {"), a.push("vec4 localPosition = vec4(position, 1.0); "), a.push("vec4 worldPosition;"), s && a.push("localPosition = positionsDecodeMatrix * localPosition;"), a.push("mat4 viewMatrix2 = viewMatrix;"), a.push("mat4 modelMatrix2 = modelMatrix;"), e && a.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;"), "spherical" === r || "cylindrical" === r ? (a.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), a.push("billboard(modelMatrix2);"), a.push("billboard(viewMatrix2);"), a.push("billboard(modelViewMatrix);"), a.push("worldPosition = modelMatrix2 * localPosition;"), a.push("worldPosition.xyz = worldPosition.xyz + offset;"), a.push("vec4 viewPosition = modelViewMatrix * localPosition;")) : (a.push("worldPosition = modelMatrix2 * localPosition;"), a.push("worldPosition.xyz = worldPosition.xyz + offset;"), a.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")), a.push("vColor = edgeColor;"), i && a.push("vWorldPosition = worldPosition;"), a.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (a.push("vFragDepth = 1.0 + clipPos.w;"), a.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), a.push("gl_Position = clipPos;"), a.push("}"), a } function buildFragment$4(e) { var t = e.scene, i = e.scene._sectionPlanesState, s = (e = e.scene.gammaOutput, 0 < i.sectionPlanes.length), r = []; if (r.push("#version 300 es"), r.push("// Edges drawing fragment shader"), r.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), r.push("precision highp float;"), r.push("precision highp int;"), r.push("#else"), r.push("precision mediump float;"), r.push("precision mediump int;"), r.push("#endif"), t.logarithmicDepthBufferEnabled && (r.push("in float isPerspective;"), r.push("uniform float logDepthBufFC;"), r.push("in float vFragDepth;")), e && (r.push("uniform float gammaFactor;"), r.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), r.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), r.push("}")), s) { r.push("in vec4 vWorldPosition;"), r.push("uniform bool clippable;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)r.push("uniform bool sectionPlaneActive" + e + ";"), r.push("uniform vec3 sectionPlanePos" + e + ";"), r.push("uniform vec3 sectionPlaneDir" + e + ";") } if (r.push("in vec4 vColor;"), r.push("out vec4 outColor;"), r.push("void main(void) {"), s) { r.push("if (clippable) {"), r.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)r.push("if (sectionPlaneActive" + e + ") {"), r.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), r.push("}"); r.push("  if (dist > 0.0) { discard; }"), r.push("}") } return t.logarithmicDepthBufferEnabled && r.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), r.push(e ? "outColor = linearToGamma(vColor, gammaFactor);" : "outColor = vColor;"), r.push("}"), r } const ids = new Map$1({}), tempVec3a$10 = math.vec3(), EmphasisEdgesRenderer = function (e, t) { this.id = ids.addItem({}), this._hash = e, this._scene = t.scene, this._useCount = 0, this._shaderSource = new EmphasisEdgesShaderSource(t), this._allocate(t) }, renderers$4 = {}; EmphasisEdgesRenderer.get = function (e) { var t = [e.scene.id, e.scene.gammaOutput ? "go" : "", e.scene._sectionPlanesState.getHash(), e._geometry._state.compressGeometry ? "cp" : "", e._state.hash].join(";"); let i = renderers$4[t]; return i || (i = new EmphasisEdgesRenderer(t, e), renderers$4[t] = i, stats.memory.programs++), i._useCount++, i }, EmphasisEdgesRenderer.prototype.put = function () { 0 == --this._useCount && (ids.removeItem(this.id), this._program && this._program.destroy(), delete renderers$4[this._hash], stats.memory.programs--) }, EmphasisEdgesRenderer.prototype.webglContextRestored = function () { this._program = null }, EmphasisEdgesRenderer.prototype.drawMesh = function (e, t, i) { this._program || this._allocate(t); var s = this._scene, r = s.camera, a = s.canvas.gl; let o; var n = t._state, h = t._geometry, l = h._state, c = t.origin; if (e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), a.uniformMatrix4fv(this._uViewMatrix, !1, c ? e.getRTCViewMatrix(n.originHash, c) : r.viewMatrix), n.clippable) { var u = s._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = s._sectionPlanesState.sectionPlanes, d = t.renderFlags; for (let e = 0; e < u; e++) { var m, f = this._uSectionPlanes[e]; f && (m = d.sectionPlanesActivePerLayer[e], a.uniform1i(f.active, m ? 1 : 0), m) && (m = p[e], a.uniform3fv(f.pos, c ? getPlaneRTCPos(m.dist, m.dir, c, tempVec3a$10) : m.pos), a.uniform3fv(f.dir, m.dir)) } } } switch (i) { case 0: o = t._xrayMaterial._state; break; case 1: o = t._highlightMaterial._state; break; case 2: o = t._selectedMaterial._state; break; default: o = t._edgeMaterial._state }let g; o.id !== this._lastMaterialId && (r = o.backfaces, e.backfaces !== r && (r ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), e.backfaces = r), e.lineWidth !== o.edgeWidth && (a.lineWidth(o.edgeWidth), e.lineWidth = o.edgeWidth), this._uEdgeColor && (s = o.edgeColor, i = o.edgeAlpha, a.uniform4f(this._uEdgeColor, s[0], s[1], s[2], i)), this._lastMaterialId = o.id), a.uniformMatrix4fv(this._uModelMatrix, a.FALSE, t.worldMatrix), this._uClippable && a.uniform1i(this._uClippable, n.clippable), a.uniform3fv(this._uOffset, n.offset), l.primitive === a.TRIANGLES ? g = h._getEdgeIndices() : l.primitive === a.LINES && (g = l.indicesBuf), g && (l.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._aPosition && (this._aPosition.bindArrayBuffer(l.positionsBuf, l.compressGeometry ? a.UNSIGNED_SHORT : a.FLOAT), e.bindArray++), g.bind(), e.bindArray++, this._lastGeometryId = l.id), a.drawElements(a.LINES, g.numItems, g.itemType, 0), e.drawElements++) }, EmphasisEdgesRenderer.prototype._allocate = function (e) { var t = (e = e.scene).canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uModelMatrix = s.getLocation("modelMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._uEdgeColor = s.getLocation("edgeColor"), this._aPosition = s.getAttribute("position"), this._uClippable = s.getLocation("clippable"), this._uGammaFactor = s.getLocation("gammaFactor"), this._uOffset = s.getLocation("offset"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null } }, EmphasisEdgesRenderer.prototype._bindProgram = function (e) { var t = this._program, i = this._scene, s = i.canvas.gl, r = i.camera.project; t.bind(), e.useProgram++, this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null, s.uniformMatrix4fv(this._uProjMatrix, !1, r.matrix), i.logarithmicDepthBufferEnabled && (t = 2 / (Math.log(r.far + 1) / Math.LN2), s.uniform1f(this._uLogDepthBufFC, t)), this._uGammaFactor && s.uniform1f(this._uGammaFactor, i.gammaFactor) }; class PickMeshShaderSource { constructor(e) { this.vertex = buildVertex$3(e), this.fragment = buildFragment$3(e) } } function buildVertex$3(e) { var t = e.scene, i = 0 < t._sectionPlanesState.sectionPlanes.length, s = !!e._geometry._state.compressGeometry, r = e._state.billboard, a = (e = e._state.stationary, []); return a.push("#version 300 es"), a.push("// Mesh picking vertex shader"), a.push("in vec3 position;"), a.push("uniform mat4 modelMatrix;"), a.push("uniform mat4 viewMatrix;"), a.push("uniform mat4 projMatrix;"), a.push("out vec4 vViewPosition;"), a.push("uniform vec3 offset;"), s && a.push("uniform mat4 positionsDecodeMatrix;"), i && a.push("out vec4 vWorldPosition;"), t.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("out float vFragDepth;"), a.push("bool isPerspectiveMatrix(mat4 m) {"), a.push("    return (m[2][3] == - 1.0);"), a.push("}"), a.push("out float isPerspective;")), "spherical" !== r && "cylindrical" !== r || (a.push("void billboard(inout mat4 mat) {"), a.push("   mat[0][0] = 1.0;"), a.push("   mat[0][1] = 0.0;"), a.push("   mat[0][2] = 0.0;"), "spherical" === r && (a.push("   mat[1][0] = 0.0;"), a.push("   mat[1][1] = 1.0;"), a.push("   mat[1][2] = 0.0;")), a.push("   mat[2][0] = 0.0;"), a.push("   mat[2][1] = 0.0;"), a.push("   mat[2][2] =1.0;"), a.push("}")), a.push("void main(void) {"), a.push("vec4 localPosition = vec4(position, 1.0); "), s && a.push("localPosition = positionsDecodeMatrix * localPosition;"), a.push("mat4 viewMatrix2 = viewMatrix;"), a.push("mat4 modelMatrix2 = modelMatrix;"), e && a.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;"), "spherical" !== r && "cylindrical" !== r || (a.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), a.push("billboard(modelMatrix2);"), a.push("billboard(viewMatrix2);")), a.push("   vec4 worldPosition = modelMatrix2 * localPosition;"), a.push("   worldPosition.xyz = worldPosition.xyz + offset;"), a.push("   vec4 viewPosition = viewMatrix2 * worldPosition;"), i && a.push("   vWorldPosition = worldPosition;"), a.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (a.push("vFragDepth = 1.0 + clipPos.w;"), a.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), a.push("gl_Position = clipPos;"), a.push("}"), a } function buildFragment$3(e) { var t = (e = e.scene)._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Mesh picking fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("uniform vec4 pickColor;"), i) { s.push("uniform bool clippable;"), s.push("in vec4 vWorldPosition;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("if (clippable) {"), s.push("  float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("if (sectionPlaneActive" + r + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = pickColor; "), s.push("}"), s } const tempVec3a$$ = math.vec3(), PickMeshRenderer = function (e, t) { this._hash = e, this._shaderSource = new PickMeshShaderSource(t), this._scene = t.scene, this._useCount = 0, this._allocate(t) }, renderers$3 = {}; PickMeshRenderer.get = function (e) { var t = [e.scene.canvas.canvas.id, e.scene._sectionPlanesState.getHash(), e._geometry._state.hash, e._state.hash].join(";"); let i = renderers$3[t]; if (!i) { if ((i = new PickMeshRenderer(t, e)).errors) return console.log(i.errors.join("\n")), null; renderers$3[t] = i, stats.memory.programs++ } return i._useCount++, i }, PickMeshRenderer.prototype.put = function () { 0 == --this._useCount && (this._program && this._program.destroy(), delete renderers$3[this._hash], stats.memory.programs--) }, PickMeshRenderer.prototype.webglContextRestored = function () { this._program = null }, PickMeshRenderer.prototype.drawMesh = function (e, t) { this._program || this._allocate(t); var i = this._scene, s = i.canvas.gl, r = t._state, a = t._material._state, o = t._geometry._state, n = t.origin; if (e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), s.uniformMatrix4fv(this._uViewMatrix, !1, n ? e.getRTCPickViewMatrix(r.originHash, n) : e.pickViewMatrix), r.clippable) { var h = i._sectionPlanesState.sectionPlanes.length; if (0 < h) { var l = i._sectionPlanesState.sectionPlanes, c = t.renderFlags; for (let e = 0; e < h; e++) { var u, p = this._uSectionPlanes[e]; p && (u = c.sectionPlanesActivePerLayer[e], s.uniform1i(p.active, u ? 1 : 0), u) && (u = l[e], s.uniform3fv(p.pos, n ? getPlaneRTCPos(u.dist, u.dir, n, tempVec3a$$) : u.pos), s.uniform3fv(p.dir, u.dir)) } } } a.id !== this._lastMaterialId && (r = a.backfaces, e.backfaces !== r && (r ? s.disable(s.CULL_FACE) : s.enable(s.CULL_FACE), e.backfaces = r), i = a.frontface, e.frontface !== i && (i ? s.frontFace(s.CCW) : s.frontFace(s.CW), e.frontface = i), this._lastMaterialId = a.id), s.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), s.uniformMatrix4fv(this._uModelMatrix, !1, t.worldMatrix), this._uClippable && s.uniform1i(this._uClippable, t._state.clippable), s.uniform3fv(this._uOffset, t._state.offset), o.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && s.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, o.positionsDecodeMatrix), this._aPosition && (this._aPosition.bindArrayBuffer(o.positionsBuf, o.compressGeometry ? s.UNSIGNED_SHORT : s.FLOAT), e.bindArray++), o.indicesBuf && (o.indicesBuf.bind(), e.bindArray++), this._lastGeometryId = o.id), r = t._state.pickID, s.uniform4f(this._uPickColor, (255 & r) / 255, (r >> 8 & 255) / 255, (r >> 16 & 255) / 255, (r >> 24 & 255) / 255), o.indicesBuf ? (s.drawElements(o.primitive, o.indicesBuf.numItems, o.indicesBuf.itemType, 0), e.drawElements++) : o.positions && s.drawArrays(s.TRIANGLES, 0, o.positions.numItems) }, PickMeshRenderer.prototype._allocate = function (e) { var t = (e = e.scene).canvas.gl; if (this._program = new Program(t, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uModelMatrix = i.getLocation("modelMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._uClippable = i.getLocation("clippable"), this._uPickColor = i.getLocation("pickColor"), this._uOffset = i.getLocation("offset"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")), this._lastMaterialId = null, this._lastGeometryId = null } }, PickMeshRenderer.prototype._bindProgram = function (e) { var t = this._scene, i = t.canvas.gl, s = t.camera.project; this._program.bind(), e.useProgram++, t.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(s.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, e)), this._lastMaterialId = null, this._lastGeometryId = null }; class PickTriangleShaderSource { constructor(e) { this.vertex = buildVertex$2(e), this.fragment = buildFragment$2(e) } } function buildVertex$2(e) { var t = e.scene, i = 0 < t._sectionPlanesState.sectionPlanes.length, s = !!e._geometry._state.compressGeometry; return e._state.billboard, e._state.stationary, (e = []).push("#version 300 es"), e.push("// Surface picking vertex shader"), e.push("in vec3 position;"), e.push("in vec4 color;"), e.push("uniform mat4 modelMatrix;"), e.push("uniform mat4 viewMatrix;"), e.push("uniform mat4 projMatrix;"), e.push("uniform vec3 offset;"), i && (e.push("uniform bool clippable;"), e.push("out vec4 vWorldPosition;")), t.logarithmicDepthBufferEnabled && (e.push("uniform float logDepthBufFC;"), e.push("out float vFragDepth;"), e.push("bool isPerspectiveMatrix(mat4 m) {"), e.push("    return (m[2][3] == - 1.0);"), e.push("}"), e.push("out float isPerspective;")), e.push("out vec4 vColor;"), s && e.push("uniform mat4 positionsDecodeMatrix;"), e.push("void main(void) {"), e.push("vec4 localPosition = vec4(position, 1.0); "), s && e.push("localPosition = positionsDecodeMatrix * localPosition;"), e.push("   vec4 worldPosition = modelMatrix * localPosition; "), e.push("   worldPosition.xyz = worldPosition.xyz + offset;"), e.push("   vec4 viewPosition = viewMatrix * worldPosition;"), i && e.push("   vWorldPosition = worldPosition;"), e.push("   vColor = color;"), e.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (e.push("vFragDepth = 1.0 + clipPos.w;"), e.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), e.push("gl_Position = clipPos;"), e.push("}"), e } function buildFragment$2(e) { var t = (e = e.scene)._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Surface picking fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), s.push("in vec4 vColor;"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("uniform bool clippable;"), s.push("in vec4 vWorldPosition;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vColor;"), s.push("}"), s } const tempVec3a$_ = math.vec3(), PickTriangleRenderer = function (e, t) { this._hash = e, this._scene = t.scene, this._useCount = 0, this._shaderSource = new PickTriangleShaderSource(t), this._allocate(t) }, renderers$2 = {}; PickTriangleRenderer.get = function (e) { var t = [e.scene.canvas.canvas.id, e.scene._sectionPlanesState.getHash(), e._geometry._state.compressGeometry ? "cp" : "", e._state.hash].join(";"); let i = renderers$2[t]; if (!i) { if ((i = new PickTriangleRenderer(t, e)).errors) return console.log(i.errors.join("\n")), null; renderers$2[t] = i, stats.memory.programs++ } return i._useCount++, i }, PickTriangleRenderer.prototype.put = function () { 0 == --this._useCount && (this._program && this._program.destroy(), delete renderers$2[this._hash], stats.memory.programs--) }, PickTriangleRenderer.prototype.webglContextRestored = function () { this._program = null }, PickTriangleRenderer.prototype.drawMesh = function (e, t) { this._program || this._allocate(t); var i = this._scene, s = i.canvas.gl, r = t._state, a = t._material._state, o = t._geometry, n = t._geometry._state, h = t.origin, l = a.backfaces, c = (a = a.frontface, i.camera.project), u = o._getPickTrianglePositions(); o = o._getPickTriangleColors(); if (this._program.bind(), e.useProgram++, i.logarithmicDepthBufferEnabled && (c = 2 / (Math.log(c.far + 1) / Math.LN2), s.uniform1f(this._uLogDepthBufFC, c)), s.uniformMatrix4fv(this._uViewMatrix, !1, h ? e.getRTCPickViewMatrix(r.originHash, h) : e.pickViewMatrix), r.clippable) { var p = i._sectionPlanesState.sectionPlanes.length; if (0 < p) { var d = i._sectionPlanesState.sectionPlanes, m = t.renderFlags; for (let e = 0; e < p; e++) { var f, g = this._uSectionPlanes[e]; g && (f = m.sectionPlanesActivePerLayer[e], s.uniform1i(g.active, f ? 1 : 0), f) && (f = d[e], s.uniform3fv(g.pos, h ? getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$_) : f.pos), s.uniform3fv(g.dir, f.dir)) } } } s.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), i.logarithmicDepthBufferEnabled && s.uniform1f(this._uZFar, i.camera.project.far), e.backfaces !== l && (l ? s.disable(s.CULL_FACE) : s.enable(s.CULL_FACE), e.backfaces = l), e.frontface !== a && (a ? s.frontFace(s.CCW) : s.frontFace(s.CW), e.frontface = a), s.uniformMatrix4fv(this._uModelMatrix, !1, t.worldMatrix), this._uClippable && s.uniform1i(this._uClippable, t._state.clippable), s.uniform3fv(this._uOffset, t._state.offset), this._uPositionsDecodeMatrix ? (s.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, n.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(u, n.compressGeometry ? s.UNSIGNED_SHORT : s.FLOAT)) : this._aPosition.bindArrayBuffer(u), o.bind(), s.enableVertexAttribArray(this._aColor.location), s.vertexAttribPointer(this._aColor.location, o.itemSize, o.itemType, !0, 0, 0), s.drawArrays(n.primitive, 0, u.numItems / 3) }, PickTriangleRenderer.prototype._allocate = function (e) { var t = (e = e.scene).canvas.gl; if (this._program = new Program(t, this._shaderSource), this._useCount = 0, this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uModelMatrix = i.getLocation("modelMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aColor = i.getAttribute("color"), this._uClippable = i.getLocation("clippable"), this._uOffset = i.getLocation("offset"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } }; class OcclusionShaderSource { constructor(e) { this.vertex = buildVertex$1(e), this.fragment = buildFragment$1(e) } } function buildVertex$1(e) { var t = e.scene, i = 0 < t._sectionPlanesState.sectionPlanes.length, s = !!e._geometry._state.compressGeometry, r = e._state.billboard, a = (e = e._state.stationary, []); return a.push("#version 300 es"), a.push("// Mesh occlusion vertex shader"), a.push("in vec3 position;"), a.push("uniform mat4 modelMatrix;"), a.push("uniform mat4 viewMatrix;"), a.push("uniform mat4 projMatrix;"), a.push("uniform vec3 offset;"), s && a.push("uniform mat4 positionsDecodeMatrix;"), i && a.push("out vec4 vWorldPosition;"), t.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("out float vFragDepth;"), a.push("bool isPerspectiveMatrix(mat4 m) {"), a.push("    return (m[2][3] == - 1.0);"), a.push("}"), a.push("out float isPerspective;")), "spherical" !== r && "cylindrical" !== r || (a.push("void billboard(inout mat4 mat) {"), a.push("   mat[0][0] = 1.0;"), a.push("   mat[0][1] = 0.0;"), a.push("   mat[0][2] = 0.0;"), "spherical" === r && (a.push("   mat[1][0] = 0.0;"), a.push("   mat[1][1] = 1.0;"), a.push("   mat[1][2] = 0.0;")), a.push("   mat[2][0] = 0.0;"), a.push("   mat[2][1] = 0.0;"), a.push("   mat[2][2] =1.0;"), a.push("}")), a.push("void main(void) {"), a.push("vec4 localPosition = vec4(position, 1.0); "), a.push("vec4 worldPosition;"), s && a.push("localPosition = positionsDecodeMatrix * localPosition;"), a.push("mat4 viewMatrix2 = viewMatrix;"), a.push("mat4 modelMatrix2 = modelMatrix;"), e && a.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;"), "spherical" === r || "cylindrical" === r ? (a.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;"), a.push("billboard(modelMatrix2);"), a.push("billboard(viewMatrix2);"), a.push("billboard(modelViewMatrix);"), a.push("worldPosition = modelMatrix2 * localPosition;"), a.push("worldPosition.xyz = worldPosition.xyz + offset;"), a.push("vec4 viewPosition = modelViewMatrix * localPosition;")) : (a.push("worldPosition = modelMatrix2 * localPosition;"), a.push("worldPosition.xyz = worldPosition.xyz + offset;"), a.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")), i && a.push("   vWorldPosition = worldPosition;"), a.push("vec4 clipPos = projMatrix * viewPosition;"), t.logarithmicDepthBufferEnabled && (a.push("vFragDepth = 1.0 + clipPos.w;"), a.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), a.push("gl_Position = clipPos;"), a.push("}"), a } function buildFragment$1(e) { var t = (e = e.scene)._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Mesh occlusion fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("uniform bool clippable;"), s.push("in vec4 vWorldPosition;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("if (clippable) {"), s.push("  float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("if (sectionPlaneActive" + r + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); "), e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } const tempVec3a$Z = math.vec3(), OcclusionRenderer = function (e, t) { this._hash = e, this._shaderSource = new OcclusionShaderSource(t), this._scene = t.scene, this._useCount = 0, this._allocate(t) }, renderers$1 = {}; OcclusionRenderer.get = function (e) { var t = [e.scene.canvas.canvas.id, e.scene._sectionPlanesState.getHash(), e._geometry._state.hash, e._state.occlusionHash].join(";"); let i = renderers$1[t]; if (!i) { if ((i = new OcclusionRenderer(t, e)).errors) return console.log(i.errors.join("\n")), null; renderers$1[t] = i, stats.memory.programs++ } return i._useCount++, i }, OcclusionRenderer.prototype.put = function () { 0 == --this._useCount && (this._program && this._program.destroy(), delete renderers$1[this._hash], stats.memory.programs--) }, OcclusionRenderer.prototype.webglContextRestored = function () { this._program = null }, OcclusionRenderer.prototype.drawMesh = function (e, t) { this._program || this._allocate(t); var i = this._scene, s = i.canvas.gl, r = t._material._state, a = t._state, o = t._geometry._state, n = t.origin, h = (e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), r.id !== this._lastMaterialId && (h = r.backfaces, e.backfaces !== h && (h ? s.disable(s.CULL_FACE) : s.enable(s.CULL_FACE), e.backfaces = h), h = r.frontface, e.frontface !== h && (h ? s.frontFace(s.CCW) : s.frontFace(s.CW), e.frontface = h), this._lastMaterialId = r.id), i.camera); if (s.uniformMatrix4fv(this._uViewMatrix, !1, n ? e.getRTCViewMatrix(a.originHash, n) : h.viewMatrix), a.clippable) { var l = i._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = i._sectionPlanesState.sectionPlanes, u = t.renderFlags; for (let e = 0; e < l; e++) { var p, d = this._uSectionPlanes[e]; d && (p = u.sectionPlanesActivePerLayer[e], s.uniform1i(d.active, p ? 1 : 0), p) && (p = c[e], s.uniform3fv(d.pos, n ? getPlaneRTCPos(p.dist, p.dir, n, tempVec3a$Z) : p.pos), s.uniform3fv(d.dir, p.dir)) } } } s.uniformMatrix4fv(this._uProjMatrix, !1, h._project._state.matrix), s.uniformMatrix4fv(this._uModelMatrix, s.FALSE, t.worldMatrix), this._uClippable && s.uniform1i(this._uClippable, t._state.clippable), s.uniform3fv(this._uOffset, t._state.offset), o.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && s.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, o.positionsDecodeMatrix), this._aPosition && (this._aPosition.bindArrayBuffer(o.positionsBuf, o.compressGeometry ? s.UNSIGNED_SHORT : s.FLOAT), e.bindArray++), o.indicesBuf && (o.indicesBuf.bind(), e.bindArray++), this._lastGeometryId = o.id), o.indicesBuf ? (s.drawElements(o.primitive, o.indicesBuf.numItems, o.indicesBuf.itemType, 0), e.drawElements++) : o.positions && s.drawArrays(s.TRIANGLES, 0, o.positions.numItems) }, OcclusionRenderer.prototype._allocate = function (e) { var t = (e = e.scene).canvas.gl; if (this._program = new Program(t, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uModelMatrix = i.getLocation("modelMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._uClippable = i.getLocation("clippable"), this._uOffset = i.getLocation("offset"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null } }, OcclusionRenderer.prototype._bindProgram = function (e) { var t = this._scene, i = t.camera.project, s = t.canvas.gl; this._program.bind(), e.useProgram++, s.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), t.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), s.uniform1f(this._uLogDepthBufFC, e)), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null }; class ShadowShaderSource { constructor(e) { this.vertex = buildVertex(e), this.fragment = buildFragment(e) } } function buildVertex(e) { var t = 0 < e.scene._sectionPlanesState.sectionPlanes.length, i = (e = !!e._geometry._state.compressGeometry, []); return i.push("// Mesh shadow vertex shader"), i.push("in vec3 position;"), i.push("uniform mat4 modelMatrix;"), i.push("uniform mat4 shadowViewMatrix;"), i.push("uniform mat4 shadowProjMatrix;"), i.push("uniform vec3 offset;"), e && i.push("uniform mat4 positionsDecodeMatrix;"), t && i.push("out vec4 vWorldPosition;"), i.push("void main(void) {"), i.push("vec4 localPosition = vec4(position, 1.0); "), i.push("vec4 worldPosition;"), e && i.push("localPosition = positionsDecodeMatrix * localPosition;"), i.push("worldPosition = modelMatrix * localPosition;"), i.push("worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = shadowViewMatrix * worldPosition; "), t && i.push("vWorldPosition = worldPosition;"), i.push("   gl_Position = shadowProjMatrix * viewPosition;"), i.push("}"), i } function buildFragment(e) { (e = e.scene).canvas.gl; var t = e._sectionPlanesState, i = (e = 0 < t.sectionPlanes.length, []); if (i.push("// Mesh shadow fragment shader"), i.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), i.push("precision highp float;"), i.push("precision highp int;"), i.push("#else"), i.push("precision mediump float;"), i.push("precision mediump int;"), i.push("#endif"), e) { i.push("uniform bool clippable;"), i.push("in vec4 vWorldPosition;"); for (var s = 0; s < t.sectionPlanes.length; s++)i.push("uniform bool sectionPlaneActive" + s + ";"), i.push("uniform vec3 sectionPlanePos" + s + ";"), i.push("uniform vec3 sectionPlaneDir" + s + ";") } if (i.push("vec4 encodeFloat( const in float depth ) {"), i.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);"), i.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);"), i.push("  vec4 comp = fract(depth * bitShift);"), i.push("  comp -= comp.xxyz * bitMask;"), i.push("  return comp;"), i.push("}"), i.push("out vec4 outColor;"), i.push("void main(void) {"), e) { for (i.push("if (clippable) {"), i.push("  float dist = 0.0;"), s = 0; s < t.sectionPlanes.length; s++)i.push("if (sectionPlaneActive" + s + ") {"), i.push("   dist += clamp(dot(-sectionPlaneDir" + s + ".xyz, vWorldPosition.xyz - sectionPlanePos" + s + ".xyz), 0.0, 1000.0);"), i.push("}"); i.push("  if (dist > 0.0) { discard; }"), i.push("}") } return i.push("outColor = encodeFloat(gl_FragCoord.z);"), i.push("}"), i } const ShadowRenderer = function (e, t) { this._hash = e, this._shaderSource = new ShadowShaderSource(t), this._scene = t.scene, this._useCount = 0, this._allocate(t) }, renderers = {}; ShadowRenderer.get = function (e) { var t = [(t = e.scene).canvas.canvas.id, t._sectionPlanesState.getHash(), e._geometry._state.hash, e._state.hash].join(";"); let i = renderers[t]; if (!i) { if ((i = new ShadowRenderer(t, e)).errors) return console.log(i.errors.join("\n")), null; renderers[t] = i, stats.memory.programs++ } return i._useCount++, i }, ShadowRenderer.prototype.put = function () { 0 == --this._useCount && (this._program && this._program.destroy(), delete renderers[this._hash], stats.memory.programs--) }, ShadowRenderer.prototype.webglContextRestored = function () { this._program = null }, ShadowRenderer.prototype.drawMesh = function (e, t) { this._program || this._allocate(t); var i, s = this._scene.canvas.gl, r = t._material._state, a = t._geometry._state; e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), r.id !== this._lastMaterialId && (i = r.backfaces, e.backfaces !== i && (i ? s.disable(s.CULL_FACE) : s.enable(s.CULL_FACE), e.backfaces = i), i = r.frontface, e.frontface !== i && (i ? s.frontFace(s.CCW) : s.frontFace(s.CW), e.frontface = i), e.lineWidth !== r.lineWidth && (s.lineWidth(r.lineWidth), e.lineWidth = r.lineWidth), this._uPointSize && s.uniform1i(this._uPointSize, r.pointSize), this._lastMaterialId = r.id), s.uniformMatrix4fv(this._uModelMatrix, s.FALSE, t.worldMatrix), a.combineGeometry && (i = t.vertexBufs).id !== this._lastVertexBufsId && (i.positionsBuf && this._aPosition && (this._aPosition.bindArrayBuffer(i.positionsBuf, i.compressGeometry ? s.UNSIGNED_SHORT : s.FLOAT), e.bindArray++), this._lastVertexBufsId = i.id), this._uClippable && s.uniform1i(this._uClippable, t._state.clippable), s.uniform3fv(this._uOffset, t._state.offset), a.id !== this._lastGeometryId && (this._uPositionsDecodeMatrix && s.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, a.positionsDecodeMatrix), a.combineGeometry ? a.indicesBufCombined && (a.indicesBufCombined.bind(), e.bindArray++) : (this._aPosition && (this._aPosition.bindArrayBuffer(a.positionsBuf, a.compressGeometry ? s.UNSIGNED_SHORT : s.FLOAT), e.bindArray++), a.indicesBuf && (a.indicesBuf.bind(), e.bindArray++)), this._lastGeometryId = a.id), a.combineGeometry ? a.indicesBufCombined && (s.drawElements(a.primitive, a.indicesBufCombined.numItems, a.indicesBufCombined.itemType, 0), e.drawElements++) : a.indicesBuf ? (s.drawElements(a.primitive, a.indicesBuf.numItems, a.indicesBuf.itemType, 0), e.drawElements++) : a.positions && (s.drawArrays(s.TRIANGLES, 0, a.positions.numItems), e.drawArrays++) }, ShadowRenderer.prototype._allocate = function (e) { var t = (e = e.scene).canvas.gl; if (this._program = new Program(t, this._shaderSource), this._scene = e, this._useCount = 0, this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uModelMatrix = i.getLocation("modelMatrix"), this._uShadowViewMatrix = i.getLocation("shadowViewMatrix"), this._uShadowProjMatrix = i.getLocation("shadowProjMatrix"), this._uSectionPlanes = {}; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._uClippable = i.getLocation("clippable"), this._uOffset = i.getLocation("offset"), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null } }, ShadowRenderer.prototype._bindProgram = function (e) { this._program || this._allocate(mesh); var t, i, s, r = this._scene, a = r.canvas.gl, o = r._sectionPlanesState; if (this._program.bind(), e.useProgram++, a.uniformMatrix4fv(this._uShadowViewMatrix, !1, e.shadowViewMatrix), a.uniformMatrix4fv(this._uShadowProjMatrix, !1, e.shadowProjMatrix), this._lastMaterialId = null, this._lastVertexBufsId = null, this._lastGeometryId = null, 0 < o.sectionPlanes.length) for (let e = 0, r = this._uSectionPlanes.length; e < r; e++)i = (t = this._uSectionPlanes[e]).active, s = o.sectionPlanes[e], i && a.uniform1i(i, s.active), t.pos && a.uniform3fv(t.pos, s.pos), t.dir && a.uniform3fv(t.dir, s.dir) }; class RenderFlags { constructor() { this.visibleLayers = [], this.sectionPlanesActivePerLayer = [], this.reset() } reset() { this.culled = !1, this.sectioned = !1, this.numLayers = 0, this.numVisibleLayers = 0, this.colorOpaque = !1, this.colorTransparent = !1, this.edgesOpaque = !1, this.edgesTransparent = !1, this.xrayedSilhouetteOpaque = !1, this.xrayedEdgesOpaque = !1, this.xrayedSilhouetteTransparent = !1, this.xrayedEdgesTransparent = !1, this.highlightedSilhouetteOpaque = !1, this.highlightedEdgesOpaque = !1, this.highlightedSilhouetteTransparent = !1, this.highlightedEdgesTransparent = !1, this.selectedSilhouetteOpaque = !1, this.selectedEdgesOpaque = !1, this.selectedSilhouetteTransparent = !1, this.selectedEdgesTransparent = !1 } } const obb = math.OBB3(), angleAxis = math.vec4(), q1 = math.vec4(), q2 = math.vec4(), xAxis = math.vec3([1, 0, 0]), yAxis = math.vec3([0, 1, 0]), zAxis = math.vec3([0, 0, 1]), veca = math.vec3(3), vecb = math.vec3(3), identityMat = math.identityMat4(); class Mesh extends Component { constructor(e, t = {}) { super(e, t), this.originalSystemId = t.originalSystemId || this.id, this.renderFlags = new RenderFlags, this._state = new RenderState({ visible: !0, culled: !1, pickable: null, clippable: null, collidable: null, occluder: !1 !== t.occluder, castsShadow: null, receivesShadow: null, xrayed: !1, highlighted: !1, selected: !1, edges: !1, stationary: !!t.stationary, background: !!t.background, billboard: this._checkBillboard(t.billboard), layer: null, colorize: null, pickID: this.scene._renderer.getPickID(this), drawHash: "", pickHash: "", offset: math.vec3(), origin: null, originHash: null }), this._drawRenderer = null, this._shadowRenderer = null, this._emphasisFillRenderer = null, this._emphasisEdgesRenderer = null, this._pickMeshRenderer = null, this._pickTriangleRenderer = null, this._occlusionRenderer = null, this._geometry = t.geometry ? this._checkComponent2(["ReadableGeometry", "VBOGeometry"], t.geometry) : this.scene.geometry, this._material = t.material ? this._checkComponent2(["PhongMaterial", "MetallicMaterial", "SpecularMaterial", "LambertMaterial"], t.material) : this.scene.material, this._xrayMaterial = t.xrayMaterial ? this._checkComponent("EmphasisMaterial", t.xrayMaterial) : this.scene.xrayMaterial, this._highlightMaterial = t.highlightMaterial ? this._checkComponent("EmphasisMaterial", t.highlightMaterial) : this.scene.highlightMaterial, this._selectedMaterial = t.selectedMaterial ? this._checkComponent("EmphasisMaterial", t.selectedMaterial) : this.scene.selectedMaterial, this._edgeMaterial = t.edgeMaterial ? this._checkComponent("EdgeMaterial", t.edgeMaterial) : this.scene.edgeMaterial, this._parentNode = null, this._aabb = null, this._aabbDirty = !0, this._numTriangles = this._geometry ? this._geometry.numTriangles : 0, this.scene._aabbDirty = !0, this._scale = math.vec3(), this._quaternion = math.identityQuaternion(), this._rotation = math.vec3(), this._position = math.vec3(), this._worldMatrix = math.identityMat4(), this._worldNormalMatrix = math.identityMat4(), this._localMatrixDirty = !0, this._worldMatrixDirty = !0, this._worldNormalMatrixDirty = !0, (e = t.origin || t.rtcCenter) && (this._state.origin = math.vec3(e), this._state.originHash = e.join()), t.matrix ? this.matrix = t.matrix : (this.scale = t.scale, this.position = t.position, t.quaternion || (this.rotation = t.rotation)), this._isObject = t.isObject, this._isObject && this.scene._registerObject(this), this._isModel = t.isModel, this._isModel && this.scene._registerModel(this), this.visible = t.visible, this.culled = t.culled, this.pickable = t.pickable, this.clippable = t.clippable, this.collidable = t.collidable, this.castsShadow = t.castsShadow, this.receivesShadow = t.receivesShadow, this.xrayed = t.xrayed, this.highlighted = t.highlighted, this.selected = t.selected, this.edges = t.edges, this.layer = t.layer, this.colorize = t.colorize, this.opacity = t.opacity, this.offset = t.offset, t.parentId ? ((e = this.scene.components[t.parentId]) ? e.isNode ? e.addChild(this) : this.error("Parent is not a Node: '" + t.parentId + "'") : this.error("Parent not found: '" + t.parentId + "'"), this._parentNode = e) : t.parent && (t.parent.isNode || this.error("Parent is not a Node"), t.parent.addChild(this), this._parentNode = t.parent), this.compile() } get type() { return "Mesh" } get isMesh() { return !0 } get parent() { return this._parentNode } get geometry() { return this._geometry } get material() { return this._material } get position() { return this._position } set position(e) { this._position.set(e || [0, 0, 0]), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get rotation() { return this._rotation } set rotation(e) { this._rotation.set(e || [0, 0, 0]), math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get quaternion() { return this._quaternion } set quaternion(e) { this._quaternion.set(e || [0, 0, 0, 1]), math.quaternionToEuler(this._quaternion, "XYZ", this._rotation), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get scale() { return this._scale } set scale(e) { this._scale.set(e || [1, 1, 1]), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get matrix() { return this._localMatrixDirty && (this.__localMatrix || (this.__localMatrix = math.identityMat4()), math.composeMat4(this._position, this._quaternion, this._scale, this.__localMatrix), this._localMatrixDirty = !1), this.__localMatrix } set matrix(e) { this.__localMatrix || (this.__localMatrix = math.identityMat4()), this.__localMatrix.set(e || identityMat), math.decomposeMat4(this.__localMatrix, this._position, this._quaternion, this._scale), this._localMatrixDirty = !1, this._setWorldMatrixDirty(), this._setAABBDirty(), this.glRedraw() } get worldMatrix() { return this._worldMatrixDirty && this._buildWorldMatrix(), this._worldMatrix } get worldNormalMatrix() { return this._worldNormalMatrixDirty && this._buildWorldNormalMatrix(), this._worldNormalMatrix } get isEntity() { return !0 } get isModel() { return this._isModel } get isObject() { return this._isObject } get aabb() { return this._aabbDirty && this._updateAABB(), this._aabb } get origin() { return this._state.origin } set origin(e) { e ? (this._state.origin || (this._state.origin = math.vec3()), this._state.origin.set(e), this._state.originHash = e.join(), this._setAABBDirty(), this.scene._aabbDirty = !0) : this._state.origin && (this._state.origin = null, this._state.originHash = null, this._setAABBDirty(), this.scene._aabbDirty = !0) } get rtcCenter() { return this.origin } set rtcCenter(e) { this.origin = e } get numTriangles() { return this._numTriangles } get visible() { return this._state.visible } set visible(e) { this._state.visible = e = !1 !== e, this._isObject && this.scene._objectVisibilityUpdated(this), this.glRedraw() } get xrayed() { return this._state.xrayed } set xrayed(e) { this._state.xrayed !== (e = !!e) && (this._state.xrayed = e, this._isObject && this.scene._objectXRayedUpdated(this), this.glRedraw()) } get highlighted() { return this._state.highlighted } set highlighted(e) { (e = !!e) !== this._state.highlighted && (this._state.highlighted = e, this._isObject && this.scene._objectHighlightedUpdated(this), this.glRedraw()) } get selected() { return this._state.selected } set selected(e) { (e = !!e) !== this._state.selected && (this._state.selected = e, this._isObject && this.scene._objectSelectedUpdated(this), this.glRedraw()) } get edges() { return this._state.edges } set edges(e) { (e = !!e) !== this._state.edges && (this._state.edges = e, this.glRedraw()) } get culled() { return this._state.culled } set culled(e) { this._state.culled = !!e, this.glRedraw() } get clippable() { return this._state.clippable } set clippable(e) { this._state.clippable !== (e = !1 !== e) && (this._state.clippable = e, this.glRedraw()) } get collidable() { return this._state.collidable } set collidable(e) { (e = !1 !== e) !== this._state.collidable && (this._state.collidable = e, this._setAABBDirty(), this.scene._aabbDirty = !0) } get pickable() { return this._state.pickable } set pickable(e) { this._state.pickable !== (e = !1 !== e) && (this._state.pickable = e) } get castsShadow() { return this._state.castsShadow } set castsShadow(e) { (e = !1 !== e) !== this._state.castsShadow && (this._state.castsShadow = e, this.glRedraw()) } get receivesShadow() { return this._state.receivesShadow } set receivesShadow(e) { (e = !1 !== e) !== this._state.receivesShadow && (this._state.receivesShadow = e, this._state.hash = e ? "/mod/rs;" : "/mod;", this.fire("dirty", this)) } get saoEnabled() { return !1 } get colorize() { return this._state.colorize } set colorize(e) { let t = this._state.colorize; t || ((t = this._state.colorize = new Float32Array(4))[3] = 1), e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.scene._objectColorizeUpdated(this, !!e), this.glRedraw() } get opacity() { return this._state.colorize[3] } set opacity(e) { let t = this._state.colorize; t || ((t = this._state.colorize = new Float32Array(4))[0] = 1, t[1] = 1, t[2] = 1); var i = null != e; t[3] = i ? e : 1, this.scene._objectOpacityUpdated(this, i), this.glRedraw() } get transparent() { return 2 === this._material.alphaMode || this._state.colorize[3] < 1 } get layer() { return this._state.layer } set layer(e) { e = e || 0, (e = Math.round(e)) !== this._state.layer && (this._state.layer = e, this._renderer.needStateSort()) } get stationary() { return this._state.stationary } get billboard() { return this._state.billboard } get offset() { return this._state.offset } set offset(e) { this._state.offset.set(e || [0, 0, 0]), this._setAABBDirty(), this.glRedraw() } get isDrawable() { return !0 } get isStateSortable() { return !0 } get xrayMaterial() { return this._xrayMaterial } get highlightMaterial() { return this._highlightMaterial } get selectedMaterial() { return this._selectedMaterial } get edgeMaterial() { return this._edgeMaterial } _checkBillboard(e) { return "spherical" !== (e = e || "none") && "cylindrical" !== e && "none" !== e && (this.error("Unsupported value for 'billboard': " + e + " - accepted values are 'spherical', 'cylindrical' and 'none' - defaulting to 'none'."), e = "none"), e } compile() { var e = this._makeDrawHash(); this._state.drawHash !== e && (this._state.drawHash = e, this._putDrawRenderers(), this._drawRenderer = DrawRenderer.get(this), this._emphasisFillRenderer = EmphasisFillRenderer.get(this), this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this)), e = this._makePickHash(); this._state.pickHash !== e && (this._state.pickHash = e, this._putPickRenderers(), this._pickMeshRenderer = PickMeshRenderer.get(this)), this._state.occluder && (e = this._makeOcclusionHash(), this._state.occlusionHash !== e) && (this._state.occlusionHash = e, this._putOcclusionRenderer(), this._occlusionRenderer = OcclusionRenderer.get(this)) } _setLocalMatrixDirty() { this._localMatrixDirty = !0, this._setWorldMatrixDirty() } _setWorldMatrixDirty() { this._worldMatrixDirty = !0, this._worldNormalMatrixDirty = !0 } _buildWorldMatrix() { var e = this.matrix; if (this._parentNode) math.mulMat4(this._parentNode.worldMatrix, e, this._worldMatrix); else for (let t = 0, i = e.length; t < i; t++)this._worldMatrix[t] = e[t]; this._worldMatrixDirty = !1 } _buildWorldNormalMatrix() { this._worldMatrixDirty && this._buildWorldMatrix(), this._worldNormalMatrix || (this._worldNormalMatrix = math.mat4()), math.transposeMat4(this._worldMatrix, this._worldNormalMatrix), math.inverseMat4(this._worldNormalMatrix), this._worldNormalMatrixDirty = !1 } _setAABBDirty() { if (this.collidable) for (let e = this; e; e = e._parentNode)e._aabbDirty = !0 } _updateAABB() { this.scene._aabbDirty = !0, this._aabb || (this._aabb = math.AABB3()), this._buildAABB(this.worldMatrix, this._aabb), this._aabbDirty = !1 } _webglContextRestored() { this._drawRenderer && this._drawRenderer.webglContextRestored(), this._shadowRenderer && this._shadowRenderer.webglContextRestored(), this._emphasisFillRenderer && this._emphasisFillRenderer.webglContextRestored(), this._emphasisEdgesRenderer && this._emphasisEdgesRenderer.webglContextRestored(), this._pickMeshRenderer && this._pickMeshRenderer.webglContextRestored(), this._pickTriangleRenderer && this._pickMeshRenderer.webglContextRestored(), this._occlusionRenderer && this._occlusionRenderer.webglContextRestored() } _makeDrawHash() { var e = [(e = this.scene).canvas.canvas.id, (e.gammaInput ? "gi;" : ";") + (e.gammaOutput ? "go" : ""), e._lightsState.getHash(), e._sectionPlanesState.getHash()], t = this._state; return t.stationary && e.push("/s"), "none" === t.billboard ? e.push("/n") : "spherical" === t.billboard ? e.push("/s") : "cylindrical" === t.billboard && e.push("/c"), t.receivesShadow && e.push("/rs"), e.push(";"), e.join("") } _makePickHash() { var e = [(e = this.scene).canvas.canvas.id, e._sectionPlanesState.getHash()], t = this._state; return t.stationary && e.push("/s"), "none" === t.billboard ? e.push("/n") : "spherical" === t.billboard ? e.push("/s") : "cylindrical" === t.billboard && e.push("/c"), e.push(";"), e.join("") } _makeOcclusionHash() { var e = [(e = this.scene).canvas.canvas.id, e._sectionPlanesState.getHash()], t = this._state; return t.stationary && e.push("/s"), "none" === t.billboard ? e.push("/n") : "spherical" === t.billboard ? e.push("/s") : "cylindrical" === t.billboard && e.push("/c"), e.push(";"), e.join("") } _buildAABB(e, t) { math.transformOBB3(e, this._geometry.obb, obb), math.OBB3ToAABB3(obb, t), e = this._state.offset, t[0] += e[0], t[1] += e[1], t[2] += e[2], t[3] += e[0], t[4] += e[1], t[5] += e[2], this._state.origin && (e = this._state.origin, t[0] += e[0], t[1] += e[1], t[2] += e[2], t[3] += e[0], t[4] += e[1], t[5] += e[2]) } rotate(e, t) { return angleAxis[0] = e[0], angleAxis[1] = e[1], angleAxis[2] = e[2], angleAxis[3] = t * math.DEGTORAD, math.angleAxisToQuaternion(angleAxis, q1), math.mulQuaternions(this.quaternion, q1, q2), this.quaternion = q2, this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw(), this } rotateOnWorldAxis(e, t) { return angleAxis[0] = e[0], angleAxis[1] = e[1], angleAxis[2] = e[2], angleAxis[3] = t * math.DEGTORAD, math.angleAxisToQuaternion(angleAxis, q1), math.mulQuaternions(q1, this.quaternion, q1), this } rotateX(e) { return this.rotate(xAxis, e) } rotateY(e) { return this.rotate(yAxis, e) } rotateZ(e) { return this.rotate(zAxis, e) } translate(e, t) { return math.vec3ApplyQuaternion(this.quaternion, e, veca), math.mulVec3Scalar(veca, t, vecb), math.addVec3(this.position, vecb, this.position), this._setLocalMatrixDirty(), this._setAABBDirty(), this.glRedraw(), this } translateX(e) { return this.translate(xAxis, e) } translateY(e) { return this.translate(yAxis, e) } translateZ(e) { return this.translate(zAxis, e) } _putDrawRenderers() { this._drawRenderer && (this._drawRenderer.put(), this._drawRenderer = null), this._shadowRenderer && (this._shadowRenderer.put(), this._shadowRenderer = null), this._emphasisFillRenderer && (this._emphasisFillRenderer.put(), this._emphasisFillRenderer = null), this._emphasisEdgesRenderer && (this._emphasisEdgesRenderer.put(), this._emphasisEdgesRenderer = null) } _putPickRenderers() { this._pickMeshRenderer && (this._pickMeshRenderer.put(), this._pickMeshRenderer = null), this._pickTriangleRenderer && (this._pickTriangleRenderer.put(), this._pickTriangleRenderer = null) } _putOcclusionRenderer() { this._occlusionRenderer && (this._occlusionRenderer.put(), this._occlusionRenderer = null) } stateSortCompare(e, t) { return e._state.layer - t._state.layer || e._drawRenderer.id - t._drawRenderer.id || e._material._state.id - t._material._state.id || e._geometry._state.id - t._geometry._state.id } rebuildRenderFlags() { this.renderFlags.reset(), this._getActiveSectionPlanes() ? (this.renderFlags.numLayers = 1, this.renderFlags.numVisibleLayers = 1, this.renderFlags.visibleLayers[0] = 0, this._updateRenderFlags()) : this.renderFlags.culled = !0 } _updateRenderFlags() { var e, t = this.renderFlags, i = this._state; i.xrayed ? ((e = this._xrayMaterial._state).fill && (e.fillAlpha < 1 ? t.xrayedSilhouetteTransparent = !0 : t.xrayedSilhouetteOpaque = !0), e.edges && (e.edgeAlpha < 1 ? t.xrayedEdgesTransparent = !0 : t.xrayedEdgesOpaque = !0)) : (this._material._state.alpha < 1 || i.colorize[3] < 1 ? t.colorTransparent = !0 : t.colorOpaque = !0, i.edges && (this._edgeMaterial._state.alpha < 1 ? t.edgesTransparent = !0 : t.edgesOpaque = !0), i.selected ? ((e = this._selectedMaterial._state).fill && (e.fillAlpha < 1 ? t.selectedSilhouetteTransparent = !0 : t.selectedSilhouetteOpaque = !0), e.edges && (e.edgeAlpha < 1 ? t.selectedEdgesTransparent = !0 : t.selectedEdgesOpaque = !0)) : i.highlighted && ((e = this._highlightMaterial._state).fill && (e.fillAlpha < 1 ? t.highlightedSilhouetteTransparent = !0 : t.highlightedSilhouetteOpaque = !0), e.edges) && (e.edgeAlpha < 1 ? t.highlightedEdgesTransparent = !0 : t.highlightedEdgesOpaque = !0)) } _getActiveSectionPlanes() { if (this._state.clippable) { var e = this.scene._sectionPlanesState.sectionPlanes, t = e.length; if (0 < t) for (let r = 0; r < t; r++) { var i = e[r], s = this.renderFlags; if (i.active) if (this._state.origin) { if (-1 === (i = math.planeAABB3Intersect(i.dir, i.dist, this.aabb))) return !1; s.sectionPlanesActivePerLayer[r] = 0 === i } else s.sectionPlanesActivePerLayer[r] = !0; else s.sectionPlanesActivePerLayer[r] = !1 } } return !0 } drawColorOpaque(e) { (this._drawRenderer || (this._drawRenderer = DrawRenderer.get(this))) && this._drawRenderer.drawMesh(e, this) } drawColorTransparent(e) { (this._drawRenderer || (this._drawRenderer = DrawRenderer.get(this))) && this._drawRenderer.drawMesh(e, this) } drawSilhouetteXRayed(e) { (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) && this._emphasisFillRenderer.drawMesh(e, this, 0) } drawSilhouetteHighlighted(e) { (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) && this._emphasisFillRenderer.drawMesh(e, this, 1) } drawSilhouetteSelected(e) { (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) && this._emphasisFillRenderer.drawMesh(e, this, 2) } drawEdgesColorOpaque(e) { (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) && this._emphasisEdgesRenderer.drawMesh(e, this, 3) } drawEdgesColorTransparent(e) { (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) && this._emphasisEdgesRenderer.drawMesh(e, this, 3) } drawEdgesXRayed(e) { (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) && this._emphasisEdgesRenderer.drawMesh(e, this, 0) } drawEdgesHighlighted(e) { (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) && this._emphasisEdgesRenderer.drawMesh(e, this, 1) } drawEdgesSelected(e) { (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) && this._emphasisEdgesRenderer.drawMesh(e, this, 2) } drawOcclusion(e) { (this._state.occluder && this._occlusionRenderer || (this._occlusionRenderer = OcclusionRenderer.get(this))) && this._occlusionRenderer.drawMesh(e, this) } drawShadow(e) { (this._shadowRenderer || (this._shadowRenderer = ShadowRenderer.get(this))) && this._shadowRenderer.drawMesh(e, this) } drawPickMesh(e) { (this._pickMeshRenderer || (this._pickMeshRenderer = PickMeshRenderer.get(this))) && this._pickMeshRenderer.drawMesh(e, this) } canPickTriangle() { return this._geometry.isReadableGeometry } drawPickTriangles(e) { (this._pickTriangleRenderer || (this._pickTriangleRenderer = PickTriangleRenderer.get(this))) && this._pickTriangleRenderer.drawMesh(e, this) } pickTriangleSurface(e, t, i) { pickTriangleSurface(this, e, t, i) } drawPickVertices(e) { } delegatePickedEntity() { return this } destroy() { super.destroy(), this._putDrawRenderers(), this._putPickRenderers(), this._putOcclusionRenderer(), this.scene._renderer.putPickID(this._state.pickID), this._isObject && (this.scene._deregisterObject(this), this._visible && this.scene._objectVisibilityUpdated(this, !1), this._xrayed && this.scene._objectXRayedUpdated(this, !1), this._selected && this.scene._objectSelectedUpdated(this, !1), this._highlighted && this.scene._objectHighlightedUpdated(this, !1), this.scene._objectColorizeUpdated(this, !1), this.scene._objectOpacityUpdated(this, !1), this.scene._objectOffsetUpdated(this, !1)), this._isModel && this.scene._deregisterModel(this), this.glRedraw() } } const pickTriangleSurface = function () { const e = math.vec3(), t = math.vec3(), i = math.vec3(), s = math.vec3(), r = math.vec3(), a = math.vec3(), o = math.vec4(), n = math.vec3(), h = math.vec3(), l = math.vec3(), c = math.vec3(), u = math.vec3(), p = math.vec3(), d = math.vec3(), m = math.vec3(), f = math.vec3(), g = math.vec4(), _ = math.vec4(), v = math.vec4(), y = math.vec3(), T = math.vec3(), I = math.vec3(), E = math.vec3(), C = math.vec3(), P = math.vec3(), b = math.vec3(), A = math.vec3(), D = math.vec3(), R = math.vec3(), F = math.vec3(); return function (w, M, S, x) { var L = x.primIndex; if (null != L && -1 < L) { var O = w.geometry._state, N = (B = w.scene).camera, B = B.canvas; if ("triangles" === O.primitiveName) { x.primitive = "triangle"; var G, U, k, V = O.indices, H = O.positions; let j, z, W; W = V ? (G = V[L + 0], U = V[L + 1], k = V[L + 2], a[0] = G, a[1] = U, a[2] = k, x.indices = a, j = 3 * G, z = 3 * U, 3 * k) : (j = 3 * L, (z = j + 3) + 3), i[0] = H[j + 0], i[1] = H[j + 1], i[2] = H[j + 2], s[0] = H[z + 0], s[1] = H[z + 1], s[2] = H[z + 2], r[0] = H[W + 0], r[1] = H[W + 1], r[2] = H[W + 2], O.compressGeometry && (V = O.positionsDecodeMatrix) && (geometryCompressionUtils.decompressPosition(i, V, i), geometryCompressionUtils.decompressPosition(s, V, s), geometryCompressionUtils.decompressPosition(r, V, r)), x.canvasPos ? (L = x.canvasPos, math.canvasPosToLocalRay(B.canvas, M, S, w.worldMatrix, L, e, t)) : x.origin && x.direction && math.worldRayToLocalRay(w.worldMatrix, x.origin, x.direction, e, t), math.normalizeVec3(t), math.rayPlaneIntersect(e, t, i, s, r, o), x.localPos = o, x.position = o, g[0] = o[0], g[1] = o[1], g[2] = o[2], g[3] = 1, math.transformVec4(w.worldMatrix, g, _), n[0] = _[0], n[1] = _[1], n[2] = _[2], x.worldPos = n, math.transformVec4(N.matrix, _, v), h[0] = v[0], h[1] = v[1], h[2] = v[2], x.viewPos = h, math.cartesianToBarycentric(o, i, s, r, l), x.bary = l, (H = O.normals) && (O.compressGeometry ? (V = 3 * G, B = 3 * U, M = 3 * k, geometryCompressionUtils.decompressNormal(H.subarray(V, 2 + V), c), geometryCompressionUtils.decompressNormal(H.subarray(B, 2 + B), u), geometryCompressionUtils.decompressNormal(H.subarray(M, 2 + M), p)) : (c[0] = H[j], c[1] = H[j + 1], c[2] = H[j + 2], u[0] = H[z], u[1] = H[z + 1], u[2] = H[z + 2], p[0] = H[W], p[1] = H[W + 1], p[2] = H[W + 2]), S = math.addVec3(math.addVec3(math.mulVec3Scalar(c, l[0], y), math.mulVec3Scalar(u, l[1], T), I), math.mulVec3Scalar(p, l[2], E), C), x.worldNormal = math.normalizeVec3(math.transformVec3(w.worldNormalMatrix, S, P))), (L = O.uv) && (d[0] = L[2 * G], d[1] = L[2 * G + 1], m[0] = L[2 * U], m[1] = L[2 * U + 1], f[0] = L[2 * k], f[1] = L[2 * k + 1], O.compressGeometry && (N = O.uvDecodeMatrix) && (geometryCompressionUtils.decompressUV(d, N, d), geometryCompressionUtils.decompressUV(m, N, m), geometryCompressionUtils.decompressUV(f, N, f)), x.uv = math.addVec3(math.addVec3(math.mulVec2Scalar(d, l[0], b), math.mulVec2Scalar(m, l[1], A), D), math.mulVec2Scalar(f, l[2], R), F)) } } } }(); class Material extends Component { get type() { return "Material" } constructor(e, t = {}) { super(e, t), stats.memory.materials++ } destroy() { super.destroy(), stats.memory.materials-- } } const alphaModes$1 = { opaque: 0, mask: 1, blend: 2 }, alphaModeNames$1 = ["opaque", "mask", "blend"]; class PhongMaterial extends Material { get type() { return "PhongMaterial" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "PhongMaterial", ambient: math.vec3([1, 1, 1]), diffuse: math.vec3([1, 1, 1]), specular: math.vec3([1, 1, 1]), emissive: math.vec3([0, 0, 0]), alpha: null, shininess: null, reflectivity: null, alphaMode: null, alphaCutoff: null, lineWidth: null, pointSize: null, backfaces: null, frontface: null, hash: null }), this.ambient = t.ambient, this.diffuse = t.diffuse, this.specular = t.specular, this.emissive = t.emissive, this.alpha = t.alpha, this.shininess = t.shininess, this.reflectivity = t.reflectivity, this.lineWidth = t.lineWidth, this.pointSize = t.pointSize, t.ambientMap && (this._ambientMap = this._checkComponent("Texture", t.ambientMap)), t.diffuseMap && (this._diffuseMap = this._checkComponent("Texture", t.diffuseMap)), t.specularMap && (this._specularMap = this._checkComponent("Texture", t.specularMap)), t.emissiveMap && (this._emissiveMap = this._checkComponent("Texture", t.emissiveMap)), t.alphaMap && (this._alphaMap = this._checkComponent("Texture", t.alphaMap)), t.reflectivityMap && (this._reflectivityMap = this._checkComponent("Texture", t.reflectivityMap)), t.normalMap && (this._normalMap = this._checkComponent("Texture", t.normalMap)), t.occlusionMap && (this._occlusionMap = this._checkComponent("Texture", t.occlusionMap)), t.diffuseFresnel && (this._diffuseFresnel = this._checkComponent("Fresnel", t.diffuseFresnel)), t.specularFresnel && (this._specularFresnel = this._checkComponent("Fresnel", t.specularFresnel)), t.emissiveFresnel && (this._emissiveFresnel = this._checkComponent("Fresnel", t.emissiveFresnel)), t.alphaFresnel && (this._alphaFresnel = this._checkComponent("Fresnel", t.alphaFresnel)), t.reflectivityFresnel && (this._reflectivityFresnel = this._checkComponent("Fresnel", t.reflectivityFresnel)), this.alphaMode = t.alphaMode, this.alphaCutoff = t.alphaCutoff, this.backfaces = t.backfaces, this.frontface = t.frontface, this._makeHash() } _makeHash() { var e = this._state, t = ["/p"]; this._normalMap && (t.push("/nm"), this._normalMap.hasMatrix) && t.push("/mat"), this._ambientMap && (t.push("/am"), this._ambientMap.hasMatrix && t.push("/mat"), t.push("/" + this._ambientMap.encoding)), this._diffuseMap && (t.push("/dm"), this._diffuseMap.hasMatrix && t.push("/mat"), t.push("/" + this._diffuseMap.encoding)), this._specularMap && (t.push("/sm"), this._specularMap.hasMatrix) && t.push("/mat"), this._emissiveMap && (t.push("/em"), this._emissiveMap.hasMatrix && t.push("/mat"), t.push("/" + this._emissiveMap.encoding)), this._alphaMap && (t.push("/opm"), this._alphaMap.hasMatrix) && t.push("/mat"), this._reflectivityMap && (t.push("/rm"), this._reflectivityMap.hasMatrix) && t.push("/mat"), this._occlusionMap && (t.push("/ocm"), this._occlusionMap.hasMatrix) && t.push("/mat"), this._diffuseFresnel && t.push("/df"), this._specularFresnel && t.push("/sf"), this._emissiveFresnel && t.push("/ef"), this._alphaFresnel && t.push("/of"), this._reflectivityFresnel && t.push("/rf"), t.push(";"), e.hash = t.join("") } set ambient(e) { let t = this._state.ambient; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.ambient = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = .2, t[1] = .2, t[2] = .2), this.glRedraw() } get ambient() { return this._state.ambient } set diffuse(e) { let t = this._state.diffuse; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.diffuse = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get diffuse() { return this._state.diffuse } set specular(e) { let t = this._state.specular; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.specular = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get specular() { return this._state.specular } set emissive(e) { let t = this._state.emissive; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.emissive = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 0, t[1] = 0, t[2] = 0), this.glRedraw() } get emissive() { return this._state.emissive } set alpha(e) { this._state.alpha !== (e = null != e ? e : 1) && (this._state.alpha = e, this.glRedraw()) } get alpha() { return this._state.alpha } set shininess(e) { this._state.shininess = void 0 !== e ? e : 80, this.glRedraw() } get shininess() { return this._state.shininess } set lineWidth(e) { this._state.lineWidth = e || 1, this.glRedraw() } get lineWidth() { return this._state.lineWidth } set pointSize(e) { this._state.pointSize = e || 1, this.glRedraw() } get pointSize() { return this._state.pointSize } set reflectivity(e) { this._state.reflectivity = void 0 !== e ? e : 1, this.glRedraw() } get reflectivity() { return this._state.reflectivity } get normalMap() { return this._normalMap } get ambientMap() { return this._ambientMap } get diffuseMap() { return this._diffuseMap } get specularMap() { return this._specularMap } get emissiveMap() { return this._emissiveMap } get alphaMap() { return this._alphaMap } get reflectivityMap() { return this._reflectivityMap } get occlusionMap() { return this._occlusionMap } get diffuseFresnel() { return this._diffuseFresnel } get specularFresnel() { return this._specularFresnel } get emissiveFresnel() { return this._emissiveFresnel } get alphaFresnel() { return this._alphaFresnel } get reflectivityFresnel() { return this._reflectivityFresnel } set alphaMode(e) { let t = alphaModes$1[e = e || "opaque"]; void 0 === t && (this.error("Unsupported value for 'alphaMode': " + e + " - defaulting to 'opaque'"), t = "opaque"), this._state.alphaMode !== t && (this._state.alphaMode = t, this.glRedraw()) } get alphaMode() { return alphaModeNames$1[this._state.alphaMode] } set alphaCutoff(e) { this._state.alphaCutoff !== (e = null == e ? .5 : e) && (this._state.alphaCutoff = e) } get alphaCutoff() { return this._state.alphaCutoff } set backfaces(e) { this._state.backfaces !== (e = !!e) && (this._state.backfaces = e, this.glRedraw()) } get backfaces() { return this._state.backfaces } set frontface(e) { this._state.frontface !== (e = "cw" !== e) && (this._state.frontface = e, this.glRedraw()) } get frontface() { return this._state.frontface ? "ccw" : "cw" } destroy() { super.destroy(), this._state.destroy() } } function getExtension(e, t) { if (void 0 === e._cachedExtensions && (e._cachedExtensions = {}), void 0 !== e._cachedExtensions[t]) return e._cachedExtensions[t]; let i; switch (t) { case "WEBGL_depth_texture": i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = e.getExtension(t) }return e._cachedExtensions[t] = i } function convertConstant(e, t, i = null) { let s; if (1009 === t) return e.UNSIGNED_BYTE; if (1017 === t) return e.UNSIGNED_SHORT_4_4_4_4; if (1018 === t) return e.UNSIGNED_SHORT_5_5_5_1; if (1010 === t) return e.BYTE; if (1011 === t) return e.SHORT; if (1012 === t) return e.UNSIGNED_SHORT; if (1013 === t) return e.INT; if (1014 === t) return e.UNSIGNED_INT; if (1015 === t) return e.FLOAT; if (1016 === t) return e.HALF_FLOAT; if (1021 === t) return e.ALPHA; if (1023 === t) return e.RGBA; if (1024 === t) return e.LUMINANCE; if (1025 === t) return e.LUMINANCE_ALPHA; if (1026 === t) return e.DEPTH_COMPONENT; if (1027 === t) return e.DEPTH_STENCIL; if (1028 === t) return e.RED; if (1022 === t) return e.RGBA; if (1029 === t) return e.RED_INTEGER; if (1030 === t) return e.RG; if (1031 === t) return e.RG_INTEGER; if (1033 === t) return e.RGBA_INTEGER; if (33776 === t || 33777 === t || 33778 === t || 33779 === t) if (i === sRGBEncoding) { const i = getExtension(e, "WEBGL_compressed_texture_s3tc_srgb"); if (null === i) return null; if (33776 === t) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (33777 === t) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (33778 === t) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (33779 === t) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (null === (s = getExtension(e, "WEBGL_compressed_texture_s3tc"))) return null; if (33776 === t) return s.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === t) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === t) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === t) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) { const i = getExtension(e, "WEBGL_compressed_texture_pvrtc"); if (null === i) return null; if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === t) { const t = getExtension(e, "WEBGL_compressed_texture_etc1"); return null !== t ? t.COMPRESSED_RGB_ETC1_WEBGL : null } if (37492 === t || 37496 === t) { const s = getExtension(e, "WEBGL_compressed_texture_etc"); if (null === s) return null; if (37492 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2; if (37496 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC } if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) { const s = getExtension(e, "WEBGL_compressed_texture_astc"); if (null === s) return null; if (37808 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR; if (37809 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR; if (37810 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR; if (37811 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR; if (37812 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR; if (37813 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR; if (37814 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR; if (37815 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR; if (37816 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR; if (37817 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR; if (37818 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR; if (37819 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR; if (37820 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR; if (37821 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR } if (36492 === t) { const s = getExtension(e, "EXT_texture_compression_bptc"); if (null === s) return null; if (36492 === t) return i === sRGBEncoding ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT } return 1020 === t ? e.UNSIGNED_INT_24_8 : t === RepeatWrapping ? e.REPEAT : t === ClampToEdgeWrapping ? e.CLAMP_TO_EDGE : t === NearestMipMapNearestFilter || t === NearestMipMapLinearFilter ? e.NEAREST_MIPMAP_LINEAR : t === LinearMipMapNearestFilter ? e.LINEAR_MIPMAP_NEAREST : t === LinearMipMapLinearFilter ? e.LINEAR_MIPMAP_LINEAR : t === NearestFilter ? e.NEAREST : t === LinearFilter ? e.LINEAR : null } const color$2 = new Uint8Array([0, 0, 0, 1]); class Texture2D { constructor({ gl: e, target: t, format: i, type: s, wrapS: r, wrapT: a, wrapR: o, encoding: n, preloadColor: h, premultiplyAlpha: l, flipY: c }) { this.gl = e, this.target = t || e.TEXTURE_2D, this.format = i || 1023, this.type = s || 1009, this.internalFormat = null, this.premultiplyAlpha = !!l, this.flipY = !!c, this.unpackAlignment = 4, this.wrapS = r || RepeatWrapping, this.wrapT = a || RepeatWrapping, this.wrapR = o || RepeatWrapping, this.encoding = n || sRGBEncoding, this.texture = e.createTexture(), h && this.setPreloadColor(h), this.allocated = !0 } setPreloadColor(e) { e ? (color$2[0] = Math.floor(255 * e[0]), color$2[1] = Math.floor(255 * e[1]), color$2[2] = Math.floor(255 * e[2]), color$2[3] = Math.floor(255 * (void 0 !== e[3] ? e[3] : 1))) : (color$2[0] = 0, color$2[1] = 0, color$2[2] = 0, color$2[3] = 255); var t = this.gl; if (t.bindTexture(this.target, this.texture), this.target === t.TEXTURE_CUBE_MAP) { var i = [t.TEXTURE_CUBE_MAP_POSITIVE_X, t.TEXTURE_CUBE_MAP_NEGATIVE_X, t.TEXTURE_CUBE_MAP_POSITIVE_Y, t.TEXTURE_CUBE_MAP_NEGATIVE_Y, t.TEXTURE_CUBE_MAP_POSITIVE_Z, t.TEXTURE_CUBE_MAP_NEGATIVE_Z]; for (let e = 0, s = i.length; e < s; e++)t.texImage2D(i[e], 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, color$2) } else t.texImage2D(this.target, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, color$2); t.bindTexture(this.target, null) } setTarget(e) { this.target = e || this.gl.TEXTURE_2D } setImage(e, t = {}) { var i = this.gl; void 0 !== t.format && (this.format = t.format), void 0 !== t.internalFormat && (this.internalFormat = t.internalFormat), void 0 !== t.encoding && (this.encoding = t.encoding), void 0 !== t.type && (this.type = t.type), void 0 !== t.flipY && (this.flipY = t.flipY), void 0 !== t.premultiplyAlpha && (this.premultiplyAlpha = t.premultiplyAlpha), void 0 !== t.unpackAlignment && (this.unpackAlignment = t.unpackAlignment), void 0 !== t.minFilter && (this.minFilter = t.minFilter), void 0 !== t.magFilter && (this.magFilter = t.magFilter), void 0 !== t.wrapS && (this.wrapS = t.wrapS), void 0 !== t.wrapT && (this.wrapT = t.wrapT), void 0 !== t.wrapR && (this.wrapR = t.wrapR); let s = !1; i.bindTexture(this.target, this.texture), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, this.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, this.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE), t = convertConstant(i, this.minFilter), i.texParameteri(this.target, i.TEXTURE_MIN_FILTER, t), t !== i.NEAREST_MIPMAP_NEAREST && t !== i.LINEAR_MIPMAP_NEAREST && t !== i.NEAREST_MIPMAP_LINEAR && t !== i.LINEAR_MIPMAP_LINEAR || (s = !0), (t = convertConstant(i, this.magFilter)) && i.texParameteri(this.target, i.TEXTURE_MAG_FILTER, t), (t = convertConstant(i, this.wrapS)) && i.texParameteri(this.target, i.TEXTURE_WRAP_S, t), (t = convertConstant(i, this.wrapT)) && i.texParameteri(this.target, i.TEXTURE_WRAP_T, t); var r = convertConstant(i, this.format, this.encoding), a = convertConstant(i, this.type), o = getInternalFormat(i, this.internalFormat, r, a, this.encoding, !1); if (this.target === i.TEXTURE_CUBE_MAP) { if (utils.isArray(e)) { var n = e, h = [i.TEXTURE_CUBE_MAP_POSITIVE_X, i.TEXTURE_CUBE_MAP_NEGATIVE_X, i.TEXTURE_CUBE_MAP_POSITIVE_Y, i.TEXTURE_CUBE_MAP_NEGATIVE_Y, i.TEXTURE_CUBE_MAP_POSITIVE_Z, i.TEXTURE_CUBE_MAP_NEGATIVE_Z]; for (let e = 0, t = h.length; e < t; e++)i.texImage2D(h[e], 0, o, r, a, n[e]) } } else i.texImage2D(i.TEXTURE_2D, 0, o, r, a, e); s && i.generateMipmap(this.target), i.bindTexture(this.target, null) } setCompressedData({ mipmaps: e, props: t = {} }) { var i = this.gl, s = e.length, r = (t = (void 0 !== t.format && (this.format = t.format), void 0 !== t.internalFormat && (this.internalFormat = t.internalFormat), void 0 !== t.encoding && (this.encoding = t.encoding), void 0 !== t.type && (this.type = t.type), void 0 !== t.flipY && (this.flipY = t.flipY), void 0 !== t.premultiplyAlpha && (this.premultiplyAlpha = t.premultiplyAlpha), void 0 !== t.unpackAlignment && (this.unpackAlignment = t.unpackAlignment), void 0 !== t.minFilter && (this.minFilter = t.minFilter), void 0 !== t.magFilter && (this.magFilter = t.magFilter), void 0 !== t.wrapS && (this.wrapS = t.wrapS), void 0 !== t.wrapT && (this.wrapT = t.wrapT), void 0 !== t.wrapR && (this.wrapR = t.wrapR), i.activeTexture(i.TEXTURE0 + 0), i.bindTexture(this.target, this.texture), 1 < e.length), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, this.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, this.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE), (o = convertConstant(i, this.wrapS)) && i.texParameteri(this.target, i.TEXTURE_WRAP_S, o), (o = convertConstant(i, this.wrapT)) && i.texParameteri(this.target, i.TEXTURE_WRAP_T, o), this.type !== i.TEXTURE_3D && this.type !== i.TEXTURE_2D_ARRAY || ((o = convertConstant(i, this.wrapR)) && i.texParameteri(this.target, i.TEXTURE_WRAP_R, o), i.texParameteri(this.type, i.TEXTURE_WRAP_R, o)), t ? (i.texParameteri(this.target, i.TEXTURE_MIN_FILTER, filterFallback(i, this.minFilter)), i.texParameteri(this.target, i.TEXTURE_MAG_FILTER, filterFallback(i, this.magFilter))) : (i.texParameteri(this.target, i.TEXTURE_MIN_FILTER, convertConstant(i, this.minFilter)), i.texParameteri(this.target, i.TEXTURE_MAG_FILTER, convertConstant(i, this.magFilter))), convertConstant(i, this.format, this.encoding)), a = convertConstant(i, this.type), o = getInternalFormat(i, this.internalFormat, r, a, this.encoding, !1); i.texStorage2D(i.TEXTURE_2D, s, o, e[0].width, e[0].height); for (let t = 0, s = e.length; t < s; t++) { var n = e[t]; 1023 !== this.format ? null !== r ? i.compressedTexSubImage2D(i.TEXTURE_2D, t, 0, 0, n.width, n.height, r, n.data) : console.warn("Attempt to load unsupported compressed texture format in .setCompressedData()") : i.texSubImage2D(i.TEXTURE_2D, t, 0, 0, n.width, n.height, r, a, n.data) } i.bindTexture(this.target, null) } setProps(e) { var t = this.gl; t.bindTexture(this.target, this.texture), this._uploadProps(e), t.bindTexture(this.target, null) } _uploadProps(e) { var t, i = this.gl; void 0 !== e.format && (this.format = e.format), void 0 !== e.internalFormat && (this.internalFormat = e.internalFormat), void 0 !== e.encoding && (this.encoding = e.encoding), void 0 !== e.type && (this.type = e.type), void 0 !== e.minFilter && (t = convertConstant(i, e.minFilter)) && (this.minFilter = e.minFilter, i.texParameteri(this.target, i.TEXTURE_MIN_FILTER, t), t !== i.NEAREST_MIPMAP_NEAREST && t !== i.LINEAR_MIPMAP_NEAREST && t !== i.NEAREST_MIPMAP_LINEAR && t !== i.LINEAR_MIPMAP_LINEAR || i.generateMipmap(this.target)), void 0 !== e.magFilter && (t = convertConstant(i, e.magFilter)) && (this.magFilter = e.magFilter, i.texParameteri(this.target, i.TEXTURE_MAG_FILTER, t)), void 0 !== e.wrapS && (t = convertConstant(i, e.wrapS)) && (this.wrapS = e.wrapS, i.texParameteri(this.target, i.TEXTURE_WRAP_S, t)), void 0 !== e.wrapT && (t = convertConstant(i, e.wrapT)) && (this.wrapT = e.wrapT, i.texParameteri(this.target, i.TEXTURE_WRAP_T, t)) } bind(e) { var t; if (this.allocated) return !!this.texture && ((t = this.gl).activeTexture(t["TEXTURE" + e]), t.bindTexture(this.target, this.texture), !0) } unbind(e) { var t; this.allocated && this.texture && ((t = this.gl).activeTexture(t["TEXTURE" + e]), t.bindTexture(this.target, null)) } destroy() { this.allocated && this.texture && (this.gl.deleteTexture(this.texture), this.texture = null) } } function getInternalFormat(e, t, i, s, r, a = !1) { if (null !== t) { if (void 0 !== e[t]) return e[t]; console.warn("Attempt to use non-existing WebGL internal format '" + t + "'") } let o = i; return i === e.RED && (s === e.FLOAT && (o = e.R32F), s === e.HALF_FLOAT && (o = e.R16F), s === e.UNSIGNED_BYTE) && (o = e.R8), i === e.RG && (s === e.FLOAT && (o = e.RG32F), s === e.HALF_FLOAT && (o = e.RG16F), s === e.UNSIGNED_BYTE) && (o = e.RG8), (o = i === e.RGBA && (s === e.FLOAT && (o = e.RGBA32F), s === e.HALF_FLOAT && (o = e.RGBA16F), s === e.UNSIGNED_BYTE && (o = r === sRGBEncoding && !1 === a ? e.SRGB8_ALPHA8 : e.RGBA8), s === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4), s === e.UNSIGNED_SHORT_5_5_5_1) ? e.RGB5_A1 : o) !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || getExtension(e, "EXT_color_buffer_float"), o } function filterFallback(e, t) { return t === NearestFilter || 1004 === t || 1005 === t ? e.NEAREST : e.LINEAR } function ensureImageSizePowerOfTwo$1(e) { var t; return isPowerOfTwo$1(e.width) && isPowerOfTwo$1(e.height) || ((t = document.createElement("canvas")).width = nextHighestPowerOfTwo$1(e.width), t.height = nextHighestPowerOfTwo$1(e.height), t.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, t.width, t.height), e = t), e } function isPowerOfTwo$1(e) { return !(e & e - 1) } function nextHighestPowerOfTwo$1(e) { --e; for (let t = 1; t < 32; t <<= 1)e |= e >> t; return e + 1 } class Texture extends Component { get type() { return "Texture" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ texture: new Texture2D({ gl: this.scene.canvas.gl }), matrix: math.identityMat4(), hasMatrix: t.translate && (0 !== t.translate[0] || 0 !== t.translate[1]) || !!t.rotate || t.scale && (0 !== t.scale[0] || 0 !== t.scale[1]), minFilter: this._checkMinFilter(t.minFilter), magFilter: this._checkMagFilter(t.magFilter), wrapS: this._checkWrapS(t.wrapS), wrapT: this._checkWrapT(t.wrapT), flipY: this._checkFlipY(t.flipY), encoding: this._checkEncoding(t.encoding) }), this._src = null, this._image = null, this._translate = math.vec2([0, 0]), this._scale = math.vec2([1, 1]), this._rotate = math.vec2([0, 0]), this._matrixDirty = !1, this.translate = t.translate, this.scale = t.scale, this.rotate = t.rotate, t.src ? this.src = t.src : t.image && (this.image = t.image), stats.memory.textures++ } _checkMinFilter(e) { return (e = e || LinearMipMapLinearFilter) !== LinearFilter && e !== LinearMipMapNearestFilter && e !== LinearMipMapLinearFilter && e !== NearestMipMapLinearFilter && e !== NearestMipMapNearestFilter && (this.error("Unsupported value for 'minFilter' - supported values are LinearFilter, LinearMipMapNearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter and LinearMipMapLinearFilter. Defaulting to LinearMipMapLinearFilter."), e = LinearMipMapLinearFilter), e } _checkMagFilter(e) { return (e = e || LinearFilter) !== LinearFilter && e !== NearestFilter && (this.error("Unsupported value for 'magFilter' - supported values are LinearFilter and NearestFilter. Defaulting to LinearFilter."), e = LinearFilter), e } _checkWrapS(e) { return (e = e || RepeatWrapping) !== ClampToEdgeWrapping && e !== MirroredRepeatWrapping && e !== RepeatWrapping && (this.error("Unsupported value for 'wrapS' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping."), e = RepeatWrapping), e } _checkWrapT(e) { return (e = e || RepeatWrapping) !== ClampToEdgeWrapping && e !== MirroredRepeatWrapping && e !== RepeatWrapping && (this.error("Unsupported value for 'wrapT' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping."), e = RepeatWrapping), e } _checkFlipY(e) { return !!e } _checkEncoding(e) { return 3e3 !== (e = e || 3e3) && e !== sRGBEncoding && (this.error("Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding."), e = 3e3), e } _webglContextRestored() { this._state.texture = new Texture2D({ gl: this.scene.canvas.gl }), this._image ? this.image = this._image : this._src && (this.src = this._src) } _update() { var e = this._state; if (this._matrixDirty) { let t, i; 0 === this._translate[0] && 0 === this._translate[1] || (t = math.translationMat4v([this._translate[0], this._translate[1], 0], this._state.matrix)), 1 === this._scale[0] && 1 === this._scale[1] || (i = math.scalingMat4v([this._scale[0], this._scale[1], 1]), t = t ? math.mulMat4(t, i) : i), 0 !== this._rotate && (i = math.rotationMat4v(.0174532925 * this._rotate, [0, 0, 1]), t = t ? math.mulMat4(t, i) : i), t && (e.matrix = t), this._matrixDirty = !1 } this.glRedraw() } set image(e) { this._image = ensureImageSizePowerOfTwo$1(e), this._image.crossOrigin = "Anonymous", this._state.texture.setImage(this._image, this._state), this._src = null, this.glRedraw() } get image() { return this._image } set src(e) { this.scene.loading++, this.scene.canvas.spinner.processes++; const t = this; let i = new Image; i.onload = function () { i = ensureImageSizePowerOfTwo$1(i), t._state.texture.setImage(i, t._state), t.scene.loading--, t.glRedraw(), t.scene.canvas.spinner.processes-- }, i.src = e, this._src = e, this._image = null } get src() { return this._src } set translate(e) { this._translate.set(e || [0, 0]), this._matrixDirty = !0, this._needUpdate() } get translate() { return this._translate } set scale(e) { this._scale.set(e || [1, 1]), this._matrixDirty = !0, this._needUpdate() } get scale() { return this._scale } set rotate(e) { this._rotate !== (e = e || 0) && (this._rotate = e, this._matrixDirty = !0, this._needUpdate()) } get rotate() { return this._rotate } get minFilter() { return this._state.minFilter } get magFilter() { return this._state.magFilter } get wrapS() { return this._state.wrapS } get wrapT() { return this._state.wrapT } get flipY() { return this._state.flipY } get encoding() { return this._state.encoding } destroy() { super.destroy(), this._state.texture && this._state.texture.destroy(), this._state.destroy(), stats.memory.textures-- } } const tempVec3$4 = math.vec3(), tempVec3b$b = math.vec3(), zeroVec$1 = (math.vec3(), math.vec3([0, -1, 0])), tempQuat = math.vec4([0, 0, 0, 1]); class ImagePlane extends Component { constructor(e, t = {}) { super(e, t), this._src = null, this._image = null, this._pos = math.vec3(), this._origin = math.vec3(), this._rtcPos = math.vec3(), this._dir = math.vec3(), this._size = 1, this._imageSize = math.vec2(), this._texture = new Texture(this), this._plane = new Mesh(this, { geometry: new ReadableGeometry(this, buildPlaneGeometry({ center: [0, 0, 0], xSize: 1, zSize: 1, xSegments: 10, zSegments: 10 })), material: new PhongMaterial(this, { diffuse: [0, 0, 0], ambient: [0, 0, 0], specular: [0, 0, 0], diffuseMap: this._texture, emissiveMap: this._texture, backfaces: !0 }), clippable: t.clippable }), this._grid = new Mesh(this, { geometry: new ReadableGeometry(this, buildGridGeometry({ size: 1, divisions: 10 })), material: new PhongMaterial(this, { diffuse: [0, 0, 0], ambient: [0, 0, 0], emissive: [.2, .8, .2] }), position: [0, .001, 0], clippable: t.clippable }), this._node = new Node$1(this, { rotation: [0, 0, 0], position: [0, 0, 0], scale: [1, 1, 1], clippable: !1, children: [this._plane, this._grid] }), this._gridVisible = !1, this.visible = !0, this.gridVisible = t.gridVisible, this.position = t.position, this.rotation = t.rotation, this.dir = t.dir, this.size = t.size, this.collidable = t.collidable, this.clippable = t.clippable, this.pickable = t.pickable, this.opacity = t.opacity, t.image ? this.image = t.image : this.src = t.src } set visible(e) { this._plane.visible = e, this._grid.visible = this._gridVisible && e } get visible() { return this._plane.visible } set gridVisible(e) { this._gridVisible = e = !1 !== e, this._grid.visible = this._gridVisible && this.visible } get gridVisible() { return this._gridVisible } set image(e) { this._image = e, this._image && (this._imageSize[0] = e.width, this._imageSize[1] = e.height, this._updatePlaneSizeFromImage(), this._src = null, this._texture.image = this._image) } get image() { return this._image } set src(e) { if (this._src = e, this._src) { this._image = null; const e = new Image; e.onload = () => { this._texture.image = e, this._imageSize[0] = e.width, this._imageSize[1] = e.height, this._updatePlaneSizeFromImage() }, e.src = this._src } } get src() { return this._src } set position(e) { this._pos.set(e || [0, 0, 0]), worldToRTCPos(this._pos, this._origin, this._rtcPos), this._node.origin = this._origin, this._node.position = this._rtcPos } get position() { return this._pos } set rotation(e) { this._node.rotation = e } get rotation() { return this._node.rotation } set size(e) { this._size = null == e ? 1 : e, this._image && this._updatePlaneSizeFromImage() } get size() { return this._size } set dir(e) { var t, i; this._dir.set(e || [0, 0, -1]), e && (i = this.scene.center, t = [-this._dir[0], -this._dir[1], -this._dir[2]], math.subVec3(i, this.position, tempVec3$4), i = -math.dotVec3(t, tempVec3$4), math.normalizeVec3(t), math.mulVec3Scalar(t, i, tempVec3b$b), math.vec3PairToQuaternion(zeroVec$1, e, tempQuat), this._node.quaternion = tempQuat) } get dir() { return this._dir } set collidable(e) { this._node.collidable = !1 !== e } get collidable() { return this._node.collidable } set clippable(e) { this._node.clippable = !1 !== e } get clippable() { return this._node.clippable } set pickable(e) { this._node.pickable = !1 !== e } get pickable() { return this._node.pickable } set opacity(e) { this._node.opacity = e } get opacity() { return this._node.opacity } destroy() { super.destroy() } _updatePlaneSizeFromImage() { var e = this._size, t = this._imageSize[0], i = this._imageSize[1]; this._node.scale = i < t ? [e, 1, e * (i / t)] : [e * (t / i), 1, e] } } class LambertMaterial extends Material { get type() { return "LambertMaterial" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "LambertMaterial", ambient: math.vec3([1, 1, 1]), color: math.vec3([1, 1, 1]), emissive: math.vec3([0, 0, 0]), alpha: null, alphaMode: 0, lineWidth: null, pointSize: null, backfaces: null, frontface: null, hash: "/lam;" }), this.ambient = t.ambient, this.color = t.color, this.emissive = t.emissive, this.alpha = t.alpha, this.lineWidth = t.lineWidth, this.pointSize = t.pointSize, this.backfaces = t.backfaces, this.frontface = t.frontface } set ambient(e) { let t = this._state.ambient; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.ambient = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = .2, t[1] = .2, t[2] = .2), this.glRedraw() } get ambient() { return this._state.ambient } set color(e) { let t = this._state.color; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.color = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get color() { return this._state.color } set emissive(e) { let t = this._state.emissive; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.emissive = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 0, t[1] = 0, t[2] = 0), this.glRedraw() } get emissive() { return this._state.emissive } set alpha(e) { this._state.alpha !== (e = null != e ? e : 1) && (this._state.alpha = e, this._state.alphaMode = e < 1 ? 2 : 0, this.glRedraw()) } get alpha() { return this._state.alpha } set lineWidth(e) { this._state.lineWidth = e || 1, this.glRedraw() } get lineWidth() { return this._state.lineWidth } set pointSize(e) { this._state.pointSize = e || 1, this.glRedraw() } get pointSize() { return this._state.pointSize } set backfaces(e) { this._state.backfaces !== (e = !!e) && (this._state.backfaces = e, this.glRedraw()) } get backfaces() { return this._state.backfaces } set frontface(e) { this._state.frontface !== (e = "cw" !== e) && (this._state.frontface = e, this.glRedraw()) } get frontface() { return this._state.frontface ? "ccw" : "cw" } _getState() { return this._state } destroy() { super.destroy(), this._state.destroy() } } const modes = { opaque: 0, mask: 1, blend: 2 }, modeNames = ["opaque", "mask", "blend"]; class MetallicMaterial extends Material { get type() { return "MetallicMaterial" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "MetallicMaterial", baseColor: math.vec4([1, 1, 1]), emissive: math.vec4([0, 0, 0]), metallic: null, roughness: null, specularF0: null, alpha: null, alphaMode: null, alphaCutoff: null, lineWidth: null, pointSize: null, backfaces: null, frontface: null, hash: null }), this.baseColor = t.baseColor, this.metallic = t.metallic, this.roughness = t.roughness, this.specularF0 = t.specularF0, this.emissive = t.emissive, this.alpha = t.alpha, t.baseColorMap && (this._baseColorMap = this._checkComponent("Texture", t.baseColorMap)), t.metallicMap && (this._metallicMap = this._checkComponent("Texture", t.metallicMap)), t.roughnessMap && (this._roughnessMap = this._checkComponent("Texture", t.roughnessMap)), t.metallicRoughnessMap && (this._metallicRoughnessMap = this._checkComponent("Texture", t.metallicRoughnessMap)), t.emissiveMap && (this._emissiveMap = this._checkComponent("Texture", t.emissiveMap)), t.occlusionMap && (this._occlusionMap = this._checkComponent("Texture", t.occlusionMap)), t.alphaMap && (this._alphaMap = this._checkComponent("Texture", t.alphaMap)), t.normalMap && (this._normalMap = this._checkComponent("Texture", t.normalMap)), this.alphaMode = t.alphaMode, this.alphaCutoff = t.alphaCutoff, this.backfaces = t.backfaces, this.frontface = t.frontface, this.lineWidth = t.lineWidth, this.pointSize = t.pointSize, this._makeHash() } _makeHash() { var e = this._state, t = ["/met"]; this._baseColorMap && (t.push("/bm"), this._baseColorMap._state.hasMatrix && t.push("/mat"), t.push("/" + this._baseColorMap._state.encoding)), this._metallicMap && (t.push("/mm"), this._metallicMap._state.hasMatrix) && t.push("/mat"), this._roughnessMap && (t.push("/rm"), this._roughnessMap._state.hasMatrix) && t.push("/mat"), this._metallicRoughnessMap && (t.push("/mrm"), this._metallicRoughnessMap._state.hasMatrix) && t.push("/mat"), this._emissiveMap && (t.push("/em"), this._emissiveMap._state.hasMatrix) && t.push("/mat"), this._occlusionMap && (t.push("/ocm"), this._occlusionMap._state.hasMatrix) && t.push("/mat"), this._alphaMap && (t.push("/am"), this._alphaMap._state.hasMatrix) && t.push("/mat"), this._normalMap && (t.push("/nm"), this._normalMap._state.hasMatrix) && t.push("/mat"), t.push(";"), e.hash = t.join("") } set baseColor(e) { let t = this._state.baseColor; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.baseColor = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get baseColor() { return this._state.baseColor } get baseColorMap() { return this._baseColorMap } set metallic(e) { this._state.metallic !== (e = null != e ? e : 1) && (this._state.metallic = e, this.glRedraw()) } get metallic() { return this._state.metallic } get metallicMap() { return this._attached.metallicMap } set roughness(e) { this._state.roughness !== (e = null != e ? e : 1) && (this._state.roughness = e, this.glRedraw()) } get roughness() { return this._state.roughness } get roughnessMap() { return this._attached.roughnessMap } get metallicRoughnessMap() { return this._attached.metallicRoughnessMap } set specularF0(e) { this._state.specularF0 !== (e = null != e ? e : 0) && (this._state.specularF0 = e, this.glRedraw()) } get specularF0() { return this._state.specularF0 } set emissive(e) { let t = this._state.emissive; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.emissive = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 0, t[1] = 0, t[2] = 0), this.glRedraw() } get emissive() { return this._state.emissive } get emissiveMap() { return this._attached.emissiveMap } get occlusionMap() { return this._attached.occlusionMap } set alpha(e) { this._state.alpha !== (e = null != e ? e : 1) && (this._state.alpha = e, this.glRedraw()) } get alpha() { return this._state.alpha } get alphaMap() { return this._attached.alphaMap } get normalMap() { return this._attached.normalMap } set alphaMode(e) { let t = modes[e = e || "opaque"]; void 0 === t && (this.error("Unsupported value for 'alphaMode': " + e + " defaulting to 'opaque'"), t = "opaque"), this._state.alphaMode !== t && (this._state.alphaMode = t, this.glRedraw()) } get alphaMode() { return modeNames[this._state.alphaMode] } set alphaCutoff(e) { this._state.alphaCutoff !== (e = null == e ? .5 : e) && (this._state.alphaCutoff = e) } get alphaCutoff() { return this._state.alphaCutoff } set backfaces(e) { this._state.backfaces !== (e = !!e) && (this._state.backfaces = e, this.glRedraw()) } get backfaces() { return this._state.backfaces } set frontface(e) { this._state.frontface !== (e = "cw" !== e) && (this._state.frontface = e, this.glRedraw()) } get frontface() { return this._state.frontface ? "ccw" : "cw" } set lineWidth(e) { this._state.lineWidth = e || 1, this.glRedraw() } get lineWidth() { return this._state.lineWidth } set pointSize(e) { this._state.pointSize = e || 1, this.glRedraw() } get pointSize() { return this._state.pointSize } destroy() { super.destroy(), this._state.destroy() } } const alphaModes = { opaque: 0, mask: 1, blend: 2 }, alphaModeNames = ["opaque", "mask", "blend"]; class SpecularMaterial extends Material { get type() { return "SpecularMaterial" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "SpecularMaterial", diffuse: math.vec3([1, 1, 1]), emissive: math.vec3([0, 0, 0]), specular: math.vec3([1, 1, 1]), glossiness: null, specularF0: null, alpha: null, alphaMode: null, alphaCutoff: null, lineWidth: null, pointSize: null, backfaces: null, frontface: null, hash: null }), this.diffuse = t.diffuse, this.specular = t.specular, this.glossiness = t.glossiness, this.specularF0 = t.specularF0, this.emissive = t.emissive, this.alpha = t.alpha, t.diffuseMap && (this._diffuseMap = this._checkComponent("Texture", t.diffuseMap)), t.emissiveMap && (this._emissiveMap = this._checkComponent("Texture", t.emissiveMap)), t.specularMap && (this._specularMap = this._checkComponent("Texture", t.specularMap)), t.glossinessMap && (this._glossinessMap = this._checkComponent("Texture", t.glossinessMap)), t.specularGlossinessMap && (this._specularGlossinessMap = this._checkComponent("Texture", t.specularGlossinessMap)), t.occlusionMap && (this._occlusionMap = this._checkComponent("Texture", t.occlusionMap)), t.alphaMap && (this._alphaMap = this._checkComponent("Texture", t.alphaMap)), t.normalMap && (this._normalMap = this._checkComponent("Texture", t.normalMap)), this.alphaMode = t.alphaMode, this.alphaCutoff = t.alphaCutoff, this.backfaces = t.backfaces, this.frontface = t.frontface, this.lineWidth = t.lineWidth, this.pointSize = t.pointSize, this._makeHash() } _makeHash() { var e = this._state, t = ["/spe"]; this._diffuseMap && (t.push("/dm"), this._diffuseMap.hasMatrix && t.push("/mat"), t.push("/" + this._diffuseMap.encoding)), this._emissiveMap && (t.push("/em"), this._emissiveMap.hasMatrix) && t.push("/mat"), this._glossinessMap && (t.push("/gm"), this._glossinessMap.hasMatrix) && t.push("/mat"), this._specularMap && (t.push("/sm"), this._specularMap.hasMatrix) && t.push("/mat"), this._specularGlossinessMap && (t.push("/sgm"), this._specularGlossinessMap.hasMatrix) && t.push("/mat"), this._occlusionMap && (t.push("/ocm"), this._occlusionMap.hasMatrix) && t.push("/mat"), this._normalMap && (t.push("/nm"), this._normalMap.hasMatrix) && t.push("/mat"), this._alphaMap && (t.push("/opm"), this._alphaMap.hasMatrix) && t.push("/mat"), t.push(";"), e.hash = t.join("") } set diffuse(e) { let t = this._state.diffuse; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.diffuse = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get diffuse() { return this._state.diffuse } get diffuseMap() { return this._diffuseMap } set specular(e) { let t = this._state.specular; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.specular = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 1, t[1] = 1, t[2] = 1), this.glRedraw() } get specular() { return this._state.specular } get specularMap() { return this._specularMap } get specularGlossinessMap() { return this._specularGlossinessMap } set glossiness(e) { this._state.glossiness !== (e = null != e ? e : 1) && (this._state.glossiness = e, this.glRedraw()) } get glossiness() { return this._state.glossiness } get glossinessMap() { return this._glossinessMap } set specularF0(e) { this._state.specularF0 !== (e = null != e ? e : 0) && (this._state.specularF0 = e, this.glRedraw()) } get specularF0() { return this._state.specularF0 } set emissive(e) { let t = this._state.emissive; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.emissive = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = 0, t[1] = 0, t[2] = 0), this.glRedraw() } get emissive() { return this._state.emissive } get emissiveMap() { return this._emissiveMap } set alpha(e) { this._state.alpha !== (e = null != e ? e : 1) && (this._state.alpha = e, this.glRedraw()) } get alpha() { return this._state.alpha } get alphaMap() { return this._alphaMap } get normalMap() { return this._normalMap } get occlusionMap() { return this._occlusionMap } set alphaMode(e) { let t = alphaModes[e = e || "opaque"]; void 0 === t && (this.error("Unsupported value for 'alphaMode': " + e + " defaulting to 'opaque'"), t = "opaque"), this._state.alphaMode !== t && (this._state.alphaMode = t, this.glRedraw()) } get alphaMode() { return alphaModeNames[this._state.alphaMode] } set alphaCutoff(e) { this._state.alphaCutoff !== (e = null == e ? .5 : e) && (this._state.alphaCutoff = e) } get alphaCutoff() { return this._state.alphaCutoff } set backfaces(e) { this._state.backfaces !== (e = !!e) && (this._state.backfaces = e, this.glRedraw()) } get backfaces() { return this._state.backfaces } set frontface(e) { this._state.frontface !== (e = "cw" !== e) && (this._state.frontface = e, this.glRedraw()) } get frontface() { return this._state.frontface ? "ccw" : "cw" } set lineWidth(e) { this._state.lineWidth = e || 1, this.glRedraw() } get lineWidth() { return this._state.lineWidth } set pointSize(e) { this._state.pointSize = e || 1, this.glRedraw() } get pointSize() { return this._state.pointSize } destroy() { super.destroy(), this._state.destroy() } } const PRESETS$3 = { default: { fill: !0, fillColor: [.4, .4, .4], fillAlpha: .2, edges: !0, edgeColor: [.2, .2, .2], edgeAlpha: .5, edgeWidth: 1 }, defaultWhiteBG: { fill: !0, fillColor: [1, 1, 1], fillAlpha: .6, edgeColor: [.2, .2, .2], edgeAlpha: 1, edgeWidth: 1 }, defaultLightBG: { fill: !0, fillColor: [.4, .4, .4], fillAlpha: .2, edges: !0, edgeColor: [.2, .2, .2], edgeAlpha: .5, edgeWidth: 1 }, defaultDarkBG: { fill: !0, fillColor: [.4, .4, .4], fillAlpha: .2, edges: !0, edgeColor: [.5, .5, .5], edgeAlpha: .5, edgeWidth: 1 }, phosphorous: { fill: !0, fillColor: [0, 0, 0], fillAlpha: .4, edges: !0, edgeColor: [.9, .9, .9], edgeAlpha: .5, edgeWidth: 2 }, sunset: { fill: !0, fillColor: [.9, .9, .6], fillAlpha: .2, edges: !0, edgeColor: [.9, .9, .9], edgeAlpha: .5, edgeWidth: 1 }, vectorscope: { fill: !0, fillColor: [0, 0, 0], fillAlpha: .7, edges: !0, edgeColor: [.2, 1, .2], edgeAlpha: 1, edgeWidth: 2 }, battlezone: { fill: !0, fillColor: [0, 0, 0], fillAlpha: 1, edges: !0, edgeColor: [.2, 1, .2], edgeAlpha: 1, edgeWidth: 3 }, sepia: { fill: !0, fillColor: [.970588207244873, .7965892553329468, .6660899519920349], fillAlpha: .4, edges: !0, edgeColor: [.529411792755127, .4577854573726654, .4100345969200134], edgeAlpha: 1, edgeWidth: 1 }, yellowHighlight: { fill: !0, fillColor: [1, 1, 0], fillAlpha: .5, edges: !0, edgeColor: [.529411792755127, .4577854573726654, .4100345969200134], edgeAlpha: 1, edgeWidth: 1 }, greenSelected: { fill: !0, fillColor: [0, 1, 0], fillAlpha: .5, edges: !0, edgeColor: [.4577854573726654, .529411792755127, .4100345969200134], edgeAlpha: 1, edgeWidth: 1 }, gamegrid: { fill: !0, fillColor: [.2, .2, .7], fillAlpha: .9, edges: !0, edgeColor: [.4, .4, 1.6], edgeAlpha: .8, edgeWidth: 3 } }; class EmphasisMaterial extends Material { get type() { return "EmphasisMaterial" } get presets() { return PRESETS$3 } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "EmphasisMaterial", fill: null, fillColor: null, fillAlpha: null, edges: null, edgeColor: null, edgeAlpha: null, edgeWidth: null, backfaces: !0, glowThrough: !0 }), this._preset = "default", t.preset ? (this.preset = t.preset, void 0 !== t.fill && (this.fill = t.fill), t.fillColor && (this.fillColor = t.fillColor), void 0 !== t.fillAlpha && (this.fillAlpha = t.fillAlpha), void 0 !== t.edges && (this.edges = t.edges), t.edgeColor && (this.edgeColor = t.edgeColor), void 0 !== t.edgeAlpha && (this.edgeAlpha = t.edgeAlpha), void 0 !== t.edgeWidth && (this.edgeWidth = t.edgeWidth), void 0 !== t.backfaces && (this.backfaces = t.backfaces), void 0 !== t.glowThrough && (this.glowThrough = t.glowThrough)) : (this.fill = t.fill, this.fillColor = t.fillColor, this.fillAlpha = t.fillAlpha, this.edges = t.edges, this.edgeColor = t.edgeColor, this.edgeAlpha = t.edgeAlpha, this.edgeWidth = t.edgeWidth, this.backfaces = t.backfaces, this.glowThrough = t.glowThrough) } set fill(e) { this._state.fill !== (e = !1 !== e) && (this._state.fill = e, this.glRedraw()) } get fill() { return this._state.fill } set fillColor(e) { let t = this._state.fillColor; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.fillColor = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = .4, t[1] = .4, t[2] = .4), this.glRedraw() } get fillColor() { return this._state.fillColor } set fillAlpha(e) { this._state.fillAlpha !== (e = null != e ? e : .2) && (this._state.fillAlpha = e, this.glRedraw()) } get fillAlpha() { return this._state.fillAlpha } set edges(e) { this._state.edges !== (e = !1 !== e) && (this._state.edges = e, this.glRedraw()) } get edges() { return this._state.edges } set edgeColor(e) { let t = this._state.edgeColor; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.edgeColor = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = .2, t[1] = .2, t[2] = .2), this.glRedraw() } get edgeColor() { return this._state.edgeColor } set edgeAlpha(e) { this._state.edgeAlpha !== (e = null != e ? e : .5) && (this._state.edgeAlpha = e, this.glRedraw()) } get edgeAlpha() { return this._state.edgeAlpha } set edgeWidth(e) { this._state.edgeWidth = e || 1, this.glRedraw() } get edgeWidth() { return this._state.edgeWidth } set backfaces(e) { this._state.backfaces !== (e = !!e) && (this._state.backfaces = e, this.glRedraw()) } get backfaces() { return this._state.backfaces } set glowThrough(e) { this._state.glowThrough !== (e = !1 !== e) && (this._state.glowThrough = e, this.glRedraw()) } get glowThrough() { return this._state.glowThrough } set preset(e) { var t; this._preset !== (e = e || "default") && ((t = PRESETS$3[e]) ? (this.fill = t.fill, this.fillColor = t.fillColor, this.fillAlpha = t.fillAlpha, this.edges = t.edges, this.edgeColor = t.edgeColor, this.edgeAlpha = t.edgeAlpha, this.edgeWidth = t.edgeWidth, this.glowThrough = t.glowThrough, this._preset = e) : this.error("unsupported preset: '" + e + "' - supported values are " + Object.keys(PRESETS$3).join(", "))) } get preset() { return this._preset } destroy() { super.destroy(), this._state.destroy() } } const PRESETS$2 = { default: { edgeColor: [0, 0, 0], edgeAlpha: 1, edgeWidth: 1 }, defaultWhiteBG: { edgeColor: [.2, .2, .2], edgeAlpha: 1, edgeWidth: 1 }, defaultLightBG: { edgeColor: [.2, .2, .2], edgeAlpha: 1, edgeWidth: 1 }, defaultDarkBG: { edgeColor: [.5, .5, .5], edgeAlpha: 1, edgeWidth: 1 } }; class EdgeMaterial extends Material { get type() { return "EdgeMaterial" } get presets() { return PRESETS$2 } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "EdgeMaterial", edges: null, edgeColor: null, edgeAlpha: null, edgeWidth: null }), this._preset = "default", t.preset ? (this.preset = t.preset, t.edgeColor && (this.edgeColor = t.edgeColor), void 0 !== t.edgeAlpha && (this.edgeAlpha = t.edgeAlpha), void 0 !== t.edgeWidth && (this.edgeWidth = t.edgeWidth)) : (this.edgeColor = t.edgeColor, this.edgeAlpha = t.edgeAlpha, this.edgeWidth = t.edgeWidth), this.edges = !1 !== t.edges } set edges(e) { this._state.edges !== (e = !1 !== e) && (this._state.edges = e, this.glRedraw()) } get edges() { return this._state.edges } set edgeColor(e) { let t = this._state.edgeColor; if (t) { if (e && t[0] === e[0] && t[1] === e[1] && t[2] === e[2]) return } else t = this._state.edgeColor = new Float32Array(3); e ? (t[0] = e[0], t[1] = e[1], t[2] = e[2]) : (t[0] = .2, t[1] = .2, t[2] = .2), this.glRedraw() } get edgeColor() { return this._state.edgeColor } set edgeAlpha(e) { this._state.edgeAlpha !== (e = null != e ? e : 1) && (this._state.edgeAlpha = e, this.glRedraw()) } get edgeAlpha() { return this._state.edgeAlpha } set edgeWidth(e) { this._state.edgeWidth = e || 1, this.glRedraw() } get edgeWidth() { return this._state.edgeWidth } set preset(e) { var t; this._preset !== (e = e || "default") && ((t = PRESETS$2[e]) ? (this.edgeColor = t.edgeColor, this.edgeAlpha = t.edgeAlpha, this.edgeWidth = t.edgeWidth, this._preset = e) : this.error("unsupported preset: '" + e + "' - supported values are " + Object.keys(PRESETS$2).join(", "))) } get preset() { return this._preset } destroy() { super.destroy(), this._state.destroy() } } class Fresnel extends Component { get type() { return "Fresnel" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ edgeColor: math.vec3([0, 0, 0]), centerColor: math.vec3([1, 1, 1]), edgeBias: 0, centerBias: 1, power: 1 }), this.edgeColor = t.edgeColor, this.centerColor = t.centerColor, this.edgeBias = t.edgeBias, this.centerBias = t.centerBias, this.power = t.power } set edgeColor(e) { this._state.edgeColor.set(e || [0, 0, 0]), this.glRedraw() } get edgeColor() { return this._state.edgeColor } set centerColor(e) { this._state.centerColor.set(e || [1, 1, 1]), this.glRedraw() } get centerColor() { return this._state.centerColor } set edgeBias(e) { this._state.edgeBias = e || 0, this.glRedraw() } get edgeBias() { return this._state.edgeBias } set centerBias(e) { this._state.centerBias = null != e ? e : 1, this.glRedraw() } get centerBias() { return this._state.centerBias } set power(e) { this._state.power = null != e ? e : 1, this.glRedraw() } get power() { return this._state.power } destroy() { super.destroy(), this._state.destroy() } } class Bitmap extends Component { constructor(e, t = {}) { super(e, t), this._type = t.type || (t.src ? t.src.split(".").pop() : null) || "jpg", this._pos = math.vec3(t.pos || [0, 0, 0]), this._up = math.vec3(t.up || [0, 1, 0]), this._normal = math.vec3(t.normal || [0, 0, 1]), this._height = t.height || 1, this._origin = math.vec3(), this._rtcPos = math.vec3(), this._imageSize = math.vec2(), this._texture = new Texture(this), this._image = new Image, "jpg" !== this._type && "png" !== this._type && (this.error('Unsupported type - defaulting to "jpg"'), this._type = "jpg"), this._node = new Node$1(this, { matrix: math.inverseMat4(math.lookAtMat4v(this._pos, math.subVec3(this._pos, this._normal, math.mat4()), this._up, math.mat4())), children: [this._bitmapMesh = new Mesh(this, { scale: [1, 1, 1], rotation: [-90, 0, 0], collidable: t.collidable, pickable: t.pickable, opacity: t.opacity, clippable: t.clippable, geometry: new ReadableGeometry(this, buildPlaneGeometry({ center: [0, 0, 0], xSize: 1, zSize: 1, xSegments: 2, zSegments: 2 })), material: new PhongMaterial(this, { diffuse: [0, 0, 0], ambient: [0, 0, 0], specular: [0, 0, 0], diffuseMap: this._texture, emissiveMap: this._texture, backfaces: !0 }) })] }), t.image ? this.image = t.image : t.src ? this.src = t.src : t.imageData && (this.imageData = t.imageData), this.scene._bitmapCreated(this) } set visible(e) { this._bitmapMesh.visible = e } get visible() { return this._bitmapMesh.visible } set image(e) { this._image = e, this._image && (this._texture.image = this._image, this._imageSize[0] = this._image.width, this._imageSize[1] = this._image.height, this._updateBitmapMeshScale()) } get image() { return this._image } set src(e) { if (e) switch (this._image.onload = () => { this._texture.image = this._image, this._imageSize[0] = this._image.width, this._imageSize[1] = this._image.height, this._updateBitmapMeshScale() }, (this._image.src = e).split(".").pop()) { case "jpeg": case "jpg": this._type = "jpg"; break; case "png": this._type = "png" } } get src() { return this._image.src } set imageData(e) { this._image.onload = () => { this._texture.image = image, this._imageSize[0] = image.width, this._imageSize[1] = image.height, this._updateBitmapMeshScale() }, this._image.src = e } get imageData() { var e = document.createElement("canvas"), t = e.getContext("2d"); return e.width = this._image.width, e.height = this._image.height, t.drawImage(this._image, 0, 0), e.toDataURL("jpg" === this._type ? "image/jpeg" : "image/png") } set type(e) { "png" === (e = e || "jpg") && "jpg" === e || (this.error("Unsupported value for `type` - supported types are `jpg` and `png` - defaulting to `jpg`"), e = "jpg"), this._type = e } get type() { return this._type } get pos() { return this._pos } get normal() { return this._normal } get up() { return this._up } set height(e) { this._height = null == e ? 1 : e, this._image && this._updateBitmapMeshScale() } get height() { return this._height } set collidable(e) { this._bitmapMesh.collidable = !1 !== e } get collidable() { return this._bitmapMesh.collidable } set clippable(e) { this._bitmapMesh.clippable = !1 !== e } get clippable() { return this._bitmapMesh.clippable } set pickable(e) { this._bitmapMesh.pickable = !1 !== e } get pickable() { return this._bitmapMesh.pickable } set opacity(e) { this._bitmapMesh.opacity = e } get opacity() { return this._bitmapMesh.opacity } destroy() { super.destroy(), this.scene._bitmapDestroyed(this) } _updateBitmapMeshScale() { var e = this._imageSize[1] / this._imageSize[0]; this._bitmapMesh.scale = [this._height * e, 1, this._height] } } class LineSet extends Component { constructor(e, t = {}) { if (super(e, t), this._positions = t.positions || [], this._origin = math.vec3(t.origin || [0, 0, 0]), t.indices) this._indices = t.indices; else { this._indices = []; for (let e = 0, t = this._positions.length / 3 - 1; e < t; e += 2)this._indices.push(e), this._indices.push(e + 1) } this._mesh = new Mesh(this, { visible: t.visible, clippable: t.clippable, collidable: t.collidable, geometry: new VBOGeometry(this, { primitive: "lines", positions: this._positions, indices: this._indices, origin: t.origin }), material: new PhongMaterial(this, { diffuse: t.color || [0, 0, 0], emissive: t.color || [0, 0, 0] }) }), this.scene._lineSetCreated(this) } set visible(e) { this._mesh.visible = e } get visible() { return this._mesh.visible } get positions() { return this._positions } get indices() { return this._indices } destroy() { super.destroy(), this.scene._lineSetDestroyed(this) } } class Light extends Component { get type() { return "Light" } get isLight() { return !0 } constructor(e, t = {}) { super(e, t) } } class AmbientLight extends Light { get type() { return "AmbientLight" } constructor(e, t = {}) { super(e, t), this._state = { type: "ambient", color: math.vec3([.7, .7, .7]), intensity: 1 }, this.color = t.color, this.intensity = t.intensity, this.scene._lightCreated(this) } set color(e) { this._state.color.set(e || [.7, .7, .8]), this.glRedraw() } get color() { return this._state.color } set intensity(e) { this._state.intensity = void 0 !== e ? e : 1, this.glRedraw() } get intensity() { return this._state.intensity } destroy() { super.destroy(), this.scene._lightDestroyed(this) } } const Canvas2Image = function () { const e = document.createElement("canvas"), t = String.fromCharCode; if (!e.getContext) return { saveAsBMP: function () { }, saveAsPNG: function () { }, saveAsJPEG: function () { } }; function i(e) { window.open(e) || (document.location.href = e) } function s(e, t) { return "data:" + t + ";base64," + e } function r(e) { var t = document.createElement("img"); return t.src = e, t } function a(e, t, i, s) { var r, a; return t && i ? ((r = document.createElement("canvas")).width = t, r.height = i, r.style.width = t + "px", r.style.height = i + "px", a = r.getContext("2d"), s ? (a.save(), a.scale(1, -1), a.imageSmoothingEnabled = !0, a.drawImage(e, 0, 0, e.width, e.height, 0, 0, t, -i), a.restore()) : (a.imageSmoothingEnabled = !0, a.drawImage(e, 0, 0, e.width, e.height, 0, 0, t, i)), r) : e } const o = !!e.getContext("2d").getImageData, n = !!e.toDataURL, h = !!window.btoa; return { saveAsPNG: function (e, t, s, o, h) { return n && (e = a(e, s, o, h).toDataURL("image/png"), t ? r(e) : (i(e), !0)) }, saveAsJPEG: function (e, t, s, o, h) { var l; return n && (l = "image/jpeg", 5 == (e = a(e, s, o, h).toDataURL(l)).indexOf(l)) && (t ? r(e) : (i(e), !0)) }, saveAsBMP: function (e, l, c, u, p) { return n && o && h && (c = e = a(e, c, u, p), u = parseInt(c.width), p = parseInt(c.height), c = function (e) { var i, s, r = "", a = e.width, o = e.height, n = (r = (r += "BM") + t((h = a * o * 4 + 54) % 256), h = Math.floor(h / 256), r += t(h % 256), h = Math.floor(h / 256), r += t(h % 256), h = Math.floor(h / 256), a), h = (r = (r += t(h % 256)) + t(0, 0, 0, 0, 54, 0, 0, 0) + t(40, 0, 0, 0) + t(n % 256), n = Math.floor(n / 256), r += t(n % 256), n = Math.floor(n / 256), r += t(n % 256), n = Math.floor(n / 256), o), l = (n = (r = (r += t(n % 256)) + t(h % 256), h = Math.floor(h / 256), r += t(h % 256), h = Math.floor(h / 256), r += t(h % 256), h = Math.floor(h / 256), a * o * 4), r = (r += t(h % 256)) + t(1, 0, 32, 0) + t(0, 0, 0, 0) + t(n % 256), n = Math.floor(n / 256), r += t(n % 256), n = Math.floor(n / 256), r += t(n % 256), n = Math.floor(n / 256), r = (r += t(n % 256)) + t(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), e.data); let c, u, p = "", d = o; do { for (s = a * (d - 1) * 4, u = "", c = 0; c < a; c++)u += t(l[s + (i = 4 * c) + 2], l[s + i + 1], l[s + i], l[s + i + 3]) } while (p += u, --d); { let e, i, s = ""; if ("string" == typeof (h = r + p)) s = h; else for (i = h, e = 0; e < i.length; e++)s += t(i[e]); return btoa(s) } }(e = c.getContext("2d").getImageData(0, 0, u, p)), l ? r(s(c, "image/bmp")) : (i(s(c, "image/bmp")), !0)) } } }(); class RenderBuffer { constructor(e, t, i) { i = i || {}, this.gl = t, this.allocated = !1, this.canvas = e, this.buffer = null, this.bound = !1, this.size = i.size, this._hasDepthTexture = !!i.depthTexture } setSize(e) { this.size = e } webglContextRestored(e) { this.gl = e, this.buffer = null, this.allocated = !1, this.bound = !1 } bind() { var e; this._touch(), this.bound || ((e = this.gl).bindFramebuffer(e.FRAMEBUFFER, this.buffer.framebuf), this.bound = !0) } _touch() { let e, t; var i = this.gl; if (t = this.size ? (e = this.size[0], this.size[1]) : (e = i.drawingBufferWidth, i.drawingBufferHeight), this.buffer) { if (this.buffer.width === e && this.buffer.height === t) return; i.deleteTexture(this.buffer.texture), i.deleteFramebuffer(this.buffer.framebuf), i.deleteRenderbuffer(this.buffer.renderbuf) } var s = i.createTexture(); let r; i.bindTexture(i.TEXTURE_2D, s), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, e, t, 0, i.RGBA, i.UNSIGNED_BYTE, null), this._hasDepthTexture && (r = i.createTexture(), i.bindTexture(i.TEXTURE_2D, r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texImage2D(i.TEXTURE_2D, 0, i.DEPTH_COMPONENT32F, e, t, 0, i.DEPTH_COMPONENT, i.FLOAT, null)); var a = i.createRenderbuffer(), o = (i.bindRenderbuffer(i.RENDERBUFFER, a), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT32F, e, t), i.createFramebuffer()); if (i.bindFramebuffer(i.FRAMEBUFFER, o), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, s, 0), this._hasDepthTexture ? i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, r, 0) : i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, a), i.bindTexture(i.TEXTURE_2D, null), i.bindRenderbuffer(i.RENDERBUFFER, null), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.FRAMEBUFFER, o), !i.isFramebuffer(o)) throw "Invalid framebuffer"; i.bindFramebuffer(i.FRAMEBUFFER, null); var n = i.checkFramebufferStatus(i.FRAMEBUFFER); switch (n) { case i.FRAMEBUFFER_COMPLETE: break; case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"; case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"; case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"; case i.FRAMEBUFFER_UNSUPPORTED: throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"; default: throw "Incomplete framebuffer: " + n }this.buffer = { framebuf: o, renderbuf: a, texture: s, depthTexture: r, width: e, height: t }, this.bound = !1 } clear() { if (!this.bound) throw "Render buffer not bound"; var e = this.gl; e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT) } read(e, t) { t = this.gl.drawingBufferHeight - t; var i = new Uint8Array(4), s = this.gl; return s.readPixels(e, t, 1, 1, s.RGBA, s.UNSIGNED_BYTE, i), i } readImage(e) { var t = this.gl, i = (a = this._getImageDataCache()).pixelData, s = a.canvas, r = a.imageData, a = a.context, o = (t.readPixels(0, 0, this.buffer.width, this.buffer.height, t.RGBA, t.UNSIGNED_BYTE, i), r.data.set(i), a.putImageData(r, 0, 0), e.width || s.width), n = e.height || s.height, h = e.format || "jpeg"; let l; switch (h) { case "jpeg": l = Canvas2Image.saveAsJPEG(s, !0, o, n, !0); break; case "png": l = Canvas2Image.saveAsPNG(s, !0, o, n, !0); break; case "bmp": l = Canvas2Image.saveAsBMP(s, !0, o, n, !0); break; default: console.error("Unsupported image format: '" + h + "' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'jpeg'"), l = Canvas2Image.saveAsJPEG(s, !0, o, n, !0) }return l.src } _getImageDataCache() { var e, t, i, s = this.buffer.width, r = this.buffer.height; let a = this._imageDataCache; return !a || a.width === s && a.height === r || (this._imageDataCache = null, a = null), a || ((e = document.createElement("canvas")).width = s, e.height = r, i = (t = e.getContext("2d")).createImageData(s, r), a = { pixelData: new Uint8Array(s * r * 4), canvas: e, context: t, imageData: i, width: s, height: r }, this._imageDataCache = a), a } unbind() { var e = this.gl; e.bindFramebuffer(e.FRAMEBUFFER, null), this.bound = !1 } getTexture() { const e = this; return this._texture || (this._texture = { renderBuffer: this, bind: function (t) { return !(!e.buffer || !e.buffer.texture || (e.gl.activeTexture(e.gl["TEXTURE" + t]), e.gl.bindTexture(e.gl.TEXTURE_2D, e.buffer.texture), 0)) }, unbind: function (t) { e.buffer && e.buffer.texture && (e.gl.activeTexture(e.gl["TEXTURE" + t]), e.gl.bindTexture(e.gl.TEXTURE_2D, null)) } }) } hasDepthTexture() { return this._hasDepthTexture } getDepthTexture() { if (!this._hasDepthTexture) return null; const e = this; return this._depthTexture || (this._dethTexture = { renderBuffer: this, bind: function (t) { return !(!e.buffer || !e.buffer.depthTexture || (e.gl.activeTexture(e.gl["TEXTURE" + t]), e.gl.bindTexture(e.gl.TEXTURE_2D, e.buffer.depthTexture), 0)) }, unbind: function (t) { e.buffer && e.buffer.depthTexture && (e.gl.activeTexture(e.gl["TEXTURE" + t]), e.gl.bindTexture(e.gl.TEXTURE_2D, null)) } }) } destroy() { var e; this.allocated && ((e = this.gl).deleteTexture(this.buffer.texture), e.deleteTexture(this.buffer.depthTexture), e.deleteFramebuffer(this.buffer.framebuf), e.deleteRenderbuffer(this.buffer.renderbuf), this.allocated = !1, this.buffer = null, this.bound = !1), this._imageDataCache = null, this._texture = null, this._depthTexture = null } } class DirLight extends Light { get type() { return "DirLight" } constructor(e, t = {}) { super(e, t), this._shadowRenderBuf = null, this._shadowViewMatrix = null, this._shadowProjMatrix = null, this._shadowViewMatrixDirty = !0, this._shadowProjMatrixDirty = !0; e = this.scene.camera; var i = this.scene.canvas; this._onCameraViewMatrix = e.on("viewMatrix", (() => { this._shadowViewMatrixDirty = !0 })), this._onCameraProjMatrix = e.on("projMatrix", (() => { this._shadowProjMatrixDirty = !0 })), this._onCanvasBoundary = i.on("boundary", (() => { this._shadowProjMatrixDirty = !0 })), this._state = new RenderState({ type: "dir", dir: math.vec3([1, 1, 1]), color: math.vec3([.7, .7, .8]), intensity: 1, space: t.space || "view", castsShadow: !1, getShadowViewMatrix: () => { var e, t, i; return this._shadowViewMatrixDirty && (this._shadowViewMatrix || (this._shadowViewMatrix = math.identityMat4()), e = this.scene.camera, t = this._state.dir, t = [(e = e.look)[0] - t[0], e[1] - t[1], e[2] - t[2]], i = [0, 1, 0], math.lookAtMat4v(t, e, i, this._shadowViewMatrix), this._shadowViewMatrixDirty = !1), this._shadowViewMatrix }, getShadowProjMatrix: () => (this._shadowProjMatrixDirty && (this._shadowProjMatrix || (this._shadowProjMatrix = math.identityMat4()), math.orthoMat4c(-40, 40, -40, 40, -40, 80, this._shadowProjMatrix), this._shadowProjMatrixDirty = !1), this._shadowProjMatrix), getShadowRenderBuf: () => (this._shadowRenderBuf || (this._shadowRenderBuf = new RenderBuffer(this.scene.canvas.canvas, this.scene.canvas.gl, { size: [1024, 1024] })), this._shadowRenderBuf) }), this.dir = t.dir, this.color = t.color, this.intensity = t.intensity, this.castsShadow = t.castsShadow, this.scene._lightCreated(this) } set dir(e) { this._state.dir.set(e || [1, 1, 1]), this._shadowViewMatrixDirty = !0, this.glRedraw() } get dir() { return this._state.dir } set color(e) { this._state.color.set(e || [.7, .7, .8]), this.glRedraw() } get color() { return this._state.color } set intensity(e) { this._state.intensity = e = void 0 !== e ? e : 1, this.glRedraw() } get intensity() { return this._state.intensity } set castsShadow(e) { this._state.castsShadow !== (e = !!e) && (this._state.castsShadow = e, this._shadowViewMatrixDirty = !0, this.glRedraw()) } get castsShadow() { return this._state.castsShadow } destroy() { var e = this.scene.camera, t = this.scene.canvas; e.off(this._onCameraViewMatrix), e.off(this._onCameraProjMatrix), t.off(this._onCanvasBoundary), super.destroy(), this._state.destroy(), this._shadowRenderBuf && this._shadowRenderBuf.destroy(), this.scene._lightDestroyed(this), this.glRedraw() } } class PointLight extends Light { get type() { return "PointLight" } constructor(e, t = {}) { super(e, t); const i = this, s = (this._shadowRenderBuf = null, this._shadowViewMatrix = null, this._shadowProjMatrix = null, this._shadowViewMatrixDirty = !0, this._shadowProjMatrixDirty = !0, this.scene.camera); e = this.scene.canvas, this._onCameraViewMatrix = s.on("viewMatrix", (() => { this._shadowViewMatrixDirty = !0 })), this._onCameraProjMatrix = s.on("projMatrix", (() => { this._shadowProjMatrixDirty = !0 })), this._onCanvasBoundary = e.on("boundary", (() => { this._shadowProjMatrixDirty = !0 })), this._state = new RenderState({ type: "point", pos: math.vec3([1, 1, 1]), color: math.vec3([.7, .7, .8]), intensity: 1, attenuation: [0, 0, 0], space: t.space || "view", castsShadow: !1, getShadowViewMatrix: () => { var e, t, r; return i._shadowViewMatrixDirty && (i._shadowViewMatrix || (i._shadowViewMatrix = math.identityMat4()), e = i._state.pos, t = s.look, r = s.up, math.lookAtMat4v(e, t, r, i._shadowViewMatrix), i._shadowViewMatrixDirty = !1), i._shadowViewMatrix }, getShadowProjMatrix: () => { var e; return i._shadowProjMatrixDirty && (i._shadowProjMatrix || (i._shadowProjMatrix = math.identityMat4()), e = i.scene.canvas.canvas, math.perspectiveMat4(Math.PI / 180 * 70, e.clientWidth / e.clientHeight, .1, 500, i._shadowProjMatrix), i._shadowProjMatrixDirty = !1), i._shadowProjMatrix }, getShadowRenderBuf: () => (i._shadowRenderBuf || (i._shadowRenderBuf = new RenderBuffer(i.scene.canvas.canvas, i.scene.canvas.gl, { size: [1024, 1024] })), i._shadowRenderBuf) }), this.pos = t.pos, this.color = t.color, this.intensity = t.intensity, this.constantAttenuation = t.constantAttenuation, this.linearAttenuation = t.linearAttenuation, this.quadraticAttenuation = t.quadraticAttenuation, this.castsShadow = t.castsShadow, this.scene._lightCreated(this) } set pos(e) { this._state.pos.set(e || [1, 1, 1]), this._shadowViewMatrixDirty = !0, this.glRedraw() } get pos() { return this._state.pos } set color(e) { this._state.color.set(e || [.7, .7, .8]), this.glRedraw() } get color() { return this._state.color } set intensity(e) { this._state.intensity = e = void 0 !== e ? e : 1, this.glRedraw() } get intensity() { return this._state.intensity } set constantAttenuation(e) { this._state.attenuation[0] = e || 0, this.glRedraw() } get constantAttenuation() { return this._state.attenuation[0] } set linearAttenuation(e) { this._state.attenuation[1] = e || 0, this.glRedraw() } get linearAttenuation() { return this._state.attenuation[1] } set quadraticAttenuation(e) { this._state.attenuation[2] = e || 0, this.glRedraw() } get quadraticAttenuation() { return this._state.attenuation[2] } set castsShadow(e) { this._state.castsShadow !== (e = !!e) && (this._state.castsShadow = e, this._shadowViewMatrixDirty = !0, this.glRedraw()) } get castsShadow() { return this._state.castsShadow } destroy() { var e = this.scene.camera, t = this.scene.canvas; e.off(this._onCameraViewMatrix), e.off(this._onCameraProjMatrix), t.off(this._onCanvasBoundary), super.destroy(), this._state.destroy(), this._shadowRenderBuf && this._shadowRenderBuf.destroy(), this.scene._lightDestroyed(this), this.glRedraw() } } function ensureImageSizePowerOfTwo(e) { var t; return isPowerOfTwo(e.width) && isPowerOfTwo(e.height) || ((t = document.createElement("canvas")).width = nextHighestPowerOfTwo(e.width), t.height = nextHighestPowerOfTwo(e.height), t.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, t.width, t.height), e = t), e } function isPowerOfTwo(e) { return !(e & e - 1) } function nextHighestPowerOfTwo(e) { --e; for (let t = 1; t < 32; t <<= 1)e |= e >> t; return e + 1 } class CubeTexture extends Component { get type() { return "CubeTexture" } constructor(e, t = {}) { super(e, t), e = this.scene.canvas.gl, this._state = new RenderState({ texture: new Texture2D({ gl: e, target: e.TEXTURE_CUBE_MAP }), flipY: this._checkFlipY(t.minFilter), encoding: this._checkEncoding(t.encoding), minFilter: 1008, magFilter: LinearFilter, wrapS: ClampToEdgeWrapping, wrapT: ClampToEdgeWrapping, mipmaps: !0 }), this._src = t.src, this._images = [], this._loadSrc(t.src), stats.memory.textures++ } _checkFlipY(e) { return !!e } _checkEncoding(e) { return 3e3 !== (e = e || 3e3) && e !== sRGBEncoding && (this.error("Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding."), e = 3e3), e } _webglContextRestored() { this.scene.canvas.gl, this._state.texture = null, this._src && this._loadSrc(this._src) } _loadSrc(e) { const t = this, i = this.scene.canvas.gl; let s = !(this._images = []), r = 0; for (let a = 0; a < e.length; a++) { const o = new Image; o.onload = function () { let e = o; const n = a; return function () { if (!s && (e = ensureImageSizePowerOfTwo(e), t._images[n] = e, 6 == ++r)) { let e = t._state.texture; e || (e = new Texture2D({ gl: i, target: i.TEXTURE_CUBE_MAP }), t._state.texture = e), e.setImage(t._images, t._state), t.fire("loaded", t._src, !1), t.glRedraw() } } }(), o.onerror = function () { s = !0 }, o.src = e[a] } } destroy() { super.destroy(), this._state.texture && this._state.texture.destroy(), stats.memory.textures--, this._state.destroy() } } class ReflectionMap extends CubeTexture { get type() { return "ReflectionMap" } constructor(e, t = {}) { super(e, t), this.scene._lightsState.addReflectionMap(this._state), this.scene._reflectionMapCreated(this) } destroy() { super.destroy(), this.scene._reflectionMapDestroyed(this) } } class LightMap extends CubeTexture { get type() { return "LightMap" } constructor(e, t = {}) { super(e, t), this.scene._lightMapCreated(this) } destroy() { super.destroy(), this.scene._lightMapDestroyed(this) } } const ENTITY_FLAGS = { VISIBLE: 1, CULLED: 4, PICKABLE: 8, CLIPPABLE: 16, COLLIDABLE: 32, CAST_SHADOW: 64, RECEIVE_SHADOW: 128, XRAYED: 256, HIGHLIGHTED: 512, SELECTED: 1024, EDGES: 2048, BACKFACES: 4096, TRANSPARENT: 8192 }, tempFloatRGB = new Float32Array([0, 0, 0]), tempIntRGB = new Uint16Array([0, 0, 0]); class VBOSceneModelNode { constructor(e, t, i, s, r, a) { this._isObject = t, this.scene = e.scene, this.model = e, this.meshes = s; for (var o = this._numTriangles = 0, n = this.meshes.length; o < n; o++) { var h = this.meshes[o]; (h.parent = this)._numTriangles += h.numTriangles } this.id = i, this.originalSystemId = math.unglobalizeObjectId(e.id, i), this._flags = r, this._aabb = a, this._offsetAABB = math.AABB3(a), this._offset = math.vec3(), this._colorizeUpdated = !1, this._opacityUpdated = !1, this._isObject && e.scene._registerObject(this) } get isEntity() { return !0 } get isModel() { return !1 } get isObject() { return this._isObject } get aabb() { return this._offsetAABB } get numTriangles() { return this._numTriangles } get visible() { return this._getFlag(ENTITY_FLAGS.VISIBLE) } set visible(e) { if (!!(this._flags & ENTITY_FLAGS.VISIBLE) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.VISIBLE : this._flags & ~ENTITY_FLAGS.VISIBLE; for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setVisible(this._flags); this._isObject && this.model.scene._objectVisibilityUpdated(this), this.model.glRedraw() } } get highlighted() { return this._getFlag(ENTITY_FLAGS.HIGHLIGHTED) } set highlighted(e) { if (!!(this._flags & ENTITY_FLAGS.HIGHLIGHTED) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.HIGHLIGHTED : this._flags & ~ENTITY_FLAGS.HIGHLIGHTED; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setHighlighted(this._flags); this._isObject && this.model.scene._objectHighlightedUpdated(this), this.model.glRedraw() } } get xrayed() { return this._getFlag(ENTITY_FLAGS.XRAYED) } set xrayed(e) { if (!!(this._flags & ENTITY_FLAGS.XRAYED) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.XRAYED : this._flags & ~ENTITY_FLAGS.XRAYED; for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setXRayed(this._flags); this._isObject && this.model.scene._objectXRayedUpdated(this), this.model.glRedraw() } } get selected() { return this._getFlag(ENTITY_FLAGS.SELECTED) } set selected(e) { if (!!(this._flags & ENTITY_FLAGS.SELECTED) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.SELECTED : this._flags & ~ENTITY_FLAGS.SELECTED; for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setSelected(this._flags); this._isObject && this.model.scene._objectSelectedUpdated(this), this.model.glRedraw() } } get edges() { return this._getFlag(ENTITY_FLAGS.EDGES) } set edges(e) { if (!!(this._flags & ENTITY_FLAGS.EDGES) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.EDGES : this._flags & ~ENTITY_FLAGS.EDGES; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setEdges(this._flags); this.model.glRedraw() } } get culled() { return this._getFlag(ENTITY_FLAGS.CULLED) } set culled(e) { if (!!(this._flags & ENTITY_FLAGS.CULLED) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.CULLED : this._flags & ~ENTITY_FLAGS.CULLED; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setCulled(this._flags); this.model.glRedraw() } } get clippable() { return this._getFlag(ENTITY_FLAGS.CLIPPABLE) } set clippable(e) { if (!!(this._flags & ENTITY_FLAGS.CLIPPABLE) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.CLIPPABLE : this._flags & ~ENTITY_FLAGS.CLIPPABLE; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setClippable(this._flags); this.model.glRedraw() } } get collidable() { return this._getFlag(ENTITY_FLAGS.COLLIDABLE) } set collidable(e) { if (!!(this._flags & ENTITY_FLAGS.COLLIDABLE) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.COLLIDABLE : this._flags & ~ENTITY_FLAGS.COLLIDABLE; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setCollidable(this._flags) } } get pickable() { return this._getFlag(ENTITY_FLAGS.PICKABLE) } set pickable(e) { if (!!(this._flags & ENTITY_FLAGS.PICKABLE) !== e) { this._flags = e ? this._flags | ENTITY_FLAGS.PICKABLE : this._flags & ~ENTITY_FLAGS.PICKABLE; for (var t = 0, i = this.meshes.length; t < i; t++)this.meshes[t]._setPickable(this._flags) } } get colorize() { var e; return 0 === this.meshes.length ? null : (e = this.meshes[0]._colorize, tempFloatRGB[0] = e[0] / 255, tempFloatRGB[1] = e[1] / 255, tempFloatRGB[2] = e[2] / 255, tempFloatRGB) } set colorize(e) { if (e) { tempIntRGB[0] = Math.floor(255 * e[0]), tempIntRGB[1] = Math.floor(255 * e[1]), tempIntRGB[2] = Math.floor(255 * e[2]); for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setColorize(tempIntRGB) } else for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setColorize(null); this._isObject && (this.scene._objectColorizeUpdated(this, e = !!e), this._colorizeUpdated = e), this.model.glRedraw() } get opacity() { return 0 < this.meshes.length ? this.meshes[0]._colorize[3] / 255 : 1 } set opacity(e) { if (0 !== this.meshes.length) { var t = null != e, i = this.meshes[0]._colorize[3]; let s = 255; if (t) { if (e < 0 ? e = 0 : 1 < e && (e = 1), i === (s = Math.floor(255 * e))) return } else if (i === (s = 255)) return; for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setOpacity(s, this._flags); this._isObject && (this.scene._objectOpacityUpdated(this, t), this._opacityUpdated = t), this.model.glRedraw() } } get offset() { return this._offset } set offset(e) { e ? (this._offset[0] = e[0], this._offset[1] = e[1], this._offset[2] = e[2]) : (this._offset[0] = 0, this._offset[1] = 0, this._offset[2] = 0); for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._setOffset(this._offset); this._offsetAABB[0] = this._aabb[0] + this._offset[0], this._offsetAABB[1] = this._aabb[1] + this._offset[1], this._offsetAABB[2] = this._aabb[2] + this._offset[2], this._offsetAABB[3] = this._aabb[3] + this._offset[0], this._offsetAABB[4] = this._aabb[4] + this._offset[1], this._offsetAABB[5] = this._aabb[5] + this._offset[2], this.scene._aabbDirty = !0, this.scene._objectOffsetUpdated(this, e), this.model._aabbDirty = !0, this.model.glRedraw() } get castsShadow() { return !1 } set castsShadow(e) { } get receivesShadow() { return !1 } set receivesShadow(e) { } get saoEnabled() { return this.model.saoEnabled } _getFlag(e) { return !!(this._flags & e) } _finalize() { var e = this.model.scene; this._isObject && (this.visible && e._objectVisibilityUpdated(this), this.highlighted && e._objectHighlightedUpdated(this), this.xrayed && e._objectXRayedUpdated(this), this.selected) && e._objectSelectedUpdated(this); for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._finalize(this._flags) } _finalize2() { for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._finalize2() } _destroy() { var e = this.model.scene; this._isObject && (e._deregisterObject(this), this.visible && e._objectVisibilityUpdated(this, !1), this.xrayed && e._objectXRayedUpdated(this), this.selected && e._objectSelectedUpdated(this), this.highlighted && e._objectHighlightedUpdated(this), this._opacityUpdated && this.scene._objectColorizeUpdated(this, !1), this._opacityUpdated && this.scene._objectOpacityUpdated(this, !1), this.scene._objectOffsetUpdated(this, !1)); for (let e = 0, t = this.meshes.length; e < t; e++)this.meshes[e]._destroy(); e._aabbDirty = !0 } } const tempVec4a$b = math.vec4(), tempVec4b$b = math.vec4(); class Marker extends Component { constructor(e, t) { super(e, t), this._entity = null, this._visible = null, this._worldPos = math.vec3(), this._origin = math.vec3(), this._rtcPos = math.vec3(), this._viewPos = math.vec3(), this._canvasPos = math.vec2(), this._occludable = !1, this._onCameraViewMatrix = this.scene.camera.on("matrix", (() => { this._viewPosDirty = !0, this._needUpdate() })), this._onCameraProjMatrix = this.scene.camera.on("projMatrix", (() => { this._canvasPosDirty = !0, this._needUpdate() })), this._onEntityDestroyed = null, this._onEntityModelDestroyed = null, this._renderer.addMarker(this), this.entity = t.entity, this.worldPos = t.worldPos, this.occludable = t.occludable } _update() { var e; this._viewPosDirty && (math.transformPoint3(this.scene.camera.viewMatrix, this._worldPos, this._viewPos), this._viewPosDirty = !1, this._canvasPosDirty = !0, this.fire("viewPos", this._viewPos)), this._canvasPosDirty && (tempVec4a$b.set(this._viewPos), tempVec4a$b[3] = 1, math.transformPoint4(this.scene.camera.projMatrix, tempVec4a$b, tempVec4b$b), e = this.scene.canvas.boundary, this._canvasPos[0] = Math.floor((1 + tempVec4b$b[0] / tempVec4b$b[3]) * e[2] / 2), this._canvasPos[1] = Math.floor((1 - tempVec4b$b[1] / tempVec4b$b[3]) * e[3] / 2), this._canvasPosDirty = !1, this.fire("canvasPos", this._canvasPos)) } _setVisible(e) { this._visible, this._visible = e, this.fire("visible", this._visible) } set entity(e) { if (this._entity) { if (this._entity === e) return; null !== this._onEntityDestroyed && (this._entity.off(this._onEntityDestroyed), this._onEntityDestroyed = null), null !== this._onEntityModelDestroyed && (this._entity.model.off(this._onEntityModelDestroyed), this._onEntityModelDestroyed = null) } this._entity = e, this._entity && (this._entity instanceof VBOSceneModelNode ? this._onEntityModelDestroyed = this._entity.model.on("destroyed", (() => { this._entity = null, this._onEntityModelDestroyed = null })) : this._onEntityDestroyed = this._entity.on("destroyed", (() => { this._entity = null, this._onEntityDestroyed = null }))), this.fire("entity", this._entity, !0) } get entity() { return this._entity } set occludable(e) { (e = !!e) !== this._occludable && (this._occludable = e) } get occludable() { return this._occludable } set worldPos(e) { this._worldPos.set(e || [0, 0, 0]), worldToRTCPos(this._worldPos, this._origin, this._rtcPos), this._occludable && this._renderer.markerWorldPosUpdated(this), this._viewPosDirty = !0, this.fire("worldPos", this._worldPos), this._needUpdate() } get worldPos() { return this._worldPos } get origin() { return this._origin } get rtcPos() { return this._rtcPos } get viewPos() { return this._update(), this._viewPos } get canvasPos() { return this._update(), this._canvasPos } get visible() { return !!this._visible } destroy() { this.fire("destroyed", !0), this.scene.camera.off(this._onCameraViewMatrix), this.scene.camera.off(this._onCameraProjMatrix), this._entity && (null !== this._onEntityDestroyed && this._entity.off(this._onEntityDestroyed), null !== this._onEntityModelDestroyed) && this._entity.model.off(this._onEntityModelDestroyed), this._renderer.removeMarker(this), super.destroy() } } class SpriteMarker extends Marker { constructor(e, t = {}) { super(e, { entity: t.entity, occludable: t.occludable, worldPos: t.worldPos }), this._occluded = !1, this._visible = !0, this._src = null, this._image = null, this._pos = math.vec3(), this._origin = math.vec3(), this._rtcPos = math.vec3(), this._dir = math.vec3(), this._size = 1, this._imageSize = math.vec2(), this._texture = new Texture(this, { src: t.src }), this._geometry = new ReadableGeometry(this, { primitive: "triangles", positions: [3, 3, 0, -3, 3, 0, -3, -3, 0, 3, -3, 0], normals: [-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0], uv: [1, -1, 0, -1, 0, 0, 1, 0], indices: [0, 1, 2, 0, 2, 3] }), this._mesh = new Mesh(this, { geometry: this._geometry, material: new PhongMaterial(this, { ambient: [.9, .3, .9], shininess: 30, diffuseMap: this._texture, backfaces: !0 }), scale: [1, 1, 1], position: t.worldPos, rotation: [90, 0, 0], billboard: "spherical", occluder: !1 }), this.visible = !0, this.collidable = t.collidable, this.clippable = t.clippable, this.pickable = t.pickable, this.opacity = t.opacity, this.size = t.size, t.image ? this.image = t.image : this.src = t.src } _setVisible(e) { this._occluded = !e, this._mesh.visible = this._visible && !this._occluded, super._setVisible(e) } set visible(e) { this._visible = null == e || e, this._mesh.visible = this._visible && !this._occluded } get visible() { return this._visible } set image(e) { this._image = e, this._image && (this._imageSize[0] = this._image.width, this._imageSize[1] = this._image.height, this._updatePlaneSizeFromImage(), this._src = null, this._texture.image = this._image) } get image() { return this._image } set src(e) { if (this._src = e, this._src) { this._image = null; const e = new Image; e.onload = () => { this._texture.image = e, this._imageSize[0] = e.width, this._imageSize[1] = e.height, this._updatePlaneSizeFromImage() }, e.src = this._src } } get src() { return this._src } set size(e) { this._size = null == e ? 1 : e, this._image && this._updatePlaneSizeFromImage() } get size() { return this._size } set collidable(e) { this._mesh.collidable = !1 !== e } get collidable() { return this._mesh.collidable } set clippable(e) { this._mesh.clippable = !1 !== e } get clippable() { return this._mesh.clippable } set pickable(e) { this._mesh.pickable = !1 !== e } get pickable() { return this._mesh.pickable } set opacity(e) { this._mesh.opacity = e } get opacity() { return this._mesh.opacity } _updatePlaneSizeFromImage() { var e = .5 * this._size, t = this._imageSize[0], i = this._imageSize[1], s = i / t; this._geometry.positions = i < t ? [e, e * s, 0, -e, e * s, 0, -e, -e * s, 0, e, -e * s, 0] : [e / s, e, 0, -e / s, e, 0, -e / s, -e, 0, e / s, -e, 0] } } class CameraMemento { constructor(e) { this._eye = math.vec3(), this._look = math.vec3(), this._up = math.vec3(), this._projection = {}, e && this.saveCamera(e) } saveCamera(e) { var t = (e = e.camera).project; switch (this._eye.set(e.eye), this._look.set(e.look), this._up.set(e.up), e.projection) { case "perspective": this._projection = { projection: "perspective", fov: t.fov, fovAxis: t.fovAxis, near: t.near, far: t.far }; break; case "ortho": this._projection = { projection: "ortho", scale: t.scale, near: t.near, far: t.far }; break; case "frustum": this._projection = { projection: "frustum", left: t.left, right: t.right, top: t.top, bottom: t.bottom, near: t.near, far: t.far }; break; case "custom": this._projection = { projection: "custom", matrix: t.matrix.slice() } } } restoreCamera(e, t) { const i = e.camera, s = this._projection; function r() { switch (s.type) { case "perspective": i.perspective.fov = s.fov, i.perspective.fovAxis = s.fovAxis, i.perspective.near = s.near, i.perspective.far = s.far; break; case "ortho": i.ortho.scale = s.scale, i.ortho.near = s.near, i.ortho.far = s.far; break; case "frustum": i.frustum.left = s.left, i.frustum.right = s.right, i.frustum.top = s.top, i.frustum.bottom = s.bottom, i.frustum.near = s.near, i.frustum.far = s.far; break; case "custom": i.customProjection.matrix = s.matrix } } t ? e.viewer.cameraFlight.flyTo({ eye: this._eye, look: this._look, up: this._up, orthoScale: s.scale, projection: s.projection }, (() => { r(), t() })) : (i.eye = this._eye, i.look = this._look, i.up = this._up, r(), i.projection = s.projection) } } const color$1 = math.vec3(); class ModelMemento { constructor(e) { var t; this.objectsVisible = [], this.objectsEdges = [], this.objectsXrayed = [], this.objectsHighlighted = [], this.objectsSelected = [], this.objectsClippable = [], this.objectsPickable = [], this.objectsColorize = [], this.objectsOpacity = [], this.numObjects = 0, e && (t = e.metaScene.scene, this.saveObjects(t, e)) } saveObjects(e, t, i) { if (t = t.rootMetaObject) for (var s = t.getObjectIDsInSubtree(), r = (this.numObjects = 0, this._mask = i ? utils.apply(i, {}) : null, e.objects), a = !i || i.visible, o = !i || i.edges, n = !i || i.xrayed, h = !i || i.highlighted, l = !i || i.selected, c = !i || i.clippable, u = !i || i.pickable, p = !i || i.colorize, d = !i || i.opacity, m = 0, f = s.length; m < f; m++) { var g, _ = r[s[m]]; _ && (a && (this.objectsVisible[m] = _.visible), o && (this.objectsEdges[m] = _.edges), n && (this.objectsXrayed[m] = _.xrayed), h && (this.objectsHighlighted[m] = _.highlighted), l && (this.objectsSelected[m] = _.selected), c && (this.objectsClippable[m] = _.clippable), u && (this.objectsPickable[m] = _.pickable), p && (g = _.colorize, this.objectsColorize[3 * m + 0] = g[0], this.objectsColorize[3 * m + 1] = g[1], this.objectsColorize[3 * m + 2] = g[2]), d && (this.objectsOpacity[m] = _.opacity), this.numObjects++) } } restoreObjects(e, t) { if (t = t.rootMetaObject) for (var i = t.getObjectIDsInSubtree(), s = !(t = this._mask) || t.visible, r = !t || t.edges, a = !t || t.xrayed, o = !t || t.highlighted, n = !t || t.selected, h = !t || t.clippable, l = !t || t.pickable, c = !t || t.colorize, u = !t || t.opacity, p = e.objects, d = 0, m = i.length; d < m; d++) { var f = p[i[d]]; f && (s && (f.visible = this.objectsVisible[d]), r && (f.edges = this.objectsEdges[d]), a && (f.xrayed = this.objectsXrayed[d]), o && (f.highlighted = this.objectsHighlighted[d]), n && (f.selected = this.objectsSelected[d]), h && (f.clippable = this.objectsClippable[d]), l && (f.pickable = this.objectsPickable[d]), c && (color$1[0] = this.objectsColorize[3 * d + 0], color$1[1] = this.objectsColorize[3 * d + 1], color$1[2] = this.objectsColorize[3 * d + 2], f.colorize = color$1), u) && (f.opacity = this.objectsOpacity[d]) } } } const color = math.vec3(); class ObjectsMemento { constructor() { this.objectsVisible = [], this.objectsEdges = [], this.objectsXrayed = [], this.objectsHighlighted = [], this.objectsSelected = [], this.objectsClippable = [], this.objectsPickable = [], this.objectsColorize = [], this.objectsHasColorize = [], this.objectsOpacity = [], this.numObjects = 0 } saveObjects(e, t) { this.numObjects = 0, this._mask = t ? utils.apply(t, {}) : null; var i, s, r, a, o = e.objects, n = !t || t.visible, h = !t || t.edges, l = !t || t.xrayed, c = !t || t.highlighted, u = !t || t.selected, p = !t || t.clippable, d = !t || t.pickable, m = !t || t.colorize, f = !t || t.opacity; for (i in o) o.hasOwnProperty(i) && (s = o[i], r = this.numObjects, n && (this.objectsVisible[r] = s.visible), h && (this.objectsEdges[r] = s.edges), l && (this.objectsXrayed[r] = s.xrayed), c && (this.objectsHighlighted[r] = s.highlighted), u && (this.objectsSelected[r] = s.selected), p && (this.objectsClippable[r] = s.clippable), d && (this.objectsPickable[r] = s.pickable), m && ((a = s.colorize) ? (this.objectsColorize[3 * r + 0] = a[0], this.objectsColorize[3 * r + 1] = a[1], this.objectsColorize[3 * r + 2] = a[2], this.objectsHasColorize[r] = !0) : this.objectsHasColorize[r] = !1), f && (this.objectsOpacity[r] = s.opacity), this.numObjects++) } restoreObjects(e) { var t, i, s = this._mask, r = !s || s.visible, a = !s || s.edges, o = !s || s.xrayed, n = !s || s.highlighted, h = !s || s.selected, l = !s || s.clippable, c = !s || s.pickable, u = !s || s.colorize, p = !s || s.opacity, d = 0, m = e.objects; for (t in m) m.hasOwnProperty(t) && (i = m[t], r && (i.visible = this.objectsVisible[d]), a && (i.edges = this.objectsEdges[d]), o && (i.xrayed = this.objectsXrayed[d]), n && (i.highlighted = this.objectsHighlighted[d]), h && (i.selected = this.objectsSelected[d]), l && (i.clippable = this.objectsClippable[d]), c && (i.pickable = this.objectsPickable[d]), u && (this.objectsHasColorize[d] ? (color[0] = this.objectsColorize[3 * d + 0], color[1] = this.objectsColorize[3 * d + 1], color[2] = this.objectsColorize[3 * d + 2], i.colorize = color) : i.colorize = null), p && (i.opacity = this.objectsOpacity[d]), d++) } } class CubicBezierCurve extends Curve { constructor(e, t = {}) { super(e, t), this.v0 = t.v0, this.v1 = t.v1, this.v2 = t.v2, this.v3 = t.v3, this.t = t.t } set v0(e) { this._v0 = e || math.vec3([0, 0, 0]) } get v0() { return this._v0 } set v1(e) { this._v1 = e || math.vec3([0, 0, 0]) } get v1() { return this._v1 } set v2(e) { this._v2 = e || math.vec3([0, 0, 0]) } get v2() { return this._v2 } set v3(e) { this.fire("v3", this._v3 = e || math.vec3([0, 0, 0])) } get v3() { return this._v3 } set t(e) { this._t = (e = e || 0) < 0 ? 0 : 1 < e ? 1 : e } get t() { return this._t } get point() { return this.getPoint(this._t) } getPoint(e) { var t = math.vec3(); return t[0] = math.b3(e, this._v0[0], this._v1[0], this._v2[0], this._v3[0]), t[1] = math.b3(e, this._v0[1], this._v1[1], this._v2[1], this._v3[1]), t[2] = math.b3(e, this._v0[2], this._v1[2], this._v2[2], this._v3[2]), t } getJSON() { return { v0: this._v0, v1: this._v1, v2: this._v2, v3: this._v3, t: this._t } } } class Path extends Curve { constructor(e, t = {}) { super(e, t), this._cachedLengths = [], this._dirty = !0, this._curves = [], this._t = 0, this._dirtySubs = [], this._destroyedSubs = [], this.curves = t.curves || [], this.t = t.t } addCurve(e) { this._curves.push(e), this._dirty = !0 } set curves(e) { var t, i; for (e = e || [], t = 0, i = this._curves.length; t < i; t++)(o = this._curves[t]).off(this._dirtySubs[t]), o.off(this._destroyedSubs[t]); this._curves = [], this._dirtySubs = [], this._destroyedSubs = []; var s = this; function r() { s._dirty = !0 } function a() { var e = this.id; for (t = 0, i = s._curves.length; t < i; t++)if (s._curves[t].id === e) return s._curves = s._curves.slice(t, t + 1), s._dirtySubs = s._dirtySubs.slice(t, t + 1), s._destroyedSubs = s._destroyedSubs.slice(t, t + 1), void (s._dirty = !0) } for (t = 0, i = e.length; t < i; t++) { if (o = e[t], utils.isNumeric(o) || utils.isString(o)) { var o, n = o; if (!(o = this.scene.components[n])) { this.error("Component not found: " + _inQuotes(n)); continue } } "xeokit.SplineCurve" !== (n = o.type) && "xeokit.Path" !== n && "xeokit.CubicBezierCurve" !== n && "xeokit.QuadraticBezierCurve" !== n ? this.error("Component " + _inQuotes(o.id) + " is not a xeokit.SplineCurve, xeokit.Path or xeokit.QuadraticBezierCurve") : (this._curves.push(o), this._dirtySubs.push(o.on("dirty", r)), this._destroyedSubs.push(o.once("destroyed", a))) } this._dirty = !0 } get curves() { return this._curves } set t(e) { this._t = (e = e || 0) < 0 ? 0 : 1 < e ? 1 : e } get t() { return this._t } get point() { return this.getPoint(this._t) } get length() { var e = this._getCurveLengths(); return e[e.length - 1] } getPoint(e) { for (var t, i, s = e * this.length, r = this._getCurveLengths(), a = 0; a < r.length;) { if (r[a] >= s) return i = 1 - (r[a] - s) / (t = this._curves[a]).length, t.getPointAt(i); a++ } return null } _getCurveLengths() { if (!this._dirty) return this._cachedLengths; for (var e = [], t = 0, i = this._curves.length, s = 0; s < i; s++)t += this._curves[s].length, e.push(t); return this._cachedLengths = e, this._dirty = !1, e } _getJSON() { for (var e = [], t = 0, i = this._curves.length; t < i; t++)e.push(this._curves[t].id); return { curves: e, t: this._t } } destroy() { var e, t, i; for (super.destroy(), e = 0, t = this._curves.length; e < t; e++)(i = this._curves[e]).off(this._dirtySubs[e]), i.off(this._destroyedSubs[e]) } } class QuadraticBezierCurve extends Curve { constructor(e, t = {}) { super(e, t), this.v0 = t.v0, this.v1 = t.v1, this.v2 = t.v2, this.t = t.t } set v0(e) { this._v0 = e || math.vec3([0, 0, 0]) } get v0() { return this._v0 } set v1(e) { this._v1 = e || math.vec3([0, 0, 0]) } get v1() { return this._v1 } set v2(e) { this._v2 = e || math.vec3([0, 0, 0]) } get v2() { return this._v2 } set t(e) { this._t = (e = e || 0) < 0 ? 0 : 1 < e ? 1 : e } get t() { return this._t } get point() { return this.getPoint(this._t) } getPoint(e) { var t = math.vec3(); return t[0] = math.b2(e, this._v0[0], this._v1[0], this._v2[0]), t[1] = math.b2(e, this._v0[1], this._v1[1], this._v2[1]), t[2] = math.b2(e, this._v0[2], this._v1[2], this._v2[2]), t } getJSON() { return { v0: this._v0, v1: this._v1, v2: this._v2, t: this._t } } } class SceneModel { get objects() { } get origin() { } get position() { } get rotation() { } get quaternion() { } get scale() { } get matrix() { } get worldMatrix() { } get worldNormalMatrix() { } get viewMatrix() { } get viewNormalMatrix() { } get backfaces() { } set backfaces(e) { } get entityList() { } get isEntity() { } get isModel() { } get isObject() { } get aabb() { } get numTriangles() { } get numLines() { } get numPoints() { } get visible() { } set visible(e) { } get xrayed() { } set xrayed(e) { } get highlighted() { } set highlighted(e) { } get selected() { } set selected(e) { } get edges() { } set edges(e) { } get culled() { } set culled(e) { } get clippable() { } set clippable(e) { } get collidable() { } set collidable(e) { } get pickable() { } set pickable(e) { } get colorize() { } set colorize(e) { } get opacity() { } set opacity(e) { } get castsShadow() { } set castsShadow(e) { } get receivesShadow() { } set receivesShadow(e) { } get saoEnabled() { } get pbrEnabled() { } get colorTextureEnabled() { } get isDrawable() { } get isStateSortable() { } get xrayMaterial() { } get highlightMaterial() { } get selectedMaterial() { } get edgeMaterial() { } getPickViewMatrix(e) { } createGeometry(e) { } createTexture(e) { } createTextureSet(e) { } createMesh(e) { } createEntity(e) { } finalize() { } stateSortCompare(e, t) { } drawColorOpaque(e) { } drawColorTransparent(e) { } drawDepth(e) { } drawNormals(e) { } drawSilhouetteXRayed(e) { } drawSilhouetteHighlighted(e) { } drawSilhouetteSelected(e) { } drawEdgesColorOpaque(e) { } drawEdgesColorTransparent(e) { } drawEdgesXRayed(e) { } drawEdgesHighlighted(e) { } drawEdgesSelected(e) { } drawOcclusion(e) { } drawShadow(e) { } drawPickMesh(e) { } drawPickDepths(e) { } drawPickNormals(e) { } destroy() { } } class VBOSceneModelMesh { constructor(e, t, i, s, r = null, a = 0) { this.model = e, this.object = null, this.parent = null, this.id = t, this.pickId = this.model.scene._renderer.getPickID(this), this.aabb = math.AABB3(), this._layer = r, this._portionId = a, this._color = [i[0], i[1], i[2], s], this._colorize = [i[0], i[1], i[2], s], this._colorizing = !1, this._transparent = s < 255, this.numTriangles = 0, this.origin = null } _finalize(e) { this._layer.initFlags(this._portionId, e, this._transparent) } _finalize2() { this._layer.flushInitFlags && this._layer.flushInitFlags() } _setVisible(e) { this._layer.setVisible(this._portionId, e, this._transparent) } _setColor(e) { this._color[0] = e[0], this._color[1] = e[1], this._color[2] = e[2], this._colorizing || this._layer.setColor(this._portionId, this._color, !1) } _setColorize(e) { e ? (this._colorize[0] = e[0], this._colorize[1] = e[1], this._colorize[2] = e[2], this._layer.setColor(this._portionId, this._colorize, !1), this._colorizing = !0) : (this._layer.setColor(this._portionId, this._color, !1), this._colorizing = !1) } _setOpacity(e, t) { var i = e < 255, s = this._transparent !== i; this._color[3] = e, this._colorize[3] = e, this._transparent = i, this._colorizing ? this._layer.setColor(this._portionId, this._colorize) : this._layer.setColor(this._portionId, this._color), s && this._layer.setTransparent(this._portionId, t, i) } _setOffset(e) { this._layer.setOffset(this._portionId, e) } _setHighlighted(e) { this._layer.setHighlighted(this._portionId, e, this._transparent) } _setXRayed(e) { this._layer.setXRayed(this._portionId, e, this._transparent) } _setSelected(e) { this._layer.setSelected(this._portionId, e, this._transparent) } _setEdges(e) { this._layer.setEdges(this._portionId, e, this._transparent) } _setClippable(e) { this._layer.setClippable(this._portionId, e, this._transparent) } _setCollidable(e) { this._layer.setCollidable(this._portionId, e) } _setPickable(e) { this._layer.setPickable(this._portionId, e, this._transparent) } _setCulled(e) { this._layer.setCulled(this._portionId, e, this._transparent) } canPickTriangle() { return !1 } drawPickTriangles(e, t) { } pickTriangleSurface(e) { } precisionRayPickSurface(e, t, i, s) { return !!this._layer.precisionRayPickSurface && this._layer.precisionRayPickSurface(this._portionId, e, t, i, s) } canPickWorldPos() { return !0 } drawPickDepths(e) { this.model.drawPickDepths(e) } drawPickNormals(e) { this.model.drawPickNormals(e) } delegatePickedEntity() { return this.parent } _destroy() { this.model.scene._renderer.putPickID(this.pickId) } } class ScratchMemory { constructor() { this._uint8Arrays = {}, this._float32Arrays = {} } _clear() { this._uint8Arrays = {}, this._float32Arrays = {} } getUInt8Array(e) { let t = this._uint8Arrays[e]; return t || (t = new Uint8Array(e), this._uint8Arrays[e] = t), t } getFloat32Array(e) { let t = this._float32Arrays[e]; return t || (t = new Float32Array(e), this._float32Arrays[e] = t), t } } const batchingLayerScratchMemory = new ScratchMemory; let countUsers = 0; function getScratchMemory() { return countUsers++, batchingLayerScratchMemory } function putScratchMemory() { 0 !== countUsers && 0 == --countUsers && batchingLayerScratchMemory._clear() } const RENDER_PASSES = { NOT_RENDERED: 0, COLOR_OPAQUE: 1, COLOR_TRANSPARENT: 2, SILHOUETTE_HIGHLIGHTED: 3, SILHOUETTE_SELECTED: 4, SILHOUETTE_XRAYED: 5, EDGES_COLOR_OPAQUE: 6, EDGES_COLOR_TRANSPARENT: 7, EDGES_HIGHLIGHTED: 8, EDGES_SELECTED: 9, EDGES_XRAYED: 10, PICK: 11 }, tempVec4$7 = math.vec4(), tempVec3a$Y = math.vec3(); class TrianglesBatchingColorRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = this._scene, r = s.camera, a = t.model, o = s.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(r.viewMatrix, h) : r.viewMatrix), o.uniformMatrix4fv(this._uViewNormalMatrix, !1, r.viewNormalMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, a.worldMatrix), o.uniformMatrix4fv(this._uWorldNormalMatrix, !1, a.worldNormalMatrix); var l = s._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = s._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = a.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$Y), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aNormal && this._aNormal.bindArrayBuffer(n.normalsBuf), this._aColor && this._aColor.bindArrayBuffer(n.colorsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0), e.drawElements++ } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aNormal = s.getAttribute("normal"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._withSAO && (this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t, i, s = this._scene, r = s.canvas.gl, a = this._program, o = s._lightsState.lights, n = s.camera.project; a.bind(), r.uniformMatrix4fv(this._uProjMatrix, !1, n.matrix), this._uLightAmbient && r.uniform4fv(this._uLightAmbient, s._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = o.length; e < t; e++) { var h = o[e]; this._uLightColor[e] && r.uniform4f(this._uLightColor[e], h.color[0], h.color[1], h.color[2], h.intensity), this._uLightPos[e] && (r.uniform3fv(this._uLightPos[e], h.pos), this._uLightAttenuation[e]) && r.uniform1f(this._uLightAttenuation[e], h.attenuation), this._uLightDir[e] && r.uniform3fv(this._uLightDir[e], h.dir) } this._withSAO && (a = s.sao).possible && (i = r.drawingBufferWidth, t = r.drawingBufferHeight, tempVec4$7[0] = i, tempVec4$7[1] = t, tempVec4$7[2] = a.blendCutoff, tempVec4$7[3] = a.blendFactor, r.uniform4fv(this._uSAOParams, tempVec4$7), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, 0)), s.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(n.far + 1) / Math.LN2), r.uniform1f(this._uLogDepthBufFC, i)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = e._sectionPlanesState, i = e._lightsState; t = 0 < t.sectionPlanes.length; let s; var r = []; r.push("#version 300 es"), r.push("// Triangles batching draw vertex shader"), r.push("uniform int renderPass;"), r.push("in vec3 position;"), r.push("in vec3 normal;"), r.push("in vec4 color;"), r.push("in vec4 flags;"), r.push("in vec4 flags2;"), e.entityOffsetsEnabled && r.push("in vec3 offset;"), r.push("uniform mat4 worldMatrix;"), r.push("uniform mat4 worldNormalMatrix;"), r.push("uniform mat4 viewMatrix;"), r.push("uniform mat4 projMatrix;"), r.push("uniform mat4 viewNormalMatrix;"), r.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (r.push("uniform float logDepthBufFC;"), r.push("out float vFragDepth;"), r.push("bool isPerspectiveMatrix(mat4 m) {"), r.push("    return (m[2][3] == - 1.0);"), r.push("}"), r.push("out float isPerspective;")), r.push("uniform vec4 lightAmbient;"); for (let e = 0, t = i.lights.length; e < t; e++)"ambient" !== (s = i.lights[e]).type && (r.push("uniform vec4 lightColor" + e + ";"), "dir" === s.type && r.push("uniform vec3 lightDir" + e + ";"), "point" === s.type && r.push("uniform vec3 lightPos" + e + ";"), "spot" === s.type) && (r.push("uniform vec3 lightPos" + e + ";"), r.push("uniform vec3 lightDir" + e + ";")); r.push("vec3 octDecode(vec2 oct) {"), r.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), r.push("    if (v.z < 0.0) {"), r.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), r.push("    }"), r.push("    return normalize(v);"), r.push("}"), t && (r.push("out vec4 vWorldPosition;"), r.push("out vec4 vFlags2;")), r.push("out vec4 vColor;"), r.push("void main(void) {"), r.push("if (int(flags.x) != renderPass) {"), r.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), r.push("} else {"), r.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && r.push("worldPosition.xyz = worldPosition.xyz + offset;"), r.push("vec4 viewPosition  = viewMatrix * worldPosition; "), r.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); "), r.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);"), r.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), r.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), r.push("float lambertian = 1.0;"); for (let e = 0, t = i.lights.length; e < t; e++)if ("ambient" !== (s = i.lights[e]).type) { if ("dir" === s.type) "view" === s.space ? r.push("viewLightDir = normalize(lightDir" + e + ");") : r.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === s.type) "view" === s.space ? r.push("viewLightDir = -normalize(lightPos" + e + " - viewPosition.xyz);") : r.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== s.type) continue; "view" === s.space ? r.push("viewLightDir = normalize(lightDir" + e + ");") : r.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);") } r.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), r.push("reflectedColor += lambertian * (lightColor" + e + ".rgb * lightColor" + e + ".a);") } return r.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));"), r.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);"), r.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (r.push("vFragDepth = 1.0 + clipPos.w;"), r.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (r.push("vWorldPosition = worldPosition;"), r.push("vFlags2 = flags2;")), r.push("gl_Position = clipPos;"), r.push("}"), r.push("}"), r } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching draw fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), this._withSAO && (s.push("uniform sampler2D uOcclusionTexture;"), s.push("uniform vec4      uSAOParams;"), s.push("const float       packUpscale = 256. / 255.;"), s.push("const float       unpackDownScale = 255. / 256.;"), s.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), s.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), s.push("float unpackRGBToFloat( const in vec4 v ) {"), s.push("    return dot( v, unPackFactors );"), s.push("}")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { "), s.push("      discard;"), s.push("  }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), this._withSAO ? (s.push("   float viewportWidth     = uSAOParams[0];"), s.push("   float viewportHeight    = uSAOParams[1];"), s.push("   float blendCutoff       = uSAOParams[2];"), s.push("   float blendFactor       = uSAOParams[3];"), s.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), s.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), s.push("   outColor            = vec4(vColor.rgb * ambient, 1.0);")) : s.push("   outColor            = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4$6 = math.vec4(), tempVec3a$X = math.vec3(); class TrianglesBatchingFlatColorRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = this._scene, r = s.camera, a = t.model, o = s.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(r.viewMatrix, h) : r.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, a.worldMatrix); var l = s._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = s._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = a.renderFlags; for (let e = 0; e < l; e++) { var d, m = this._uSectionPlanes[e], f = p.sectionPlanesActivePerLayer[u + e]; o.uniform1i(m.active, f ? 1 : 0), f && (f = c[e], h ? (d = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$X), o.uniform3fv(m.pos, d)) : o.uniform3fv(m.pos, f.pos), o.uniform3fv(m.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aColor && this._aColor.bindArrayBuffer(n.colorsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._withSAO && (this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t, i, s = this._scene, r = s.canvas.gl, a = this._program, o = s._lightsState.lights, n = s.camera.project; a.bind(), r.uniformMatrix4fv(this._uProjMatrix, !1, n.matrix), this._uLightAmbient && r.uniform4fv(this._uLightAmbient, s._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = o.length; e < t; e++) { var h = o[e]; this._uLightColor[e] && r.uniform4f(this._uLightColor[e], h.color[0], h.color[1], h.color[2], h.intensity), this._uLightPos[e] && (r.uniform3fv(this._uLightPos[e], h.pos), this._uLightAttenuation[e]) && r.uniform1f(this._uLightAttenuation[e], h.attenuation), this._uLightDir[e] && r.uniform3fv(this._uLightDir[e], h.dir) } this._withSAO && (a = s.sao).possible && (i = r.drawingBufferWidth, t = r.drawingBufferHeight, tempVec4$6[0] = i, tempVec4$6[1] = t, tempVec4$6[2] = a.blendCutoff, tempVec4$6[3] = a.blendFactor, r.uniform4fv(this._uSAOParams, tempVec4$6), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, 0)), s.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(n.far + 1) / Math.LN2), r.uniform1f(this._uLogDepthBufFC, i)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching flat-shading draw vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vViewPosition = viewPosition;"), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._lightsState, i = e._sectionPlanesState, s = 0 < i.sectionPlanes.length, r = []; if (r.push("#version 300 es"), r.push("// Triangles batching flat-shading draw fragment shader"), r.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), r.push("precision highp float;"), r.push("precision highp int;"), r.push("#else"), r.push("precision mediump float;"), r.push("precision mediump int;"), r.push("#endif"), e.logarithmicDepthBufferEnabled && (r.push("in float isPerspective;"), r.push("uniform float logDepthBufFC;"), r.push("in float vFragDepth;")), this._withSAO && (r.push("uniform sampler2D uOcclusionTexture;"), r.push("uniform vec4      uSAOParams;"), r.push("const float       packUpscale = 256. / 255.;"), r.push("const float       unpackDownScale = 255. / 256.;"), r.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), r.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), r.push("float unpackRGBToFloat( const in vec4 v ) {"), r.push("    return dot( v, unPackFactors );"), r.push("}")), s) { r.push("in vec4 vWorldPosition;"), r.push("in vec4 vFlags2;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)r.push("uniform bool sectionPlaneActive" + e + ";"), r.push("uniform vec3 sectionPlanePos" + e + ";"), r.push("uniform vec3 sectionPlaneDir" + e + ";") } r.push("uniform mat4 viewMatrix;"), r.push("uniform vec4 lightAmbient;"); for (let e = 0, i = t.lights.length; e < i; e++) { var a = t.lights[e]; "ambient" !== a.type && (r.push("uniform vec4 lightColor" + e + ";"), "dir" === a.type && r.push("uniform vec3 lightDir" + e + ";"), "point" === a.type && r.push("uniform vec3 lightPos" + e + ";"), "spot" === a.type) && (r.push("uniform vec3 lightPos" + e + ";"), r.push("uniform vec3 lightDir" + e + ";")) } if (r.push("in vec4 vViewPosition;"), r.push("in vec4 vColor;"), r.push("out vec4 outColor;"), r.push("void main(void) {"), s) { r.push("  bool clippable = (float(vFlags2.x) > 0.0);"), r.push("  if (clippable) {"), r.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)r.push("if (sectionPlaneActive" + e + ") {"), r.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), r.push("}"); r.push("  if (dist > 0.0) { "), r.push("      discard;"), r.push("  }"), r.push("}") } r.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), r.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), r.push("float lambertian = 1.0;"), r.push("vec3 xTangent = dFdx( vViewPosition.xyz );"), r.push("vec3 yTangent = dFdy( vViewPosition.xyz );"), r.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );"); for (let e = 0, i = t.lights.length; e < i; e++) { var o = t.lights[e]; if ("ambient" !== o.type) { if ("dir" === o.type) "view" === o.space ? r.push("viewLightDir = normalize(lightDir" + e + ");") : r.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === o.type) "view" === o.space ? r.push("viewLightDir = -normalize(lightPos" + e + " - viewPosition.xyz);") : r.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== o.type) continue; "view" === o.space ? r.push("viewLightDir = normalize(lightDir" + e + ");") : r.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);") } r.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), r.push("reflectedColor += lambertian * (lightColor" + e + ".rgb * lightColor" + e + ".a);") } } return r.push("vec4 fragColor =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);"), this._withSAO ? (r.push("   float viewportWidth     = uSAOParams[0];"), r.push("   float viewportHeight    = uSAOParams[1];"), r.push("   float blendCutoff       = uSAOParams[2];"), r.push("   float blendFactor       = uSAOParams[3];"), r.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), r.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), r.push("   outColor            = vec4(fragColor.rgb * ambient, 1.0);")) : r.push("   outColor            = fragColor;"), e.logarithmicDepthBufferEnabled && r.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), r.push("}"), r } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const defaultColor$4 = new Float32Array([1, 1, 1]), tempVec3a$W = math.vec3(); class TrianglesBatchingSilhouetteRenderer { constructor(e, t) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (l = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (l = r.highlightMaterial._state).fillColor, l = l.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], l)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (l = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], i)) : o.uniform4fv(this._uColor, defaultColor$4); e = h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix; var l, c = (o.uniformMatrix4fv(this._uViewMatrix, !1, e), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$W), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uColor = i.getLocation("color"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching silhouette vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), i.push("uniform vec4 color;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.y) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState; let i, s; var r = 0 < t.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Triangles batching silhouette fragment shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), e.logarithmicDepthBufferEnabled && (a.push("in float isPerspective;"), a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), r) for (a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("uniform bool sectionPlaneActive" + i + ";"), a.push("uniform vec3 sectionPlanePos" + i + ";"), a.push("uniform vec3 sectionPlaneDir" + i + ";"); if (a.push("uniform vec4 color;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), r) { for (a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("if (sectionPlaneActive" + i + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("  if (dist > 0.0) { discard; }"), a.push("}") } return e.logarithmicDepthBufferEnabled && a.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("outColor = color;"), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$V = math.vec3(), defaultColor$3 = new Float32Array([0, 0, 0, 1]); class TrianglesBatchingEdgesRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.EDGES_XRAYED ? (l = (e = r.xrayMaterial._state).edgeColor, e = e.edgeAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], e)) : i === RENDER_PASSES.EDGES_HIGHLIGHTED ? (e = (l = r.highlightMaterial._state).edgeColor, l = l.edgeAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], l)) : i === RENDER_PASSES.EDGES_SELECTED ? (l = (e = r.selectedMaterial._state).edgeColor, i = e.edgeAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], i)) : o.uniform4fv(this._uColor, defaultColor$3), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var l, c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$V), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.edgeIndicesBuf.bind(), o.drawElements(o.LINES, n.edgeIndicesBuf.numItems, n.edgeIndicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uColor = i.getLocation("color"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = this._program, s = e.camera.project; i.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, s.matrix), e.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(s.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, i)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Batched geometry edges drawing vertex shader"), i.push("uniform int renderPass;"), i.push("uniform vec4 color;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.z) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("  vWorldPosition = worldPosition;"), i.push("  vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vColor = vec4(color.r, color.g, color.b, color.a);"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry edges drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$U = math.vec3(); class TrianglesBatchingEdgesColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var l = r._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$U), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.edgeIndicesBuf.bind(), o.drawElements(o.LINES, n.edgeIndicesBuf.numItems, n.edgeIndicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aColor = i.getAttribute("color"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = this._program, s = e.camera.project; i.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, s.matrix), e.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(s.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, i)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Batched geometry edges drawing vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.z) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("  vWorldPosition = worldPosition;"), i.push("  vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry edges drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$T = math.vec3(); class TrianglesBatchingPickMeshRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = (i = (this._program || this._allocate(t), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), e.pickViewMatrix || a.viewMatrix), i = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, i), r.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, e)), r._sectionPlanesState.sectionPlanes.length); if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$T), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aPickColor && this._aPickColor.bindArrayBuffer(n.pickColorsBuf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aPickColor = i.getAttribute("pickColor"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene.canvas.gl; this._program.bind(), t.uniform1i(this._uPickInvisible, e.pickInvisible) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Batched geometry picking vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 pickColor;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vPickColor;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);"), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry picking fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("in vec4 vPickColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vPickColor; "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$S = math.vec3(); class TrianglesBatchingPickDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = (i = (this._program || this._allocate(), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible), e.pickViewMatrix || a.viewMatrix), a = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, a), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniform1f(this._uPickZNear, e.pickZNear), o.uniform1f(this._uPickZFar, e.pickZFar), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(e.pickZFar + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$S), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._uPickZNear = i.getLocation("pickZNear"), this._uPickZFar = i.getLocation("pickZFar"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching pick depth vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("vViewPosition = viewPosition;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching pick depth fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("uniform float pickZNear;"), s.push("uniform float pickZFar;"), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("in vec4 vViewPosition;"), s.push("vec4 packDepth(const in float depth) {"), s.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);"), s.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);"), s.push("  vec4 res = fract(depth * bitShift);"), s.push("  res -= res.xxyz * bitMask;"), s.push("  return res;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));"), s.push("    outColor = packDepth(zNormalizedDepth); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$R = math.vec3(); class TrianglesBatchingPickNormalsRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = (i = (this._program || this._allocate(t), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), e.pickViewMatrix || a.viewMatrix), i = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$R), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aNormal && this._aNormal.bindArrayBuffer(n.normalsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aNormal = i.getAttribute("normal"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching pick normals vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec3 normal;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("vec3 octDecode(vec2 oct) {"), i.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), i.push("    if (v.z < 0.0) {"), i.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), i.push("    }"), i.push("    return normalize(v);"), i.push("}"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec3 vWorldNormal;"), i.push("out vec4 outColor;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("      vec3 worldNormal =  octDecode(normal.xy); "), i.push("      vWorldNormal = worldNormal;"), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching pick normals fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("in vec3 vWorldNormal;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4((vWorldNormal * 0.5) + 0.5, 1.0);"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$Q = math.vec3(); class TrianglesBatchingOcclusionRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.canvas.gl, o = t._state, n = r.camera, h = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), a.uniform1i(this._uRenderPass, i), a.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(n.viewMatrix, h) : n.viewMatrix), a.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var l = r._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], a.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$Q), a.uniform3fv(f.pos, m)) : a.uniform3fv(f.pos, d.pos), a.uniform3fv(f.dir, d.dir)) } } a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(o.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(o.offsetsBuf), this._aColor && this._aColor.bindArrayBuffer(o.colorsBuf), this._aFlags.bindArrayBuffer(o.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(o.flags2Buf), o.indicesBuf.bind(), a.drawElements(a.TRIANGLES, o.indicesBuf.numItems, o.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching occlusion vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching occlusion fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("      if (sectionPlaneActive" + e + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$P = math.vec3(); class TrianglesBatchingDepthRenderer { constructor(e) { this._scene = e, this._allocate(), this._hash = this._getHash() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix); var l = r._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$P), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching depth vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec2 vHighPrecisionZW;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vHighPrecisionZW = gl_Position.zw;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching depth fragment shader"), s.push("precision highp float;"), s.push("precision highp int;"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("const float   packUpScale = 256. / 255.;"), s.push("const float   unpackDownscale = 255. / 256.;"), s.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), s.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );"), s.push("const float   shiftRight8 = 1.0 / 256.;"), s.push("vec4 packDepthToRGBA( const in float v ) {"), s.push("    vec4 r = vec4( fract( v * packFactors ), v );"), s.push("    r.yzw -= r.xyz * shiftRight8;"), s.push("    return r * packUpScale;"), s.push("}"), s.push("in vec2 vHighPrecisionZW;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;"), s.push("    outColor = vec4(vec3(1.0 - fragCoordZ), 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null, stats.memory.programs-- } } const tempVec3a$O = math.vec3(); class TrianglesBatchingNormalsRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(t)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uViewNormalMatrix, !1, a.viewNormalMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uWorldNormalMatrix, !1, s.worldNormalMatrix); var l = r._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$O), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aNormal.bindArrayBuffer(n.normalsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uWorldNormalMatrix = i.getLocation("worldNormalMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uViewNormalMatrix = i.getLocation("viewNormalMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aNormal = i.getAttribute("normal"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 && (this._aFlags2 = i.getAttribute("flags2")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Batched geometry normals vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec3 normal;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 worldNormalMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 viewNormalMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("vec3 octDecode(vec2 oct) {"), i.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), i.push("    if (v.z < 0.0) {"), i.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), i.push("    }"), i.push("    return normalize(v);"), i.push("}"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec3 vViewNormal;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition   = viewMatrix * worldPosition; "), i.push("      vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); "), i.push("      vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);"), t && (i.push("      vWorldPosition  = worldPosition;"), i.push("      vFlags2         = flags2;")), i.push("      vViewNormal = viewNormal;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry normals fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vViewNormal;"), s.push("vec3 packNormalToRGB( const in vec3 normal ) {"), s.push("    return normalize( normal ) * 0.5 + 0.5;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$N = math.vec3(); class TrianglesBatchingShadowRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t) { var i = this._scene, s = i.canvas.gl, r = t._state, a = (this._program || this._allocate(), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), s.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), i.logarithmicDepthBufferEnabled && s.uniform1f(this._uZFar, i.camera.project.far), this._aPosition.bindArrayBuffer(r.positionsBuf), this._aColor && this._aColor.bindArrayBuffer(r.colorsBuf), this._aFlags && this._aFlags.bindArrayBuffer(r.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(r.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(r.offsetsBuf), r.indicesBuf.bind(), i._sectionPlanesState.sectionPlanes.length); if (0 < a) { var o = i._sectionPlanesState.sectionPlanes, n = t.layerIndex * a, h = model.renderFlags, l = t._state.origin; for (let e = 0; e < a; e++) { var c, u, p = this._uSectionPlanes[e]; p && (c = h.sectionPlanesActivePerLayer[n + e], s.uniform1i(p.active, c ? 1 : 0), c) && (c = o[e], l ? (u = getPlaneRTCPos(c.dist, c.dir, l, tempVec3a$N), s.uniform3fv(p.pos, u)) : s.uniform3fv(p.pos, c.pos), s.uniform3fv(p.dir, c.dir)) } } s.drawElements(s.TRIANGLES, r.indicesBuf.numItems, r.indicesBuf.itemType, 0) } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uShadowViewMatrix = s.getLocation("shadowViewMatrix"), this._uShadowProjMatrix = s.getLocation("shadowProjMatrix"), e.logarithmicDepthBufferEnabled && (this._uZFar = s.getLocation("zFar")), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2") } } _bindProgram(e) { var t = this._scene.canvas.gl; this._program.bind(), t.uniformMatrix4fv(this._uShadowViewMatrix, !1, e.shadowViewMatrix), t.uniformMatrix4fv(this._uShadowProjMatrix, !1, e.shadowProjMatrix), this._lastLightId = null } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Batched geometry shadow vertex shader"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 shadowViewMatrix;"), i.push("uniform mat4 shadowProjMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("out vec4 outColor;"), i.push("void main(void) {"), i.push("  bool visible        = (float(flags.x) > 0.0);"), i.push("  bool transparent    = ((float(color.a) / 255.0) < 1.0);"), i.push("  if (!visible || transparent) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = shadowViewMatrix * worldPosition; "), t && (i.push("      vWorldPosition = worldPosition;"), i.push("      vFlags2 = flags2;")), i.push("      vViewPosition = viewPosition;"), i.push("      gl_Position = shadowProjMatrix * viewPosition;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene._sectionPlanesState, t = 0 < e.sectionPlanes.length, i = []; if (i.push("#version 300 es"), i.push("// Batched geometry shadow fragment shader"), i.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), i.push("precision highp float;"), i.push("precision highp int;"), i.push("#else"), i.push("precision mediump float;"), i.push("precision mediump int;"), i.push("#endif"), t) { i.push("in vec4 vWorldPosition;"), i.push("in vec4 vFlags2;"); for (let t = 0; t < e.sectionPlanes.length; t++)i.push("uniform bool sectionPlaneActive" + t + ";"), i.push("uniform vec3 sectionPlanePos" + t + ";"), i.push("uniform vec3 sectionPlaneDir" + t + ";") } if (i.push("in vec4 vViewPosition;"), i.push("vec4 encodeFloat( const in float v ) {"), i.push("  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);"), i.push("  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);"), i.push("  vec4 comp = fract(v * bitShift);"), i.push("  comp -= comp.xxyz * bitMask;"), i.push("  return comp;"), i.push("}"), i.push("out vec4 outColor;"), i.push("void main(void) {"), t) { i.push("  bool clippable = (float(vFlags2.x) > 0.0);"), i.push("  if (clippable) {"), i.push("      float dist = 0.0;"); for (var s = 0; s < e.sectionPlanes.length; s++)i.push("      if (sectionPlaneActive" + s + ") {"), i.push("          dist += clamp(dot(-sectionPlaneDir" + s + ".xyz, vWorldPosition.xyz - sectionPlanePos" + s + ".xyz), 0.0, 1000.0);"), i.push("      }"); i.push("      if (dist > 0.0) { discard; }"), i.push("  }") } return i.push("    outColor = encodeFloat( gl_FragCoord.z); "), i.push("}"), i } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4$5 = math.vec4(), tempVec3a$M = math.vec3(); class TrianglesBatchingPBRRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e.gammaOutput, e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS, r = this._scene, a = r.camera, o = t.model, n = r.canvas.gl, h = t._state, l = t._state.origin, c = h.textureSet, u = r._lightsState; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), n.uniform1i(this._uRenderPass, i), n.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), n.uniformMatrix4fv(this._uViewNormalMatrix, !1, a.viewNormalMatrix), n.uniformMatrix4fv(this._uWorldMatrix, !1, o.worldMatrix), n.uniformMatrix4fv(this._uWorldNormalMatrix, !1, o.worldNormalMatrix); var p = r._sectionPlanesState.sectionPlanes.length; if (0 < p) { var d = r._sectionPlanesState.sectionPlanes, m = t.layerIndex * p, f = o.renderFlags; for (let e = 0; e < p; e++) { var g, _, v = this._uSectionPlanes[e]; v && (g = f.sectionPlanesActivePerLayer[m + e], n.uniform1i(v.active, g ? 1 : 0), g) && (g = d[e], l ? (_ = getPlaneRTCPos(g.dist, g.dir, l, tempVec3a$M), n.uniform3fv(v.pos, _)) : n.uniform3fv(v.pos, g.pos), n.uniform3fv(v.dir, g.dir)) } } n.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._uUVDecodeMatrix && n.uniformMatrix3fv(this._uUVDecodeMatrix, !1, h.uvDecodeMatrix), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aNormal && this._aNormal.bindArrayBuffer(h.normalsBuf), this._aUV && this._aUV.bindArrayBuffer(h.uvBuf), this._aColor && this._aColor.bindArrayBuffer(h.colorsBuf), this._aMetallicRoughness && this._aMetallicRoughness.bindArrayBuffer(h.metallicRoughnessBuf), this._aFlags && this._aFlags.bindArrayBuffer(h.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(h.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(h.offsetsBuf), 0 < u.reflectionMaps.length && u.reflectionMaps[0].texture && this._uReflectionMap && (this._program.bindTexture(this._uReflectionMap, u.reflectionMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), 0 < u.lightMaps.length && u.lightMaps[0].texture && this._uLightMap && (this._program.bindTexture(this._uLightMap, u.lightMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), this._withSAO && (i = r.sao).possible && (a = n.drawingBufferWidth, t = n.drawingBufferHeight, tempVec4$5[0] = a, tempVec4$5[1] = t, tempVec4$5[2] = i.blendCutoff, tempVec4$5[3] = i.blendFactor, n.uniform4fv(this._uSAOParams, tempVec4$5), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), this._program.bindTexture(this._uBaseColorMap, c.colorTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uMetallicRoughMap, c.metallicRoughnessTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uEmissiveMap, c.emissiveTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uNormalMap, c.normalsTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uAOMap, c.occlusionTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, h.indicesBuf.bind(), n.drawElements(n.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0), e.drawElements++ } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uUVDecodeMatrix = s.getLocation("uvDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uGammaFactor = s.getLocation("gammaFactor"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }0 < i.reflectionMaps.length && (this._uReflectionMap = "reflectionMap"), 0 < i.lightMaps.length && (this._uLightMap = "lightMap"), this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aNormal = s.getAttribute("normal"), this._aUV = s.getAttribute("uv"), this._aColor = s.getAttribute("color"), this._aMetallicRoughness = s.getAttribute("metallicRoughness"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._uBaseColorMap = "uBaseColorMap", this._uMetallicRoughMap = "uMetallicRoughMap", this._uEmissiveMap = "uEmissiveMap", this._uNormalMap = "uNormalMap", this._uAOMap = "uAOMap", this._withSAO && (this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene, i = t.canvas.gl, s = this._program, r = t._lightsState.lights, a = t.camera.project; s.bind(), i.uniformMatrix4fv(this._uProjMatrix, !1, a.matrix), this._uLightAmbient && i.uniform4fv(this._uLightAmbient, t._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = r.length; e < t; e++) { var o = r[e]; this._uLightColor[e] && i.uniform4f(this._uLightColor[e], o.color[0], o.color[1], o.color[2], o.intensity), this._uLightPos[e] && (i.uniform3fv(this._uLightPos[e], o.pos), this._uLightAttenuation[e]) && i.uniform1f(this._uLightAttenuation[e], o.attenuation), this._uLightDir[e] && i.uniform3fv(this._uLightDir[e], o.dir) } t.logarithmicDepthBufferEnabled && (s = 2 / (Math.log(a.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, s)), this._uGammaFactor && i.uniform1f(this._uGammaFactor, t.gammaFactor) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = e._sectionPlanesState, i = e._lightsState, s = 0 < t.sectionPlanes.length, r = (t = t.clippingCaps, []); return r.push("#version 300 es"), r.push("// Triangles batching quality draw vertex shader"), r.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), r.push("precision highp float;"), r.push("precision highp int;"), r.push("precision highp usampler2D;"), r.push("precision highp isampler2D;"), r.push("precision highp sampler2D;"), r.push("#else"), r.push("precision mediump float;"), r.push("precision mediump int;"), r.push("precision mediump usampler2D;"), r.push("precision mediump isampler2D;"), r.push("precision mediump sampler2D;"), r.push("#endif"), r.push("uniform int renderPass;"), r.push("in vec3 position;"), r.push("in vec3 normal;"), r.push("in vec4 color;"), r.push("in vec2 uv;"), r.push("in vec2 metallicRoughness;"), r.push("in vec4 flags;"), r.push("in vec4 flags2;"), e.entityOffsetsEnabled && r.push("in vec3 offset;"), r.push("uniform mat4 worldMatrix;"), r.push("uniform mat4 worldNormalMatrix;"), r.push("uniform mat4 viewMatrix;"), r.push("uniform mat4 projMatrix;"), r.push("uniform mat4 viewNormalMatrix;"), r.push("uniform mat4 positionsDecodeMatrix;"), r.push("uniform mat3 uvDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (r.push("uniform float logDepthBufFC;"), r.push("out float vFragDepth;"), r.push("bool isPerspectiveMatrix(mat4 m) {"), r.push("    return (m[2][3] == - 1.0);"), r.push("}"), r.push("out float isPerspective;")), r.push("vec3 octDecode(vec2 oct) {"), r.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), r.push("    if (v.z < 0.0) {"), r.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), r.push("    }"), r.push("    return normalize(v);"), r.push("}"), r.push("out vec4 vViewPosition;"), r.push("out vec3 vViewNormal;"), r.push("out vec4 vColor;"), r.push("out vec2 vUV;"), r.push("out vec2 vMetallicRoughness;"), 0 < i.lightMaps.length && r.push("out vec3 vWorldNormal;"), s && (r.push("out vec4 vWorldPosition;"), r.push("out vec4 vFlags2;"), t) && r.push("out vec4 vClipPosition;"), r.push("void main(void) {"), r.push("if (int(flags.x) != renderPass) {"), r.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), r.push("} else {"), r.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && r.push("worldPosition.xyz = worldPosition.xyz + offset;"), r.push("vec4 viewPosition  = viewMatrix * worldPosition; "), r.push("vec4 worldNormal =  worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); "), r.push("vec3 viewNormal = normalize((viewNormalMatrix * worldNormal).xyz);"), r.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (r.push("isPerspective = float (isPerspectiveMatrix(projMatrix));"), r.push("vFragDepth = 1.0 + clipPos.w;")), s && (r.push("vWorldPosition = worldPosition;"), r.push("vFlags2 = flags2;"), t) && r.push("vClipPosition = clipPos;"), r.push("vViewPosition = viewPosition;"), r.push("vViewNormal = viewNormal;"), r.push("vColor = color;"), r.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;"), r.push("vMetallicRoughness = metallicRoughness;"), 0 < i.lightMaps.length && r.push("vWorldNormal = worldNormal.xyz;"), r.push("gl_Position = clipPos;"), r.push("}"), r.push("}"), r } _buildFragmentShader() { var e = this._scene, t = e.gammaOutput, i = e._sectionPlanesState, s = e._lightsState, r = 0 < i.sectionPlanes.length, a = i.clippingCaps, o = []; o.push("#version 300 es"), o.push("// Triangles batching quality draw fragment shader"), o.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), o.push("precision highp float;"), o.push("precision highp int;"), o.push("#else"), o.push("precision mediump float;"), o.push("precision mediump int;"), o.push("#endif"), e.logarithmicDepthBufferEnabled && (o.push("in float isPerspective;"), o.push("uniform float logDepthBufFC;"), o.push("in float vFragDepth;")), o.push("uniform sampler2D uBaseColorMap;"), o.push("uniform sampler2D uMetallicRoughMap;"), o.push("uniform sampler2D uEmissiveMap;"), o.push("uniform sampler2D uNormalMap;"), o.push("uniform sampler2D uAOMap;"), o.push("in vec4 vViewPosition;"), o.push("in vec3 vViewNormal;"), o.push("in vec4 vColor;"), o.push("in vec2 vUV;"), o.push("in vec2 vMetallicRoughness;"), 0 < s.lightMaps.length && o.push("in vec3 vWorldNormal;"), o.push("uniform mat4 viewMatrix;"), 0 < s.reflectionMaps.length && o.push("uniform samplerCube reflectionMap;"), 0 < s.lightMaps.length && o.push("uniform samplerCube lightMap;"), o.push("uniform vec4 lightAmbient;"); for (let e = 0, t = s.lights.length; e < t; e++) { var n = s.lights[e]; "ambient" !== n.type && (o.push("uniform vec4 lightColor" + e + ";"), "dir" === n.type && o.push("uniform vec3 lightDir" + e + ";"), "point" === n.type && o.push("uniform vec3 lightPos" + e + ";"), "spot" === n.type) && (o.push("uniform vec3 lightPos" + e + ";"), o.push("uniform vec3 lightDir" + e + ";")) } if (this._withSAO && (o.push("uniform sampler2D uOcclusionTexture;"), o.push("uniform vec4      uSAOParams;"), o.push("const float       packUpscale = 256. / 255.;"), o.push("const float       unpackDownScale = 255. / 256.;"), o.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), o.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), o.push("float unpackRGBToFloat( const in vec4 v ) {"), o.push("    return dot( v, unPackFactors );"), o.push("}")), o.push("uniform float gammaFactor;"), o.push("vec4 linearToLinear( in vec4 value ) {"), o.push("  return value;"), o.push("}"), o.push("vec4 sRGBToLinear( in vec4 value ) {"), o.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );"), o.push("}"), o.push("vec4 gammaToLinear( in vec4 value) {"), o.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );"), o.push("}"), t && (o.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), o.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), o.push("}")), r) { o.push("in vec4 vWorldPosition;"), o.push("in vec4 vFlags2;"), a && o.push("in vec4 vClipPosition;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)o.push("uniform bool sectionPlaneActive" + e + ";"), o.push("uniform vec3 sectionPlanePos" + e + ";"), o.push("uniform vec3 sectionPlaneDir" + e + ";") } if (o.push("#define PI 3.14159265359"), o.push("#define RECIPROCAL_PI 0.31830988618"), o.push("#define RECIPROCAL_PI2 0.15915494"), o.push("#define EPSILON 1e-6"), o.push("#define saturate(a) clamp( a, 0.0, 1.0 )"), o.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {"), o.push("       vec3 texel = texture( uNormalMap, uv ).xyz;"), o.push("       if (texel.x == 0.0 && texel.y == 0.0 && texel.z == 0.0) {"), o.push("              return surf_norm;"), o.push("       }"), o.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );"), o.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );"), o.push("      vec2 st0 = dFdx( uv.st );"), o.push("      vec2 st1 = dFdy( uv.st );"), o.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );"), o.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );"), o.push("      vec3 N = normalize( surf_norm );"), o.push("      vec3 mapN = texel.xyz * 2.0 - 1.0;"), o.push("      mat3 tsn = mat3( S, T, N );"), o.push("      return normalize( tsn * mapN );"), o.push("}"), o.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {"), o.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );"), o.push("}"), o.push("struct IncidentLight {"), o.push("   vec3 color;"), o.push("   vec3 direction;"), o.push("};"), o.push("struct ReflectedLight {"), o.push("   vec3 diffuse;"), o.push("   vec3 specular;"), o.push("};"), o.push("struct Geometry {"), o.push("   vec3 position;"), o.push("   vec3 viewNormal;"), o.push("   vec3 worldNormal;"), o.push("   vec3 viewEyeDir;"), o.push("};"), o.push("struct Material {"), o.push("   vec3  diffuseColor;"), o.push("   float specularRoughness;"), o.push("   vec3  specularColor;"), o.push("   float shine;"), o.push("};"), o.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {"), o.push("   float r = ggxRoughness + 0.0001;"), o.push("   return (2.0 / (r * r) - 2.0);"), o.push("}"), o.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {"), o.push("   float maxMIPLevelScalar = float( maxMIPLevel );"), o.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );"), o.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );"), o.push("}"), 0 < s.reflectionMaps.length && (o.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {"), o.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"), o.push("   vec3 envMapColor = sRGBToLinear(texture(reflectionMap, reflectVec, mipLevel)).rgb;"), o.push("  return envMapColor;"), o.push("}")), o.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {"), o.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );"), o.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;"), o.push("}"), o.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), o.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), o.push("   return 1.0 / ( gl * gv );"), o.push("}"), o.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), o.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), o.push("   return 0.5 / max( gv + gl, EPSILON );"), o.push("}"), o.push("float D_GGX(const in float alpha, const in float dotNH) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;"), o.push("   return RECIPROCAL_PI * a2 / ( denom * denom);"), o.push("}"), o.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), o.push("   float alpha = ( roughness * roughness );"), o.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );"), o.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );"), o.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );"), o.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );"), o.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );"), o.push("   vec3  F = F_Schlick( specularColor, dotLH );"), o.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );"), o.push("   float D = D_GGX( alpha, dotNH );"), o.push("   return F * (G * D);"), o.push("}"), o.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), o.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));"), o.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);"), o.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);"), o.push("   vec4 r = roughness * c0 + c1;"), o.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;"), o.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;"), o.push("   return specularColor * AB.x + AB.y;"), o.push("}"), (0 < s.lightMaps.length || 0 < s.reflectionMaps.length) && (o.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), 0 < s.lightMaps.length && (o.push("   vec3 irradiance = sRGBToLinear(texture(lightMap, geometry.worldNormal)).rgb;"), o.push("   irradiance *= PI;"), o.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);"), o.push("   reflectedLight.diffuse +=  irradiance * diffuseBRDFContrib;")), 0 < s.reflectionMaps.length && (o.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);"), o.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);"), o.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);"), o.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);"), o.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);"), o.push("   reflectedLight.specular     += radiance * specularBRDFContrib;")), o.push("}")), o.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), o.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));"), o.push("   vec3 irradiance = dotNL * incidentLight.color * PI;"), o.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);"), o.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);"), o.push("}"), o.push("out vec4 outColor;"), o.push("void main(void) {"), r) { o.push("  bool clippable = (float(vFlags2.x) > 0.0);"), o.push("  if (clippable) {"), o.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)o.push("if (sectionPlaneActive" + e + ") {"), o.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), o.push("}"); a ? (o.push("  if (dist > (0.002 * vClipPosition.w)) {"), o.push("      discard;"), o.push("  }"), o.push("  if (dist > 0.0) { "), o.push("      outColor=vec4(1.0, 0.0, 0.0, 1.0);"), e.logarithmicDepthBufferEnabled && o.push("  gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), o.push("  return;"), o.push("}")) : (o.push("  if (dist > 0.0) { "), o.push("      discard;"), o.push("  }")), o.push("}") } o.push("IncidentLight  light;"), o.push("Material       material;"), o.push("Geometry       geometry;"), o.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));"), o.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));"), o.push("float opacity = float(vColor.a) / 255.0;"), o.push("vec3  baseColor = rgb;"), o.push("float specularF0 = 1.0;"), o.push("float metallic = float(vMetallicRoughness.r) / 255.0;"), o.push("float roughness = float(vMetallicRoughness.g) / 255.0;"), o.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;"), o.push("vec4 baseColorTexel = sRGBToLinear(texture(uBaseColorMap, vUV));"), o.push("baseColor *= baseColorTexel.rgb;"), o.push("vec3 metalRoughTexel = texture(uMetallicRoughMap, vUV).rgb;"), o.push("metallic *= metalRoughTexel.b;"), o.push("roughness *= metalRoughTexel.g;"), o.push("vec3 viewNormal = perturbNormal2Arb(vViewPosition.xyz, normalize(vViewNormal), vUV );"), o.push("material.diffuseColor      = baseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);"), o.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);"), o.push("material.specularColor     = mix(vec3(dielectricSpecular), baseColor, metallic);"), o.push("geometry.position      = vViewPosition.xyz;"), o.push("geometry.viewNormal    = -normalize(viewNormal);"), o.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);"), 0 < s.lightMaps.length && o.push("geometry.worldNormal   = normalize(vWorldNormal);"), (0 < s.lightMaps.length || 0 < s.reflectionMaps.length) && o.push("computePBRLightMapping(geometry, material, reflectedLight);"); for (let e = 0, t = s.lights.length; e < t; e++) { var h = s.lights[e]; if ("ambient" !== h.type) { if ("dir" === h.type) "view" === h.space ? o.push("light.direction =  normalize(lightDir" + e + ");") : o.push("light.direction =  normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === h.type) "view" === h.space ? o.push("light.direction =  normalize(lightPos" + e + " - vViewPosition.xyz);") : o.push("light.direction =  normalize((viewMatrix * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== h.type) continue; "view" === h.space ? o.push("light.direction =  normalize(lightDir" + e + ");") : o.push("light.direction =  normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);") } o.push("light.color =  lightColor" + e + ".rgb * lightColor" + e + ".a;"), o.push("computePBRLighting(light, geometry, material, reflectedLight);") } } return o.push("vec3 emissiveColor = sRGBToLinear(texture(uEmissiveMap, vUV)).rgb;"), o.push("float aoFactor = texture(uAOMap, vUV).r;"), o.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * baseColor * opacity * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular) + emissiveColor;"), o.push("vec4 fragColor;"), this._withSAO ? (o.push("   float viewportWidth     = uSAOParams[0];"), o.push("   float viewportHeight    = uSAOParams[1];"), o.push("   float blendCutoff       = uSAOParams[2];"), o.push("   float blendFactor       = uSAOParams[3];"), o.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), o.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), o.push("   fragColor               = vec4(outgoingLight.rgb * ambient * aoFactor, opacity);")) : o.push("   fragColor            = vec4(outgoingLight.rgb * aoFactor, opacity);"), t && o.push("fragColor = linearToGamma(fragColor, gammaFactor);"), o.push("outColor = fragColor;"), e.logarithmicDepthBufferEnabled && o.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), o.push("}"), o } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$L = math.vec3(); class TrianglesBatchingPickNormalsFlatRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = (i = (this._program || this._allocate(t), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), e.pickViewMatrix || a.viewMatrix), i = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < l) { var c = r._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = s.renderFlags; for (let e = 0; e < l; e++) { var d, m = this._uSectionPlanes[e], f = p.sectionPlanesActivePerLayer[u + e]; o.uniform1i(m.active, f ? 1 : 0), f && (f = c[e], h ? (d = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$L), o.uniform3fv(m.pos, d)) : o.uniform3fv(m.pos, f.pos), o.uniform3fv(m.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching pick flat normals vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("out vec4 vWorldPosition;"), t && i.push("out vec4 vFlags2;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("  } else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("      vWorldPosition = worldPosition;"), t && i.push("      vFlags2 = flags2;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("  }"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Triangles batching pick flat normals fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("in vec4 vWorldPosition;"), i) { s.push("in vec4 vFlags2;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { for (s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );"), s.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );"), s.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );"), s.push("  outColor = vec4((worldNormal * 0.5) + 0.5, 1.0);"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4$4 = math.vec4(), tempVec3a$K = math.vec3(); class TrianglesBatchingColorTextureRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e.gammaOutput, e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS, r = this._scene, a = r.camera, o = t.model, n = r.canvas.gl, h = t._state, l = t._state.origin, c = h.textureSet; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), n.uniform1i(this._uRenderPass, i), n.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), n.uniformMatrix4fv(this._uWorldMatrix, !1, o.worldMatrix); var u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = o.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], n.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], l ? (g = getPlaneRTCPos(f.dist, f.dir, l, tempVec3a$K), n.uniform3fv(_.pos, g)) : n.uniform3fv(_.pos, f.pos), n.uniform3fv(_.dir, f.dir)) } } n.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._uUVDecodeMatrix && n.uniformMatrix3fv(this._uUVDecodeMatrix, !1, h.uvDecodeMatrix), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aUV && this._aUV.bindArrayBuffer(h.uvBuf), this._aColor && this._aColor.bindArrayBuffer(h.colorsBuf), this._aFlags && this._aFlags.bindArrayBuffer(h.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(h.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(h.offsetsBuf), c && c.colorTexture && (this._program.bindTexture(this._uColorMap, c.colorTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s), this._withSAO && (i = r.sao).possible && (a = n.drawingBufferWidth, t = n.drawingBufferHeight, tempVec4$4[0] = a, tempVec4$4[1] = t, tempVec4$4[2] = i.blendCutoff, tempVec4$4[3] = i.blendFactor, n.uniform4fv(this._uSAOParams, tempVec4$4), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), h.indicesBuf.bind(), n.drawElements(n.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0), e.drawElements++ } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uUVDecodeMatrix = s.getLocation("uvDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uGammaFactor = s.getLocation("gammaFactor"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aUV = s.getAttribute("uv"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._uColorMap = "uColorMap", this._withSAO && (this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene, i = t.canvas.gl, s = this._program, r = t._lightsState.lights, a = t.camera.project; s.bind(), i.uniformMatrix4fv(this._uProjMatrix, !1, a.matrix), this._uLightAmbient && i.uniform4fv(this._uLightAmbient, t._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = r.length; e < t; e++) { var o = r[e]; this._uLightColor[e] && i.uniform4f(this._uLightColor[e], o.color[0], o.color[1], o.color[2], o.intensity), this._uLightPos[e] && (i.uniform3fv(this._uLightPos[e], o.pos), this._uLightAttenuation[e]) && i.uniform1f(this._uLightAttenuation[e], o.attenuation), this._uLightDir[e] && i.uniform3fv(this._uLightDir[e], o.dir) } t.logarithmicDepthBufferEnabled && (s = 2 / (Math.log(a.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, s)), this._uGammaFactor && i.uniform1f(this._uGammaFactor, t.gammaFactor) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles batching color texture vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec2 uv;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), i.push("uniform mat3 uvDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("out vec4 vColor;"), i.push("out vec2 vUV;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vViewPosition = viewPosition;"), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);"), i.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e.gammaOutput, i = e._lightsState, s = e._sectionPlanesState, r = 0 < s.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Triangles batching color texture fragment shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), e.logarithmicDepthBufferEnabled && (a.push("in float isPerspective;"), a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), a.push("uniform sampler2D uColorMap;"), this._withSAO && (a.push("uniform sampler2D uOcclusionTexture;"), a.push("uniform vec4      uSAOParams;"), a.push("const float       packUpscale = 256. / 255.;"), a.push("const float       unpackDownScale = 255. / 256.;"), a.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), a.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), a.push("float unpackRGBToFloat( const in vec4 v ) {"), a.push("    return dot( v, unPackFactors );"), a.push("}")), a.push("uniform float gammaFactor;"), a.push("vec4 linearToLinear( in vec4 value ) {"), a.push("  return value;"), a.push("}"), a.push("vec4 sRGBToLinear( in vec4 value ) {"), a.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );"), a.push("}"), a.push("vec4 gammaToLinear( in vec4 value) {"), a.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );"), a.push("}"), t && (a.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), a.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), a.push("}")), r) { a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"); for (let e = 0, t = s.sectionPlanes.length; e < t; e++)a.push("uniform bool sectionPlaneActive" + e + ";"), a.push("uniform vec3 sectionPlanePos" + e + ";"), a.push("uniform vec3 sectionPlaneDir" + e + ";") } a.push("uniform mat4 viewMatrix;"), a.push("uniform vec4 lightAmbient;"); for (let e = 0, t = i.lights.length; e < t; e++) { var o = i.lights[e]; "ambient" !== o.type && (a.push("uniform vec4 lightColor" + e + ";"), "dir" === o.type && a.push("uniform vec3 lightDir" + e + ";"), "point" === o.type && a.push("uniform vec3 lightPos" + e + ";"), "spot" === o.type) && (a.push("uniform vec3 lightPos" + e + ";"), a.push("uniform vec3 lightDir" + e + ";")) } if (a.push("in vec4 vViewPosition;"), a.push("in vec4 vColor;"), a.push("in vec2 vUV;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), r) { a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"); for (let e = 0, t = s.sectionPlanes.length; e < t; e++)a.push("if (sectionPlaneActive" + e + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("  if (dist > 0.0) { "), a.push("      discard;"), a.push("  }"), a.push("}") } a.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), a.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), a.push("float lambertian = 1.0;"), a.push("vec3 xTangent = dFdx( vViewPosition.xyz );"), a.push("vec3 yTangent = dFdy( vViewPosition.xyz );"), a.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );"); for (let e = 0, t = i.lights.length; e < t; e++) { var n = i.lights[e]; if ("ambient" !== n.type) { if ("dir" === n.type) "view" === n.space ? a.push("viewLightDir = normalize(lightDir" + e + ");") : a.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === n.type) "view" === n.space ? a.push("viewLightDir = -normalize(lightPos" + e + " - viewPosition.xyz);") : a.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== n.type) continue; "view" === n.space ? a.push("viewLightDir = normalize(lightDir" + e + ");") : a.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);") } a.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), a.push("reflectedColor += lambertian * (lightColor" + e + ".rgb * lightColor" + e + ".a);") } } return a.push("vec4 color =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);"), a.push(t ? "vec4 colorTexel = color * sRGBToLinear(texture(uColorMap, vUV));" : "vec4 colorTexel = color * texture(uColorMap, vUV);"), a.push("float opacity = color.a;"), this._withSAO ? (a.push("   float viewportWidth     = uSAOParams[0];"), a.push("   float viewportHeight    = uSAOParams[1];"), a.push("   float blendCutoff       = uSAOParams[2];"), a.push("   float blendFactor       = uSAOParams[3];"), a.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), a.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), a.push("   outColor                = vec4(colorTexel.rgb * ambient, opacity);")) : a.push("   outColor                = vec4(colorTexel.rgb, opacity);"), t && a.push("outColor = linearToGamma(outColor, gammaFactor);"), e.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class TrianglesBatchingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._colorRendererWithSAO && !this._colorRendererWithSAO.getValid() && (this._colorRendererWithSAO.destroy(), this._colorRendererWithSAO = null), this._flatColorRenderer && !this._flatColorRenderer.getValid() && (this._flatColorRenderer.destroy(), this._flatColorRenderer = null), this._flatColorRendererWithSAO && !this._flatColorRendererWithSAO.getValid() && (this._flatColorRendererWithSAO.destroy(), this._flatColorRendererWithSAO = null), this._colorTextureRenderer && !this._colorTextureRenderer.getValid() && (this._colorTextureRenderer.destroy(), this._colorTextureRenderer = null), this._colorTextureRendererWithSAO && !this._colorTextureRendererWithSAO.getValid() && (this._colorTextureRendererWithSAO.destroy(), this._colorTextureRendererWithSAO = null), this._pbrRenderer && !this._pbrRenderer.getValid() && (this._pbrRenderer.destroy(), this._pbrRenderer = null), this._pbrRendererWithSAO && !this._pbrRendererWithSAO.getValid() && (this._pbrRendererWithSAO.destroy(), this._pbrRendererWithSAO = null), this._depthRenderer && !this._depthRenderer.getValid() && (this._depthRenderer.destroy(), this._depthRenderer = null), this._normalsRenderer && !this._normalsRenderer.getValid() && (this._normalsRenderer.destroy(), this._normalsRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null), this._edgesRenderer && !this._edgesRenderer.getValid() && (this._edgesRenderer.destroy(), this._edgesRenderer = null), this._edgesColorRenderer && !this._edgesColorRenderer.getValid() && (this._edgesColorRenderer.destroy(), this._edgesColorRenderer = null), this._pickMeshRenderer && !this._pickMeshRenderer.getValid() && (this._pickMeshRenderer.destroy(), this._pickMeshRenderer = null), this._pickDepthRenderer && !this._pickDepthRenderer.getValid() && (this._pickDepthRenderer.destroy(), this._pickDepthRenderer = null), this._pickNormalsRenderer && !1 === this._pickNormalsRenderer.getValid() && (this._pickNormalsRenderer.destroy(), this._pickNormalsRenderer = null), this._pickNormalsFlatRenderer && !1 === this._pickNormalsFlatRenderer.getValid() && (this._pickNormalsFlatRenderer.destroy(), this._pickNormalsFlatRenderer = null), this._occlusionRenderer && !1 === this._occlusionRenderer.getValid() && (this._occlusionRenderer.destroy(), this._occlusionRenderer = null), this._shadowRenderer && !this._shadowRenderer.getValid() && (this._shadowRenderer.destroy(), this._shadowRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new TrianglesBatchingColorRenderer(this._scene, !1)), this._colorRenderer } get colorRendererWithSAO() { return this._colorRendererWithSAO || (this._colorRendererWithSAO = new TrianglesBatchingColorRenderer(this._scene, !0)), this._colorRendererWithSAO } get flatColorRenderer() { return this._flatColorRenderer || (this._flatColorRenderer = new TrianglesBatchingFlatColorRenderer(this._scene, !1)), this._flatColorRenderer } get flatColorRendererWithSAO() { return this._flatColorRendererWithSAO || (this._flatColorRendererWithSAO = new TrianglesBatchingFlatColorRenderer(this._scene, !0)), this._flatColorRendererWithSAO } get colorTextureRenderer() { return this._colorTextureRenderer || (this._colorTextureRenderer = new TrianglesBatchingColorTextureRenderer(this._scene, !1)), this._colorTextureRenderer } get colorTextureRendererWithSAO() { return this._colorTextureRendererWithSAO || (this._colorTextureRendererWithSAO = new TrianglesBatchingColorTextureRenderer(this._scene, !0)), this._colorTextureRendererWithSAO } get pbrRenderer() { return this._pbrRenderer || (this._pbrRenderer = new TrianglesBatchingPBRRenderer(this._scene, !1)), this._pbrRenderer } get pbrRendererWithSAO() { return this._pbrRendererWithSAO || (this._pbrRendererWithSAO = new TrianglesBatchingPBRRenderer(this._scene, !0)), this._pbrRendererWithSAO } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new TrianglesBatchingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } get depthRenderer() { return this._depthRenderer || (this._depthRenderer = new TrianglesBatchingDepthRenderer(this._scene)), this._depthRenderer } get normalsRenderer() { return this._normalsRenderer || (this._normalsRenderer = new TrianglesBatchingNormalsRenderer(this._scene)), this._normalsRenderer } get edgesRenderer() { return this._edgesRenderer || (this._edgesRenderer = new TrianglesBatchingEdgesRenderer(this._scene)), this._edgesRenderer } get edgesColorRenderer() { return this._edgesColorRenderer || (this._edgesColorRenderer = new TrianglesBatchingEdgesColorRenderer(this._scene)), this._edgesColorRenderer } get pickMeshRenderer() { return this._pickMeshRenderer || (this._pickMeshRenderer = new TrianglesBatchingPickMeshRenderer(this._scene)), this._pickMeshRenderer } get pickNormalsRenderer() { return this._pickNormalsRenderer || (this._pickNormalsRenderer = new TrianglesBatchingPickNormalsRenderer(this._scene)), this._pickNormalsRenderer } get pickNormalsFlatRenderer() { return this._pickNormalsFlatRenderer || (this._pickNormalsFlatRenderer = new TrianglesBatchingPickNormalsFlatRenderer(this._scene)), this._pickNormalsFlatRenderer } get pickDepthRenderer() { return this._pickDepthRenderer || (this._pickDepthRenderer = new TrianglesBatchingPickDepthRenderer(this._scene)), this._pickDepthRenderer } get occlusionRenderer() { return this._occlusionRenderer || (this._occlusionRenderer = new TrianglesBatchingOcclusionRenderer(this._scene)), this._occlusionRenderer } get shadowRenderer() { return this._shadowRenderer || (this._shadowRenderer = new TrianglesBatchingShadowRenderer(this._scene)), this._shadowRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._colorRendererWithSAO && this._colorRendererWithSAO.destroy(), this._flatColorRenderer && this._flatColorRenderer.destroy(), this._flatColorRendererWithSAO && this._flatColorRendererWithSAO.destroy(), this._colorTextureRenderer && this._colorTextureRenderer.destroy(), this._colorTextureRendererWithSAO && this._colorTextureRendererWithSAO.destroy(), this._pbrRenderer && this._pbrRenderer.destroy(), this._pbrRendererWithSAO && this._pbrRendererWithSAO.destroy(), this._depthRenderer && this._depthRenderer.destroy(), this._normalsRenderer && this._normalsRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy(), this._edgesRenderer && this._edgesRenderer.destroy(), this._edgesColorRenderer && this._edgesColorRenderer.destroy(), this._pickMeshRenderer && this._pickMeshRenderer.destroy(), this._pickDepthRenderer && this._pickDepthRenderer.destroy(), this._pickNormalsRenderer && this._pickNormalsRenderer.destroy(), this._pickNormalsFlatRenderer && this._pickNormalsFlatRenderer.destroy(), this._occlusionRenderer && this._occlusionRenderer.destroy(), this._shadowRenderer && this._shadowRenderer.destroy() } } const cachdRenderers = {}; function getBatchingRenderers$1(e) { const t = e.id; let i = cachdRenderers[t]; return i || (i = new TrianglesBatchingRenderers(e), (cachdRenderers[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachdRenderers[t], i._destroy() }))), i } class TrianglesBatchingBuffer { constructor(e = 5e6) { this.maxVerts = e = 5e6 < e ? 5e6 : e, this.maxIndices = 3 * e, this.positions = [], this.colors = [], this.uv = [], this.metallicRoughness = [], this.normals = [], this.pickColors = [], this.flags = [], this.flags2 = [], this.offsets = [], this.indices = [], this.edgeIndices = [] } } const translate = math.mat4(), scale = math.mat4(); function quantizePositions(e, t, i) { var s = e.length, r = new Uint16Array(s), a = t[0], o = t[1], n = t[2], h = t[3] - a, l = t[4] - o, c = t[5] - n, u = 65525, p = u / h, d = u / l, m = u / c, f = e => 0 <= e ? e : 0; for (let t = 0; t < s; t += 3)r[t + 0] = Math.floor(f(e[t + 0] - a) * p), r[t + 1] = Math.floor(f(e[t + 1] - o) * d), r[t + 2] = Math.floor(f(e[t + 2] - n) * m); return math.identityMat4(translate), math.translationMat4v(t, translate), math.identityMat4(scale), math.scalingMat4v([h / u, l / u, c / u], scale), math.mulMat4(translate, scale, i), r } function transformAndOctEncodeNormals(e, t, i, s, r) { function a(e, t) { return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] } let o, n, h, l, c, u; var p = new Float32Array([0, 0, 0, 0]), d = new Float32Array([0, 0, 0, 0]); for (u = 0; u < i; u += 3)p[0] = t[u], p[1] = t[u + 1], p[2] = t[u + 2], math.transformVec3(e, p, d), math.normalizeVec3(d, d), h = o = octEncodeVec3(d, "floor", "floor"), n = octDecodeVec2(o), c = a(d, n), (l = a(d, octDecodeVec2(o = octEncodeVec3(d, "ceil", "floor")))) > c && (h = o, c = l), (l = a(d, octDecodeVec2(o = octEncodeVec3(d, "floor", "ceil")))) > c && (h = o, c = l), (l = a(d, octDecodeVec2(o = octEncodeVec3(d, "ceil", "ceil")))) > c && (h = o, c = l), s[r + u + 0] = h[0], s[r + u + 1] = h[1], s[r + u + 2] = 0; return r + i } function octEncodeNormals(e) { var t = e.length, i = new Int8Array(t); let s, r, a, o, n; for (let h = 0; h < t; h += 3)a = s = octEncodeNormal(e, h, "floor", "floor"), r = octDecodeVec2(s), n = dot(e, h, r), r = octDecodeVec2(s = octEncodeNormal(e, h, "ceil", "floor")), (o = dot(e, h, r)) > n && (a = s, n = o), r = octDecodeVec2(s = octEncodeNormal(e, h, "floor", "ceil")), (o = dot(e, h, r)) > n && (a = s, n = o), r = octDecodeVec2(s = octEncodeNormal(e, h, "ceil", "ceil")), (o = dot(e, h, r)) > n && (a = s, n = o), i[h + 0] = a[0], i[h + 1] = a[1], i[h + 2] = 0; return i } function octEncodeVec3(e, t, i) { let s = e[0] / (Math.abs(e[0]) + Math.abs(e[1]) + Math.abs(e[2])), r = e[1] / (Math.abs(e[0]) + Math.abs(e[1]) + Math.abs(e[2])); var a; return e[2] < 0 && (e = s, e = (1 - Math.abs(r)) * (0 <= s ? 1 : -1), a = (1 - Math.abs(s)) * (0 <= r ? 1 : -1), s = e, r = a), new Int8Array([Math[t](127.5 * s + (s < 0 ? -1 : 0)), Math[i](127.5 * r + (r < 0 ? -1 : 0))]) } function octEncodeNormal(e, t, i, s) { let r = e[t] / (Math.abs(e[t]) + Math.abs(e[t + 1]) + Math.abs(e[t + 2])), a = e[t + 1] / (Math.abs(e[t]) + Math.abs(e[t + 1]) + Math.abs(e[t + 2])); return e[t + 2] < 0 && (e = (1 - Math.abs(a)) * (0 <= r ? 1 : -1), t = (1 - Math.abs(r)) * (0 <= a ? 1 : -1), r = e, a = t), new Int8Array([Math[i](127.5 * r + (r < 0 ? -1 : 0)), Math[s](127.5 * a + (a < 0 ? -1 : 0))]) } function octDecodeVec2(e) { let t = e[0], i = e[1]; t /= t < 0 ? 127 : 128, i /= i < 0 ? 127 : 128, (e = 1 - Math.abs(t) - Math.abs(i)) < 0 && (t = (1 - Math.abs(i)) * (0 <= t ? 1 : -1), i = (1 - Math.abs(t)) * (0 <= i ? 1 : -1)); var s = Math.sqrt(t * t + i * i + e * e); return [t / s, i / s, e / s] } function dot(e, t, i) { return e[t] * i[0] + e[t + 1] * i[1] + e[t + 2] * i[2] } const tempMat4$2 = math.mat4(), tempMat4b = math.mat4(), tempVec4a$a = math.vec4([0, 0, 0, 1]), tempVec4b$a = math.vec4([0, 0, 0, 1]), tempVec4c$7 = math.vec4([0, 0, 0, 1]), tempOBB3$2 = math.OBB3(), tempVec3a$J = math.vec3(), tempVec3b$a = math.vec3(), tempVec3c$8 = math.vec3(), tempVec3d$3 = math.vec3(), tempVec3e$2 = math.vec3(), tempVec3f$2 = math.vec3(), tempVec3g$1 = math.vec3(); class TrianglesBatchingLayer { constructor(e) { this.model = e.model, this.sortId = "TrianglesBatchingLayer" + (e.solid ? "-solid" : "-surface") + (e.autoNormals ? "-autonormals" : "-normals") + (e.textureSet && e.textureSet.colorTexture ? "-colorTexture" : "") + (e.textureSet && e.textureSet.metallicRoughnessTexture ? "-metallicRoughnessTexture" : ""), this.layerIndex = e.layerIndex, this._batchingRenderers = getBatchingRenderers$1(e.model.scene), this._buffer = new TrianglesBatchingBuffer(e.maxGeometryBatchSize), this._scratchMemory = e.scratchMemory, this._state = new RenderState({ origin: math.vec3(), positionsBuf: null, offsetsBuf: null, normalsBuf: null, colorsBuf: null, uvBuf: null, metallicRoughnessBuf: null, flagsBuf: null, flags2Buf: null, indicesBuf: null, edgeIndicesBuf: null, positionsDecodeMatrix: math.mat4(), uvDecodeMatrix: null, textureSet: e.textureSet, pbrSupported: !1 }), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numEdgesLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this._modelAABB = math.collapseAABB3(), this._portions = [], this._numVerts = 0, this._finalized = !1, e.positionsDecodeMatrix ? (this._state.positionsDecodeMatrix.set(e.positionsDecodeMatrix), this._preCompressedPositionsExpected = !0) : this._preCompressedPositionsExpected = !1, e.uvDecodeMatrix ? (this._state.uvDecodeMatrix = math.mat3(e.uvDecodeMatrix), this._preCompressedNormalsExpected = !0) : this._preCompressedNormalsExpected = !1, e.origin && this._state.origin.set(e.origin), this.aabb = math.collapseAABB3(), this.solid = !!e.solid } canCreatePortion(e, t) { if (this._finalized) throw "Already finalized"; return this._buffer.positions.length + e < 3 * this._buffer.maxVerts && this._buffer.indices.length + t < this._buffer.maxIndices } createPortion(e) { if (this._finalized) throw "Already finalized"; var t = e.positions, i = e.positionsCompressed, s = e.normals, r = e.normalsCompressed, a = e.uv, o = e.uvCompressed, n = e.colors, h = e.colorsCompressed, l = e.indices, c = e.edgeIndices, u = e.color, p = e.metallic, d = e.roughness, m = e.opacity, f = e.meshMatrix, g = e.worldMatrix, _ = e.worldAABB, v = e.pickColor, y = (e = this.model.scene, this._buffer), T = y.positions.length / 3; let I; if (this._preCompressedPositionsExpected) { if (!i) throw "positionsCompressed expected"; I = i.length / 3; for (let e = 0, t = i.length; e < t; e++)y.positions.push(i[e]); var E = geometryCompressionUtils.getPositionsBounds(i), C = geometryCompressionUtils.decompressPosition(E.min, this._state.positionsDecodeMatrix, []); E = geometryCompressionUtils.decompressPosition(E.max, this._state.positionsDecodeMatrix, []); _[0] = C[0], _[1] = C[1], _[2] = C[2], _[3] = E[0], _[4] = E[1], _[5] = E[2], g && (math.AABB3ToOBB3(_, tempOBB3$2), math.transformOBB3(g, tempOBB3$2), math.OBB3ToAABB3(tempOBB3$2, _)) } else { if (!t) throw "positions expected"; I = t.length / 3, C = t.length, E = y.positions.length; for (let e = 0, i = t.length; e < i; e++)y.positions.push(t[e]); if (f) for (let e = E, t = E + C; e < t; e += 3)tempVec4a$a[0] = y.positions[e + 0], tempVec4a$a[1] = y.positions[e + 1], tempVec4a$a[2] = y.positions[e + 2], math.transformPoint4(f, tempVec4a$a, tempVec4b$a), y.positions[e + 0] = tempVec4b$a[0], y.positions[e + 1] = tempVec4b$a[1], y.positions[e + 2] = tempVec4b$a[2], math.expandAABB3Point3(this._modelAABB, tempVec4b$a), g ? (math.transformPoint4(g, tempVec4b$a, tempVec4c$7), math.expandAABB3Point3(_, tempVec4c$7)) : math.expandAABB3Point3(_, tempVec4b$a); else for (let e = E, t = E + C; e < t; e += 3)tempVec4a$a[0] = y.positions[e + 0], tempVec4a$a[1] = y.positions[e + 1], tempVec4a$a[2] = y.positions[e + 2], math.expandAABB3Point3(this._modelAABB, tempVec4a$a), g ? (math.transformPoint4(g, tempVec4a$a, tempVec4b$a), math.expandAABB3Point3(_, tempVec4b$a)) : math.expandAABB3Point3(_, tempVec4a$a) } if (this._state.origin && (E = this._state.origin, _[0] += E[0], _[1] += E[1], _[2] += E[2], _[3] += E[0], _[4] += E[1], _[5] += E[2]), math.expandAABB3(this.aabb, _), r && 0 < r.length) for (let e = 0, t = r.length; e < t; e++)y.normals.push(r[e]); else s && 0 < s.length && (C = tempMat4$2, f ? math.inverseMat4(math.transposeMat4(f, tempMat4b), C) : math.identityMat4(C, C), transformAndOctEncodeNormals(C, s, s.length, y.normals, y.normals.length)); if (n) for (let e = 0, t = n.length; e < t; e += 3)y.colors.push(255 * n[e]), y.colors.push(255 * n[e + 1]), y.colors.push(255 * n[e + 2]), y.colors.push(255); else if (h) for (let e = 0, t = n.length; e < t; e += 3)y.colors.push(n[e]), y.colors.push(n[e + 1]), y.colors.push(n[e + 2]), y.colors.push(255); else if (u) { var P = u[0], b = u[1], A = u[2], D = m; for (let e = 0; e < I; e++)y.colors.push(P), y.colors.push(b), y.colors.push(A), y.colors.push(D) } var R = null != p ? p : 0, F = null != d ? d : 255; for (let e = 0; e < I; e++)y.metallicRoughness.push(R), y.metallicRoughness.push(F); if (a && 0 < a.length) for (let e = 0, t = a.length; e < t; e++)y.uv.push(a[e]); else if (o && 0 < o.length) for (let e = 0, t = o.length; e < t; e++)y.uv.push(o[e]); if (l) for (let e = 0, t = l.length; e < t; e++)y.indices.push(T + l[e]); if (c) for (let e = 0, t = c.length; e < t; e++)y.edgeIndices.push(T + c[e]); for (let e = E = y.pickColors.length, t = E + 4 * I; e < t; e += 4)y.pickColors.push(v[0]), y.pickColors.push(v[1]), y.pickColors.push(v[2]), y.pickColors.push(v[3]); if (e.entityOffsetsEnabled) for (let e = 0; e < I; e++)y.offsets.push(0), y.offsets.push(0), y.offsets.push(0); return C = this._portions.length, s = { vertsBaseIndex: T, numVerts: I }, e.pickSurfacePrecisionEnabled && (l && (s.indices = l), e.entityOffsetsEnabled) && (s.offset = new Float32Array(3)), this._portions.push(s), this._numPortions++, this.model.numPortions++, this._numVerts += s.numVerts, C } finalize() { if (this._finalized) this.model.error("Already finalized"); else { var e, t, i = this._state, s = this.model.scene.canvas.gl, r = this._buffer; if (0 < r.positions.length) { var a = this._preCompressedPositionsExpected ? new Uint16Array(r.positions) : quantizePositions(r.positions, this._modelAABB, i.positionsDecodeMatrix); if (i.positionsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, a, a.length, 3, s.STATIC_DRAW), this.model.scene.pickSurfacePrecisionEnabled) for (let e = 0, t = this._portions.length; e < t; e++) { var o = this._portions[e], n = 3 * o.vertsBaseIndex, h = n + 3 * o.numVerts; o.quantizedPositions = a.slice(n, h) } } 0 < r.normals.length && (e = new Int8Array(r.normals), i.normalsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, r.normals.length, 3, s.STATIC_DRAW, !0)), 0 < r.colors.length && (e = new Uint8Array(r.colors), i.colorsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, r.colors.length, 4, s.DYNAMIC_DRAW, !1)), 0 < r.uv.length && (i.uvDecodeMatrix ? i.uvBuf = new ArrayBuf(s, s.ARRAY_BUFFER, r.uv, r.uv.length, 2, s.STATIC_DRAW, !1) : (e = geometryCompressionUtils.getUVBounds(r.uv), t = (e = geometryCompressionUtils.compressUVs(r.uv, e.min, e.max)).quantized, i.uvDecodeMatrix = math.mat3(e.decodeMatrix), i.uvBuf = new ArrayBuf(s, s.ARRAY_BUFFER, t, t.length, 2, s.STATIC_DRAW, !1))), 0 < r.metallicRoughness.length && (e = new Uint8Array(r.metallicRoughness), i.metallicRoughnessBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, r.metallicRoughness.length, 2, s.STATIC_DRAW, !1)), 0 < r.positions.length && (t = r.positions.length / 3 * 4, e = new Uint8Array(t), t = new Uint8Array(t), i.flagsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, e.length, 4, s.DYNAMIC_DRAW, !1), i.flags2Buf = new ArrayBuf(s, s.ARRAY_BUFFER, t, t.length, 4, s.DYNAMIC_DRAW, !0)), 0 < r.pickColors.length && (e = new Uint8Array(r.pickColors), i.pickColorsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, r.pickColors.length, 4, s.STATIC_DRAW, !1)), this.model.scene.entityOffsetsEnabled && 0 < r.offsets.length && (t = new Float32Array(r.offsets), i.offsetsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, t, r.offsets.length, 3, s.DYNAMIC_DRAW)), 0 < r.indices.length && (e = new Uint32Array(r.indices), i.indicesBuf = new ArrayBuf(s, s.ELEMENT_ARRAY_BUFFER, e, r.indices.length, 1, s.STATIC_DRAW)), 0 < r.edgeIndices.length && (t = new Uint32Array(r.edgeIndices), i.edgeIndicesBuf = new ArrayBuf(s, s.ELEMENT_ARRAY_BUFFER, t, r.edgeIndices.length, 1, s.STATIC_DRAW)), this._state.pbrSupported = !!(i.metallicRoughnessBuf && i.uvBuf && i.normalsBuf && i.textureSet && i.textureSet.colorTexture && i.textureSet.metallicRoughnessTexture), this._state.colorTextureSupported = !!i.uvBuf && !!i.textureSet && !!i.textureSet.colorTexture, this._buffer = null, this._finalized = !0 } } isEmpty() { return !this._state.indicesBuf } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.EDGES && (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i, !0), this._setFlags2(e, t, !0) } flushInitFlags() { this._setDeferredFlags(), this._setDeferredFlags2() } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.EDGES ? (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++) : (this._numEdgesLayerPortions--, this.model.numEdgesLayerPortions--), this._setFlags(e, t, i) } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; var i = 4 * (e = this._portions[e]).vertsBaseIndex, s = 4 * e.numVerts, r = this._scratchMemory.getUInt8Array(s), a = t[0], o = t[1], n = t[2], h = t[3]; for (let e = 0; e < s; e += 4)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n, r[e + 3] = h; this._state.colorsBuf && this._state.colorsBuf.setData(r, i, s) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i, s = !1) { if (!this._finalized) throw "Not finalized"; var r, a = 4 * (e = this._portions[e]).vertsBaseIndex, o = 4 * e.numVerts, n = (e = !!(t & ENTITY_FLAGS.VISIBLE), !!(t & ENTITY_FLAGS.XRAYED)), h = !!(t & ENTITY_FLAGS.HIGHLIGHTED), l = !!(t & ENTITY_FLAGS.SELECTED), c = !!(t & ENTITY_FLAGS.EDGES), u = !!(t & ENTITY_FLAGS.PICKABLE), p = (t = !!(t & ENTITY_FLAGS.CULLED), !e || t || n || h && !this.model.scene.highlightMaterial.glowThrough || l && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE), d = (r = !e || t ? RENDER_PASSES.NOT_RENDERED : l ? RENDER_PASSES.SILHOUETTE_SELECTED : h ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : n ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, !e || t ? RENDER_PASSES.NOT_RENDERED : l ? RENDER_PASSES.EDGES_SELECTED : h ? RENDER_PASSES.EDGES_HIGHLIGHTED : n ? RENDER_PASSES.EDGES_XRAYED : c ? i ? RENDER_PASSES.EDGES_COLOR_TRANSPARENT : RENDER_PASSES.EDGES_COLOR_OPAQUE : RENDER_PASSES.NOT_RENDERED), m = e && !t && u ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; if (s) { this._deferredFlagValues || (this._deferredFlagValues = new Uint8Array(4 * this._numVerts)); for (let e = a, t = a + o; e < t; e += 4)this._deferredFlagValues[e + 0] = p, this._deferredFlagValues[e + 1] = r, this._deferredFlagValues[e + 2] = d, this._deferredFlagValues[e + 3] = m } else if (this._state.flagsBuf) { var f = this._scratchMemory.getUInt8Array(o); for (let e = 0; e < o; e += 4)f[e + 0] = p, f[e + 1] = r, f[e + 2] = d, f[e + 3] = m; this._state.flagsBuf.setData(f, a, o) } } _setDeferredFlags() { this._deferredFlagValues && (this._state.flagsBuf.setData(this._deferredFlagValues), this._deferredFlagValues = null) } _setFlags2(e, t, i = !1) { if (!this._finalized) throw "Not finalized"; var s = 4 * (e = this._portions[e]).vertsBaseIndex, r = 4 * e.numVerts, a = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0; if (i) { this._setDeferredFlag2Values || (this._setDeferredFlag2Values = new Uint8Array(4 * this._numVerts)); for (let e = s, t = s + r; e < t; e += 4)this._setDeferredFlag2Values[e] = a } else if (this._state.flags2Buf) { var o = this._scratchMemory.getUInt8Array(r); for (let e = 0; e < r; e += 4)o[e + 0] = a; this._state.flags2Buf.setData(o, s, r) } } _setDeferredFlags2() { this._setDeferredFlag2Values && (this._state.flags2Buf.setData(this._setDeferredFlag2Values), this._setDeferredFlag2Values = null) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; if (this.model.scene.entityOffsetsEnabled) { var i = 3 * (e = this._portions[e]).vertsBaseIndex, s = 3 * e.numVerts, r = this._scratchMemory.getFloat32Array(s), a = t[0], o = t[1], n = t[2]; for (let e = 0; e < s; e += 3)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n; this._state.offsetsBuf && this._state.offsetsBuf.setData(r, i, s), this.model.scene.pickSurfacePrecisionEnabled && (e.offset[0] = t[0], e.offset[1] = t[1], e.offset[2] = t[2]) } else this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), t.withSAO && this.model.saoEnabled ? t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._batchingRenderers.pbrRendererWithSAO && this._batchingRenderers.pbrRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._batchingRenderers.colorTextureRendererWithSAO && this._batchingRenderers.colorTextureRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._state.normalsBuf ? this._batchingRenderers.colorRendererWithSAO && this._batchingRenderers.colorRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._batchingRenderers.flatColorRendererWithSAO && this._batchingRenderers.flatColorRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._batchingRenderers.pbrRenderer && this._batchingRenderers.pbrRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._batchingRenderers.colorTextureRenderer && this._batchingRenderers.colorTextureRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._state.normalsBuf ? this._batchingRenderers.colorRenderer && this._batchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._batchingRenderers.flatColorRenderer && this._batchingRenderers.flatColorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE)) } _updateBackfaceCull(e, t) { var i; e = this.model.backfaces || !this.solid || e.sectioned; t.backfaces !== e && (i = t.gl, e ? i.disable(i.CULL_FACE) : i.enable(i.CULL_FACE), t.backfaces = e) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._batchingRenderers.pbrRenderer && this._batchingRenderers.pbrRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._batchingRenderers.colorTextureRenderer && this._batchingRenderers.colorTextureRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : this._state.normalsBuf ? this._batchingRenderers.colorRenderer && this._batchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : this._batchingRenderers.flatColorRenderer && this._batchingRenderers.flatColorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT)) } drawDepth(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.depthRenderer) && this._batchingRenderers.depthRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawNormals(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.normalsRenderer) && this._batchingRenderers.normalsRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.silhouetteRenderer) && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.silhouetteRenderer) && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.silhouetteRenderer) && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numEdgesLayerPortions && this._batchingRenderers.edgesColorRenderer && this._batchingRenderers.edgesColorRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_COLOR_OPAQUE) } drawEdgesColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numEdgesLayerPortions && 0 !== this._numTransparentLayerPortions && this._batchingRenderers.edgesColorRenderer && this._batchingRenderers.edgesColorRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_COLOR_TRANSPARENT) } drawEdgesHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._batchingRenderers.edgesRenderer && this._batchingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_HIGHLIGHTED) } drawEdgesSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._batchingRenderers.edgesRenderer && this._batchingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_SELECTED) } drawEdgesXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._batchingRenderers.edgesRenderer && this._batchingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_XRAYED) } drawOcclusion(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.occlusionRenderer) && this._batchingRenderers.occlusionRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawShadow(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.shadowRenderer) && this._batchingRenderers.shadowRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawPickMesh(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.pickMeshRenderer) && this._batchingRenderers.pickMeshRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickDepths(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.pickDepthRenderer) && this._batchingRenderers.pickDepthRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickNormals(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._batchingRenderers.pickNormalsFlatRenderer) && this._batchingRenderers.pickNormalsFlatRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } precisionRayPickSurface(e, t, i, s, r) { if (!this.model.scene.pickSurfacePrecisionEnabled) return !1; var a = this._state, o = this._portions[e]; if (!o) return this.model.error("portion not found: " + e), !1; var n = o.quantizedPositions, h = o.indices, l = a.origin, c = o.offset, u = tempVec3a$J, p = tempVec3b$a, d = (u.set(l ? math.subVec3(t, l, tempVec3c$8) : t), p.set(i), c && math.subVec3(u, c), math.transformRay(this.model.worldNormalMatrix, u, p, u, p), tempVec3d$3), m = tempVec3e$2, f = tempVec3f$2; let g = !1, _ = 0; var v = tempVec3g$1; for (let e = 0, i = h.length; e < i; e += 3) { var y = 3 * h[e], T = 3 * h[e + 1], I = 3 * h[e + 2]; d[0] = n[y], d[1] = n[1 + y], d[2] = n[2 + y], m[0] = n[T], m[1] = n[1 + T], m[2] = n[2 + T], f[0] = n[I], f[1] = n[1 + I], f[2] = n[2 + I], math.decompressPosition(d, a.positionsDecodeMatrix), math.decompressPosition(m, a.positionsDecodeMatrix), math.decompressPosition(f, a.positionsDecodeMatrix), math.rayTriangleIntersect(u, p, d, m, f, v) && (math.transformPoint3(this.model.worldMatrix, v, v), c && math.addVec3(v, c), l && math.addVec3(v, l), y = Math.abs(math.lenVec3(math.subVec3(v, t, []))), !g || y > _) && (_ = y, s.set(v), r && math.triangleNormal(d, m, f, r), g = !0) } return g && r && (math.transformVec3(this.model.worldNormalMatrix, r, r), math.normalizeVec3(r)), g } destroy() { var e = this._state; e.positionsBuf && (e.positionsBuf.destroy(), e.positionsBuf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.normalsBuf && (e.normalsBuf.destroy(), e.normalsBuf = null), e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.metallicRoughnessBuf && (e.metallicRoughnessBuf.destroy(), e.metallicRoughnessBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.pickColorsBuf && (e.pickColorsBuf.destroy(), e.pickColorsBuf = null), e.indicesBuf && (e.indicesBuf.destroy(), e.indicessBuf = null), e.edgeIndicesBuf && (e.edgeIndicesBuf.destroy(), e.edgeIndicessBuf = null), e.destroy() } } const tempVec4$3 = math.vec4(), tempVec3a$I = math.vec3(); class TrianglesInstancingColorRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uViewNormalMatrix, !1, a.viewNormalMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uWorldNormalMatrix, !1, s.worldNormalMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$I), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aModelNormalMatrixCol0.bindArrayBuffer(n.modelNormalMatrixCol0Buf), this._aModelNormalMatrixCol1.bindArrayBuffer(n.modelNormalMatrixCol1Buf), this._aModelNormalMatrixCol2.bindArrayBuffer(n.modelNormalMatrixCol2Buf), o.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aNormal.bindArrayBuffer(h.normalsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), e.drawElements++, o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 0), o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aNormal = s.getAttribute("normal"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aOffset = s.getAttribute("offset"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._aModelNormalMatrixCol0 = s.getAttribute("modelNormalMatrixCol0"), this._aModelNormalMatrixCol1 = s.getAttribute("modelNormalMatrixCol1"), this._aModelNormalMatrixCol2 = s.getAttribute("modelNormalMatrixCol2"), this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t, i, s, r = this._scene, a = r.canvas.gl, o = r._lightsState.lights, n = r.camera.project; this._program.bind(), a.uniformMatrix4fv(this._uProjMatrix, !1, n.matrix), this._uLightAmbient && a.uniform4fv(this._uLightAmbient, r._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = o.length; e < t; e++) { var h = o[e]; this._uLightColor[e] && a.uniform4f(this._uLightColor[e], h.color[0], h.color[1], h.color[2], h.intensity), this._uLightPos[e] && (a.uniform3fv(this._uLightPos[e], h.pos), this._uLightAttenuation[e]) && a.uniform1f(this._uLightAttenuation[e], h.attenuation), this._uLightDir[e] && a.uniform3fv(this._uLightDir[e], h.dir) } this._withSAO && (t = r.sao).possible && (s = a.drawingBufferWidth, i = a.drawingBufferHeight, tempVec4$3[0] = s, tempVec4$3[1] = i, tempVec4$3[2] = t.blendCutoff, tempVec4$3[3] = t.blendFactor, a.uniform4fv(this._uSAOParams, tempVec4$3), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, 0)), r.logarithmicDepthBufferEnabled && (s = 2 / (Math.log(n.far + 1) / Math.LN2), a.uniform1f(this._uLogDepthBufFC, s)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = e._sectionPlanesState, i = e._lightsState; t = 0 < t.sectionPlanes.length; let s, r, a; var o = []; for (o.push("#version 300 es"), o.push("// Instancing geometry drawing vertex shader"), o.push("uniform int renderPass;"), o.push("in vec3 position;"), o.push("in vec2 normal;"), o.push("in vec4 color;"), o.push("in vec4 flags;"), o.push("in vec4 flags2;"), e.entityOffsetsEnabled && o.push("in vec3 offset;"), o.push("in vec4 modelMatrixCol0;"), o.push("in vec4 modelMatrixCol1;"), o.push("in vec4 modelMatrixCol2;"), o.push("in vec4 modelNormalMatrixCol0;"), o.push("in vec4 modelNormalMatrixCol1;"), o.push("in vec4 modelNormalMatrixCol2;"), o.push("uniform mat4 worldMatrix;"), o.push("uniform mat4 worldNormalMatrix;"), o.push("uniform mat4 viewMatrix;"), o.push("uniform mat4 viewNormalMatrix;"), o.push("uniform mat4 projMatrix;"), o.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (o.push("uniform float logDepthBufFC;"), o.push("out float vFragDepth;"), o.push("bool isPerspectiveMatrix(mat4 m) {"), o.push("    return (m[2][3] == - 1.0);"), o.push("}"), o.push("out float isPerspective;")), o.push("uniform vec4 lightAmbient;"), s = 0, r = i.lights.length; s < r; s++)"ambient" !== (a = i.lights[s]).type && (o.push("uniform vec4 lightColor" + s + ";"), "dir" === a.type && o.push("uniform vec3 lightDir" + s + ";"), "point" === a.type && o.push("uniform vec3 lightPos" + s + ";"), "spot" === a.type) && (o.push("uniform vec3 lightPos" + s + ";"), o.push("uniform vec3 lightDir" + s + ";")); for (o.push("vec3 octDecode(vec2 oct) {"), o.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), o.push("    if (v.z < 0.0) {"), o.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), o.push("    }"), o.push("    return normalize(v);"), o.push("}"), t && (o.push("out vec4 vWorldPosition;"), o.push("out vec4 vFlags2;")), o.push("out vec4 vColor;"), o.push("void main(void) {"), o.push("if (int(flags.x) != renderPass) {"), o.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), o.push("} else {"), o.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), o.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && o.push("      worldPosition.xyz = worldPosition.xyz + offset;"), o.push("vec4 viewPosition  = viewMatrix * worldPosition; "), o.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); "), o.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 0.0);"), o.push("vec3 viewNormal = normalize(vec4(viewNormalMatrix * worldNormal).xyz);"), o.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), o.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), o.push("float lambertian = 1.0;"), s = 0, r = i.lights.length; s < r; s++)if ("ambient" !== (a = i.lights[s]).type) { if ("dir" === a.type) "view" === a.space ? o.push("viewLightDir = normalize(lightDir" + s + ");") : o.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + s + ", 0.0)).xyz);"); else if ("point" === a.type) "view" === a.space ? o.push("viewLightDir = -normalize(lightPos" + s + " - viewPosition.xyz);") : o.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + s + ", 0.0)).xyz);"); else { if ("spot" !== a.type) continue; "view" === a.space ? o.push("viewLightDir = normalize(lightDir" + s + ");") : o.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + s + ", 0.0)).xyz);") } o.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), o.push("reflectedColor += lambertian * (lightColor" + s + ".rgb * lightColor" + s + ".a);") } return o.push("vec3 rgb = (vec3(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0));"), o.push("vColor =  vec4((lightAmbient.rgb * lightAmbient.a * rgb) + (reflectedColor * rgb), float(color.a) / 255.0);"), o.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (o.push("vFragDepth = 1.0 + clipPos.w;"), o.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (o.push("vWorldPosition = worldPosition;"), o.push("vFlags2 = flags2;")), o.push("gl_Position = clipPos;"), o.push("}"), o.push("}"), o } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing geometry drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), this._withSAO && (s.push("uniform sampler2D uOcclusionTexture;"), s.push("uniform vec4      uSAOParams;"), s.push("const float       packUpscale = 256. / 255.;"), s.push("const float       unpackDownScale = 255. / 256.;"), s.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), s.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), s.push("float unpackRGBToFloat( const in vec4 v ) {"), s.push("    return dot( v, unPackFactors );"), s.push("}")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { "), s.push("      discard;"), s.push("  }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), this._withSAO ? (s.push("   float viewportWidth     = uSAOParams[0];"), s.push("   float viewportHeight    = uSAOParams[1];"), s.push("   float blendCutoff       = uSAOParams[2];"), s.push("   float blendFactor       = uSAOParams[3];"), s.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), s.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), s.push("   outColor                = vec4(vColor.rgb * ambient, 1.0);")) : s.push("    outColor           = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4$2 = math.vec4(), tempVec3a$H = math.vec3(); class TrianglesInstancingFlatColorRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f = this._uSectionPlanes[e], g = d.sectionPlanesActivePerLayer[p + e]; o.uniform1i(f.active, g ? 1 : 0), g && (g = u[e], l ? (m = getPlaneRTCPos(g.dist, g.dir, l, tempVec3a$H), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, g.pos), o.uniform3fv(f.dir, g.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aOffset = s.getAttribute("offset"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t, i, s, r = this._scene, a = r.canvas.gl, o = r._lightsState.lights, n = r.camera.project; this._program.bind(), a.uniformMatrix4fv(this._uProjMatrix, !1, n.matrix), this._uLightAmbient && a.uniform4fv(this._uLightAmbient, r._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = o.length; e < t; e++) { var h = o[e]; this._uLightColor[e] && a.uniform4f(this._uLightColor[e], h.color[0], h.color[1], h.color[2], h.intensity), this._uLightPos[e] && (a.uniform3fv(this._uLightPos[e], h.pos), this._uLightAttenuation[e]) && a.uniform1f(this._uLightAttenuation[e], h.attenuation), this._uLightDir[e] && a.uniform3fv(this._uLightDir[e], h.dir) } this._withSAO && (t = r.sao).possible && (s = a.drawingBufferWidth, i = a.drawingBufferHeight, tempVec4$2[0] = s, tempVec4$2[1] = i, tempVec4$2[2] = t.blendCutoff, tempVec4$2[3] = t.blendFactor, a.uniform4fv(this._uSAOParams, tempVec4$2), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, 0)), r.logarithmicDepthBufferEnabled && (s = 2 / (Math.log(n.far + 1) / Math.LN2), a.uniform1f(this._uLogDepthBufFC, s)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry flat-shading drawing vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vViewPosition = viewPosition;"), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = e._lightsState; let s, r; var a = 0 < t.sectionPlanes.length, o = []; if (o.push("#version 300 es"), o.push("// Instancing geometry flat-shading drawing fragment shader"), o.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), o.push("precision highp float;"), o.push("precision highp int;"), o.push("#else"), o.push("precision mediump float;"), o.push("precision mediump int;"), o.push("#endif"), e.logarithmicDepthBufferEnabled && (o.push("in float isPerspective;"), o.push("uniform float logDepthBufFC;"), o.push("in float vFragDepth;")), this._withSAO && (o.push("uniform sampler2D uOcclusionTexture;"), o.push("uniform vec4      uSAOParams;"), o.push("const float       packUpscale = 256. / 255.;"), o.push("const float       unpackDownScale = 255. / 256.;"), o.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), o.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), o.push("float unpackRGBToFloat( const in vec4 v ) {"), o.push("    return dot( v, unPackFactors );"), o.push("}")), a) { o.push("in vec4 vWorldPosition;"), o.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)o.push("uniform bool sectionPlaneActive" + e + ";"), o.push("uniform vec3 sectionPlanePos" + e + ";"), o.push("uniform vec3 sectionPlaneDir" + e + ";") } for (o.push("uniform mat4 viewMatrix;"), o.push("uniform vec4 lightAmbient;"), s = 0, r = i.lights.length; s < r; s++) { var n = i.lights[s]; "ambient" !== n.type && (o.push("uniform vec4 lightColor" + s + ";"), "dir" === n.type && o.push("uniform vec3 lightDir" + s + ";"), "point" === n.type && o.push("uniform vec3 lightPos" + s + ";"), "spot" === n.type) && (o.push("uniform vec3 lightPos" + s + ";"), o.push("uniform vec3 lightDir" + s + ";")) } if (o.push("in vec4 vViewPosition;"), o.push("in vec4 vColor;"), o.push("out vec4 outColor;"), o.push("void main(void) {"), a) { o.push("  bool clippable = (float(vFlags2.x) > 0.0);"), o.push("  if (clippable) {"), o.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)o.push("if (sectionPlaneActive" + e + ") {"), o.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), o.push("}"); o.push("  if (dist > 0.0) { "), o.push("      discard;"), o.push("  }"), o.push("}") } for (o.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), o.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), o.push("float lambertian = 1.0;"), o.push("vec3 xTangent = dFdx( vViewPosition.xyz );"), o.push("vec3 yTangent = dFdy( vViewPosition.xyz );"), o.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );"), s = 0, r = i.lights.length; s < r; s++) { var h = i.lights[s]; if ("ambient" !== h.type) { if ("dir" === h.type) "view" === h.space ? o.push("viewLightDir = normalize(lightDir" + s + ");") : o.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + s + ", 0.0)).xyz);"); else if ("point" === h.type) "view" === h.space ? o.push("viewLightDir = -normalize(lightPos" + s + " - viewPosition.xyz);") : o.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + s + ", 0.0)).xyz);"); else { if ("spot" !== h.type) continue; "view" === h.space ? o.push("viewLightDir = normalize(lightDir" + s + ");") : o.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + s + ", 0.0)).xyz);") } o.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), o.push("reflectedColor += lambertian * (lightColor" + s + ".rgb * lightColor" + s + ".a);") } } return o.push("vec4 fragColor = vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);"), this._withSAO ? (o.push("   float viewportWidth     = uSAOParams[0];"), o.push("   float viewportHeight    = uSAOParams[1];"), o.push("   float blendCutoff       = uSAOParams[2];"), o.push("   float blendFactor       = uSAOParams[3];"), o.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), o.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), o.push("   outColor            = vec4(fragColor.rgb * ambient, 1.0);")) : o.push("    outColor           = fragColor;"), e.logarithmicDepthBufferEnabled && o.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), o.push("}"), o } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$G = math.vec3(); class TrianglesInstancingSilhouetteRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t.model.scene), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (c = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (c = r.highlightMaterial._state).fillColor, c = c.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], c)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (c = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], i)) : o.uniform4fv(this._uColor, math.vec3([1, 1, 1])), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c, u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], l ? (g = getPlaneRTCPos(f.dist, f.dir, l, tempVec3a$G), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uColor = s.getLocation("color"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing fill vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("uniform vec4 color;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.y) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing fill fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("uniform vec4 color;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = color;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$F = math.vec3(), defaultColor$2 = new Float32Array([0, 0, 0, 1]); class TrianglesInstancingEdgesRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.EDGES_XRAYED ? (c = (e = r.xrayMaterial._state).edgeColor, e = e.edgeAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], e)) : i === RENDER_PASSES.EDGES_HIGHLIGHTED ? (e = (c = r.highlightMaterial._state).edgeColor, c = c.edgeAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], c)) : i === RENDER_PASSES.EDGES_SELECTED ? (c = (e = r.selectedMaterial._state).edgeColor, i = e.edgeAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], i)) : o.uniform4fv(this._uColor, defaultColor$2), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c, u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], l ? (g = getPlaneRTCPos(f.dist, f.dir, l, tempVec3a$F), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aFlags && (this._aFlags.bindArrayBuffer(n.flagsBuf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags.location, 1)), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.edgeIndicesBuf.bind(), o.drawElementsInstanced(o.LINES, h.edgeIndicesBuf.numItems, h.edgeIndicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0), this._aFlags && o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uColor = s.getLocation("color"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles instancing edges vertex shader"), i.push("uniform int renderPass;"), i.push("uniform vec4 color;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.z) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vColor = vec4(color.r, color.g, color.b, color.a);"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry edges drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$E = math.vec3(); class TrianglesInstancingEdgesColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$E), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1), this._aFlags && (this._aFlags.bindArrayBuffer(n.flagsBuf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags.location, 1)), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.edgeIndicesBuf.bind(), o.drawElementsInstanced(o.LINES, h.edgeIndicesBuf.numItems, h.edgeIndicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aColor.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0), this._aFlags && o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aColor = s.getAttribute("color"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Triangles instancing edges vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.z) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vColor = vec4(float(color.r*0.5) / 255.0, float(color.g*0.5) / 255.0, float(color.b*0.5) / 255.0, float(color.a) / 255.0);"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry edges drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vColor;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$D = math.vec3(); class TrianglesInstancingPickMeshRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i); i = e.pickViewMatrix || a.viewMatrix, i = l ? createRTCViewMat(i, l) : i; var c = (o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPickColor.bindArrayBuffer(n.pickColorsBuf), o.vertexAttribDivisor(this._aPickColor.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$D), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aPickColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uPickInvisible = s.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._uRenderPass = s.getLocation("renderPass"), this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aPickColor = s.getAttribute("pickColor"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene.canvas.gl; this._program.bind(), t.uniform1i(this._uPickInvisible, e.pickInvisible) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry picking vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 pickColor;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vPickColor;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);"), t && (i.push("  vWorldPosition = worldPosition;"), i.push("  vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry picking fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vPickColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vPickColor; "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$C = math.vec3(); class TrianglesInstancingPickDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.canvas.gl, o = t._state, n = o.geometry, h = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()); var l = r.camera, c = (i = (a.uniform1i(this._uRenderPass, i), a.uniform1i(this._uPickInvisible, e.pickInvisible), e.pickViewMatrix || l.viewMatrix), l = h ? createRTCViewMat(i, h) : i, a.uniformMatrix4fv(this._uViewMatrix, !1, l), a.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), a.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), a.uniform1f(this._uPickZNear, e.pickZNear), a.uniform1f(this._uPickZFar, e.pickZFar), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(e.pickZFar + 1) / Math.LN2), a.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], a.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$C), a.uniform3fv(g.pos, f)) : a.uniform3fv(g.pos, m.pos), a.uniform3fv(g.dir, m.dir)) } } a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, n.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(o.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(o.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(o.modelMatrixCol2Buf), a.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), a.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), a.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aFlags.bindArrayBuffer(o.flagsBuf), a.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(o.flags2Buf), a.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(o.offsetsBuf), a.vertexAttribDivisor(this._aOffset.location, 1)), n.indicesBuf.bind(), a.drawElementsInstanced(a.TRIANGLES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0, o.numInstances), a.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), a.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), a.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), a.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && a.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && a.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), this._uPickZNear = i.getLocation("pickZNear"), this._uPickZFar = i.getLocation("pickZFar"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry depth vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("  vWorldPosition = worldPosition;"), i.push("  vFlags2 = flags2;")), i.push("  vViewPosition = viewPosition;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry depth fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("uniform float pickZNear;"), s.push("uniform float pickZFar;"), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vViewPosition;"), s.push("vec4 packDepth(const in float depth) {"), s.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);"), s.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);"), s.push("  vec4 res = fract(depth * bitShift);"), s.push("  res -= res.xxyz * bitMask;"), s.push("  return res;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));"), s.push("    outColor = packDepth(zNormalizedDepth); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$B = math.vec3(); class TrianglesInstancingPickNormalsRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible); i = e.pickViewMatrix || a.viewMatrix, i = l ? createRTCViewMat(i, l) : i; var c = (o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uWorldNormalMatrix, !1, s.worldNormalMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$B), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aModelNormalMatrixCol0.bindArrayBuffer(n.modelNormalMatrixCol0Buf), this._aModelNormalMatrixCol1.bindArrayBuffer(n.modelNormalMatrixCol1Buf), this._aModelNormalMatrixCol2.bindArrayBuffer(n.modelNormalMatrixCol2Buf), o.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aNormal.bindArrayBuffer(h.normalsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPickInvisible = s.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aNormal = s.getAttribute("normal"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._aModelNormalMatrixCol0 = s.getAttribute("modelNormalMatrixCol0"), this._aModelNormalMatrixCol1 = s.getAttribute("modelNormalMatrixCol1"), this._aModelNormalMatrixCol2 = s.getAttribute("modelNormalMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry normals vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec2 normal;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("in vec4 modelNormalMatrixCol0;"), i.push("in vec4 modelNormalMatrixCol1;"), i.push("in vec4 modelNormalMatrixCol2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("vec3 octDecode(vec2 oct) {"), i.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), i.push("    if (v.z < 0.0) {"), i.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), i.push("    }"), i.push("    return normalize(v);"), i.push("}"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec3 vWorldNormal;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("  vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); "), i.push("  vec3 worldNormal = vec3(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2));"), i.push("  vWorldNormal = worldNormal;"), t && i.push("  vWorldPosition = worldPosition;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry normals fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vWorldNormal;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("if (sectionPlaneActive" + r + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4((vWorldNormal * 0.5) + 0.5, 1.0);"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$A = math.vec3(); class TrianglesInstancingOcclusionRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$A), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aColor && (this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1)), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), this._aColor && o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing occlusion vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("in float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && i.push("  vWorldPosition = worldPosition;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing occlusion fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); "), e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$z = math.vec3(); class TrianglesInstancingDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$z), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry depth drawing vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec2 vHighPrecisionZW;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("vHighPrecisionZW = gl_Position.zw;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState; let i, s; var r = 0 < t.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Instancing geometry depth drawing fragment shader"), a.push("precision highp float;"), a.push("precision highp int;"), e.logarithmicDepthBufferEnabled && (a.push("in float isPerspective;"), a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), r) for (a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("uniform bool sectionPlaneActive" + i + ";"), a.push("uniform vec3 sectionPlanePos" + i + ";"), a.push("uniform vec3 sectionPlaneDir" + i + ";"); if (a.push("in vec2 vHighPrecisionZW;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), r) { for (a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("if (sectionPlaneActive" + i + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("if (dist > 0.0) { discard; }"), a.push("}") } return e.logarithmicDepthBufferEnabled && a.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;"), a.push("    outColor = vec4(vec3(1.0 - fragCoordZ), 1.0); "), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$y = math.vec3(); class TrianglesInstancingNormalsRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(a.viewMatrix, l) : a.viewMatrix), o.uniformMatrix4fv(this._uViewNormalMatrix, !1, a.viewNormalMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uWorldNormalMatrix, !1, s.worldNormalMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], l ? (f = getPlaneRTCPos(m.dist, m.dir, l, tempVec3a$y), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aNormal.bindArrayBuffer(h.normalsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aNormal = s.getAttribute("normal"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 && (this._aFlags2 = s.getAttribute("flags2")), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry normals drawing vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec3 normal;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 worldNormalMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 viewNormalMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), i.push("vec3 octDecode(vec2 oct) {"), i.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), i.push("    if (v.z < 0.0) {"), i.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), i.push("    }"), i.push("    return normalize(v);"), i.push("}"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec3 vViewNormal;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("  vec4 worldNormal    = worldNormalMatrix * vec4(octDecode(normal.xy), 0.0); "), i.push("  vec3 viewNormal     = normalize((viewNormalMatrix * worldNormal).xyz);"), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("  vViewNormal = viewNormal;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing geometry depth drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vViewNormal;"), s.push("vec3 packNormalToRGB( const in vec3 normal ) {"), s.push("    return normalize( normal ) * 0.5 + 0.5;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$x = math.vec3(); class TrianglesInstancingShadowRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._lastLightId = null, this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t) { var i = t.model, s = i.scene, r = s.canvas.gl, a = t._state, o = a.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e, t)), r.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, o.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(a.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(a.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(a.modelMatrixCol2Buf), r.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), r.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), r.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(o.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(a.offsetsBuf), r.vertexAttribDivisor(this._aOffset.location, 1)), this._aColor.bindArrayBuffer(a.colorsBuf), r.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(a.flagsBuf), r.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(a.flags2Buf), r.vertexAttribDivisor(this._aFlags2.location, 1)); var n = s._sectionPlanesState.sectionPlanes.length; if (0 < n) { var h = s._sectionPlanesState.sectionPlanes, l = t.layerIndex * n, c = i.renderFlags, u = t._state.origin; for (let e = 0; e < n; e++) { var p, d, m = this._uSectionPlanes[e]; m && (p = c.sectionPlanesActivePerLayer[l + e], r.uniform1i(m.active, p ? 1 : 0), p) && (p = h[e], u ? (d = getPlaneRTCPos(p.dist, p.dir, u, tempVec3a$x), r.uniform3fv(m.pos, d)) : r.uniform3fv(m.pos, p.pos), r.uniform3fv(m.dir, p.dir)) } } o.indicesBuf.bind(), r.drawElementsInstanced(r.TRIANGLES, o.indicesBuf.numItems, o.indicesBuf.itemType, 0, a.numInstances), r.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), r.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), r.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), r.vertexAttribDivisor(this._aColor.location, 0), r.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && r.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && r.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = (t = this._scene).canvas.gl, t = t._sectionPlanesState; if (this._program = new Program(e, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uShadowViewMatrix = i.getLocation("shadowViewMatrix"), this._uShadowProjMatrix = i.getLocation("shadowProjMatrix"), this._uSectionPlanes = []; for (let e = 0, s = t.sectionPlanes.length; e < s; e++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + e), pos: i.getLocation("sectionPlanePos" + e), dir: i.getLocation("sectionPlaneDir" + e) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2") } } _bindProgram(e, t) { var i = this._scene.canvas.gl; this._program.bind(), i.uniformMatrix4fv(this._uShadowViewMatrix, !1, e.shadowViewMatrix), i.uniformMatrix4fv(this._uShadowProjMatrix, !1, e.shadowProjMatrix), this._lastLightId = null } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry shadow drawing vertex shader"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 shadowViewMatrix;"), i.push("uniform mat4 shadowProjMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("bool visible      = (float(flags.x) > 0.0);"), i.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);"), i.push("if (!visible || transparent) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("  gl_Position = shadowProjMatrix * viewPosition;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing geometry depth drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vViewNormal;"), s.push("vec3 packNormalToRGB( const in vec3 normal ) {"), s.push("    return normalize( normal ) * 0.5 + 0.5;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4$1 = math.vec4(), tempVec3a$w = math.vec3(), TEXTURE_DECODE_FUNCS = { 3e3: "linearToLinear" }; TEXTURE_DECODE_FUNCS[sRGBEncoding] = "sRGBToLinear"; class TrianglesInstancingPBRRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e.gammaOutput, e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS, r = t.model, a = this._scene, o = a.camera, n = a.canvas.gl, h = t._state, l = h.origin, c = h.textureSet, u = h.geometry, p = a._lightsState; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), n.uniform1i(this._uRenderPass, i), n.uniformMatrix4fv(this._uViewMatrix, !1, l ? createRTCViewMat(o.viewMatrix, l) : o.viewMatrix), n.uniformMatrix4fv(this._uViewNormalMatrix, !1, o.viewNormalMatrix), n.uniformMatrix4fv(this._uWorldMatrix, !1, r.worldMatrix), n.uniformMatrix4fv(this._uWorldNormalMatrix, !1, r.worldNormalMatrix); var d = a._sectionPlanesState.sectionPlanes.length; if (0 < d) { var m = a._sectionPlanesState.sectionPlanes, f = t.layerIndex * d, g = r.renderFlags; for (let e = 0; e < d; e++) { var _, v, y = this._uSectionPlanes[e]; y && (_ = g.sectionPlanesActivePerLayer[f + e], n.uniform1i(y.active, _ ? 1 : 0), _) && (_ = m[e], l ? (v = getPlaneRTCPos(_.dist, _.dir, l, tempVec3a$w), n.uniform3fv(y.pos, v)) : n.uniform3fv(y.pos, _.pos), n.uniform3fv(y.dir, _.dir)) } } n.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, u.positionsDecodeMatrix), this._uUVDecodeMatrix && n.uniformMatrix3fv(this._uUVDecodeMatrix, !1, u.uvDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(h.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(h.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(h.modelMatrixCol2Buf), n.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), n.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), n.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aModelNormalMatrixCol0.bindArrayBuffer(h.modelNormalMatrixCol0Buf), this._aModelNormalMatrixCol1.bindArrayBuffer(h.modelNormalMatrixCol1Buf), this._aModelNormalMatrixCol2.bindArrayBuffer(h.modelNormalMatrixCol2Buf), n.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 1), n.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 1), n.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(u.positionsBuf), this._aNormal.bindArrayBuffer(u.normalsBuf), this._aUV && this._aUV.bindArrayBuffer(u.uvBuf), this._aColor.bindArrayBuffer(h.colorsBuf), n.vertexAttribDivisor(this._aColor.location, 1), this._aMetallicRoughness.bindArrayBuffer(h.metallicRoughnessBuf), n.vertexAttribDivisor(this._aMetallicRoughness.location, 1), this._aFlags.bindArrayBuffer(h.flagsBuf), n.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(h.flags2Buf), n.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(h.offsetsBuf), n.vertexAttribDivisor(this._aOffset.location, 1)), 0 < p.reflectionMaps.length && p.reflectionMaps[0].texture && this._uReflectionMap && (this._program.bindTexture(this._uReflectionMap, p.reflectionMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), 0 < p.lightMaps.length && p.lightMaps[0].texture && this._uLightMap && (this._program.bindTexture(this._uLightMap, p.lightMaps[0].texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), this._withSAO && (i = a.sao).possible && (o = n.drawingBufferWidth, t = n.drawingBufferHeight, tempVec4$1[0] = o, tempVec4$1[1] = t, tempVec4$1[2] = i.blendCutoff, tempVec4$1[3] = i.blendFactor, n.uniform4fv(this._uSAOParams, tempVec4$1), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, e.bindTexture++), c && (this._program.bindTexture(this._uBaseColorMap, c.colorTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uMetallicRoughMap, c.metallicRoughnessTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uEmissiveMap, c.emissiveTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s, this._program.bindTexture(this._uNormalMap, c.normalsTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s), u.indicesBuf.bind(), n.drawElementsInstanced(n.TRIANGLES, u.indicesBuf.numItems, u.indicesBuf.itemType, 0, h.numInstances), e.drawElements++, n.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), n.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), n.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), n.vertexAttribDivisor(this._aModelNormalMatrixCol0.location, 0), n.vertexAttribDivisor(this._aModelNormalMatrixCol1.location, 0), n.vertexAttribDivisor(this._aModelNormalMatrixCol2.location, 0), n.vertexAttribDivisor(this._aColor.location, 0), n.vertexAttribDivisor(this._aMetallicRoughness.location, 0), n.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && n.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && n.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { for (var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uUVDecodeMatrix = s.getLocation("uvDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uWorldNormalMatrix = s.getLocation("worldNormalMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uViewNormalMatrix = s.getLocation("viewNormalMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uGammaFactor = s.getLocation("gammaFactor"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights), a = 0, o = r.length; a < o; a++)switch (r[a].type) { case "dir": this._uLightColor[a] = s.getLocation("lightColor" + a), this._uLightPos[a] = null, this._uLightDir[a] = s.getLocation("lightDir" + a); break; case "point": this._uLightColor[a] = s.getLocation("lightColor" + a), this._uLightPos[a] = s.getLocation("lightPos" + a), this._uLightDir[a] = null, this._uLightAttenuation[a] = s.getLocation("lightAttenuation" + a); break; case "spot": this._uLightColor[a] = s.getLocation("lightColor" + a), this._uLightPos[a] = s.getLocation("lightPos" + a), this._uLightDir[a] = s.getLocation("lightDir" + a), this._uLightAttenuation[a] = s.getLocation("lightAttenuation" + a) }0 < i.reflectionMaps.length && (this._uReflectionMap = "reflectionMap"), 0 < i.lightMaps.length && (this._uLightMap = "lightMap"), this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aNormal = s.getAttribute("normal"), this._aUV = s.getAttribute("uv"), this._aColor = s.getAttribute("color"), this._aMetallicRoughness = s.getAttribute("metallicRoughness"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aOffset = s.getAttribute("offset"), this._uBaseColorMap = "uBaseColorMap", this._uMetallicRoughMap = "uMetallicRoughMap", this._uEmissiveMap = "uEmissiveMap", this._uNormalMap = "uNormalMap", this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._aModelNormalMatrixCol0 = s.getAttribute("modelNormalMatrixCol0"), this._aModelNormalMatrixCol1 = s.getAttribute("modelNormalMatrixCol1"), this._aModelNormalMatrixCol2 = s.getAttribute("modelNormalMatrixCol2"), this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene, i = t.canvas.gl, s = t._lightsState.lights, r = t.camera.project; this._program.bind(), i.uniformMatrix4fv(this._uProjMatrix, !1, r.matrix), this._uLightAmbient && i.uniform4fv(this._uLightAmbient, t._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = s.length; e < t; e++) { var a = s[e]; this._uLightColor[e] && i.uniform4f(this._uLightColor[e], a.color[0], a.color[1], a.color[2], a.intensity), this._uLightPos[e] && (i.uniform3fv(this._uLightPos[e], a.pos), this._uLightAttenuation[e]) && i.uniform1f(this._uLightAttenuation[e], a.attenuation), this._uLightDir[e] && i.uniform3fv(this._uLightDir[e], a.dir) } t.logarithmicDepthBufferEnabled && (r = 2 / (Math.log(r.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, r)), this._uGammaFactor && i.uniform1f(this._uGammaFactor, t.gammaFactor) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = e._sectionPlanesState, i = e._lightsState, s = 0 < t.sectionPlanes.length, r = (t = t.clippingCaps, []); return r.push("#version 300 es"), r.push("// Instancing geometry quality drawing vertex shader"), r.push("uniform int renderPass;"), r.push("in vec3 position;"), r.push("in vec3 normal;"), r.push("in vec4 color;"), r.push("in vec2 uv;"), r.push("in vec2 metallicRoughness;"), r.push("in vec4 flags;"), r.push("in vec4 flags2;"), e.entityOffsetsEnabled && r.push("in vec3 offset;"), r.push("in vec4 modelMatrixCol0;"), r.push("in vec4 modelMatrixCol1;"), r.push("in vec4 modelMatrixCol2;"), r.push("in vec4 modelNormalMatrixCol0;"), r.push("in vec4 modelNormalMatrixCol1;"), r.push("in vec4 modelNormalMatrixCol2;"), r.push("uniform mat4 worldMatrix;"), r.push("uniform mat4 worldNormalMatrix;"), r.push("uniform mat4 viewMatrix;"), r.push("uniform mat4 viewNormalMatrix;"), r.push("uniform mat4 projMatrix;"), r.push("uniform mat4 positionsDecodeMatrix;"), r.push("uniform mat3 uvDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (r.push("uniform float logDepthBufFC;"), r.push("out float vFragDepth;"), r.push("bool isPerspectiveMatrix(mat4 m) {"), r.push("    return (m[2][3] == - 1.0);"), r.push("}"), r.push("out float isPerspective;")), r.push("vec3 octDecode(vec2 oct) {"), r.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));"), r.push("    if (v.z < 0.0) {"), r.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);"), r.push("    }"), r.push("    return normalize(v);"), r.push("}"), r.push("out vec4 vViewPosition;"), r.push("out vec3 vViewNormal;"), r.push("out vec4 vColor;"), r.push("out vec2 vUV;"), r.push("out vec2 vMetallicRoughness;"), 0 < i.lightMaps.length && r.push("out vec3 vWorldNormal;"), s && (r.push("out vec4 vWorldPosition;"), r.push("out vec4 vFlags2;"), t) && r.push("out vec4 vClipPosition;"), r.push("void main(void) {"), r.push("if (int(flags.x) != renderPass) {"), r.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), r.push("} else {"), r.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), r.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && r.push("      worldPosition.xyz = worldPosition.xyz + offset;"), r.push("vec4 viewPosition  = viewMatrix * worldPosition; "), r.push("vec4 modelNormal = vec4(octDecode(normal.xy), 0.0); "), r.push("vec4 worldNormal = worldNormalMatrix * vec4(dot(modelNormal, modelNormalMatrixCol0), dot(modelNormal, modelNormalMatrixCol1), dot(modelNormal, modelNormalMatrixCol2), 1.0);"), r.push("vec3 viewNormal = vec4(viewNormalMatrix * worldNormal).xyz;"), r.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (r.push("vFragDepth = 1.0 + clipPos.w;"), r.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), s && (r.push("vWorldPosition = worldPosition;"), r.push("vFlags2 = flags2;"), t) && r.push("vClipPosition = clipPos;"), r.push("vViewPosition = viewPosition;"), r.push("vViewNormal = viewNormal;"), r.push("vColor = color;"), r.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;"), r.push("vMetallicRoughness = metallicRoughness;"), 0 < i.lightMaps.length && r.push("vWorldNormal = worldNormal.xyz;"), r.push("gl_Position = clipPos;"), r.push("}"), r.push("}"), r } _buildFragmentShader() { var e = this._scene, t = e.gammaOutput, i = e._sectionPlanesState, s = e._lightsState, r = 0 < i.sectionPlanes.length, a = i.clippingCaps, o = []; o.push("#version 300 es"), o.push("// Instancing geometry quality drawing fragment shader"), o.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), o.push("precision highp float;"), o.push("precision highp int;"), o.push("#else"), o.push("precision mediump float;"), o.push("precision mediump int;"), o.push("#endif"), e.logarithmicDepthBufferEnabled && (o.push("in float isPerspective;"), o.push("uniform float logDepthBufFC;"), o.push("in float vFragDepth;")), o.push("uniform sampler2D uBaseColorMap;"), o.push("uniform sampler2D uMetallicRoughMap;"), o.push("uniform sampler2D uEmissiveMap;"), o.push("uniform sampler2D uNormalMap;"), this._withSAO && (o.push("uniform sampler2D uOcclusionTexture;"), o.push("uniform vec4      uSAOParams;"), o.push("const float       packUpscale = 256. / 255.;"), o.push("const float       unpackDownScale = 255. / 256.;"), o.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), o.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), o.push("float unpackRGBToFloat( const in vec4 v ) {"), o.push("    return dot( v, unPackFactors );"), o.push("}")), 0 < s.reflectionMaps.length && o.push("uniform samplerCube reflectionMap;"), 0 < s.lightMaps.length && o.push("uniform samplerCube lightMap;"), o.push("uniform vec4 lightAmbient;"); for (let e = 0, t = s.lights.length; e < t; e++) { var n = s.lights[e]; "ambient" !== n.type && (o.push("uniform vec4 lightColor" + e + ";"), "dir" === n.type && o.push("uniform vec3 lightDir" + e + ";"), "point" === n.type && o.push("uniform vec3 lightPos" + e + ";"), "spot" === n.type) && (o.push("uniform vec3 lightPos" + e + ";"), o.push("uniform vec3 lightDir" + e + ";")) } if (o.push("uniform float gammaFactor;"), o.push("vec4 linearToLinear( in vec4 value ) {"), o.push("  return value;"), o.push("}"), o.push("vec4 sRGBToLinear( in vec4 value ) {"), o.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );"), o.push("}"), o.push("vec4 gammaToLinear( in vec4 value) {"), o.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );"), o.push("}"), t && (o.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), o.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), o.push("}")), r) { o.push("in vec4 vWorldPosition;"), o.push("in vec4 vFlags2;"), a && o.push("in vec4 vClipPosition;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)o.push("uniform bool sectionPlaneActive" + e + ";"), o.push("uniform vec3 sectionPlanePos" + e + ";"), o.push("uniform vec3 sectionPlaneDir" + e + ";") } if (o.push("in vec4 vViewPosition;"), o.push("in vec3 vViewNormal;"), o.push("in vec4 vColor;"), o.push("in vec2 vUV;"), o.push("in vec2 vMetallicRoughness;"), 0 < s.lightMaps.length && o.push("in vec3 vWorldNormal;"), o.push("uniform mat4 viewMatrix;"), o.push("#define PI 3.14159265359"), o.push("#define RECIPROCAL_PI 0.31830988618"), o.push("#define RECIPROCAL_PI2 0.15915494"), o.push("#define EPSILON 1e-6"), o.push("#define saturate(a) clamp( a, 0.0, 1.0 )"), o.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {"), o.push("       vec3 texel = texture( uNormalMap, uv ).xyz;"), o.push("       if (texel.r == 0.0 && texel.g == 0.0 && texel.b == 0.0) {"), o.push("              return normalize(surf_norm );"), o.push("       }"), o.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );"), o.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );"), o.push("      vec2 st0 = dFdx( uv.st );"), o.push("      vec2 st1 = dFdy( uv.st );"), o.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );"), o.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );"), o.push("      vec3 N = normalize( surf_norm );"), o.push("      vec3 mapN = texel.xyz * 2.0 - 1.0;"), o.push("      mat3 tsn = mat3( S, T, N );"), o.push("      return normalize( tsn * mapN );"), o.push("}"), o.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {"), o.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );"), o.push("}"), o.push("struct IncidentLight {"), o.push("   vec3 color;"), o.push("   vec3 direction;"), o.push("};"), o.push("struct ReflectedLight {"), o.push("   vec3 diffuse;"), o.push("   vec3 specular;"), o.push("};"), o.push("struct Geometry {"), o.push("   vec3 position;"), o.push("   vec3 viewNormal;"), o.push("   vec3 worldNormal;"), o.push("   vec3 viewEyeDir;"), o.push("};"), o.push("struct Material {"), o.push("   vec3    diffuseColor;"), o.push("   float   specularRoughness;"), o.push("   vec3    specularColor;"), o.push("   float   shine;"), o.push("};"), o.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {"), o.push("   float r = ggxRoughness + 0.0001;"), o.push("   return (2.0 / (r * r) - 2.0);"), o.push("}"), o.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {"), o.push("   float maxMIPLevelScalar = float( maxMIPLevel );"), o.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );"), o.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );"), o.push("}"), 0 < s.reflectionMaps.length && (o.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {"), o.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"), o.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS[s.reflectionMaps[0].encoding] + "(texture(reflectionMap, reflectVec, mipLevel)).rgb;"), o.push("  return envMapColor;"), o.push("}")), o.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {"), o.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );"), o.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;"), o.push("}"), o.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), o.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), o.push("   return 1.0 / ( gl * gv );"), o.push("}"), o.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );"), o.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );"), o.push("   return 0.5 / max( gv + gl, EPSILON );"), o.push("}"), o.push("float D_GGX(const in float alpha, const in float dotNH) {"), o.push("   float a2 = ( alpha * alpha );"), o.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;"), o.push("   return RECIPROCAL_PI * a2 / ( denom * denom);"), o.push("}"), o.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), o.push("   float alpha = ( roughness * roughness );"), o.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );"), o.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );"), o.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );"), o.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );"), o.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );"), o.push("   vec3  F = F_Schlick( specularColor, dotLH );"), o.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );"), o.push("   float D = D_GGX( alpha, dotNH );"), o.push("   return F * (G * D);"), o.push("}"), o.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {"), o.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));"), o.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);"), o.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);"), o.push("   vec4 r = roughness * c0 + c1;"), o.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;"), o.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;"), o.push("   return specularColor * AB.x + AB.y;"), o.push("}"), (0 < s.lightMaps.length || 0 < s.reflectionMaps.length) && (o.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), 0 < s.lightMaps.length && (o.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS[s.lightMaps[0].encoding] + "(texture(lightMap, geometry.worldNormal)).rgb;"), o.push("   irradiance *= PI;"), o.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);"), o.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;")), 0 < s.reflectionMaps.length && (o.push("   vec3 reflectVec             = reflect(geometry.viewEyeDir, geometry.viewNormal);"), o.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);"), o.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);"), o.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);"), o.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);"), o.push("   reflectedLight.specular     += radiance * specularBRDFContrib;")), o.push("}")), o.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {"), o.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));"), o.push("   vec3 irradiance = dotNL * incidentLight.color * PI;"), o.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);"), o.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);"), o.push("}"), o.push("out vec4 outColor;"), o.push("void main(void) {"), r) { o.push("  bool clippable = (float(vFlags2.x) > 0.0);"), o.push("  if (clippable) {"), o.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)o.push("if (sectionPlaneActive" + e + ") {"), o.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), o.push("}"); a ? (o.push("  if (dist > (0.002 * vClipPosition.w)) {"), o.push("      discard;"), o.push("  }"), o.push("  if (dist > 0.0) { "), o.push("      outColor=vec4(1.0, 0.0, 0.0, 1.0);"), e.logarithmicDepthBufferEnabled && o.push("  gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), o.push("  return;"), o.push("}")) : (o.push("  if (dist > 0.0) { "), o.push("      discard;"), o.push("  }")), o.push("}") } o.push("IncidentLight  light;"), o.push("Material       material;"), o.push("Geometry       geometry;"), o.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));"), o.push("vec3 rgb = (vec3(float(vColor.r) / 255.0, float(vColor.g) / 255.0, float(vColor.b) / 255.0));"), o.push("float opacity = float(vColor.a) / 255.0;"), o.push("vec3  baseColor = rgb;"), o.push("float specularF0 = 1.0;"), o.push("float metallic = float(vMetallicRoughness.r) / 255.0;"), o.push("float roughness = float(vMetallicRoughness.g) / 255.0;"), o.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;"), o.push("vec4 baseColorTexel = sRGBToLinear(texture(uBaseColorMap, vUV));"), o.push("baseColor *= baseColorTexel.rgb;"), o.push("vec3 metalRoughTexel = texture(uMetallicRoughMap, vUV).rgb;"), o.push("metallic *= metalRoughTexel.b;"), o.push("roughness *= metalRoughTexel.g;"), o.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition.xyz, normalize(vViewNormal), vUV );"), o.push("material.diffuseColor      = baseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);"), o.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);"), o.push("material.specularColor     = mix(vec3(dielectricSpecular), baseColor, metallic);"), o.push("geometry.position      = vViewPosition.xyz;"), o.push("geometry.viewNormal    = -normalize(viewNormal);"), o.push("geometry.viewEyeDir    = normalize(vViewPosition.xyz);"), 0 < s.lightMaps.length && o.push("geometry.worldNormal   = normalize(vWorldNormal);"), (0 < s.lightMaps.length || 0 < s.reflectionMaps.length) && o.push("computePBRLightMapping(geometry, material, reflectedLight);"); for (let e = 0, t = s.lights.length; e < t; e++) { var h = s.lights[e]; if ("ambient" !== h.type) { if ("dir" === h.type) "view" === h.space ? o.push("light.direction = normalize(lightDir" + e + ");") : o.push("light.direction = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);"); else if ("point" === h.type) "view" === h.space ? o.push("light.direction = normalize(lightPos" + e + " - vViewPosition.xyz);") : o.push("light.direction = normalize((viewMatrix * vec4(lightPos" + e + ", 0.0)).xyz);"); else { if ("spot" !== h.type) continue; "view" === h.space ? o.push("light.direction = normalize(lightDir" + e + ");") : o.push("light.direction = normalize((viewMatrix * vec4(lightDir" + e + ", 0.0)).xyz);") } o.push("light.color =  lightColor" + e + ".rgb * lightColor" + e + ".a;"), o.push("computePBRLighting(light, geometry, material, reflectedLight);") } } return o.push("vec3 emissiveColor = sRGBToLinear(texture(uEmissiveMap, vUV)).rgb;"), o.push("vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * baseColor * opacity * rgb) + (reflectedLight.diffuse) + (reflectedLight.specular) + emissiveColor;"), o.push("vec4 fragColor;"), this._withSAO ? (o.push("   float viewportWidth     = uSAOParams[0];"), o.push("   float viewportHeight    = uSAOParams[1];"), o.push("   float blendCutoff       = uSAOParams[2];"), o.push("   float blendFactor       = uSAOParams[3];"), o.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), o.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), o.push("   fragColor            = vec4(outgoingLight.rgb * ambient, opacity);")) : o.push("   fragColor            = vec4(outgoingLight.rgb, opacity);"), t && o.push("fragColor = linearToGamma(fragColor, gammaFactor);"), o.push("outColor = fragColor;"), e.logarithmicDepthBufferEnabled && o.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), o.push("}"), o } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$v = math.vec3(); class TrianglesInstancingPickNormalsFlatRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = n.geometry, l = t._state.origin; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible); i = e.pickViewMatrix || a.viewMatrix, i = l ? createRTCViewMat(i, l) : i; var c = (o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f = this._uSectionPlanes[e], g = d.sectionPlanesActivePerLayer[p + e]; o.uniform1i(f.active, g ? 1 : 0), g && (g = u[e], l ? (m = getPlaneRTCPos(g.dist, g.dir, l, tempVec3a$v), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, g.pos), o.uniform3fv(f.dir, g.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, h.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(h.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), h.indicesBuf.bind(), o.drawElementsInstanced(o.TRIANGLES, h.indicesBuf.numItems, h.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPickInvisible = s.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry normals vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform bool pickInvisible;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && i.push("out vec4 vFlags2;"), i.push("out vec4 vWorldPosition;"), i.push("void main(void) {"), i.push("if (int(flags.w) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("  vWorldPosition = worldPosition;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Batched geometry normals fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("in float isPerspective;"), s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("in vec4 vWorldPosition;"), i) { s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vWorldNormal;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("if (sectionPlaneActive" + r + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("  vec3 xTangent = dFdx( vWorldPosition.xyz );"), s.push("  vec3 yTangent = dFdy( vWorldPosition.xyz );"), s.push("  vec3 worldNormal = normalize( cross( xTangent, yTangent ) );"), s.push("  outColor = vec4((worldNormal * 0.5) + 0.5, 1.0);"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec4 = math.vec4(), tempVec3a$u = math.vec3(); class TrianglesInstancingColorTextureRenderer { constructor(e, t) { this._scene = e, this._withSAO = t, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { var e = this._scene; return [e.gammaOutput, e._lightsState.getHash(), e._sectionPlanesState.getHash(), this._withSAO ? "sao" : "nosao"].join(";") } drawLayer(e, t, i) { var s = WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS, r = t.model, a = r.scene, o = a.camera, n = a.canvas.gl, h = t._state, l = h.geometry, c = t._state.origin, u = h.textureSet; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), n.uniform1i(this._uRenderPass, i), n.uniformMatrix4fv(this._uViewMatrix, !1, c ? createRTCViewMat(o.viewMatrix, c) : o.viewMatrix), n.uniformMatrix4fv(this._uWorldMatrix, !1, r.worldMatrix); var p = a._sectionPlanesState.sectionPlanes.length; if (0 < p) { var d = a._sectionPlanesState.sectionPlanes, m = t.layerIndex * p, f = r.renderFlags; for (let e = 0; e < p; e++) { var g, _, v = this._uSectionPlanes[e]; v && (g = f.sectionPlanesActivePerLayer[m + e], n.uniform1i(v.active, g ? 1 : 0), g) && (g = d[e], c ? (_ = getPlaneRTCPos(g.dist, g.dir, c, tempVec3a$u), n.uniform3fv(v.pos, _)) : n.uniform3fv(v.pos, g.pos), n.uniform3fv(v.dir, g.dir)) } } n.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._uUVDecodeMatrix && n.uniformMatrix3fv(this._uUVDecodeMatrix, !1, l.uvDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(h.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(h.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(h.modelMatrixCol2Buf), n.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), n.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), n.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(l.positionsBuf), this._aUV.bindArrayBuffer(l.uvBuf), this._aColor.bindArrayBuffer(h.colorsBuf), n.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(h.flagsBuf), n.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(h.flags2Buf), n.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(h.offsetsBuf), n.vertexAttribDivisor(this._aOffset.location, 1)), l.indicesBuf.bind(), n.drawElementsInstanced(n.TRIANGLES, l.indicesBuf.numItems, l.indicesBuf.itemType, 0, h.numInstances), e.drawElements++, n.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), n.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), n.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), n.vertexAttribDivisor(this._aColor.location, 0), n.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && n.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && n.vertexAttribDivisor(this._aOffset.location, 0), u && u.colorTexture && (this._program.bindTexture(this._uColorMap, u.colorTexture.texture, e.textureUnit), e.textureUnit = (e.textureUnit + 1) % s), this._withSAO && (i = a.sao).possible && (o = n.drawingBufferWidth, t = n.drawingBufferHeight, tempVec4[0] = o, tempVec4[1] = t, tempVec4[2] = i.blendCutoff, tempVec4[3] = i.blendFactor, n.uniform4fv(this._uSAOParams, tempVec4), this._program.bindTexture(this._uOcclusionTexture, e.occlusionTexture, 0)) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._lightsState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program, r = (this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uUVDecodeMatrix = s.getLocation("uvDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uGammaFactor = s.getLocation("gammaFactor"), this._uLightAmbient = s.getLocation("lightAmbient"), this._uLightColor = [], this._uLightDir = [], this._uLightPos = [], this._uLightAttenuation = [], i.lights); for (let e = 0, t = r.length; e < t; e++)switch (r[e].type) { case "dir": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = null, this._uLightDir[e] = s.getLocation("lightDir" + e); break; case "point": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = null, this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e); break; case "spot": this._uLightColor[e] = s.getLocation("lightColor" + e), this._uLightPos[e] = s.getLocation("lightPos" + e), this._uLightDir[e] = s.getLocation("lightDir" + e), this._uLightAttenuation[e] = s.getLocation("lightAttenuation" + e) }this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aColor = s.getAttribute("color"), this._aUV = s.getAttribute("uv"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aOffset = s.getAttribute("offset"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uColorMap = "uColorMap", this._uOcclusionTexture = "uOcclusionTexture", this._uSAOParams = s.getLocation("uSAOParams"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene, i = t.canvas.gl, s = t._lightsState.lights, r = t.camera.project; this._program.bind(), i.uniformMatrix4fv(this._uProjMatrix, !1, r.matrix), this._uLightAmbient && i.uniform4fv(this._uLightAmbient, t._lightsState.getAmbientColorAndIntensity()); for (let e = 0, t = s.length; e < t; e++) { var a = s[e]; this._uLightColor[e] && i.uniform4f(this._uLightColor[e], a.color[0], a.color[1], a.color[2], a.intensity), this._uLightPos[e] && (i.uniform3fv(this._uLightPos[e], a.pos), this._uLightAttenuation[e]) && i.uniform1f(this._uLightAttenuation[e], a.attenuation), this._uLightDir[e] && i.uniform3fv(this._uLightDir[e], a.dir) } t.logarithmicDepthBufferEnabled && (r = 2 / (Math.log(r.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, r)), this._uGammaFactor && i.uniform1f(this._uGammaFactor, t.gammaFactor) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry drawing vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec2 uv;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), i.push("uniform mat3 uvDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;"), i.push("bool isPerspectiveMatrix(mat4 m) {"), i.push("    return (m[2][3] == - 1.0);"), i.push("}"), i.push("out float isPerspective;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vViewPosition;"), i.push("out vec4 vColor;"), i.push("out vec2 vUV;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vViewPosition = viewPosition;"), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);"), i.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;"), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && (i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("isPerspective = float (isPerspectiveMatrix(projMatrix));")), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e.gammaOutput, i = e._sectionPlanesState, s = e._lightsState; let r, a; var o = 0 < i.sectionPlanes.length, n = []; if (n.push("#version 300 es"), n.push("// Instancing geometry drawing fragment shader"), n.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), n.push("precision highp float;"), n.push("precision highp int;"), n.push("#else"), n.push("precision mediump float;"), n.push("precision mediump int;"), n.push("#endif"), e.logarithmicDepthBufferEnabled && (n.push("in float isPerspective;"), n.push("uniform float logDepthBufFC;"), n.push("in float vFragDepth;")), n.push("uniform sampler2D uColorMap;"), this._withSAO && (n.push("uniform sampler2D uOcclusionTexture;"), n.push("uniform vec4      uSAOParams;"), n.push("const float       packUpscale = 256. / 255.;"), n.push("const float       unpackDownScale = 255. / 256.;"), n.push("const vec3        packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), n.push("const vec4        unPackFactors = unpackDownScale / vec4( packFactors, 1. );"), n.push("float unpackRGBToFloat( const in vec4 v ) {"), n.push("    return dot( v, unPackFactors );"), n.push("}")), n.push("uniform float gammaFactor;"), n.push("vec4 linearToLinear( in vec4 value ) {"), n.push("  return value;"), n.push("}"), n.push("vec4 sRGBToLinear( in vec4 value ) {"), n.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );"), n.push("}"), n.push("vec4 gammaToLinear( in vec4 value) {"), n.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );"), n.push("}"), t && (n.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {"), n.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );"), n.push("}")), o) { n.push("in vec4 vWorldPosition;"), n.push("in vec4 vFlags2;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)n.push("uniform bool sectionPlaneActive" + e + ";"), n.push("uniform vec3 sectionPlanePos" + e + ";"), n.push("uniform vec3 sectionPlaneDir" + e + ";") } for (n.push("uniform mat4 viewMatrix;"), n.push("uniform vec4 lightAmbient;"), r = 0, a = s.lights.length; r < a; r++) { var h = s.lights[r]; "ambient" !== h.type && (n.push("uniform vec4 lightColor" + r + ";"), "dir" === h.type && n.push("uniform vec3 lightDir" + r + ";"), "point" === h.type && n.push("uniform vec3 lightPos" + r + ";"), "spot" === h.type) && (n.push("uniform vec3 lightPos" + r + ";"), n.push("uniform vec3 lightDir" + r + ";")) } if (n.push("in vec4 vViewPosition;"), n.push("in vec4 vColor;"), n.push("in vec2 vUV;"), n.push("out vec4 outColor;"), n.push("void main(void) {"), o) { n.push("  bool clippable = (float(vFlags2.x) > 0.0);"), n.push("  if (clippable) {"), n.push("  float dist = 0.0;"); for (let e = 0, t = i.sectionPlanes.length; e < t; e++)n.push("if (sectionPlaneActive" + e + ") {"), n.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), n.push("}"); n.push("  if (dist > 0.0) { "), n.push("      discard;"), n.push("  }"), n.push("}") } for (n.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);"), n.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);"), n.push("float lambertian = 1.0;"), n.push("vec3 xTangent = dFdx( vViewPosition.xyz );"), n.push("vec3 yTangent = dFdy( vViewPosition.xyz );"), n.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );"), r = 0, a = s.lights.length; r < a; r++) { var l = s.lights[r]; if ("ambient" !== l.type) { if ("dir" === l.type) "view" === l.space ? n.push("viewLightDir = normalize(lightDir" + r + ");") : n.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + r + ", 0.0)).xyz);"); else if ("point" === l.type) "view" === l.space ? n.push("viewLightDir = -normalize(lightPos" + r + " - viewPosition.xyz);") : n.push("viewLightDir = -normalize((viewMatrix * vec4(lightPos" + r + ", 0.0)).xyz);"); else { if ("spot" !== l.type) continue; "view" === l.space ? n.push("viewLightDir = normalize(lightDir" + r + ");") : n.push("viewLightDir = normalize((viewMatrix * vec4(lightDir" + r + ", 0.0)).xyz);") } n.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);"), n.push("reflectedColor += lambertian * (lightColor" + r + ".rgb * lightColor" + r + ".a);") } } return n.push("vec4 color =  vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);"), n.push(t ? "vec4 colorTexel = color * sRGBToLinear(texture(uColorMap, vUV));" : "vec4 colorTexel = color * texture(uColorMap, vUV);"), n.push("float opacity = color.a;"), this._withSAO ? (n.push("   float viewportWidth     = uSAOParams[0];"), n.push("   float viewportHeight    = uSAOParams[1];"), n.push("   float blendCutoff       = uSAOParams[2];"), n.push("   float blendFactor       = uSAOParams[3];"), n.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), n.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBToFloat(texture(uOcclusionTexture, uv))) * blendFactor;"), n.push("   outColor                = vec4(vColor.rgb * colorTexel.rgb * ambient, opacity);")) : n.push("   outColor                = vec4(vColor.rgb * colorTexel.rgb, opacity);"), t && n.push("outColor = linearToGamma(outColor, gammaFactor);"), e.logarithmicDepthBufferEnabled && n.push("    gl_FragDepth = isPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;"), n.push("}"), n } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class TrianglesInstancingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._colorRendererWithSAO && !this._colorRendererWithSAO.getValid() && (this._colorRendererWithSAO.destroy(), this._colorRendererWithSAO = null), this._flatColorRenderer && !this._flatColorRenderer.getValid() && (this._flatColorRenderer.destroy(), this._flatColorRenderer = null), this._flatColorRendererWithSAO && !this._flatColorRendererWithSAO.getValid() && (this._flatColorRendererWithSAO.destroy(), this._flatColorRendererWithSAO = null), this._pbrRenderer && !this._pbrRenderer.getValid() && (this._pbrRenderer.destroy(), this._pbrRenderer = null), this._pbrRendererWithSAO && !this._pbrRendererWithSAO.getValid() && (this._pbrRendererWithSAO.destroy(), this._pbrRendererWithSAO = null), this._colorTextureRenderer && !this._colorTextureRenderer.getValid() && (this._colorTextureRenderer.destroy(), this._colorTextureRenderer = null), this._colorTextureRendererWithSAO && !this._colorTextureRendererWithSAO.getValid() && (this._colorTextureRendererWithSAO.destroy(), this._colorTextureRendererWithSAO = null), this._depthRenderer && !this._depthRenderer.getValid() && (this._depthRenderer.destroy(), this._depthRenderer = null), this._normalsRenderer && !this._normalsRenderer.getValid() && (this._normalsRenderer.destroy(), this._normalsRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null), this._edgesRenderer && !this._edgesRenderer.getValid() && (this._edgesRenderer.destroy(), this._edgesRenderer = null), this._edgesColorRenderer && !this._edgesColorRenderer.getValid() && (this._edgesColorRenderer.destroy(), this._edgesColorRenderer = null), this._pickMeshRenderer && !this._pickMeshRenderer.getValid() && (this._pickMeshRenderer.destroy(), this._pickMeshRenderer = null), this._pickDepthRenderer && !this._pickDepthRenderer.getValid() && (this._pickDepthRenderer.destroy(), this._pickDepthRenderer = null), this._pickNormalsRenderer && !1 === this._pickNormalsRenderer.getValid() && (this._pickNormalsRenderer.destroy(), this._pickNormalsRenderer = null), this._pickNormalsFlatRenderer && !this._pickNormalsFlatRenderer.getValid() && (this._pickNormalsFlatRenderer.destroy(), this._pickNormalsFlatRenderer = null), this._occlusionRenderer && !1 === this._occlusionRenderer.getValid() && (this._occlusionRenderer.destroy(), this._occlusionRenderer = null), this._shadowRenderer && !this._shadowRenderer.getValid() && (this._shadowRenderer.destroy(), this._shadowRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new TrianglesInstancingColorRenderer(this._scene, !1)), this._colorRenderer } get colorRendererWithSAO() { return this._colorRendererWithSAO || (this._colorRendererWithSAO = new TrianglesInstancingColorRenderer(this._scene, !0)), this._colorRendererWithSAO } get flatColorRenderer() { return this._flatColorRenderer || (this._flatColorRenderer = new TrianglesInstancingFlatColorRenderer(this._scene, !1)), this._flatColorRenderer } get flatColorRendererWithSAO() { return this._flatColorRendererWithSAO || (this._flatColorRendererWithSAO = new TrianglesInstancingFlatColorRenderer(this._scene, !0)), this._flatColorRendererWithSAO } get pbrRenderer() { return this._pbrRenderer || (this._pbrRenderer = new TrianglesInstancingPBRRenderer(this._scene, !1)), this._pbrRenderer } get pbrRendererWithSAO() { return this._pbrRendererWithSAO || (this._pbrRendererWithSAO = new TrianglesInstancingPBRRenderer(this._scene, !0)), this._pbrRendererWithSAO } get colorTextureRenderer() { return this._colorTextureRenderer || (this._colorTextureRenderer = new TrianglesInstancingColorTextureRenderer(this._scene, !1)), this._colorTextureRenderer } get colorTextureRendererWithSAO() { return this._colorTextureRendererWithSAO || (this._colorTextureRendererWithSAO = new TrianglesInstancingColorTextureRenderer(this._scene, !0)), this._colorTextureRendererWithSAO } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new TrianglesInstancingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } get depthRenderer() { return this._depthRenderer || (this._depthRenderer = new TrianglesInstancingDepthRenderer(this._scene)), this._depthRenderer } get normalsRenderer() { return this._normalsRenderer || (this._normalsRenderer = new TrianglesInstancingNormalsRenderer(this._scene)), this._normalsRenderer } get edgesRenderer() { return this._edgesRenderer || (this._edgesRenderer = new TrianglesInstancingEdgesRenderer(this._scene)), this._edgesRenderer } get edgesColorRenderer() { return this._edgesColorRenderer || (this._edgesColorRenderer = new TrianglesInstancingEdgesColorRenderer(this._scene)), this._edgesColorRenderer } get pickMeshRenderer() { return this._pickMeshRenderer || (this._pickMeshRenderer = new TrianglesInstancingPickMeshRenderer(this._scene)), this._pickMeshRenderer } get pickNormalsRenderer() { return this._pickNormalsRenderer || (this._pickNormalsRenderer = new TrianglesInstancingPickNormalsRenderer(this._scene)), this._pickNormalsRenderer } get pickNormalsFlatRenderer() { return this._pickNormalsFlatRenderer || (this._pickNormalsFlatRenderer = new TrianglesInstancingPickNormalsFlatRenderer(this._scene)), this._pickNormalsFlatRenderer } get pickDepthRenderer() { return this._pickDepthRenderer || (this._pickDepthRenderer = new TrianglesInstancingPickDepthRenderer(this._scene)), this._pickDepthRenderer } get occlusionRenderer() { return this._occlusionRenderer || (this._occlusionRenderer = new TrianglesInstancingOcclusionRenderer(this._scene)), this._occlusionRenderer } get shadowRenderer() { return this._shadowRenderer || (this._shadowRenderer = new TrianglesInstancingShadowRenderer(this._scene)), this._shadowRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._colorRendererWithSAO && this._colorRendererWithSAO.destroy(), this._flatColorRenderer && this._flatColorRenderer.destroy(), this._flatColorRendererWithSAO && this._flatColorRendererWithSAO.destroy(), this._pbrRenderer && this._pbrRenderer.destroy(), this._pbrRendererWithSAO && this._pbrRendererWithSAO.destroy(), this._colorTextureRenderer && this._colorTextureRenderer.destroy(), this._colorTextureRendererWithSAO && this._colorTextureRendererWithSAO.destroy(), this._depthRenderer && this._depthRenderer.destroy(), this._normalsRenderer && this._normalsRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy(), this._edgesRenderer && this._edgesRenderer.destroy(), this._edgesColorRenderer && this._edgesColorRenderer.destroy(), this._pickMeshRenderer && this._pickMeshRenderer.destroy(), this._pickDepthRenderer && this._pickDepthRenderer.destroy(), this._pickNormalsRenderer && this._pickNormalsRenderer.destroy(), this._pickNormalsFlatRenderer && this._pickNormalsFlatRenderer.destroy(), this._occlusionRenderer && this._occlusionRenderer.destroy(), this._shadowRenderer && this._shadowRenderer.destroy() } } const cachedRenderers$4 = {}; function getInstancingRenderers$1(e) { const t = e.id; let i = cachedRenderers$4[t]; return i || (i = new TrianglesInstancingRenderers(e), (cachedRenderers$4[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachedRenderers$4[t], i._destroy() }))), i } const tempUint8Vec4$2 = new Uint8Array(4), tempVec4a$9 = math.vec4([0, 0, 0, 1]), tempVec4b$9 = math.vec4([0, 0, 0, 1]), tempVec4c$6 = math.vec4([0, 0, 0, 1]), tempVec3fa$2 = new Float32Array(3), tempVec3a$t = math.vec3(), tempVec3b$9 = math.vec3(), tempVec3c$7 = math.vec3(), tempVec3d$2 = math.vec3(), tempVec3e$1 = math.vec3(), tempVec3f$1 = math.vec3(), tempVec3g = math.vec3(); class TrianglesInstancingLayer { constructor(e) { this.model = e.model, this.sortId = "TrianglesInstancingLayer" + (e.solid ? "-solid" : "-surface") + (e.normals ? "-normals" : "-autoNormals"), this.layerIndex = e.layerIndex, this._instancingRenderers = getInstancingRenderers$1(e.model.scene), this._aabb = math.collapseAABB3(); var t = { numInstances: 0, obb: math.OBB3(), origin: math.vec3(), geometry: e.geometry, textureSet: e.textureSet, pbrSupported: !1 }; this._state = new RenderState(t), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numEdgesLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this.numIndices = e.geometry.numIndices, this._colors = [], this._metallicRoughness = [], this._pickColors = [], this._offsets = [], this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = [], this._modelNormalMatrixCol0 = [], this._modelNormalMatrixCol1 = [], this._modelNormalMatrixCol2 = [], this._portions = [], e.origin && this._state.origin.set(e.origin), this._finalized = !1, this.aabb = math.collapseAABB3(), this.solid = !!e.solid } createPortion(e) { var t = e.color, i = e.metallic, s = e.roughness, r = e.opacity, a = e.meshMatrix, o = e.worldMatrix, n = e.aabb; e = e.pickColor; if (this._finalized) throw "Already finalized"; var h = t[0], l = t[1], c = t[2], u = (t[3], this._colors.push(h), this._colors.push(l), this._colors.push(c), this._colors.push(r), this._metallicRoughness.push(null != i ? i : 0), this._metallicRoughness.push(null != s ? s : 255), this.model.scene.entityOffsetsEnabled && (this._offsets.push(0), this._offsets.push(0), this._offsets.push(0)), this._modelMatrixCol0.push(a[0]), this._modelMatrixCol0.push(a[4]), this._modelMatrixCol0.push(a[8]), this._modelMatrixCol0.push(a[12]), this._modelMatrixCol1.push(a[1]), this._modelMatrixCol1.push(a[5]), this._modelMatrixCol1.push(a[9]), this._modelMatrixCol1.push(a[13]), this._modelMatrixCol2.push(a[2]), this._modelMatrixCol2.push(a[6]), this._modelMatrixCol2.push(a[10]), this._modelMatrixCol2.push(a[14]), this._state.geometry.normalsBuf && (t = math.transposeMat4(a, math.mat4()), h = math.inverseMat4(t), this._modelNormalMatrixCol0.push(h[0]), this._modelNormalMatrixCol0.push(h[4]), this._modelNormalMatrixCol0.push(h[8]), this._modelNormalMatrixCol0.push(h[12]), this._modelNormalMatrixCol1.push(h[1]), this._modelNormalMatrixCol1.push(h[5]), this._modelNormalMatrixCol1.push(h[9]), this._modelNormalMatrixCol1.push(h[13]), this._modelNormalMatrixCol2.push(h[2]), this._modelNormalMatrixCol2.push(h[6]), this._modelNormalMatrixCol2.push(h[10]), this._modelNormalMatrixCol2.push(h[14])), this._pickColors.push(e[0]), this._pickColors.push(e[1]), this._pickColors.push(e[2]), this._pickColors.push(e[3]), math.collapseAABB3(n), this._state.geometry.obb), p = u.length; for (let e = 0; e < p; e += 4)tempVec4a$9[0] = u[e + 0], tempVec4a$9[1] = u[e + 1], tempVec4a$9[2] = u[e + 2], math.transformPoint4(a, tempVec4a$9, tempVec4b$9), o ? (math.transformPoint4(o, tempVec4b$9, tempVec4c$6), math.expandAABB3Point3(n, tempVec4c$6)) : math.expandAABB3Point3(n, tempVec4b$9); return this._state.origin && (l = this._state.origin, n[0] += l[0], n[1] += l[1], n[2] += l[2], n[3] += l[0], n[4] += l[1], n[5] += l[2]), math.expandAABB3(this.aabb, n), this._state.numInstances++, c = this._portions.length, r = {}, this.model.scene.pickSurfacePrecisionEnabled && (r.matrix = a.slice(), r.inverseMatrix = null, r.normalMatrix = null), this._portions.push(r), this._numPortions++, this.model.numPortions++, c } finalize() { if (this._finalized) throw "Already finalized"; var e = this._state, t = e.geometry, i = e.textureSet, s = this.model.scene.canvas.gl, r = this._colors.length, a = r; 0 < r && (this._state.colorsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, new Uint8Array(this._colors), this._colors.length, 4, s.DYNAMIC_DRAW, !1), this._colors = []), 0 < this._metallicRoughness.length && (r = new Uint8Array(this._metallicRoughness), this._state.metallicRoughnessBuf = new ArrayBuf(s, s.ARRAY_BUFFER, r, this._metallicRoughness.length, 2, s.STATIC_DRAW, !1)), 0 < a && (this._state.flagsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, new Uint8Array(a), a, 4, s.DYNAMIC_DRAW, !1), this._state.flags2Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Uint8Array(a), a, 4, s.DYNAMIC_DRAW, !0)), this.model.scene.entityOffsetsEnabled && 0 < this._offsets.length && (this._state.offsetsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, s.DYNAMIC_DRAW, !1), this._offsets = []), 0 < this._modelMatrixCol0.length && (this._state.modelMatrixCol0Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, s.STATIC_DRAW, !1), this._state.modelMatrixCol1Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, s.STATIC_DRAW, !1), this._state.modelMatrixCol2Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, s.STATIC_DRAW, !1), this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = [], this._state.geometry.normalsBuf) && (this._state.modelNormalMatrixCol0Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol0), this._modelNormalMatrixCol0.length, 4, s.STATIC_DRAW, !1), this._state.modelNormalMatrixCol1Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol1), this._modelNormalMatrixCol1.length, 4, s.STATIC_DRAW, !1), this._state.modelNormalMatrixCol2Buf = new ArrayBuf(s, s.ARRAY_BUFFER, new Float32Array(this._modelNormalMatrixCol2), this._modelNormalMatrixCol2.length, 4, s.STATIC_DRAW, !1), this._modelNormalMatrixCol0 = [], this._modelNormalMatrixCol1 = [], this._modelNormalMatrixCol2 = []), 0 < this._pickColors.length && (this._state.pickColorsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, new Uint8Array(this._pickColors), this._pickColors.length, 4, s.STATIC_DRAW, !1), this._pickColors = []), this._state.pbrSupported = !!(e.metallicRoughnessBuf && t.uvBuf && t.normalsBuf && i && i.colorTexture && i.metallicRoughnessTexture), this._state.colorTextureSupported = !!t.uvBuf && !!i && !!i.colorTexture, this._finalized = !0 } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.EDGES && (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i), this._setFlags2(e, t) } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.EDGES ? (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++) : (this._numEdgesLayerPortions--, this.model.numEdgesLayerPortions--), this._setFlags(e, t, i) } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags2(e, t, i) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; tempUint8Vec4$2[0] = t[0], tempUint8Vec4$2[1] = t[1], tempUint8Vec4$2[2] = t[2], tempUint8Vec4$2[3] = t[3], this._state.colorsBuf && this._state.colorsBuf.setData(tempUint8Vec4$2, 4 * e, 4) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i) { if (!this._finalized) throw "Not finalized"; var s, r = !!(t & ENTITY_FLAGS.VISIBLE), a = !!(t & ENTITY_FLAGS.XRAYED), o = !!(t & ENTITY_FLAGS.HIGHLIGHTED), n = !!(t & ENTITY_FLAGS.SELECTED), h = !!(t & ENTITY_FLAGS.EDGES), l = !!(t & ENTITY_FLAGS.PICKABLE), c = (t = !!(t & ENTITY_FLAGS.CULLED), !r || t || a || o && !this.model.scene.highlightMaterial.glowThrough || n && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE); s = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.SILHOUETTE_SELECTED : o ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : a ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, o = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.EDGES_SELECTED : o ? RENDER_PASSES.EDGES_HIGHLIGHTED : a ? RENDER_PASSES.EDGES_XRAYED : h ? i ? RENDER_PASSES.EDGES_COLOR_TRANSPARENT : RENDER_PASSES.EDGES_COLOR_OPAQUE : RENDER_PASSES.NOT_RENDERED, n = r && !t && l ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; tempUint8Vec4$2[0] = c, tempUint8Vec4$2[1] = s, tempUint8Vec4$2[2] = o, tempUint8Vec4$2[3] = n, this._state.flagsBuf && this._state.flagsBuf.setData(tempUint8Vec4$2, 4 * e, 4) } _setFlags2(e, t) { if (!this._finalized) throw "Not finalized"; t = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0, tempUint8Vec4$2[0] = t, this._state.flags2Buf && this._state.flags2Buf.setData(tempUint8Vec4$2, 4 * e, 4) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; this.model.scene.entityOffsetsEnabled ? (tempVec3fa$2[0] = t[0], tempVec3fa$2[1] = t[1], tempVec3fa$2[2] = t[2], this._state.offsetsBuf && this._state.offsetsBuf.setData(tempVec3fa$2, 3 * e, 3)) : this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), e = this._state.geometry, t.withSAO && this.model.saoEnabled ? t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._instancingRenderers.pbrRendererWithSAO && this._instancingRenderers.pbrRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._instancingRenderers.colorTextureRendererWithSAO && this._instancingRenderers.colorTextureRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : e.normalsBuf ? this._instancingRenderers.colorRendererWithSAO && this._instancingRenderers.colorRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._instancingRenderers.flatColorRendererWithSAO && this._instancingRenderers.flatColorRendererWithSAO.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._instancingRenderers.pbrRenderer && this._instancingRenderers.pbrRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._instancingRenderers.colorTextureRenderer && this._instancingRenderers.colorTextureRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : e.normalsBuf ? this._instancingRenderers.colorRenderer && this._instancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) : this._instancingRenderers.flatColorRenderer && this._instancingRenderers.flatColorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE)) } _updateBackfaceCull(e, t) { var i; e = this.model.backfaces || !this.solid || e.sectioned; t.backfaces !== e && (i = t.gl, e ? i.disable(i.CULL_FACE) : i.enable(i.CULL_FACE), t.backfaces = e) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), t.pbrEnabled && this.model.pbrEnabled && this._state.pbrSupported ? this._instancingRenderers.pbrRenderer && this._instancingRenderers.pbrRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : t.colorTextureEnabled && this.model.colorTextureEnabled && this._state.colorTextureSupported ? this._instancingRenderers.colorTextureRenderer && this._instancingRenderers.colorTextureRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : this._state.normalsBuf ? this._instancingRenderers.colorRenderer && this._instancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) : this._instancingRenderers.flatColorRenderer && this._instancingRenderers.flatColorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT)) } drawDepth(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.depthRenderer) && this._instancingRenderers.depthRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawNormals(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.normalsRenderer) && this._instancingRenderers.normalsRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.silhouetteRenderer) && this._instancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.silhouetteRenderer) && this._instancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.silhouetteRenderer) && this._instancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numEdgesLayerPortions && this._instancingRenderers.edgesColorRenderer && this._instancingRenderers.edgesColorRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_COLOR_OPAQUE) } drawEdgesColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numEdgesLayerPortions && this._instancingRenderers.edgesColorRenderer && this._instancingRenderers.edgesColorRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_COLOR_TRANSPARENT) } drawEdgesXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._instancingRenderers.edgesRenderer && this._instancingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_XRAYED) } drawEdgesHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._instancingRenderers.edgesRenderer && this._instancingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_HIGHLIGHTED) } drawEdgesSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._instancingRenderers.edgesRenderer && this._instancingRenderers.edgesRenderer.drawLayer(t, this, RENDER_PASSES.EDGES_SELECTED) } drawOcclusion(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.occlusionRenderer) && this._instancingRenderers.occlusionRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawShadow(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.shadowRenderer) && this._instancingRenderers.shadowRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawPickMesh(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.pickMeshRenderer) && this._instancingRenderers.pickMeshRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickDepths(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.pickDepthRenderer) && this._instancingRenderers.pickDepthRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickNormals(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && (this._updateBackfaceCull(e, t), this._instancingRenderers.pickNormalsRenderer) && this._instancingRenderers.pickNormalsRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } precisionRayPickSurface(e, t, i, s, r) { if (!this.model.scene.pickSurfacePrecisionEnabled) return !1; var a = this._state.geometry, o = this._state, n = this._portions[e]; if (!n) return this.model.error("portion not found: " + e), !1; n.inverseMatrix || (n.inverseMatrix = math.inverseMat4(n.matrix, math.mat4())), r && !n.normalMatrix && (n.normalMatrix = math.transposeMat4(n.inverseMatrix, math.mat4())); var h = a.quantizedPositions, l = a.indices, c = o.origin, u = n.offset, p = tempVec3a$t, d = tempVec3b$9, m = (p.set(c ? math.subVec3(t, c, tempVec3c$7) : t), d.set(i), u && math.subVec3(p, u), math.transformRay(this.model.worldNormalMatrix, p, d, p, d), math.transformRay(n.inverseMatrix, p, d, p, d), tempVec3d$2), f = tempVec3e$1, g = tempVec3f$1; let _ = !1, v = 0; var y = tempVec3g; for (let e = 0, i = l.length; e < i; e += 3) { var T = 3 * l[e + 0], I = 3 * l[e + 1], E = 3 * l[e + 2]; m[0] = h[T], m[1] = h[1 + T], m[2] = h[2 + T], f[0] = h[I], f[1] = h[1 + I], f[2] = h[2 + I], g[0] = h[E], g[1] = h[1 + E], g[2] = h[2 + E], math.decompressPosition(m, o.positionsDecodeMatrix), math.decompressPosition(f, o.positionsDecodeMatrix), math.decompressPosition(g, o.positionsDecodeMatrix), math.rayTriangleIntersect(p, d, m, f, g, y) && (math.transformPoint3(n.matrix, y, y), math.transformPoint3(this.model.worldMatrix, y, y), u && math.addVec3(y, u), c && math.addVec3(y, c), T = Math.abs(math.lenVec3(math.subVec3(y, t, []))), !_ || T > v) && (v = T, s.set(y), r && math.triangleNormal(m, f, g, r), _ = !0) } return _ && r && (math.transformVec3(n.normalMatrix, r, r), math.transformVec3(this.model.worldNormalMatrix, r, r), math.normalizeVec3(r)), _ } destroy() { var e = this._state; e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.metallicRoughnessBuf && (e.metallicRoughnessBuf.destroy(), e.metallicRoughnessBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.modelMatrixCol0Buf && (e.modelMatrixCol0Buf.destroy(), e.modelMatrixCol0Buf = null), e.modelMatrixCol1Buf && (e.modelMatrixCol1Buf.destroy(), e.modelMatrixCol1Buf = null), e.modelMatrixCol2Buf && (e.modelMatrixCol2Buf.destroy(), e.modelMatrixCol2Buf = null), e.modelNormalMatrixCol0Buf && (e.modelNormalMatrixCol0Buf.destroy(), e.modelNormalMatrixCol0Buf = null), e.modelNormalMatrixCol1Buf && (e.modelNormalMatrixCol1Buf.destroy(), e.modelNormalMatrixCol1Buf = null), e.modelNormalMatrixCol2Buf && (e.modelNormalMatrixCol2Buf.destroy(), e.modelNormalMatrixCol2Buf = null), e.pickColorsBuf && (e.pickColorsBuf.destroy(), e.pickColorsBuf = null), e.destroy() } } const tempVec3a$s = math.vec3(); class LinesBatchingColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = this._scene, r = s.camera, a = t.model, o = s.canvas.gl, n = t._state, h = t._state.origin; if (t.geometry, this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(r.viewMatrix, h) : r.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, a.worldMatrix), o.lineWidth(s.linesMaterial.lineWidth); var l = s._sectionPlanesState.sectionPlanes.length; if (0 < l) { var c = s._sectionPlanesState.sectionPlanes, u = t.layerIndex * l, p = a.renderFlags; for (let e = 0; e < l; e++) { var d, m, f = this._uSectionPlanes[e]; f && (d = p.sectionPlanesActivePerLayer[u + e], o.uniform1i(f.active, d ? 1 : 0), d) && (d = c[e], h ? (m = getPlaneRTCPos(d.dist, d.dir, h, tempVec3a$s), o.uniform3fv(f.pos, m)) : o.uniform3fv(f.pos, d.pos), o.uniform3fv(f.dir, d.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aColor && this._aColor.bindArrayBuffer(n.colorsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), n.indicesBuf.bind(), o.drawElements(o.LINES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0), e.drawElements++ } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene, i = t.canvas.gl, s = this._program, r = t.camera.project; s.bind(), i.uniformMatrix4fv(this._uProjMatrix, !1, r.matrix), t.logarithmicDepthBufferEnabled && (s = 2 / (Math.log(r.far + 1) / Math.LN2), i.uniform1f(this._uLogDepthBufFC, s)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Lines batching color vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, float(color.a) / 255.0);"), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Lines batching color fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor            = vColor;"), e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const defaultColor$1 = new Float32Array([1, 1, 1]), tempVec3a$r = math.vec3(); class LinesBatchingSilhouetteRenderer { constructor(e, t) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin; if (t.geometry, this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (l = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (l = r.highlightMaterial._state).fillColor, l = l.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], l)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (l = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, l[0], l[1], l[2], i)) : o.uniform4fv(this._uColor, defaultColor$1); e = h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix; var l, c = (o.uniformMatrix4fv(this._uViewMatrix, !1, e), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.lineWidth(r.linesMaterial.lineWidth), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$r), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), n.indicesBuf.bind(), o.drawElements(o.LINES, n.indicesBuf.numItems, n.indicesBuf.itemType, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uColor = i.getLocation("color"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Lines batching silhouette vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), i.push("uniform vec4 color;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;")), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.y) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Lines batching silhouette fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("uniform vec4 color;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = color;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class LinesBatchingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new LinesBatchingColorRenderer(this._scene, !1)), this._colorRenderer } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new LinesBatchingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy() } } const cachedRenderers$3 = {}; function getBatchingRenderers(e) { const t = e.id; let i = cachedRenderers$3[t]; return i || (i = new LinesBatchingRenderers(e), (cachedRenderers$3[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachedRenderers$3[t], i._destroy() }))), i } class LinesBatchingBuffer { constructor(e = 5e6) { this.maxVerts = e = 5e6 < e ? 5e6 : e, this.maxIndices = 3 * e, this.positions = [], this.colors = [], this.flags = [], this.flags2 = [], this.offsets = [], this.indices = [] } } const tempVec4a$8 = math.vec4([0, 0, 0, 1]), tempVec4b$8 = math.vec4([0, 0, 0, 1]), tempVec4c$5 = math.vec4([0, 0, 0, 1]), tempOBB3$1 = math.OBB3(); class LinesBatchingLayer { constructor(e) { this.layerIndex = e.layerIndex, this._batchingRenderers = getBatchingRenderers(e.model.scene), this.model = e.model, this._buffer = new LinesBatchingBuffer(e.maxGeometryBatchSize), this._scratchMemory = e.scratchMemory, this._state = new RenderState({ positionsBuf: null, offsetsBuf: null, colorsBuf: null, flagsBuf: null, flags2Buf: null, indicesBuf: null, positionsDecodeMatrix: math.mat4(), origin: null }), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numEdgesLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this._modelAABB = math.collapseAABB3(), this._portions = [], this._numVerts = 0, this._finalized = !1, e.positionsDecodeMatrix ? (this._state.positionsDecodeMatrix.set(e.positionsDecodeMatrix), this._preCompressedPositionsExpected = !0) : this._preCompressedPositionsExpected = !1, e.origin && (this._state.origin = math.vec3(e.origin)), this.aabb = math.collapseAABB3() } canCreatePortion(e, t) { if (this._finalized) throw "Already finalized"; return this._buffer.positions.length + e < 3 * this._buffer.maxVerts && this._buffer.indices.length + t < this._buffer.maxIndices } createPortion(e) { if (this._finalized) throw "Already finalized"; var t = e.positions, i = e.positionsCompressed, s = e.indices, r = e.color, a = e.opacity, o = e.meshMatrix, n = e.worldMatrix, h = e.worldAABB, l = (e.pickColor, this._buffer), c = l.positions.length / 3; let u; if (this._preCompressedPositionsExpected) { if (!i) throw "positionsCompressed expected"; u = i.length / 3; for (let e = 0, t = i.length; e < t; e++)l.positions.push(i[e]); e = geometryCompressionUtils.getPositionsBounds(i); var p = geometryCompressionUtils.decompressPosition(e.min, this._state.positionsDecodeMatrix, []); e = geometryCompressionUtils.decompressPosition(e.max, this._state.positionsDecodeMatrix, []); h[0] = p[0], h[1] = p[1], h[2] = p[2], h[3] = e[0], h[4] = e[1], h[5] = e[2], n && (math.AABB3ToOBB3(h, tempOBB3$1), math.transformOBB3(n, tempOBB3$1), math.OBB3ToAABB3(tempOBB3$1, h)) } else { if (!t) throw "positions expected"; u = t.length / 3, p = t.length, e = l.positions.length; for (let e = 0, i = t.length; e < i; e++)l.positions.push(t[e]); if (o) for (let t = e, i = e + p; t < i; t += 3)tempVec4a$8[0] = l.positions[t + 0], tempVec4a$8[1] = l.positions[t + 1], tempVec4a$8[2] = l.positions[t + 2], math.transformPoint4(o, tempVec4a$8, tempVec4b$8), l.positions[t + 0] = tempVec4b$8[0], l.positions[t + 1] = tempVec4b$8[1], l.positions[t + 2] = tempVec4b$8[2], math.expandAABB3Point3(this._modelAABB, tempVec4b$8), n ? (math.transformPoint4(n, tempVec4b$8, tempVec4c$5), math.expandAABB3Point3(h, tempVec4c$5)) : math.expandAABB3Point3(h, tempVec4b$8); else for (let t = e, i = e + p; t < i; t += 3)tempVec4a$8[0] = l.positions[t + 0], tempVec4a$8[1] = l.positions[t + 1], tempVec4a$8[2] = l.positions[t + 2], math.expandAABB3Point3(this._modelAABB, tempVec4a$8), n ? (math.transformPoint4(n, tempVec4a$8, tempVec4b$8), math.expandAABB3Point3(h, tempVec4b$8)) : math.expandAABB3Point3(h, tempVec4a$8) } if (this._state.origin && (e = this._state.origin, h[0] += e[0], h[1] += e[1], h[2] += e[2], h[3] += e[0], h[4] += e[1], h[5] += e[2]), math.expandAABB3(this.aabb, h), r) { var d = r[0], m = r[1], f = r[2], g = a; for (let e = 0; e < u; e++)l.colors.push(d), l.colors.push(m), l.colors.push(f), l.colors.push(g) } if (s) for (let e = 0, t = s.length; e < t; e++)l.indices.push(s[e] + c); if (this.model.scene.entityOffsetsEnabled) for (let e = 0; e < u; e++)l.offsets.push(0), l.offsets.push(0), l.offsets.push(0); return p = this._portions.length / 2, this._portions.push(c), this._portions.push(u), this._numPortions++, this.model.numPortions++, this._numVerts += u, p } finalize() { var e, t, i, s, r; this._finalized ? this.model.error("Already finalized") : (e = this._state, t = this.model.scene.canvas.gl, 0 < (i = this._buffer).positions.length && (r = this._preCompressedPositionsExpected ? new Uint16Array(i.positions) : quantizePositions(new Float32Array(i.positions), this._modelAABB, e.positionsDecodeMatrix), e.positionsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, r, i.positions.length, 3, t.STATIC_DRAW)), 0 < i.colors.length && (r = new Uint8Array(i.colors), e.colorsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, r, i.colors.length, 4, t.DYNAMIC_DRAW, !1)), 0 < i.colors.length && (r = i.colors.length, s = new Uint8Array(r), r = new Uint8Array(r), e.flagsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, s, s.length, 4, t.DYNAMIC_DRAW, !1), e.flags2Buf = new ArrayBuf(t, t.ARRAY_BUFFER, r, r.length, 4, t.DYNAMIC_DRAW, !0)), this.model.scene.entityOffsetsEnabled && 0 < i.offsets.length && (s = new Float32Array(i.offsets), e.offsetsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, s, i.offsets.length, 3, t.DYNAMIC_DRAW)), 0 < i.indices.length && (r = new Uint32Array(i.indices), e.indicesBuf = new ArrayBuf(t, t.ELEMENT_ARRAY_BUFFER, r, i.indices.length, 1, t.STATIC_DRAW)), this._buffer = null, this._finalized = !0) } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.EDGES && (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i, !0), this._setFlags2(e, t, !0) } flushInitFlags() { this._setDeferredFlags(), this._setDeferredFlags2() } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.EDGES ? (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++) : (this._numEdgesLayerPortions--, this.model.numEdgesLayerPortions--), this._setFlags(e, t, i) } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; e *= 2; var i = 4 * this._portions[e], s = 4 * this._portions[1 + e], r = this._scratchMemory.getUInt8Array(s), a = t[0], o = t[1], n = t[2], h = t[3]; for (let e = 0; e < s; e += 4)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n, r[e + 3] = h; this._state.colorsBuf.setData(r, i, s) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i, s = !1) { if (!this._finalized) throw "Not finalized"; e *= 2; var r = 4 * this._portions[e], a = 4 * this._portions[1 + e], o = (e = (this._scratchMemory.getUInt8Array(a), !!(t & ENTITY_FLAGS.VISIBLE)), !!(t & ENTITY_FLAGS.XRAYED)), n = !!(t & ENTITY_FLAGS.HIGHLIGHTED), h = !!(t & ENTITY_FLAGS.SELECTED), l = !!(t & ENTITY_FLAGS.PICKABLE), c = (t = !!(t & ENTITY_FLAGS.CULLED), !e || t || o || n && !this.model.scene.highlightMaterial.glowThrough || h && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE), u = !e || t ? RENDER_PASSES.NOT_RENDERED : h ? RENDER_PASSES.SILHOUETTE_SELECTED : n ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : o ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, p = e && !t && l ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; if (s) { this._deferredFlagValues || (this._deferredFlagValues = new Uint8Array(4 * this._numVerts)); for (let e = r, t = r + a; e < t; e += 4)this._deferredFlagValues[e + 0] = c, this._deferredFlagValues[e + 1] = u, this._deferredFlagValues[e + 2] = 0, this._deferredFlagValues[e + 3] = p } else if (this._state.flagsBuf) { var d = this._scratchMemory.getUInt8Array(a); for (let e = 0; e < a; e += 4)d[e + 0] = c, d[e + 1] = u, d[e + 2] = 0, d[e + 3] = p; this._state.flagsBuf.setData(d, r, a) } } _setDeferredFlags() { this._deferredFlagValues && (this._state.flagsBuf.setData(this._deferredFlagValues), this._deferredFlagValues = null) } _setFlags2(e, t, i = !1) { if (!this._finalized) throw "Not finalized"; e *= 2; var s = 4 * this._portions[e], r = 4 * this._portions[1 + e], a = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0; if (i) { this._setDeferredFlag2Values || (this._setDeferredFlag2Values = new Uint8Array(4 * this._numVerts)); for (let e = s, t = s + r; e < t; e += 4)this._setDeferredFlag2Values[e] = a } else { var o = this._scratchMemory.getUInt8Array(r); for (let e = 0; e < r; e += 4)o[e + 0] = a; this._state.flags2Buf.setData(o, s, r) } } _setDeferredFlags2() { this._setDeferredFlag2Values && (this._state.flags2Buf.setData(this._setDeferredFlag2Values), this._setDeferredFlag2Values = null) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; if (this.model.scene.entityOffsetsEnabled) { e = 2 * e; var i = 3 * this._portions[e], s = 3 * this._portions[1 + e], r = this._scratchMemory.getFloat32Array(s), a = t[0], o = t[1], n = t[2]; for (let e = 0; e < s; e += 3)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n; this._state.offsetsBuf.setData(r, i, s) } else this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && this._batchingRenderers.colorRenderer && this._batchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && this._batchingRenderers.colorRenderer && this._batchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) } drawDepth(e, t) { } drawNormals(e, t) { } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._batchingRenderers.silhouetteRenderer && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._batchingRenderers.silhouetteRenderer && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._batchingRenderers.silhouetteRenderer && this._batchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { } drawEdgesColorTransparent(e, t) { } drawEdgesHighlighted(e, t) { } drawEdgesSelected(e, t) { } drawEdgesXRayed(e, t) { } drawPickMesh(e) { } drawPickDepths(e) { } drawPickNormals(e) { } drawOcclusion(e) { } drawShadow(e) { } destroy() { var e = this._state; e.positionsBuf && (e.positionsBuf.destroy(), e.positionsBuf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.indicesBuf && (e.indicesBuf.destroy(), e.indicessBuf = null), e.destroy() } } const tempVec3a$q = math.vec3(); class LinesInstancingColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = t.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.lineWidth(r.linesMaterial.lineWidth); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$q), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(l.positionsBuf), this._aColor.bindArrayBuffer(n.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), l.indicesBuf.bind(), o.drawElementsInstanced(o.LINES, l.indicesBuf.numItems, l.indicesBuf.itemType, 0, n.numInstances), e.drawElements++, o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aOffset = i.getAttribute("offset"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), this._uOcclusionTexture = "uOcclusionTexture", e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Lines instancing color vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;")), i.push("uniform vec4 lightAmbient;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("out vec4 vColor;"), i.push("void main(void) {"), i.push("if (int(flags.x) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), i.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0,  float(color.a) / 255.0);"), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState; let i, s; var r = 0 < t.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Lines instancing color fragment shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), e.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), r) for (a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("uniform bool sectionPlaneActive" + i + ";"), a.push("uniform vec3 sectionPlanePos" + i + ";"), a.push("uniform vec3 sectionPlaneDir" + i + ";"); if (a.push("in vec4 vColor;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), r) { for (a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("if (sectionPlaneActive" + i + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("if (dist > 0.0) { discard; }"), a.push("}") } return this._withSAO ? (a.push("   float viewportWidth     = uSAOParams[0];"), a.push("   float viewportHeight    = uSAOParams[1];"), a.push("   float blendCutoff       = uSAOParams[2];"), a.push("   float blendFactor       = uSAOParams[3];"), a.push("   vec2 uv                 = vec2(gl_FragCoord.x / viewportWidth, gl_FragCoord.y / viewportHeight);"), a.push("   float ambient           = smoothstep(blendCutoff, 1.0, unpackRGBAToDepth(texture(uOcclusionTexture, uv))) * blendFactor;"), a.push("   outColor            = vec4(vColor.rgb * ambient, vColor.a);")) : a.push("    outColor           = vColor;"), e.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$p = math.vec3(); class LinesInstancingSilhouetteRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = t.geometry; if (this._program || (this._allocate(t.model.scene), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (c = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (c = r.highlightMaterial._state).fillColor, c = c.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], c)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (c = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, c[0], c[1], c[2], i)) : o.uniform4fv(this._uColor, math.vec3([1, 1, 1])), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.lineWidth(r.linesMaterial.lineWidth); var c, u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], h ? (g = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$p), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), l.indicesBuf.bind(), o.drawElementsInstanced(o.LINES, l.indicesBuf.numItems, l.indicesBuf.itemType, 0, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uColor = s.getLocation("color"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Lines instancing silhouette vertex shader"), i.push("uniform int renderPass;"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 worldMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;")), i.push("uniform vec4 color;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("if (int(flags.y) != renderPass) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && i.push("vFragDepth = 1.0 + clipPos.w;"), i.push("gl_Position = clipPos;"), i.push("}"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Lines instancing silhouette fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("uniform vec4 color;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = color;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class LinesInstancingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new LinesInstancingColorRenderer(this._scene)), this._colorRenderer } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new LinesInstancingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy() } } const cachedRenderers$2 = {}; function getInstancingRenderers(e) { const t = e.id; let i = cachedRenderers$2[t]; return i || (i = new LinesInstancingRenderers(e), (cachedRenderers$2[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachedRenderers$2[t], i._destroy() }))), i } const tempUint8Vec4$1 = new Uint8Array(4), tempVec4a$7 = math.vec4([0, 0, 0, 1]), tempVec4b$7 = math.vec4([0, 0, 0, 1]), tempVec4c$4 = math.vec4([0, 0, 0, 1]), tempVec3fa$1 = new Float32Array(3); class LinesInstancingLayer { constructor(e) { this.model = e.model, this.geometry = e.geometry, this.material = e.material, this.sortId = "LinesInstancingLayer", this.layerIndex = e.layerIndex, this._linesInstancingRenderers = getInstancingRenderers(e.model.scene), this._aabb = math.collapseAABB3(), this._state = new RenderState({ obb: math.OBB3(), numInstances: 0, origin: null }), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numEdgesLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this.numIndices = e.geometry.numIndices, this._colors = [], this._offsets = [], this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = [], this._portions = [], e.origin && (this._state.origin = math.vec3(e.origin)), this._finalized = !1, this.aabb = math.collapseAABB3() } createPortion(e) { var t = e.color, i = e.opacity, s = e.meshMatrix, r = e.worldMatrix, a = e.aabb; if (this._finalized) throw "Already finalized"; e = t[0]; var o = t[1], n = t[2], h = (t[3], this._colors.push(e), this._colors.push(o), this._colors.push(n), this._colors.push(i), this.model.scene.entityOffsetsEnabled && (this._offsets.push(0), this._offsets.push(0), this._offsets.push(0)), this._modelMatrixCol0.push(s[0]), this._modelMatrixCol0.push(s[4]), this._modelMatrixCol0.push(s[8]), this._modelMatrixCol0.push(s[12]), this._modelMatrixCol1.push(s[1]), this._modelMatrixCol1.push(s[5]), this._modelMatrixCol1.push(s[9]), this._modelMatrixCol1.push(s[13]), this._modelMatrixCol2.push(s[2]), this._modelMatrixCol2.push(s[6]), this._modelMatrixCol2.push(s[10]), this._modelMatrixCol2.push(s[14]), math.collapseAABB3(a), this._state.obb), l = h.length; for (let e = 0; e < l; e += 4)tempVec4a$7[0] = h[e + 0], tempVec4a$7[1] = h[e + 1], tempVec4a$7[2] = h[e + 2], math.transformPoint4(s, tempVec4a$7, tempVec4b$7), r ? (math.transformPoint4(r, tempVec4b$7, tempVec4c$4), math.expandAABB3Point3(a, tempVec4c$4)) : math.expandAABB3Point3(a, tempVec4b$7); return this._state.origin && (t = this._state.origin, a[0] += t[0], a[1] += t[1], a[2] += t[2], a[3] += t[0], a[4] += t[1], a[5] += t[2]), math.expandAABB3(this.aabb, a), this._state.numInstances++, e = this._portions.length, this._portions.push({}), this._numPortions++, this.model.numPortions++, e } finalize() { if (this._finalized) throw "Already finalized"; var e = this.model.scene.canvas.gl, t = this._colors.length, i = t; 0 < t && (this._state.colorsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(this._colors), this._colors.length, 4, e.DYNAMIC_DRAW, !1), this._colors = []), 0 < i && (this._state.flagsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(i), i, 4, e.DYNAMIC_DRAW, !1), this._state.flags2Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(i), i, 4, e.DYNAMIC_DRAW, !0)), this.model.scene.entityOffsetsEnabled && 0 < this._offsets.length && (this._state.offsetsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, e.DYNAMIC_DRAW, !1), this._offsets = []), 0 < this._modelMatrixCol0.length && (this._state.modelMatrixCol0Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, e.STATIC_DRAW, !1), this._state.modelMatrixCol1Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, e.STATIC_DRAW, !1), this._state.modelMatrixCol2Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, e.STATIC_DRAW, !1), this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = []), this._finalized = !0 } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.EDGES && (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i), this._setFlags2(e, t) } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.EDGES ? (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++) : (this._numEdgesLayerPortions--, this.model.numEdgesLayerPortions--), this._setFlags(e, t, i) } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags2(e, t, i) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; tempUint8Vec4$1[0] = t[0], tempUint8Vec4$1[1] = t[1], tempUint8Vec4$1[2] = t[2], tempUint8Vec4$1[3] = t[3], this._state.colorsBuf.setData(tempUint8Vec4$1, 4 * e, 4) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i) { if (!this._finalized) throw "Not finalized"; var s, r = !!(t & ENTITY_FLAGS.VISIBLE), a = !!(t & ENTITY_FLAGS.XRAYED), o = !!(t & ENTITY_FLAGS.HIGHLIGHTED), n = !!(t & ENTITY_FLAGS.SELECTED), h = !!(t & ENTITY_FLAGS.EDGES), l = !!(t & ENTITY_FLAGS.PICKABLE), c = (t = !!(t & ENTITY_FLAGS.CULLED), !r || t || a || o && !this.model.scene.highlightMaterial.glowThrough || n && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE); s = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.SILHOUETTE_SELECTED : o ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : a ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, o = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.EDGES_SELECTED : o ? RENDER_PASSES.EDGES_HIGHLIGHTED : a ? RENDER_PASSES.EDGES_XRAYED : h ? i ? RENDER_PASSES.EDGES_COLOR_TRANSPARENT : RENDER_PASSES.EDGES_COLOR_OPAQUE : RENDER_PASSES.NOT_RENDERED, n = r && !t && l ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; tempUint8Vec4$1[0] = c, tempUint8Vec4$1[1] = s, tempUint8Vec4$1[2] = o, tempUint8Vec4$1[3] = n, this._state.flagsBuf.setData(tempUint8Vec4$1, 4 * e, 4) } _setFlags2(e, t) { if (!this._finalized) throw "Not finalized"; t = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0, tempUint8Vec4$1[0] = t, this._state.flags2Buf.setData(tempUint8Vec4$1, 4 * e, 4) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; this.model.scene.entityOffsetsEnabled ? (tempVec3fa$1[0] = t[0], tempVec3fa$1[1] = t[1], tempVec3fa$1[2] = t[2], this._state.offsetsBuf.setData(tempVec3fa$1, 3 * e, 3)) : this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && this._linesInstancingRenderers.colorRenderer && this._linesInstancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && this._linesInstancingRenderers.colorRenderer && this._linesInstancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) } drawDepth(e, t) { } drawNormals(e, t) { } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._linesInstancingRenderers.silhouetteRenderer && this._linesInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._linesInstancingRenderers.silhouetteRenderer && this._linesInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._linesInstancingRenderers.silhouetteRenderer && this._linesInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { } drawEdgesColorTransparent(e, t) { } drawEdgesXRayed(e, t) { } drawEdgesHighlighted(e, t) { } drawEdgesSelected(e, t) { } drawOcclusion(e, t) { } drawShadow(e, t) { } drawPickMesh(e, t) { } drawPickDepths(e, t) { } drawPickNormals(e, t) { } destroy() { var e = this._state; e.positionsBuf && (e.positionsBuf.destroy(), e.positionsBuf = null), e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.modelMatrixCol0Buf && (e.modelMatrixCol0Buf.destroy(), e.modelMatrixCol0Buf = null), e.modelMatrixCol1Buf && (e.modelMatrixCol1Buf.destroy(), e.modelMatrixCol1Buf = null), e.modelMatrixCol2Buf && (e.modelMatrixCol2Buf.destroy(), e.modelMatrixCol2Buf = null), e.destroy() } } const tempVec3a$o = math.vec3(); class PointsBatchingColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = this._scene, r = s.camera, a = t.model, o = s.canvas.gl, n = t._state, h = t._state.origin, l = s.pointsMaterial; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(r.viewMatrix, h) : r.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, a.worldMatrix); var c = s._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = s._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = a.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$o), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aColor && this._aColor.bindArrayBuffer(n.colorsBuf), l.filterIntensity && o.uniform2f(this._uIntensityRange, l.minIntensity, l.maxIntensity), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), o.uniform1f(this._uPointSize, l.pointSize), i = "ortho" === s.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * s.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, i), o.drawArrays(o.POINTS, 0, n.positionsBuf.numItems), e.drawArrays++ } } _allocate() { var e = this._scene, t = e.pointsMaterial._state, i = e.canvas.gl; if (this._program = new Program(i, this._buildShader(e)), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._uPointSize = s.getLocation("pointSize"), this._uNearPlaneHeight = s.getLocation("nearPlaneHeight"), t.filterIntensity && (this._uIntensityRange = s.getLocation("intensityRange")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = this._program, s = e.camera.project; i.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, s.matrix), e.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(s.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, i)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial, s = []; return s.push("#version 300 es"), s.push("// Points batching color vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), s.push("in vec4 color;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), i.filterIntensity && s.push("uniform vec2 intensityRange;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vColor;"), s.push("void main(void) {"), s.push("if (int(flags.x) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), i.filterIntensity && (s.push("float intensity = float(color.a) / 255.0;"), s.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {")), s.push("vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && s.push("worldPosition.xyz = worldPosition.xyz + offset;"), s.push("vec4 viewPosition  = viewMatrix * worldPosition; "), s.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);"), t && (s.push("vWorldPosition = worldPosition;"), s.push("vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), i.filterIntensity && s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points batching color fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor = vColor;"), e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const defaultColor = new Float32Array([1, 1, 1]), tempVec3a$n = math.vec3(); class PointsBatchingSilhouetteRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (_ = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, _[0], _[1], _[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (_ = r.highlightMaterial._state).fillColor, _ = _.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], _)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (_ = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, _[0], _[1], _[2], i)) : o.uniform4fv(this._uColor, defaultColor); e = h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix; var c = (o.uniformMatrix4fv(this._uViewMatrix, !1, e), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$n), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), o.uniform1f(this._uPointSize, l.pointSize); var _ = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)); o.uniform1f(this._uNearPlaneHeight, _), o.drawArrays(o.POINTS, 0, n.positionsBuf.numItems) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uColor = i.getLocation("color"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points batching silhouette vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform vec4 color;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("void main(void) {"), s.push("if (int(flags.y) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("vWorldPosition = worldPosition;"), s.push("vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState; let i, s; var r = 0 < t.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Points batching silhouette vertex shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), e.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), r) for (a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("uniform bool sectionPlaneActive" + i + ";"), a.push("uniform vec3 sectionPlanePos" + i + ";"), a.push("uniform vec3 sectionPlaneDir" + i + ";"); if (a.push("uniform vec4 color;"), a.push("out vec4 outColor;"), a.push("void main(void) {"), e.pointsMaterial.roundPoints && (a.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), a.push("  float r = dot(cxy, cxy);"), a.push("  if (r > 1.0) {"), a.push("       discard;"), a.push("  }")), r) { for (a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("if (sectionPlaneActive" + i + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("  if (dist > 0.0) { discard; }"), a.push("}") } return e.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("outColor = color;"), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$m = math.vec3(); class PointsBatchingPickMeshRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = (i = (this._program || this._allocate(t), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), e.pickViewMatrix || a.viewMatrix), i = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, i), r.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, e)), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$m), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), this._aPickColor && this._aPickColor.bindArrayBuffer(n.pickColorsBuf), o.uniform1f(this._uPointSize, l.pointSize), i = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, i), o.drawArrays(o.POINTS, 0, n.positionsBuf.numItems) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aPickColor = i.getAttribute("pickColor"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene.canvas.gl; this._program.bind(), t.uniform1i(this._uPickInvisible, e.pickInvisible) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points batching pick mesh vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 pickColor;"), s.push("uniform bool pickInvisible;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vPickColor;"), s.push("void main(void) {"), s.push("if (int(flags.w) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("  } else {"), s.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), s.push("      vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);"), t && (s.push("      vWorldPosition = worldPosition;"), s.push("      vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("gl_PointSize += 10.0;"), s.push("  }"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points batching pick mesh vertex shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("uniform bool sectionPlaneActive" + r + ";"), s.push("uniform vec3 sectionPlanePos" + r + ";"), s.push("uniform vec3 sectionPlaneDir" + r + ";") } if (s.push("in vec4 vPickColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { for (s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"), r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vPickColor; "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$l = math.vec3(); class PointsBatchingPickDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = (i = (this._program || this._allocate(), e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniform1i(this._uPickInvisible, e.pickInvisible), e.pickViewMatrix || a.viewMatrix), a = h ? createRTCViewMat(i, h) : i, o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, a), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), o.uniform1f(this._uPickZNear, e.pickZNear), o.uniform1f(this._uPickZFar, e.pickZFar), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(e.pickZFar + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], o.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$l), o.uniform3fv(g.pos, f)) : o.uniform3fv(g.pos, m.pos), o.uniform3fv(g.dir, m.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(n.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(n.offsetsBuf), this._aFlags && this._aFlags.bindArrayBuffer(n.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(n.flags2Buf), o.uniform1f(this._uPointSize, l.pointSize), a = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, a), o.drawArrays(o.POINTS, 0, n.positionsBuf.numItems) } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._uPickZNear = i.getLocation("pickZNear"), this._uPickZFar = i.getLocation("pickZFar"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points batched pick depth vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("uniform bool pickInvisible;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vViewPosition;"), s.push("void main(void) {"), s.push("if (int(flags.w) != renderPass) {"), s.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("  } else {"), s.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("      vWorldPosition = worldPosition;"), s.push("      vFlags2 = flags2;")), s.push("vViewPosition = viewPosition;"), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("gl_PointSize += 10.0;"), s.push("  }"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points batched pick depth fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("uniform float pickZNear;"), s.push("uniform float pickZFar;"), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vViewPosition;"), s.push("vec4 packDepth(const in float depth) {"), s.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);"), s.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);"), s.push("  vec4 res = fract(depth * bitShift);"), s.push("  res -= res.xxyz * bitMask;"), s.push("  return res;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("      if (sectionPlaneActive" + r + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));"), s.push("    outColor = packDepth(zNormalizedDepth); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$k = math.vec3(); class PointsBatchingOcclusionRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.canvas.gl, o = t._state, n = r.camera, h = t._state.origin, l = r.pointsMaterial._state; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), a.uniform1i(this._uRenderPass, i), a.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(n.viewMatrix, h) : n.viewMatrix), a.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var c = r._sectionPlanesState.sectionPlanes.length; if (0 < c) { var u = r._sectionPlanesState.sectionPlanes, p = t.layerIndex * c, d = s.renderFlags; for (let e = 0; e < c; e++) { var m, f, g = this._uSectionPlanes[e]; g && (m = d.sectionPlanesActivePerLayer[p + e], a.uniform1i(g.active, m ? 1 : 0), m) && (m = u[e], h ? (f = getPlaneRTCPos(m.dist, m.dir, h, tempVec3a$k), a.uniform3fv(g.pos, f)) : a.uniform3fv(g.pos, m.pos), a.uniform3fv(g.dir, m.dir)) } } a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, t._state.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(o.positionsBuf), this._aOffset && this._aOffset.bindArrayBuffer(o.offsetsBuf), this._aFlags.bindArrayBuffer(o.flagsBuf), this._aFlags2 && this._aFlags2.bindArrayBuffer(o.flags2Buf), a.uniform1f(this._uPointSize, l.pointSize), e = "ortho" === r.camera.projection ? 1 : a.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), a.uniform1f(this._uNearPlaneHeight, e), a.drawArrays(a.POINTS, 0, o.positionsBuf.numItems) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points batching occlusion vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("void main(void) {"), s.push("if (int(flags.x) != renderPass) {"), s.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("  } else {"), s.push("      vec4 worldPosition = worldMatrix * (positionsDecodeMatrix * vec4(position, 1.0)); "), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("      vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("      vWorldPosition = worldPosition;"), s.push("      vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("  gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("  }"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("// Points batching occlusion fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("      float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("      if (sectionPlaneActive" + e + ") {"), s.push("          dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("      }"); s.push("      if (dist > 0.0) { discard; }"), s.push("  }") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class PointsBatchingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null), this._pickMeshRenderer && !this._pickMeshRenderer.getValid() && (this._pickMeshRenderer.destroy(), this._pickMeshRenderer = null), this._pickDepthRenderer && !this._pickDepthRenderer.getValid() && (this._pickDepthRenderer.destroy(), this._pickDepthRenderer = null), this._occlusionRenderer && !1 === this._occlusionRenderer.getValid() && (this._occlusionRenderer.destroy(), this._occlusionRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new PointsBatchingColorRenderer(this._scene)), this._colorRenderer } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new PointsBatchingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } get pickMeshRenderer() { return this._pickMeshRenderer || (this._pickMeshRenderer = new PointsBatchingPickMeshRenderer(this._scene)), this._pickMeshRenderer } get pickDepthRenderer() { return this._pickDepthRenderer || (this._pickDepthRenderer = new PointsBatchingPickDepthRenderer(this._scene)), this._pickDepthRenderer } get occlusionRenderer() { return this._occlusionRenderer || (this._occlusionRenderer = new PointsBatchingOcclusionRenderer(this._scene)), this._occlusionRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy(), this._pickMeshRenderer && this._pickMeshRenderer.destroy(), this._pickDepthRenderer && this._pickDepthRenderer.destroy(), this._occlusionRenderer && this._occlusionRenderer.destroy() } } const cachedRenderers$1 = {}; function getPointsBatchingRenderers(e) { const t = e.id; let i = cachedRenderers$1[t]; return i || (i = new PointsBatchingRenderers(e), (cachedRenderers$1[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachedRenderers$1[t], i._destroy() }))), i } class PointsBatchingBuffer { constructor(e = 5e6) { this.maxVerts = e = 5e6 < e ? 5e6 : e, this.maxIndices = 3 * e, this.positions = [], this.colors = [], this.intensities = [], this.pickColors = [], this.flags = [], this.flags2 = [], this.offsets = [] } } const tempVec3a$j = math.vec4(), tempVec3b$8 = math.vec4(), tempVec4a$6 = math.vec4([0, 0, 0, 1]), tempVec4b$6 = math.vec4([0, 0, 0, 1]), tempVec4c$3 = math.vec4([0, 0, 0, 1]), tempOBB3 = math.OBB3(); class PointsBatchingLayer { constructor(e) { this.model = e.model, this.sortId = "PointsBatchingLayer", this.layerIndex = e.layerIndex, this._pointsBatchingRenderers = getPointsBatchingRenderers(e.model.scene), this._buffer = new PointsBatchingBuffer(e.maxGeometryBatchSize), this._scratchMemory = e.scratchMemory, this._state = new RenderState({ positionsBuf: null, offsetsBuf: null, colorsBuf: null, flagsBuf: null, flags2Buf: null, positionsDecodeMatrix: math.mat4(), origin: null }), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this._modelAABB = math.collapseAABB3(), this._portions = [], this._finalized = !1, e.positionsDecodeMatrix ? (this._state.positionsDecodeMatrix.set(e.positionsDecodeMatrix), this._preCompressedPositionsExpected = !0) : this._preCompressedPositionsExpected = !1, e.origin && (this._state.origin = math.vec3(e.origin)), this.aabb = math.collapseAABB3() } canCreatePortion(e) { if (this._finalized) throw "Already finalized"; return this._buffer.positions.length + e < 3 * this._buffer.maxVerts } createPortion(e) { if (this._finalized) throw "Already finalized"; var t = e.positions, i = e.positionsCompressed, s = e.color, r = e.colorsCompressed, a = e.colors, o = e.meshMatrix, n = e.worldMatrix, h = e.worldAABB, l = e.pickColor, c = this._buffer; e = c.positions.length / 3; let u; if (this._preCompressedPositionsExpected) { if (!i) throw "positionsCompressed expected"; for (let e = 0, t = i.length; e < t; e++)c.positions.push(i[e]); var p = geometryCompressionUtils.getPositionsBounds(i), d = geometryCompressionUtils.decompressPosition(p.min, this._state.positionsDecodeMatrix, tempVec3a$j); p = geometryCompressionUtils.decompressPosition(p.max, this._state.positionsDecodeMatrix, tempVec3b$8); h[0] = d[0], h[1] = d[1], h[2] = d[2], h[3] = p[0], h[4] = p[1], h[5] = p[2], n && (math.AABB3ToOBB3(h, tempOBB3), math.transformOBB3(n, tempOBB3), math.OBB3ToAABB3(tempOBB3, h)), u = i.length / 3 } else { if (!t) throw "positions expected"; u = t.length / 3, d = t.length, p = c.positions.length; for (let e = 0, i = t.length; e < i; e++)c.positions.push(t[e]); if (o) for (let e = p, t = p + d; e < t; e += 3)tempVec4a$6[0] = c.positions[e + 0], tempVec4a$6[1] = c.positions[e + 1], tempVec4a$6[2] = c.positions[e + 2], math.transformPoint4(o, tempVec4a$6, tempVec4b$6), c.positions[e + 0] = tempVec4b$6[0], c.positions[e + 1] = tempVec4b$6[1], c.positions[e + 2] = tempVec4b$6[2], math.expandAABB3Point3(this._modelAABB, tempVec4b$6), n ? (math.transformPoint4(n, tempVec4b$6, tempVec4c$3), math.expandAABB3Point3(h, tempVec4c$3)) : math.expandAABB3Point3(h, tempVec4b$6); else for (let e = p, t = p + d; e < t; e += 3)tempVec4a$6[0] = c.positions[e + 0], tempVec4a$6[1] = c.positions[e + 1], tempVec4a$6[2] = c.positions[e + 2], math.expandAABB3Point3(this._modelAABB, tempVec4a$6), n ? (math.transformPoint4(n, tempVec4a$6, tempVec4b$6), math.expandAABB3Point3(h, tempVec4b$6)) : math.expandAABB3Point3(h, tempVec4a$6) } if (this._state.origin && (p = this._state.origin, h[0] += p[0], h[1] += p[1], h[2] += p[2], h[3] += p[0], h[4] += p[1], h[5] += p[2]), math.expandAABB3(this.aabb, h), r) for (let e = 0, t = r.length; e < t; e++)c.colors.push(r[e]); else if (a) for (let e = 0, t = a.length; e < t; e++)c.colors.push(255 * a[e]); else if (s) { var m = s[0], f = s[1], g = s[2]; for (let e = 0; e < u; e++)c.colors.push(m), c.colors.push(f), c.colors.push(g), c.colors.push(1) } for (let e = d = c.pickColors.length, t = d + 4 * u; e < t; e += 4)c.pickColors.push(l[0]), c.pickColors.push(l[1]), c.pickColors.push(l[2]), c.pickColors.push(l[3]); if (this.model.scene.entityOffsetsEnabled) for (let e = 0; e < u; e++)c.offsets.push(0), c.offsets.push(0), c.offsets.push(0); return p = this._portions.length / 2, this._portions.push(e), this._portions.push(u), this._numPortions++, this.model.numPortions++, p } finalize() { var e, t, i, s, r; this._finalized ? this.model.error("Already finalized") : (e = this._state, t = this.model.scene.canvas.gl, 0 < (i = this._buffer).positions.length && (r = this._preCompressedPositionsExpected ? new Uint16Array(i.positions) : quantizePositions(new Float32Array(i.positions), this._modelAABB, e.positionsDecodeMatrix), e.positionsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, r, i.positions.length, 3, t.STATIC_DRAW)), 0 < i.colors.length && (r = new Uint8Array(i.colors), e.colorsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, r, i.colors.length, 4, t.STATIC_DRAW, !1)), 0 < i.positions.length && (r = i.positions.length / 3 * 4, s = new Uint8Array(r), r = new Uint8Array(r), e.flagsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, s, s.length, 4, t.DYNAMIC_DRAW, !1), e.flags2Buf = new ArrayBuf(t, t.ARRAY_BUFFER, r, r.length, 4, t.DYNAMIC_DRAW, !0)), 0 < i.pickColors.length && (s = new Uint8Array(i.pickColors), e.pickColorsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, s, i.pickColors.length, 4, t.STATIC_DRAW, !1)), this.model.scene.entityOffsetsEnabled && 0 < i.offsets.length && (r = new Float32Array(i.offsets), e.offsetsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, r, i.offsets.length, 3, t.DYNAMIC_DRAW)), this._buffer = null, this._finalized = !0) } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i), this._setFlags2(e, t) } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized" } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; e *= 2; var i = 4 * this._portions[e], s = 4 * this._portions[1 + e], r = this._scratchMemory.getUInt8Array(s), a = t[0], o = t[1], n = t[2]; for (let e = 0; e < s; e += 4)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n; this._state.colorsBuf.setData(r, i, s) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i) { if (!this._finalized) throw "Not finalized"; e *= 2; var s = 4 * this._portions[e], r = 4 * this._portions[1 + e], a = this._scratchMemory.getUInt8Array(r), o = (e = !!(t & ENTITY_FLAGS.VISIBLE), !!(t & ENTITY_FLAGS.XRAYED)), n = !!(t & ENTITY_FLAGS.HIGHLIGHTED), h = !!(t & ENTITY_FLAGS.SELECTED), l = !!(t & ENTITY_FLAGS.PICKABLE), c = (t = !!(t & ENTITY_FLAGS.CULLED), !e || t || o || n && !this.model.scene.highlightMaterial.glowThrough || h && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE), u = !e || t ? RENDER_PASSES.NOT_RENDERED : h ? RENDER_PASSES.SILHOUETTE_SELECTED : n ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : o ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, p = e && !t && l ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; for (let e = 0; e < r; e += 4)a[e + 0] = c, a[e + 1] = u, a[e + 2] = 0, a[e + 3] = p; this._state.flagsBuf.setData(a, s, r) } _setFlags2(e, t) { if (!this._finalized) throw "Not finalized"; e *= 2; var i = 4 * this._portions[e], s = 4 * this._portions[1 + e], r = this._scratchMemory.getUInt8Array(s), a = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0; for (let e = 0; e < s; e += 4)r[e + 0] = a; this._state.flags2Buf.setData(r, i, s) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; if (this.model.scene.entityOffsetsEnabled) { e = 2 * e; var i = 3 * this._portions[e], s = 3 * this._portions[1 + e], r = this._scratchMemory.getFloat32Array(s), a = t[0], o = t[1], n = t[2]; for (let e = 0; e < s; e += 3)r[e + 0] = a, r[e + 1] = o, r[e + 2] = n; this._state.offsetsBuf.setData(r, i, s) } else this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && this._pointsBatchingRenderers.colorRenderer && this._pointsBatchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && this._pointsBatchingRenderers.colorRenderer && this._pointsBatchingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) } drawDepth(e, t) { } drawNormals(e, t) { } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._pointsBatchingRenderers.silhouetteRenderer && this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._pointsBatchingRenderers.silhouetteRenderer && this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._pointsBatchingRenderers.silhouetteRenderer && this._pointsBatchingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { } drawEdgesColorTransparent(e, t) { } drawEdgesHighlighted(e, t) { } drawEdgesSelected(e, t) { } drawEdgesXRayed(e, t) { } drawPickMesh(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsBatchingRenderers.pickMeshRenderer && this._pointsBatchingRenderers.pickMeshRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickDepths(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsBatchingRenderers.pickDepthRenderer && this._pointsBatchingRenderers.pickDepthRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickNormals(e, t) { } drawOcclusion(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsBatchingRenderers.occlusionRenderer && this._pointsBatchingRenderers.occlusionRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawShadow(e, t) { } destroy() { var e = this._state; e.positionsBuf && (e.positionsBuf.destroy(), e.positionsBuf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.pickColorsBuf && (e.pickColorsBuf.destroy(), e.pickColorsBuf = null), e.destroy() } } const tempVec3a$i = math.vec3(); class PointsInstancingColorRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = t.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), this._aPosition.bindArrayBuffer(c.positionsBuf), this._aColor.bindArrayBuffer(c.colorsBuf), l.filterIntensity && o.uniform2f(this._uIntensityRange, l.minIntensity, l.maxIntensity); var u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], h ? (g = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$i), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, c.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), o.uniform1f(this._uPointSize, l.pointSize), i = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, i), o.drawArraysInstanced(o.POINTS, 0, c.positionsBuf.numItems, n.numInstances), e.drawArrays++, o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.pointsMaterial._state, i = e.canvas.gl; if (this._program = new Program(i, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, i = e._sectionPlanesState.sectionPlanes.length; t < i; t++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + t), pos: s.getLocation("sectionPlanePos" + t), dir: s.getLocation("sectionPlaneDir" + t) }); this._aPosition = s.getAttribute("position"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aOffset = s.getAttribute("offset"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uOcclusionTexture = "uOcclusionTexture", this._uPointSize = s.getLocation("pointSize"), this._uNearPlaneHeight = s.getLocation("nearPlaneHeight"), t.filterIntensity && (this._uIntensityRange = s.getLocation("intensityRange")), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing color vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), s.push("in vec4 color;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), i.filterIntensity && s.push("uniform vec2 intensityRange;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vColor;"), s.push("void main(void) {"), s.push("if (int(flags.x) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), i.filterIntensity && (s.push("float intensity = float(color.a) / 255.0;"), s.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {")), s.push("vec4 worldPosition =  positionsDecodeMatrix * vec4(position, 1.0); "), s.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("vec4 viewPosition  = viewMatrix * worldPosition; "), s.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);"), t && (s.push("vWorldPosition = worldPosition;"), s.push("vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), i.filterIntensity && s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points instancing color fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor = vColor;"), e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$h = math.vec3(); class PointsInstancingSilhouetteRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = t.geometry; if (this._program || (this._allocate(t.model.scene), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), i === RENDER_PASSES.SILHOUETTE_XRAYED ? (u = (e = r.xrayMaterial._state).fillColor, e = e.fillAlpha, o.uniform4f(this._uColor, u[0], u[1], u[2], e)) : i === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED ? (e = (u = r.highlightMaterial._state).fillColor, u = u.fillAlpha, o.uniform4f(this._uColor, e[0], e[1], e[2], u)) : i === RENDER_PASSES.SILHOUETTE_SELECTED ? (u = (e = r.selectedMaterial._state).fillColor, i = e.fillAlpha, o.uniform4f(this._uColor, u[0], u[1], u[2], i)) : o.uniform4fv(this._uColor, math.vec3([1, 1, 1])), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var u, p = r._sectionPlanesState.sectionPlanes.length; if (0 < p) { var d = r._sectionPlanesState.sectionPlanes, m = t.layerIndex * p, f = s.renderFlags; for (let e = 0; e < p; e++) { var g, _, v = this._uSectionPlanes[e]; v && (g = f.sectionPlanesActivePerLayer[m + e], o.uniform1i(v.active, g ? 1 : 0), g) && (g = d[e], h ? (_ = getPlaneRTCPos(g.dist, g.dir, h, tempVec3a$h), o.uniform3fv(v.pos, _)) : o.uniform3fv(v.pos, g.pos), o.uniform3fv(v.dir, g.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, c.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(c.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf, o.UNSIGNED_BYTE, !0), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), o.uniform1f(this._uPointSize, l.pointSize), e = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, e), o.drawArraysInstanced(o.POINTS, 0, c.positionsBuf.numItems, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uColor = s.getLocation("color"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uPointSize = s.getLocation("pointSize"), this._uNearPlaneHeight = s.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing silhouette vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), s.push("uniform vec4 color;"), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("void main(void) {"), s.push("if (int(flags.y) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), s.push("worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("vWorldPosition = worldPosition;"), s.push("vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points instancing silhouette fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("uniform vec4 color;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = color;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$g = math.vec3(); class PointsInstancingPickMeshRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = t.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e)), o.uniform1i(this._uRenderPass, i); i = e.pickViewMatrix || a.viewMatrix, i = h ? createRTCViewMat(i, h) : i, e = (o.uniformMatrix4fv(this._uViewMatrix, !1, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.project.far + 1) / Math.LN2), o.uniform1f(this._uLogDepthBufFC, i)), o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, c.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPickColor.bindArrayBuffer(n.pickColorsBuf), o.vertexAttribDivisor(this._aPickColor.location, 1), this._aPosition.bindArrayBuffer(c.positionsBuf), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), o.uniform1f(this._uPointSize, l.pointSize), "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180))); var u = (o.uniform1f(this._uNearPlaneHeight, e), r._sectionPlanesState.sectionPlanes.length); if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], h ? (g = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$g), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.drawArraysInstanced(o.POINTS, 0, c.positionsBuf.numItems, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aPickColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uPickInvisible = s.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._uRenderPass = s.getLocation("renderPass"), this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aPickColor = s.getAttribute("pickColor"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uPointSize = s.getLocation("pointSize"), this._uNearPlaneHeight = s.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram(e) { var t = this._scene.canvas.gl; this._program.bind(), t.uniform1i(this._uPickInvisible, e.pickInvisible) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing pick mesh vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 pickColor;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform bool pickInvisible;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vPickColor;"), s.push("void main(void) {"), s.push("if (int(flags.w) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), s.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), s.push("  vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);"), t && (s.push("  vWorldPosition = worldPosition;"), s.push("  vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points instancing pick mesh fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vPickColor;"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("outColor = vPickColor; "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$f = math.vec3(); class PointsInstancingPickDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.canvas.gl, o = t._state, n = t._state.origin, h = r.pointsMaterial._state, l = t.geometry; if (this._program || (this._allocate(t), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()); var c = r.camera, u = (i = (a.uniform1i(this._uRenderPass, i), a.uniform1i(this._uPickInvisible, e.pickInvisible), e.pickViewMatrix || c.viewMatrix), c = n ? createRTCViewMat(i, n) : i, a.uniformMatrix4fv(this._uViewMatrix, !1, c), a.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), a.uniformMatrix4fv(this._uProjMatrix, !1, e.pickProjMatrix), a.uniform1f(this._uPickZNear, e.pickZNear), a.uniform1f(this._uPickZFar, e.pickZFar), r.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(e.pickZFar + 1) / Math.LN2), a.uniform1f(this._uLogDepthBufFC, i)), r._sectionPlanesState.sectionPlanes.length); if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], a.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], n ? (g = getPlaneRTCPos(f.dist, f.dir, n, tempVec3a$f), a.uniform3fv(_.pos, g)) : a.uniform3fv(_.pos, f.pos), a.uniform3fv(_.dir, f.dir)) } } a.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, l.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(o.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(o.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(o.modelMatrixCol2Buf), a.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), a.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), a.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(l.positionsBuf), this._aFlags.bindArrayBuffer(o.flagsBuf), a.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(o.flags2Buf), a.vertexAttribDivisor(this._aFlags2.location, 1)), this._aOffset && (this._aOffset.bindArrayBuffer(o.offsetsBuf), a.vertexAttribDivisor(this._aOffset.location, 1)), a.uniform1f(this._uPointSize, h.pointSize), c = "ortho" === r.camera.projection ? 1 : a.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), a.uniform1f(this._uNearPlaneHeight, c), a.drawArraysInstanced(a.POINTS, 0, l.positionsBuf.numItems, o.numInstances), a.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), a.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), a.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), a.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && a.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && a.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPickInvisible = i.getLocation("pickInvisible"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), this._uPickZNear = i.getLocation("pickZNear"), this._uPickZFar = i.getLocation("pickZFar"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { this._program.bind() } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing pick depth vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform bool pickInvisible;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("out vec4 vViewPosition;"), s.push("void main(void) {"), s.push("if (int(flags.w) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), s.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("  vWorldPosition = worldPosition;"), s.push("  vFlags2 = flags2;")), s.push("  vViewPosition = viewPosition;"), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points instancing pick depth fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), s.push("uniform float pickZNear;"), s.push("uniform float pickZFar;"), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec4 vViewPosition;"), s.push("vec4 packDepth(const in float depth) {"), s.push("  const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);"), s.push("  const vec4 bitMask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);"), s.push("  vec4 res = fract(depth * bitShift);"), s.push("  res -= res.xxyz * bitMask;"), s.push("  return res;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    float zNormalizedDepth = abs((pickZNear + vViewPosition.z) / (pickZFar - pickZNear));"), s.push("    outColor = packDepth(zNormalizedDepth); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$e = math.vec3(); class PointsInstancingOcclusionRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = t.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix); var u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], h ? (g = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$e), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, c.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aColor && (this._aColor.bindArrayBuffer(c.colorsBuf), o.vertexAttribDivisor(this._aColor.location, 1)), this._aPosition.bindArrayBuffer(c.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), o.uniform1f(this._uPointSize, l.pointSize), e = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, e), o.drawArraysInstanced(o.POINTS, 0, c.positionsBuf.numItems, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), this._aColor && o.vertexAttribDivisor(this._aColor.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uRenderPass = s.getLocation("renderPass"), this._uPositionsDecodeMatrix = s.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = s.getLocation("worldMatrix"), this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), this._aOffset = s.getAttribute("offset"), this._aColor = s.getAttribute("color"), this._aFlags = s.getAttribute("flags"), this._aFlags2 = s.getAttribute("flags2"), this._aModelMatrixCol0 = s.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = s.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = s.getAttribute("modelMatrixCol2"), this._uPointSize = s.getLocation("pointSize"), this._uNearPlaneHeight = s.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing occlusion vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 color;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("void main(void) {"), s.push("if (int(flags.x) != renderPass) {"), s.push("      gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), s.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && s.push("  vWorldPosition = worldPosition;"), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Points instancing occlusion vertex shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), e.pointsMaterial.roundPoints && (s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }")), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return s.push("   outColor = vec4(0.0, 0.0, 1.0, 1.0); "), e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$d = math.vec3(); class PointsInstancingDepthRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() + this._scene.pointsMaterial.hash } drawLayer(e, t, i) { var s = t.model, r = s.scene, a = r.camera, o = r.canvas.gl, n = t._state, h = t._state.origin, l = r.pointsMaterial._state, c = t.geometry; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram()), o.uniform1i(this._uRenderPass, i), o.uniformMatrix4fv(this._uWorldMatrix, !1, s.worldMatrix), o.uniformMatrix4fv(this._uViewMatrix, !1, h ? createRTCViewMat(a.viewMatrix, h) : a.viewMatrix); var u = r._sectionPlanesState.sectionPlanes.length; if (0 < u) { var p = r._sectionPlanesState.sectionPlanes, d = t.layerIndex * u, m = s.renderFlags; for (let e = 0; e < u; e++) { var f, g, _ = this._uSectionPlanes[e]; _ && (f = m.sectionPlanesActivePerLayer[d + e], o.uniform1i(_.active, f ? 1 : 0), f) && (f = p[e], h ? (g = getPlaneRTCPos(f.dist, f.dir, h, tempVec3a$d), o.uniform3fv(_.pos, g)) : o.uniform3fv(_.pos, f.pos), o.uniform3fv(_.dir, f.dir)) } } this._aModelMatrixCol0.bindArrayBuffer(n.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(n.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(n.modelMatrixCol2Buf), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), o.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, c.positionsDecodeMatrix), this._aPosition.bindArrayBuffer(c.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(n.offsetsBuf), o.vertexAttribDivisor(this._aOffset.location, 1)), this._aFlags.bindArrayBuffer(n.flagsBuf), o.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(n.flags2Buf), o.vertexAttribDivisor(this._aFlags2.location, 1)), o.uniform1f(this._uPointSize, l.pointSize), e = "ortho" === r.camera.projection ? 1 : o.drawingBufferHeight / (2 * Math.tan(.5 * r.camera.perspective.fov * Math.PI / 180)), o.uniform1f(this._uNearPlaneHeight, e), o.drawArraysInstanced(o.POINTS, 0, c.positionsBuf.numItems, n.numInstances), o.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), o.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), o.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && o.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && o.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = this._scene, t = e.canvas.gl; if (this._program = new Program(t, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uRenderPass = i.getLocation("renderPass"), this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uWorldMatrix = i.getLocation("worldMatrix"), this._uViewMatrix = i.getLocation("viewMatrix"), this._uProjMatrix = i.getLocation("projMatrix"), this._uSectionPlanes = []; for (let t = 0, s = e._sectionPlanesState.sectionPlanes.length; t < s; t++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + t), pos: i.getLocation("sectionPlanePos" + t), dir: i.getLocation("sectionPlaneDir" + t) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), this._uPointSize = i.getLocation("pointSize"), this._uNearPlaneHeight = i.getLocation("nearPlaneHeight"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = i.getLocation("logDepthBufFC")) } } _bindProgram() { var e = this._scene, t = e.canvas.gl, i = e.camera.project; this._program.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, i.matrix), e.logarithmicDepthBufferEnabled && (e = 2 / (Math.log(i.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, e)) } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = e.pointsMaterial._state, s = []; return s.push("#version 300 es"), s.push("// Points instancing depth vertex shader"), s.push("uniform int renderPass;"), s.push("in vec3 position;"), e.entityOffsetsEnabled && s.push("in vec3 offset;"), s.push("in vec4 flags;"), s.push("in vec4 flags2;"), s.push("in vec4 modelMatrixCol0;"), s.push("in vec4 modelMatrixCol1;"), s.push("in vec4 modelMatrixCol2;"), s.push("uniform mat4 worldMatrix;"), s.push("uniform mat4 viewMatrix;"), s.push("uniform mat4 projMatrix;"), s.push("uniform mat4 positionsDecodeMatrix;"), s.push("uniform float pointSize;"), i.perspectivePoints && s.push("uniform float nearPlaneHeight;"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("out float vFragDepth;")), t && (s.push("out vec4 vWorldPosition;"), s.push("out vec4 vFlags2;")), s.push("void main(void) {"), s.push("if (int(flags.x) != renderPass) {"), s.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), s.push("} else {"), s.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), s.push("  worldPosition = worldMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && s.push("      worldPosition.xyz = worldPosition.xyz + offset;"), s.push("  vec4 viewPosition  = viewMatrix * worldPosition; "), t && (s.push("vWorldPosition = worldPosition;"), s.push("vFlags2 = flags2;")), s.push("vec4 clipPos = projMatrix * viewPosition;"), e.logarithmicDepthBufferEnabled && s.push("vFragDepth = 1.0 + clipPos.w;"), s.push("gl_Position = clipPos;"), i.perspectivePoints ? (s.push("gl_PointSize = (nearPlaneHeight * pointSize) / clipPos.w;"), s.push("gl_PointSize = max(gl_PointSize, " + Math.floor(i.minPerspectivePointSize) + ".0);"), s.push("gl_PointSize = min(gl_PointSize, " + Math.floor(i.maxPerspectivePointSize) + ".0);")) : s.push("gl_PointSize = pointSize;"), s.push("}"), s.push("}"), s } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState; let i, s; var r = 0 < t.sectionPlanes.length, a = []; if (a.push("#version 300 es"), a.push("// Points instancing depth vertex shader"), a.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), a.push("precision highp float;"), a.push("precision highp int;"), a.push("#else"), a.push("precision mediump float;"), a.push("precision mediump int;"), a.push("#endif"), e.logarithmicDepthBufferEnabled && (a.push("uniform float logDepthBufFC;"), a.push("in float vFragDepth;")), r) for (a.push("in vec4 vWorldPosition;"), a.push("in vec4 vFlags2;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("uniform bool sectionPlaneActive" + i + ";"), a.push("uniform vec3 sectionPlanePos" + i + ";"), a.push("uniform vec3 sectionPlaneDir" + i + ";"); if (a.push("const float   packUpScale = 256. / 255.;"), a.push("const float   unpackDownscale = 255. / 256.;"), a.push("const vec3    packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );"), a.push("const vec4    unpackFactors = unpackDownscale / vec4( packFactors, 1. );"), a.push("const float   shiftRight8 = 1.0 / 256.;"), a.push("vec4 packDepthToRGBA( const in float v ) {"), a.push("    vec4 r = vec4( fract( v * packFactors ), v );"), a.push("    r.yzw -= r.xyz * shiftRight8;"), a.push("    return r * packUpScale;"), a.push("}"), a.push("out vec4 outColor;"), a.push("void main(void) {"), e.pointsMaterial.roundPoints && (a.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), a.push("  float r = dot(cxy, cxy);"), a.push("  if (r > 1.0) {"), a.push("       discard;"), a.push("  }")), r) { for (a.push("  bool clippable = (float(vFlags2.x) > 0.0);"), a.push("  if (clippable) {"), a.push("  float dist = 0.0;"), i = 0, s = t.sectionPlanes.length; i < s; i++)a.push("if (sectionPlaneActive" + i + ") {"), a.push("   dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);"), a.push("}"); a.push("if (dist > 0.0) { discard; }"), a.push("}") } return a.push("    outColor = packDepthToRGBA( gl_FragCoord.z); "), e.logarithmicDepthBufferEnabled && a.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), a.push("}"), a } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } const tempVec3a$c = math.vec3(); class PointsInstancingShadowRenderer { constructor(e) { this._scene = e, this._hash = this._getHash(), this._lastLightId = null, this._allocate() } getValid() { return this._hash === this._getHash() } _getHash() { return this._scene._sectionPlanesState.getHash() } drawLayer(e, t) { var i = t.model, s = i.scene, r = s.canvas.gl, a = t._state; if (this._program || (this._allocate(), !this.errors)) { e.lastProgramId !== this._program.id && (e.lastProgramId = this._program.id, this._bindProgram(e, t)), r.uniformMatrix4fv(this._uPositionsDecodeMatrix, !1, geometry.positionsDecodeMatrix), this._aModelMatrixCol0.bindArrayBuffer(a.modelMatrixCol0Buf), this._aModelMatrixCol1.bindArrayBuffer(a.modelMatrixCol1Buf), this._aModelMatrixCol2.bindArrayBuffer(a.modelMatrixCol2Buf), r.vertexAttribDivisor(this._aModelMatrixCol0.location, 1), r.vertexAttribDivisor(this._aModelMatrixCol1.location, 1), r.vertexAttribDivisor(this._aModelMatrixCol2.location, 1), this._aPosition.bindArrayBuffer(a.positionsBuf), this._aOffset && (this._aOffset.bindArrayBuffer(a.offsetsBuf), r.vertexAttribDivisor(this._aOffset.location, 1)), this._aColor.bindArrayBuffer(a.colorsBuf), r.vertexAttribDivisor(this._aColor.location, 1), this._aFlags.bindArrayBuffer(a.flagsBuf), r.vertexAttribDivisor(this._aFlags.location, 1), this._aFlags2 && (this._aFlags2.bindArrayBuffer(a.flags2Buf), r.vertexAttribDivisor(this._aFlags2.location, 1)); var o = s._sectionPlanesState.sectionPlanes.length; if (0 < o) { var n = s._sectionPlanesState.sectionPlanes, h = t.layerIndex * o, l = i.renderFlags, c = t._state.origin; for (let e = 0; e < o; e++) { var u, p, d = this._uSectionPlanes[e]; d && (u = l.sectionPlanesActivePerLayer[h + e], r.uniform1i(d.active, u ? 1 : 0), u) && (u = n[e], c ? (p = getPlaneRTCPos(u.dist, u.dir, c, tempVec3a$c), r.uniform3fv(d.pos, p)) : r.uniform3fv(d.pos, u.pos), r.uniform3fv(d.dir, u.dir)) } } r.uniform1f(this._uPointSize, 10), r.drawArraysInstanced(r.POINTS, 0, a.positionsBuf.numItems, a.numInstances), r.vertexAttribDivisor(this._aModelMatrixCol0.location, 0), r.vertexAttribDivisor(this._aModelMatrixCol1.location, 0), r.vertexAttribDivisor(this._aModelMatrixCol2.location, 0), r.vertexAttribDivisor(this._aColor.location, 0), r.vertexAttribDivisor(this._aFlags.location, 0), this._aFlags2 && r.vertexAttribDivisor(this._aFlags2.location, 0), this._aOffset && r.vertexAttribDivisor(this._aOffset.location, 0) } } _allocate() { var e = (t = this._scene).canvas.gl, t = t._sectionPlanesState; if (this._program = new Program(e, this._buildShader()), this._program.errors) this.errors = this._program.errors; else { var i = this._program; this._uPositionsDecodeMatrix = i.getLocation("positionsDecodeMatrix"), this._uShadowViewMatrix = i.getLocation("shadowViewMatrix"), this._uShadowProjMatrix = i.getLocation("shadowProjMatrix"), this._uSectionPlanes = []; for (let e = 0, s = t.sectionPlanes.length; e < s; e++)this._uSectionPlanes.push({ active: i.getLocation("sectionPlaneActive" + e), pos: i.getLocation("sectionPlanePos" + e), dir: i.getLocation("sectionPlaneDir" + e) }); this._aPosition = i.getAttribute("position"), this._aOffset = i.getAttribute("offset"), this._aColor = i.getAttribute("color"), this._aFlags = i.getAttribute("flags"), this._aFlags2 = i.getAttribute("flags2"), this._aModelMatrixCol0 = i.getAttribute("modelMatrixCol0"), this._aModelMatrixCol1 = i.getAttribute("modelMatrixCol1"), this._aModelMatrixCol2 = i.getAttribute("modelMatrixCol2"), this._uPointSize = i.getLocation("pointSize") } } _bindProgram(e, t) { var i = this._scene.canvas.gl; this._program.bind(), i.uniformMatrix4fv(this._uShadowViewMatrix, !1, e.shadowViewMatrix), i.uniformMatrix4fv(this._uShadowProjMatrix, !1, e.shadowProjMatrix), this._lastLightId = null } _buildShader() { return { vertex: this._buildVertexShader(), fragment: this._buildFragmentShader() } } _buildVertexShader() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// Instancing geometry shadow drawing vertex shader"), i.push("in vec3 position;"), e.entityOffsetsEnabled && i.push("in vec3 offset;"), i.push("in vec4 color;"), i.push("in vec4 flags;"), i.push("in vec4 flags2;"), i.push("in vec4 modelMatrixCol0;"), i.push("in vec4 modelMatrixCol1;"), i.push("in vec4 modelMatrixCol2;"), i.push("uniform mat4 shadowViewMatrix;"), i.push("uniform mat4 shadowProjMatrix;"), i.push("uniform mat4 positionsDecodeMatrix;"), i.push("uniform float pointSize;"), t && (i.push("out vec4 vWorldPosition;"), i.push("out vec4 vFlags2;")), i.push("void main(void) {"), i.push("bool visible      = (float(flags.x) > 0.0);"), i.push("bool transparent  = ((float(color.a) / 255.0) < 1.0);"), i.push("if (!visible || transparent) {"), i.push("   gl_Position = vec4(0.0, 0.0, 0.0, 0.0);"), i.push("} else {"), i.push("  vec4 worldPosition = positionsDecodeMatrix * vec4(position, 1.0); "), i.push("  worldPosition = vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0);"), e.entityOffsetsEnabled && i.push("      worldPosition.xyz = worldPosition.xyz + offset;"), i.push("  vec4 viewPosition  = shadowViewMatrix * worldPosition; "), t && (i.push("vWorldPosition = worldPosition;"), i.push("vFlags2 = flags2;")), i.push("  gl_Position = shadowProjMatrix * viewPosition;"), i.push("}"), i.push("gl_PointSize = pointSize;"), i.push("}"), i } _buildFragmentShader() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// Instancing geometry depth drawing fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"), s.push("in vec4 vFlags2;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("in vec3 vViewNormal;"), s.push("vec3 packNormalToRGB( const in vec3 normal ) {"), s.push("    return normalize( normal ) * 0.5 + 0.5;"), s.push("}"), s.push("out vec4 outColor;"), s.push("void main(void) {"), s.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;"), s.push("  float r = dot(cxy, cxy);"), s.push("  if (r > 1.0) {"), s.push("       discard;"), s.push("  }"), i) { s.push("  bool clippable = (float(vFlags2.x) > 0.0);"), s.push("  if (clippable) {"), s.push("  float dist = 0.0;"); for (let e = 0, i = t.sectionPlanes.length; e < i; e++)s.push("if (sectionPlaneActive" + e + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + e + ".xyz, vWorldPosition.xyz - sectionPlanePos" + e + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("if (dist > 0.0) { discard; }"), s.push("}") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("    outColor = vec4(packNormalToRGB(vViewNormal), 1.0); "), s.push("}"), s } webglContextRestored() { this._program = null } destroy() { this._program && this._program.destroy(), this._program = null } } class PointsInstancingRenderers { constructor(e) { this._scene = e } _compile() { this._colorRenderer && !this._colorRenderer.getValid() && (this._colorRenderer.destroy(), this._colorRenderer = null), this._depthRenderer && !this._depthRenderer.getValid() && (this._depthRenderer.destroy(), this._depthRenderer = null), this._silhouetteRenderer && !this._silhouetteRenderer.getValid() && (this._silhouetteRenderer.destroy(), this._silhouetteRenderer = null), this._pickMeshRenderer && !this._pickMeshRenderer.getValid() && (this._pickMeshRenderer.destroy(), this._pickMeshRenderer = null), this._pickDepthRenderer && !this._pickDepthRenderer.getValid() && (this._pickDepthRenderer.destroy(), this._pickDepthRenderer = null), this._occlusionRenderer && !1 === this._occlusionRenderer.getValid() && (this._occlusionRenderer.destroy(), this._occlusionRenderer = null), this._shadowRenderer && !this._shadowRenderer.getValid() && (this._shadowRenderer.destroy(), this._shadowRenderer = null) } get colorRenderer() { return this._colorRenderer || (this._colorRenderer = new PointsInstancingColorRenderer(this._scene, !1)), this._colorRenderer } get silhouetteRenderer() { return this._silhouetteRenderer || (this._silhouetteRenderer = new PointsInstancingSilhouetteRenderer(this._scene)), this._silhouetteRenderer } get depthRenderer() { return this._depthRenderer || (this._depthRenderer = new PointsInstancingDepthRenderer(this._scene)), this._depthRenderer } get pickMeshRenderer() { return this._pickMeshRenderer || (this._pickMeshRenderer = new PointsInstancingPickMeshRenderer(this._scene)), this._pickMeshRenderer } get pickDepthRenderer() { return this._pickDepthRenderer || (this._pickDepthRenderer = new PointsInstancingPickDepthRenderer(this._scene)), this._pickDepthRenderer } get occlusionRenderer() { return this._occlusionRenderer || (this._occlusionRenderer = new PointsInstancingOcclusionRenderer(this._scene)), this._occlusionRenderer } get shadowRenderer() { return this._shadowRenderer || (this._shadowRenderer = new PointsInstancingShadowRenderer(this._scene)), this._shadowRenderer } _destroy() { this._colorRenderer && this._colorRenderer.destroy(), this._depthRenderer && this._depthRenderer.destroy(), this._silhouetteRenderer && this._silhouetteRenderer.destroy(), this._pickMeshRenderer && this._pickMeshRenderer.destroy(), this._pickDepthRenderer && this._pickDepthRenderer.destroy(), this._occlusionRenderer && this._occlusionRenderer.destroy(), this._shadowRenderer && this._shadowRenderer.destroy() } } const cachedRenderers = {}; function getPointsInstancingRenderers(e) { const t = e.id; let i = cachedRenderers[t]; return i || (i = new PointsInstancingRenderers(e), (cachedRenderers[t] = i)._compile(), e.on("compile", (() => { i._compile() })), e.on("destroyed", (() => { delete cachedRenderers[t], i._destroy() }))), i } const tempUint8Vec4 = new Uint8Array(4), tempVec4a$5 = math.vec4([0, 0, 0, 1]), tempVec4b$5 = math.vec4([0, 0, 0, 1]), tempVec4c$2 = math.vec4([0, 0, 0, 1]), tempVec3fa = new Float32Array(3); class PointsInstancingLayer { constructor(e) { this.model = e.model, this.geometry = e.geometry, this.material = e.material, this.sortId = "PointsInstancingLayer", this.layerIndex = e.layerIndex, this._pointsInstancingRenderers = getPointsInstancingRenderers(e.model.scene), this._aabb = math.collapseAABB3(), this._state = new RenderState({ obb: math.OBB3(), numInstances: 0, origin: e.origin ? math.vec3(e.origin) : null }), this._numPortions = 0, this._numVisibleLayerPortions = 0, this._numTransparentLayerPortions = 0, this._numXRayedLayerPortions = 0, this._numHighlightedLayerPortions = 0, this._numSelectedLayerPortions = 0, this._numClippableLayerPortions = 0, this._numEdgesLayerPortions = 0, this._numPickableLayerPortions = 0, this._numCulledLayerPortions = 0, this.numIndices = e.geometry.numIndices, this._pickColors = [], this._offsets = [], this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = [], this._portions = [], this._finalized = !1, this.aabb = math.collapseAABB3() } createPortion(e) { var t = e.meshMatrix, i = e.worldMatrix, s = e.aabb; e = e.pickColor; if (this._finalized) throw "Already finalized"; this.model.scene.entityOffsetsEnabled && (this._offsets.push(0), this._offsets.push(0), this._offsets.push(0)), this._modelMatrixCol0.push(t[0]), this._modelMatrixCol0.push(t[4]), this._modelMatrixCol0.push(t[8]), this._modelMatrixCol0.push(t[12]), this._modelMatrixCol1.push(t[1]), this._modelMatrixCol1.push(t[5]), this._modelMatrixCol1.push(t[9]), this._modelMatrixCol1.push(t[13]), this._modelMatrixCol2.push(t[2]), this._modelMatrixCol2.push(t[6]), this._modelMatrixCol2.push(t[10]), this._modelMatrixCol2.push(t[14]), this._pickColors.push(e[0]), this._pickColors.push(e[1]), this._pickColors.push(e[2]), this._pickColors.push(e[3]), math.collapseAABB3(s); var r = this._state.obb, a = r.length; for (let e = 0; e < a; e += 4)tempVec4a$5[0] = r[e + 0], tempVec4a$5[1] = r[e + 1], tempVec4a$5[2] = r[e + 2], math.transformPoint4(t, tempVec4a$5, tempVec4b$5), i ? (math.transformPoint4(i, tempVec4b$5, tempVec4c$2), math.expandAABB3Point3(s, tempVec4c$2)) : math.expandAABB3Point3(s, tempVec4b$5); return this._state.origin && (e = this._state.origin, s[0] += e[0], s[1] += e[1], s[2] += e[2], s[3] += e[0], s[4] += e[1], s[5] += e[2]), math.expandAABB3(this.aabb, s), this._state.numInstances++, e = this._portions.length, this._portions.push({}), this._numPortions++, this.model.numPortions++, e } finalize() { if (this._finalized) throw "Already finalized"; var e = this.model.scene.canvas.gl, t = this._pickColors.length; 0 < t && (this._state.flagsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(t), t, 4, e.DYNAMIC_DRAW, !1), this._state.flags2Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(t), t, 4, e.DYNAMIC_DRAW, !0)), this.model.scene.entityOffsetsEnabled && 0 < this._offsets.length && (this._state.offsetsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._offsets), this._offsets.length, 3, e.DYNAMIC_DRAW, !1), this._offsets = []), 0 < this._modelMatrixCol0.length && (this._state.modelMatrixCol0Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol0), this._modelMatrixCol0.length, 4, e.STATIC_DRAW, !1), this._state.modelMatrixCol1Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol1), this._modelMatrixCol1.length, 4, e.STATIC_DRAW, !1), this._state.modelMatrixCol2Buf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this._modelMatrixCol2), this._modelMatrixCol2.length, 4, e.STATIC_DRAW, !1), this._modelMatrixCol0 = [], this._modelMatrixCol1 = [], this._modelMatrixCol2 = []), 0 < this._pickColors.length && (this._state.pickColorsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Uint8Array(this._pickColors), this._pickColors.length, 4, e.STATIC_DRAW, !1), this._pickColors = []), this._finalized = !0 } initFlags(e, t, i) { t & ENTITY_FLAGS.VISIBLE && (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++), t & ENTITY_FLAGS.HIGHLIGHTED && (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++), t & ENTITY_FLAGS.XRAYED && (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++), t & ENTITY_FLAGS.SELECTED && (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++), t & ENTITY_FLAGS.CLIPPABLE && (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++), t & ENTITY_FLAGS.EDGES && (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++), t & ENTITY_FLAGS.PICKABLE && (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++), t & ENTITY_FLAGS.CULLED && (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++), i && (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++), this._setFlags(e, t, i), this._setFlags2(e, t) } setVisible(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.VISIBLE ? (this._numVisibleLayerPortions++, this.model.numVisibleLayerPortions++) : (this._numVisibleLayerPortions--, this.model.numVisibleLayerPortions--), this._setFlags(e, t, i) } setHighlighted(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.HIGHLIGHTED ? (this._numHighlightedLayerPortions++, this.model.numHighlightedLayerPortions++) : (this._numHighlightedLayerPortions--, this.model.numHighlightedLayerPortions--), this._setFlags(e, t, i) } setXRayed(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.XRAYED ? (this._numXRayedLayerPortions++, this.model.numXRayedLayerPortions++) : (this._numXRayedLayerPortions--, this.model.numXRayedLayerPortions--), this._setFlags(e, t, i) } setSelected(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.SELECTED ? (this._numSelectedLayerPortions++, this.model.numSelectedLayerPortions++) : (this._numSelectedLayerPortions--, this.model.numSelectedLayerPortions--), this._setFlags(e, t, i) } setEdges(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.EDGES ? (this._numEdgesLayerPortions++, this.model.numEdgesLayerPortions++) : (this._numEdgesLayerPortions--, this.model.numEdgesLayerPortions--), this._setFlags(e, t, i) } setClippable(e, t) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CLIPPABLE ? (this._numClippableLayerPortions++, this.model.numClippableLayerPortions++) : (this._numClippableLayerPortions--, this.model.numClippableLayerPortions--), this._setFlags2(e, t) } setCollidable(e, t) { if (!this._finalized) throw "Not finalized" } setPickable(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.PICKABLE ? (this._numPickableLayerPortions++, this.model.numPickableLayerPortions++) : (this._numPickableLayerPortions--, this.model.numPickableLayerPortions--), this._setFlags2(e, t, i) } setCulled(e, t, i) { if (!this._finalized) throw "Not finalized"; t & ENTITY_FLAGS.CULLED ? (this._numCulledLayerPortions++, this.model.numCulledLayerPortions++) : (this._numCulledLayerPortions--, this.model.numCulledLayerPortions--), this._setFlags(e, t, i) } setColor(e, t) { if (!this._finalized) throw "Not finalized"; tempUint8Vec4[0] = t[0], tempUint8Vec4[1] = t[1], tempUint8Vec4[2] = t[2], this._state.colorsBuf.setData(tempUint8Vec4, 3 * e, 3) } setTransparent(e, t, i) { i ? (this._numTransparentLayerPortions++, this.model.numTransparentLayerPortions++) : (this._numTransparentLayerPortions--, this.model.numTransparentLayerPortions--), this._setFlags(e, t, i) } _setFlags(e, t, i) { if (!this._finalized) throw "Not finalized"; var s, r = !!(t & ENTITY_FLAGS.VISIBLE), a = !!(t & ENTITY_FLAGS.XRAYED), o = !!(t & ENTITY_FLAGS.HIGHLIGHTED), n = !!(t & ENTITY_FLAGS.SELECTED), h = !!(t & ENTITY_FLAGS.EDGES), l = !!(t & ENTITY_FLAGS.PICKABLE), c = (t = !!(t & ENTITY_FLAGS.CULLED), !r || t || a || o && !this.model.scene.highlightMaterial.glowThrough || n && !this.model.scene.selectedMaterial.glowThrough ? RENDER_PASSES.NOT_RENDERED : i ? RENDER_PASSES.COLOR_TRANSPARENT : RENDER_PASSES.COLOR_OPAQUE); s = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.SILHOUETTE_SELECTED : o ? RENDER_PASSES.SILHOUETTE_HIGHLIGHTED : a ? RENDER_PASSES.SILHOUETTE_XRAYED : RENDER_PASSES.NOT_RENDERED, o = !r || t ? RENDER_PASSES.NOT_RENDERED : n ? RENDER_PASSES.EDGES_SELECTED : o ? RENDER_PASSES.EDGES_HIGHLIGHTED : a ? RENDER_PASSES.EDGES_XRAYED : h ? i ? RENDER_PASSES.EDGES_COLOR_TRANSPARENT : RENDER_PASSES.EDGES_COLOR_OPAQUE : RENDER_PASSES.NOT_RENDERED, n = r && !t && l ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED; tempUint8Vec4[0] = c, tempUint8Vec4[1] = s, tempUint8Vec4[2] = o, tempUint8Vec4[3] = n, this._state.flagsBuf.setData(tempUint8Vec4, 4 * e, 4) } _setFlags2(e, t) { if (!this._finalized) throw "Not finalized"; t = t & ENTITY_FLAGS.CLIPPABLE ? 255 : 0, tempUint8Vec4[0] = t, this._state.flags2Buf.setData(tempUint8Vec4, 4 * e, 4) } setOffset(e, t) { if (!this._finalized) throw "Not finalized"; this.model.scene.entityOffsetsEnabled ? (tempVec3fa[0] = t[0], tempVec3fa[1] = t[1], tempVec3fa[2] = t[2], this._state.offsetsBuf.setData(tempVec3fa, 3 * e, 3)) : this.model.error("Entity#offset not enabled for this Viewer") } drawColorOpaque(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._numTransparentLayerPortions !== this._numPortions && this._numXRayedLayerPortions !== this._numPortions && this._pointsInstancingRenderers.colorRenderer && this._pointsInstancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawColorTransparent(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numTransparentLayerPortions && this._numXRayedLayerPortions !== this._numPortions && this._pointsInstancingRenderers.colorRenderer && this._pointsInstancingRenderers.colorRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_TRANSPARENT) } drawDepth(e, t) { } drawNormals(e, t) { } drawSilhouetteXRayed(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numXRayedLayerPortions && this._pointsInstancingRenderers.silhouetteRenderer && this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_XRAYED) } drawSilhouetteHighlighted(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numHighlightedLayerPortions && this._pointsInstancingRenderers.silhouetteRenderer && this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) } drawSilhouetteSelected(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && 0 !== this._numSelectedLayerPortions && this._pointsInstancingRenderers.silhouetteRenderer && this._pointsInstancingRenderers.silhouetteRenderer.drawLayer(t, this, RENDER_PASSES.SILHOUETTE_SELECTED) } drawEdgesColorOpaque(e, t) { } drawEdgesColorTransparent(e, t) { } drawEdgesHighlighted(e, t) { } drawEdgesSelected(e, t) { } drawEdgesXRayed(e, t) { } drawOcclusion(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsInstancingRenderers.occlusionRenderer && this._pointsInstancingRenderers.occlusionRenderer.drawLayer(t, this, RENDER_PASSES.COLOR_OPAQUE) } drawShadow(e, t) { } drawPickMesh(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsInstancingRenderers.pickMeshRenderer && this._pointsInstancingRenderers.pickMeshRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickDepths(e, t) { this._numCulledLayerPortions !== this._numPortions && 0 !== this._numVisibleLayerPortions && this._pointsInstancingRenderers.pickDepthRenderer && this._pointsInstancingRenderers.pickDepthRenderer.drawLayer(t, this, RENDER_PASSES.PICK) } drawPickNormals(e, t) { } destroy() { var e = this._state; e.colorsBuf && (e.colorsBuf.destroy(), e.colorsBuf = null), e.flagsBuf && (e.flagsBuf.destroy(), e.flagsBuf = null), e.flags2Buf && (e.flags2Buf.destroy(), e.flags2Buf = null), e.offsetsBuf && (e.offsetsBuf.destroy(), e.offsetsBuf = null), e.modelMatrixCol0Buf && (e.modelMatrixCol0Buf.destroy(), e.modelMatrixCol0Buf = null), e.modelMatrixCol1Buf && (e.modelMatrixCol1Buf.destroy(), e.modelMatrixCol1Buf = null), e.modelMatrixCol2Buf && (e.modelMatrixCol2Buf.destroy(), e.modelMatrixCol2Buf = null), e.pickColorsBuf && (e.pickColorsBuf.destroy(), e.pickColorsBuf = null), e.destroy() } } class VBOSceneModelTextureSet { constructor(e) { this.id = e.id, this.colorTexture = e.colorTexture, this.metallicRoughnessTexture = e.metallicRoughnessTexture, this.normalsTexture = e.normalsTexture, this.emissiveTexture = e.emissiveTexture, this.occlusionTexture = e.occlusionTexture } destroy() { } } class VBOSceneModelGeometry { constructor(e, t, i) { this.id = i.id, this.model = i.model, this.primitive = i.primitive, this.positions = null, this.positionsCompressed = null, this.quantizedPositions = null, this.positionsDecodeMatrix = math.mat4(), this.normals = null, this.normalsCompressed = null, this.colors = null, this.colorsCompressed = null, this.uv = null, this.uvCompressed = null, this.uvDecodeMatrix = null, this.indices = null, this.numIndices = 0, this.obb = math.OBB3(), this.positionsBuf = null, this.normalsBuf = null, this.edgeIndicesBuf = null, this.uvBuf = null, this.colorsBuf = null; var s, r = t.scene.pickSurfacePrecisionEnabled; t = t.scene.canvas.gl; if (i.positionsCompressed && 0 < i.positionsCompressed.length ? (this.positionsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, i.positionsCompressed, i.positionsCompressed.length, 3, t.STATIC_DRAW, !1), this.positionsDecodeMatrix.set(i.positionsDecodeMatrix), s = math.collapseAABB3(), math.expandAABB3Points3(s, i.positionsCompressed), geometryCompressionUtils.decompressAABB(s, this.positionsDecodeMatrix), math.AABB3ToOBB3(s, this.obb), r && (this.quantizedPositions = i.positionsCompressed)) : i.positions && 0 < i.positions.length && (s = i.positions.length, a = math.collapseAABB3(), math.expandAABB3Points3(a, i.positions), math.AABB3ToOBB3(a, this.obb), a = quantizePositions(i.positions, a, this.positionsDecodeMatrix), this.positionsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, a, s, 3, t.STATIC_DRAW, !1), r) && (this.quantizedPositions = a), i.normalsCompressed && 0 < i.normalsCompressed.length ? this.normalsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, i.normalsCompressed, i.normalsCompressed.length, 3, t.STATIC_DRAW, !0) : i.normals && 0 < i.normals.length && (s = octEncodeNormals(i.normals), this.normalsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, s, s.length, 3, t.STATIC_DRAW, !0)), i.colorsCompressed && 0 < i.colorsCompressed.length) { var a = new Uint8Array(i.colorsCompressed); this.colorsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, a, a.length, 4, t.STATIC_DRAW, !1) } else if (i.colors && 0 < i.colors.length) { var o = i.colors, n = new Uint8Array(o.length); for (let e = 0, t = o.length; e < t; e++)n[e] = 255 * o[e]; this.colorsBuf = new ArrayBuf(t, t.ARRAY_BUFFER, n, n.length, 4, t.STATIC_DRAW, !1) } i.uvCompressed && 0 < i.uvCompressed.length ? (s = new Uint16Array(i.uvCompressed), this.uvDecodeMatrix = math.mat4(i.uvDecodeMatrix), this.uvBuf = new ArrayBuf(t, t.ARRAY_BUFFER, i.uvCompressed, s.length, 2, t.STATIC_DRAW, !1)) : i.uv && 0 < i.uv.length && (a = geometryCompressionUtils.getUVBounds(i.uv), a = (s = geometryCompressionUtils.compressUVs(i.uv, a.min, a.max)).quantized, this.uvDecodeMatrix = s.decodeMatrix, this.uvBuf = new ArrayBuf(t, t.ARRAY_BUFFER, a, a.length, 2, t.STATIC_DRAW, !1)), i.indices && 0 < i.indices.length && (this.indicesBuf = new ArrayBuf(t, t.ELEMENT_ARRAY_BUFFER, new Uint32Array(i.indices), i.indices.length, 1, t.STATIC_DRAW), r && (this.indices = i.indices), this.numIndices = i.indices.length), "triangles" !== i.primitive && "solid" !== i.primitive && "surface" !== i.primitive || (s = (s = i.edgeIndices) || buildEdgeIndices(i.positions, i.indices, null, i.edgeThreshold || 10), this.edgeIndicesBuf = new ArrayBuf(t, t.ELEMENT_ARRAY_BUFFER, new Uint32Array(s), s.length, 1, t.STATIC_DRAW)) } destroy() { } } class VBOSceneModelTexture { constructor(e) { this.id = e.id, this.texture = e.texture } destroy() { this.texture && (this.texture.destroy(), this.texture = null) } } const Cache = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class LoadingManager { constructor(e, t, i) { this.isLoading = !1, this.itemsLoaded = 0, this.itemsTotal = 0, this.urlModifier = void 0, this.handlers = [], this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i } itemStart(e) { this.itemsTotal++, !1 === this.isLoading && void 0 !== this.onStart && this.onStart(e, this.itemsLoaded, this.itemsTotal), this.isLoading = !0 } itemEnd(e) { this.itemsLoaded++, void 0 !== this.onProgress && this.onProgress(e, this.itemsLoaded, this.itemsTotal), this.itemsLoaded === this.itemsTotal && (this.isLoading = !1, void 0 !== this.onLoad) && this.onLoad() } itemError(e) { void 0 !== this.onError && this.onError(e) } resolveURL(e) { return this.urlModifier ? this.urlModifier(e) : e } setURLModifier(e) { return this.urlModifier = e, this } addHandler(e, t) { return this.handlers.push(e, t), this } removeHandler(e) { return -1 !== (e = this.handlers.indexOf(e)) && this.handlers.splice(e, 2), this } getHandler(e) { for (let s = 0, r = this.handlers.length; s < r; s += 2) { var t = this.handlers[s], i = this.handlers[s + 1]; if (t.global && (t.lastIndex = 0), t.test(e)) return i } return null } } const DefaultLoadingManager = new LoadingManager; class Loader { constructor(e) { this.manager = void 0 !== e ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const i = this; return new Promise((function (s, r) { i.load(e, s, t, r) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const loading = {}; class FileLoader extends Loader { constructor(e) { super(e) } load(e, t, i, s) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = Cache.get(e); if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => { t && t(r), this.manager.itemEnd(e) }), 0), r; if (void 0 !== loading[e]) loading[e].push({ onLoad: t, onProgress: i, onError: s }); else { loading[e] = [], loading[e].push({ onLoad: t, onProgress: i, onError: s }), i = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }); const r = this.mimeType, a = this.responseType; fetch(i).then((t => { if (200 !== t.status && 0 !== t.status) throw Error(`fetch for "${t.url}" responded with ${t.status}: ` + t.statusText); { if (0 === t.status && console.warn("FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body.getReader) return t; const i = loading[e], s = t.body.getReader(), r = (t = t.headers.get("Content-Length")) ? parseInt(t) : 0, a = 0 !== r; let o = 0; return t = new ReadableStream({ start(e) { !function t() { s.read().then((({ done: s, value: n }) => { if (s) e.close(); else { o += n.byteLength; var h = new ProgressEvent("progress", { lengthComputable: a, loaded: o, total: r }); for (let e = 0, t = i.length; e < t; e++) { var l = i[e]; l.onProgress && l.onProgress(h) } e.enqueue(n), t() } })) }() } }), new Response(t) } })).then((e => { switch (a) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then((e => (new DOMParser).parseFromString(e, r))); case "json": return e.json(); default: if (void 0 === r) return e.text(); { var t = (t = /charset="?([^;"\s]*)"?/i.exec(r)) && t[1] ? t[1].toLowerCase() : void 0; const i = new TextDecoder(t); return e.arrayBuffer().then((e => i.decode(e))) } } })).then((t => { Cache.add(e, t); var i = loading[e]; delete loading[e]; for (let e = 0, r = i.length; e < r; e++) { var s = i[e]; s.onLoad && s.onLoad(t) } })).catch((t => { var i = loading[e]; if (void 0 === i) throw this.manager.itemError(e), t; delete loading[e]; for (let e = 0, r = i.length; e < r; e++) { var s = i[e]; s.onError && s.onError(t) } this.manager.itemError(e) })).finally((() => { this.manager.itemEnd(e) })), this.manager.itemStart(e) } } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class WorkerPool$1 { constructor(e = 4) { this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0 } _initWorker(e) { var t; this.workers[e] || ((t = this.workerCreator()).addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t) } _getIdleWorker() { for (let e = 0; e < this.pool; e++)if (!(this.workerStatus & 1 << e)) return e; return -1 } _onMessage(e, t) { const i = this.workersResolve[e]; if (i && i(t), this.queue.length) { const { resolve: t, msg: i, transfer: s } = this.queue.shift(); this.workersResolve[e] = t, this.workers[e].postMessage(i, s) } else this.workerStatus ^= 1 << e } setWorkerCreator(e) { this.workerCreator = e } setWorkerLimit(e) { this.pool = e } postMessage(e, t) { return new Promise((i => { var s = this._getIdleWorker(); -1 !== s ? (this._initWorker(s), this.workerStatus |= 1 << s, this.workersResolve[s] = i, this.workers[s].postMessage(e, t)) : this.queue.push({ resolve: i, msg: e, transfer: t }) })) } destroy() { this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } const KTX2TransferSRGB = 2, KTX2_ALPHA_PREMULTIPLIED = 1; let activeTranscoders = 0; class KTX2TextureTranscoder { constructor({ viewer: e, transcoderPath: t, workerLimit: i }) { this._transcoderPath = t || "https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk/dist/basis/", this._transcoderBinary = null, this._transcoderPending = null, this._workerPool = new WorkerPool$1, this._workerSourceURL = "", i && this._workerPool.setWorkerLimit(i), t = e.capabilities, this._workerConfig = { astcSupported: t.astcSupported, etc1Supported: t.etc1Supported, etc2Supported: t.etc2Supported, dxtSupported: t.dxtSupported, bptcSupported: t.bptcSupported, pvrtcSupported: t.pvrtcSupported }, this._supportedFileTypes = ["xkt2"] } _init() { var e, t; return this._transcoderPending || ((e = new FileLoader).setPath(this._transcoderPath), e.setWithCredentials(this.withCredentials), e = e.loadAsync("basis_transcoder.js"), (t = new FileLoader).setPath(this._transcoderPath), t.setResponseType("arraybuffer"), t.setWithCredentials(this.withCredentials), t = t.loadAsync("basis_transcoder.wasm"), this._transcoderPending = Promise.all([e, t]).then((([e, t]) => { var i = KTX2TextureTranscoder.BasisWorker.toString(); e = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2TextureTranscoder.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2TextureTranscoder.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2TextureTranscoder.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n"); this._workerSourceURL = URL.createObjectURL(new Blob([e])), this._transcoderBinary = t, this._workerPool.setWorkerCreator((() => { var e = new Worker(this._workerSourceURL), t = this._transcoderBinary.slice(0); return e.postMessage({ type: "init", config: this._workerConfig, transcoderBinary: t }, [t]), e })) })), 0 < activeTranscoders && console.warn("KTX2TextureTranscoder: Multiple active KTX2TextureTranscoder may cause performance issues. Use a single KTX2TextureTranscoder instance, or call .dispose() on old instances."), activeTranscoders++), this._transcoderPending } transcode(e, t, i = {}) { return new Promise(((s, r) => { const a = i; this._init().then((() => this._workerPool.postMessage({ type: "transcode", buffers: e, taskConfig: a }, e))).then((e => { var { mipmaps: e, format: i, type: a, error: o, dfdTransferFn: n, dfdFlags: h } = e.data; if ("error" === a) return r(o); t.setCompressedData({ mipmaps: e, props: { format: i, minFilter: 1 === e.length ? LinearFilter : 1008, magFilter: 1 === e.length ? LinearFilter : 1008, encoding: 2 === n ? sRGBEncoding : 3e3, premultiplyAlpha: !!(1 & h) } }), s() })) })) } destroy() { URL.revokeObjectURL(this._workerSourceURL), this._workerPool.destroy(), activeTranscoders-- } } KTX2TextureTranscoder.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, KTX2TextureTranscoder.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, KTX2TextureTranscoder.EngineFormat = { RGBAFormat: 1023, RGBA_ASTC_4x4_Format: 37808, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776 }, KTX2TextureTranscoder.BasisWorker = function () { let e, t, i; const s = _EngineFormat, r = _TranscoderFormat, a = _BasisFormat; self.addEventListener("message", (function (o) { const c = o.data; switch (c.type) { case "init": e = c.config, u = c.transcoderBinary, t = new Promise((e => { i = { wasmBinary: u, onRuntimeInitialized: e }, BASIS(i) })).then((() => { i.initializeBasis(), void 0 === i.KTX2File && console.warn("KTX2TextureTranscoder: Please update Basis Universal transcoder.") })); break; case "transcode": t.then((() => { try { var { width: t, height: o, hasAlpha: u, mipmaps: p, format: d, dfdTransferFn: m, dfdFlags: f } = function (t) { const o = new i.KTX2File(new Uint8Array(t)); function c() { o.close(), o.delete() } if (!o.isValid()) throw c(), new Error("KTX2TextureTranscoder: Invalid or unsupported .ktx2 file"); t = o.isUASTC() ? a.UASTC_4x4 : a.ETC1S; var u = o.getWidth(), p = o.getHeight(), d = o.getLevels(), m = o.getHasAlpha(), f = o.getDFDTransferFunc(), g = o.getDFDFlags(), { transcoderFormat: _, engineFormat: t } = function (t, i, o, c) { let u, p; var d = t === a.ETC1S ? n : h; for (let s = 0; s < d.length; s++) { var m = d[s]; if (e[m.if] && m.basisFormat.includes(t) && !(c && m.transcoderFormat.length < 2) && (!m.needsPowerOfTwo || l(i) && l(o))) return u = m.transcoderFormat[c ? 1 : 0], p = m.engineFormat[c ? 1 : 0], { transcoderFormat: u, engineFormat: p } } return console.warn("KTX2TextureTranscoder: No suitable compressed texture format found. Decoding to RGBA32."), u = r.RGBA32, p = s.RGBAFormat, { transcoderFormat: u, engineFormat: p } }(t, u, p, m); if (!u || !p || !d) throw c(), new Error("KTX2TextureTranscoder: Invalid texture"); if (!o.startTranscoding()) throw c(), new Error("KTX2TextureTranscoder: .startTranscoding failed"); var v = []; for (let e = 0; e < d; e++) { var y = (T = o.getImageLevelInfo(e, 0, 0)).origWidth, T = T.origHeight, I = new Uint8Array(o.getImageTranscodedSizeInBytes(e, 0, 0, _)); if (!o.transcodeImage(I, e, 0, 0, _, 0, -1, -1)) throw c(), new Error("KTX2TextureTranscoder: .transcodeImage failed."); v.push({ data: I, width: y, height: T }) } return c(), { width: u, height: p, hasAlpha: m, mipmaps: v, format: t, dfdTransferFn: f, dfdFlags: g } }(c.buffers[0]), g = []; for (let e = 0; e < p.length; ++e)g.push(p[e].data.buffer); self.postMessage({ type: "transcode", id: c.id, width: t, height: o, hasAlpha: u, mipmaps: p, format: d, dfdTransferFn: m, dfdFlags: f }, g) } catch (t) { console.error("[KTX2TextureTranscoder.BasisWorker]: " + t), self.postMessage({ type: "error", id: c.id, error: t.message }) } })) }var u })); var o = [{ if: "astcSupported", basisFormat: [a.UASTC_4x4], transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4], engineFormat: [s.RGBA_ASTC_4x4_Format, s.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [a.ETC1S, a.UASTC_4x4], transcoderFormat: [r.BC7_M5, r.BC7_M5], engineFormat: [s.RGBA_BPTC_Format, s.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [a.ETC1S, a.UASTC_4x4], transcoderFormat: [r.BC1, r.BC3], engineFormat: [s.RGB_S3TC_DXT1_Format, s.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [a.ETC1S, a.UASTC_4x4], transcoderFormat: [r.ETC1, r.ETC2], engineFormat: [s.RGB_ETC2_Format, s.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [a.ETC1S, a.UASTC_4x4], transcoderFormat: [r.ETC1], engineFormat: [s.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [a.ETC1S, a.UASTC_4x4], transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA], engineFormat: [s.RGB_PVRTC_4BPPV1_Format, s.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }]; const n = o.sort((function (e, t) { return e.priorityETC1S - t.priorityETC1S })), h = o.sort((function (e, t) { return e.priorityUASTC - t.priorityUASTC })); function l(e) { return e <= 2 || !(e & e - 1) && 0 !== e } }; const cachedTranscoders = {}; function getKTX2TextureTranscoder(e) { const t = e.scene.id; let i = cachedTranscoders[t]; return i || (i = new KTX2TextureTranscoder({ viewer: e }), cachedTranscoders[t] = i, e.scene.on("destroyed", (() => { delete cachedTranscoders[t], i.destroy() }))), i } const tempVec3a$b = math.vec3(), tempMat4$1 = math.mat4(), defaultScale = math.vec3([1, 1, 1]), defaultPosition = math.vec3([0, 0, 0]), defaultRotation = math.vec3([0, 0, 0]), defaultQuaternion = math.identityQuaternion(), defaultColorTextureId = "defaultColorTexture", defaultMetalRoughTextureId = "defaultMetalRoughTexture", defaultNormalsTextureId = "defaultNormalsTexture", defaultEmissiveTextureId = "defaultEmissiveTexture", defaultOcclusionTextureId = "defaultOcclusionTexture", defaultTextureSetId = "defaultTextureSet"; class VBOSceneModel extends Component { constructor(e, t = {}) { super(e, t), this._textureTranscoder = t.textureTranscoder || getKTX2TextureTranscoder(this.scene.viewer), this._maxGeometryBatchSize = t.maxGeometryBatchSize, this._aabb = math.collapseAABB3(), this._aabbDirty = !1, this._layerList = [], this._nodeList = [], this._lastOrigin = null, this._lastPositionsDecodeMatrix = null, this._lastNormals = null, this._instancingLayers = {}, this._currentBatchingLayers = {}, this._scratchMemory = getScratchMemory(), this._geometries = {}, this._textures = {}, this._textureSets = {}, this._meshes = {}, this._nodes = {}, this.renderFlags = new RenderFlags, this.numGeometries = 0, this.numPortions = 0, this.numVisibleLayerPortions = 0, this.numTransparentLayerPortions = 0, this.numXRayedLayerPortions = 0, this.numHighlightedLayerPortions = 0, this.numSelectedLayerPortions = 0, this.numEdgesLayerPortions = 0, this.numPickableLayerPortions = 0, this.numClippableLayerPortions = 0, this.numCulledLayerPortions = 0, this.numEntities = 0, this._numTriangles = 0, this._numLines = 0, this._numPoints = 0, this._edgeThreshold = t.edgeThreshold || 10, this._origin = math.vec3(t.origin || [0, 0, 0]), this._position = math.vec3(t.position || [0, 0, 0]), this._rotation = math.vec3(t.rotation || [0, 0, 0]), this._quaternion = math.vec4(t.quaternion || [0, 0, 0, 1]), t.rotation && math.eulerToQuaternion(this._rotation, "XYZ", this._quaternion), this._scale = math.vec3(t.scale || [1, 1, 1]), this._worldMatrix = math.mat4(), math.composeMat4(this._position, this._quaternion, this._scale, this._worldMatrix), this._worldNormalMatrix = math.mat4(), math.inverseMat4(this._worldMatrix, this._worldNormalMatrix), math.transposeMat4(this._worldNormalMatrix), (t.matrix || t.position || t.rotation || t.scale || t.quaternion) && (this._viewMatrix = math.mat4(), this._viewNormalMatrix = math.mat4(), this._viewMatrixDirty = !0, this._worldMatrixNonIdentity = !0), this._opacity = 1, this._colorize = [1, 1, 1], this._saoEnabled = !1 !== t.saoEnabled, this._pbrEnabled = !1 !== t.pbrEnabled, this._colorTextureEnabled = !1 !== t.colorTextureEnabled, this._isModel = t.isModel, this._isModel && this.scene._registerModel(this), this._onCameraViewMatrix = this.scene.camera.on("matrix", (() => { this._viewMatrixDirty = !0 })), this._createDefaultTextureSet(), this.visible = t.visible, this.culled = t.culled, this.pickable = t.pickable, this.clippable = t.clippable, this.collidable = t.collidable, this.castsShadow = t.castsShadow, this.receivesShadow = t.receivesShadow, this.xrayed = t.xrayed, this.highlighted = t.highlighted, this.selected = t.selected, this.edges = t.edges, this.colorize = t.colorize, this.opacity = t.opacity, this.backfaces = t.backfaces } _createDefaultTextureSet() { var e = new VBOSceneModelTexture({ id: "defaultColorTexture", texture: new Texture2D({ gl: this.scene.canvas.gl, preloadColor: [1, 1, 1, 1] }) }), t = new VBOSceneModelTexture({ id: "defaultMetalRoughTexture", texture: new Texture2D({ gl: this.scene.canvas.gl, preloadColor: [0, 1, 1, 1] }) }), i = new VBOSceneModelTexture({ id: "defaultNormalsTexture", texture: new Texture2D({ gl: this.scene.canvas.gl, preloadColor: [0, 0, 0, 0] }) }), s = new VBOSceneModelTexture({ id: "defaultEmissiveTexture", texture: new Texture2D({ gl: this.scene.canvas.gl, preloadColor: [0, 0, 0, 1] }) }), r = new VBOSceneModelTexture({ id: "defaultOcclusionTexture", texture: new Texture2D({ gl: this.scene.canvas.gl, preloadColor: [1, 1, 1, 1] }) }); this._textures.defaultColorTexture = e, this._textures.defaultMetalRoughTexture = t, this._textures.defaultNormalsTexture = i, this._textures.defaultEmissiveTexture = s, this._textures.defaultOcclusionTexture = r, this._textureSets.defaultTextureSet = new VBOSceneModelTextureSet({ id: "defaultTextureSet", model: this, colorTexture: e, metallicRoughnessTexture: t, normalsTexture: i, emissiveTexture: s, occlusionTexture: r }) } get isPerformanceModel() { return !0 } get objects() { return this._nodes } get origin() { return this._origin } get position() { return this._position } get rotation() { return this._rotation } get quaternion() { return this._quaternion } get scale() { return this._scale } get matrix() { return this._worldMatrix } get worldMatrix() { return this._worldMatrix } get worldNormalMatrix() { return this._worldNormalMatrix } get viewMatrix() { return this._viewMatrix ? (this._viewMatrixDirty && (math.mulMat4(this.scene.camera.viewMatrix, this._worldMatrix, this._viewMatrix), math.inverseMat4(this._viewMatrix, this._viewNormalMatrix), math.transposeMat4(this._viewNormalMatrix), this._viewMatrixDirty = !1), this._viewMatrix) : this.scene.camera.viewMatrix } get viewNormalMatrix() { return this._viewNormalMatrix ? (this._viewMatrixDirty && (math.mulMat4(this.scene.camera.viewMatrix, this._worldMatrix, this._viewMatrix), math.inverseMat4(this._viewMatrix, this._viewNormalMatrix), math.transposeMat4(this._viewNormalMatrix), this._viewMatrixDirty = !1), this._viewNormalMatrix) : this.scene.camera.viewNormalMatrix } get backfaces() { return this._backfaces } set backfaces(e) { this._backfaces = e = !!e, this.glRedraw() } get entityList() { return this._nodeList } get isEntity() { return !0 } get isModel() { return this._isModel } get isObject() { return !1 } get aabb() { return this._aabbDirty && this._rebuildAABB(), this._aabb } get numTriangles() { return this._numTriangles } get numLines() { return this._numLines } get numPoints() { return this._numPoints } get visible() { return 0 < this.numVisibleLayerPortions } set visible(e) { this._visible = e = !1 !== e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].visible = e; this.glRedraw() } get xrayed() { return 0 < this.numXRayedLayerPortions } set xrayed(e) { this._xrayed = e = !!e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].xrayed = e; this.glRedraw() } get highlighted() { return 0 < this.numHighlightedLayerPortions } set highlighted(e) { this._highlighted = e = !!e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].highlighted = e; this.glRedraw() } get selected() { return 0 < this.numSelectedLayerPortions } set selected(e) { this._selected = e = !!e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].selected = e; this.glRedraw() } get edges() { return 0 < this.numEdgesLayerPortions } set edges(e) { this._edges = e = !!e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].edges = e; this.glRedraw() } get culled() { return this._culled } set culled(e) { this._culled = e = !!e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].culled = e; this.glRedraw() } get clippable() { return this._clippable } set clippable(e) { this._clippable = e = !1 !== e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].clippable = e; this.glRedraw() } get collidable() { return this._collidable } set collidable(e) { this._collidable = e = !1 !== e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].collidable = e } get pickable() { return 0 < this.numPickableLayerPortions } set pickable(e) { this._pickable = e = !1 !== e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].pickable = e } get colorize() { return this._colorize } set colorize(e) { this._colorize = e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].colorize = e } get opacity() { return this._opacity } set opacity(e) { this._opacity = e; for (let t = 0, i = this._nodeList.length; t < i; t++)this._nodeList[t].opacity = e } get castsShadow() { return this._castsShadow } set castsShadow(e) { (e = !1 !== e) !== this._castsShadow && (this._castsShadow = e, this.glRedraw()) } get receivesShadow() { return this._receivesShadow } set receivesShadow(e) { (e = !1 !== e) !== this._receivesShadow && (this._receivesShadow = e, this.glRedraw()) } get saoEnabled() { return this._saoEnabled } get pbrEnabled() { return this._pbrEnabled } get colorTextureEnabled() { return this._colorTextureEnabled } get isDrawable() { return !0 } get isStateSortable() { return !1 } get xrayMaterial() { return this.scene.xrayMaterial } get highlightMaterial() { return this.scene.highlightMaterial } get selectedMaterial() { return this.scene.selectedMaterial } get edgeMaterial() { return this.scene.edgeMaterial } getPickViewMatrix(e) { return this._viewMatrix || e } createGeometry(e) { var t = e.id; if (null == t) this.error("Config missing: id"); else if (this._geometries[t]) this.error("Geometry already created: " + t); else { var i, s = e.primitive; if (null == s) this.error("Param expected: primitive"); else { if ("points" === s || "lines" === s || "triangles" === s || "solid" === s || "surface" === s) return e.positions || e.positionsCompressed ? e.positionsCompressed && !e.positionsDecodeMatrix ? (this.error("Param expected: `positionsDecodeMatrix` (required for `positionsCompressed')"), null) : e.uvCompressed && !e.uvDecodeMatrix ? (this.error("Param expected: `uvDecodeMatrix` (required for `uvCompressed')"), null) : e.indices || "points" === s ? (i = new VBOSceneModelGeometry(t, this, e), this._geometries[t] = i, this._numTriangles += e.indices ? Math.round(e.indices.length / 3) : 0, void this.numGeometries++) : (this.error(`Param expected: indices (required for '${s}' primitive type)`), null) : (this.error("Param expected: `positions` or `positionsCompressed'"), null); this.error(`Unsupported value for 'primitive': '${s}' - supported values are 'points', 'lines', 'triangles', 'solid' and 'surface'. Defaulting to 'triangles'.`) } } } createTexture(e) { var t = e.id; if (null == t) this.error("Config missing: id"); else if (this._textures[t]) this.error("Texture already created: " + t); else { if (!e.src && !e.image && !e.buffers) return this.error("Param expected: `src`, `image' or 'buffers'"), null; let r = e.minFilter || 1008, a = (r !== LinearFilter && r !== LinearMipMapNearestFilter && 1008 !== r && r !== NearestMipMapLinearFilter && r !== NearestMipMapNearestFilter && (this.error("[createTexture] Unsupported value for 'minFilter' - \n            supported values are LinearFilter, LinearMipMapNearestFilter, NearestMipMapNearestFilter, \n            NearestMipMapLinearFilter and LinearMipmapLinearFilter. Defaulting to LinearMipmapLinearFilter."), r = 1008), e.magFilter || LinearFilter), o = (a !== LinearFilter && a !== NearestFilter && (this.error("[createTexture] Unsupported value for 'magFilter' - supported values are LinearFilter and NearestFilter. Defaulting to LinearFilter."), a = LinearFilter), e.wrapS || RepeatWrapping), n = (o !== ClampToEdgeWrapping && o !== MirroredRepeatWrapping && o !== RepeatWrapping && (this.error("[createTexture] Unsupported value for 'wrapS' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping."), o = RepeatWrapping), e.wrapT || RepeatWrapping), h = (n !== ClampToEdgeWrapping && n !== MirroredRepeatWrapping && n !== RepeatWrapping && (this.error("[createTexture] Unsupported value for 'wrapT' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping."), n = RepeatWrapping), e.wrapR || RepeatWrapping), l = (h !== ClampToEdgeWrapping && h !== MirroredRepeatWrapping && h !== RepeatWrapping && (this.error("[createTexture] Unsupported value for 'wrapR' - supported values are ClampToEdgeWrapping, MirroredRepeatWrapping and RepeatWrapping. Defaulting to RepeatWrapping."), h = RepeatWrapping), e.encoding || 3e3); 3e3 !== l && l !== sRGBEncoding && (this.error("[createTexture] Unsupported value for 'encoding' - supported values are LinearEncoding and sRGBEncoding. Defaulting to LinearEncoding."), l = 3e3); const c = new Texture2D({ gl: this.scene.canvas.gl, minFilter: r, magFilter: a, wrapS: o, wrapT: n, wrapR: h, encoding: l }); if (e.preloadColor && c.setPreloadColor(e.preloadColor), e.image) { var i = e.image; i.crossOrigin = "Anonymous", c.setImage(i, { minFilter: r, magFilter: a, wrapS: o, wrapT: n, wrapR: h, flipY: e.flipY, encoding: l }) } else if (e.src) { var s = e.src.split(".").pop(); switch (s) { case "jpeg": case "jpg": case "png": case "gif": const t = new Image; t.onload = () => { c.setImage(t, { minFilter: r, magFilter: a, wrapS: o, wrapT: n, wrapR: h, flipY: e.flipY, encoding: l }), this.glRedraw() }, t.src = e.src; break; default: this._textureTranscoder ? utils.loadArraybuffer(e.src, (e => { e.byteLength ? this._textureTranscoder.transcode([e], c).then((() => { this.glRedraw() })) : this.error("Can't create texture from 'src': file data is zero length") }), (function (e) { this.error("Can't create texture from 'src': " + e) })) : this.error(`Can't create texture from 'src' - VBOSceneModel needs to be configured with a TextureTranscoder for this file type ('${s}')`) } } else e.buffers && (this._textureTranscoder ? this._textureTranscoder.transcode(e.buffers, c).then((() => { this.glRedraw() })) : this.error("Can't create texture from 'buffers' - VBOSceneModel needs to be configured with a TextureTranscoder for this option")); this._textures[t] = new VBOSceneModelTexture({ id: t, texture: c }) } } createTextureSet(e) { var t = e.id; if (null == t) this.error("Config missing: id"); else if (this._textureSets[t]) this.error("Texture set already created: " + t); else { let i, s, r, a, o; if (void 0 !== e.colorTextureId && null !== e.colorTextureId) { if (!(i = this._textures[e.colorTextureId])) return void this.error(`Texture not found: ${e.colorTextureId} - ensure that you create it first with createTexture()`) } else i = this._textures.defaultColorTexture; if (void 0 !== e.metallicRoughnessTextureId && null !== e.metallicRoughnessTextureId) { if (!(s = this._textures[e.metallicRoughnessTextureId])) return void this.error(`Texture not found: ${e.metallicRoughnessTextureId} - ensure that you create it first with createTexture()`) } else s = this._textures.defaultMetalRoughTexture; if (void 0 !== e.normalsTextureId && null !== e.normalsTextureId) { if (!(r = this._textures[e.normalsTextureId])) return void this.error(`Texture not found: ${e.normalsTextureId} - ensure that you create it first with createTexture()`) } else r = this._textures.defaultNormalsTexture; if (void 0 !== e.emissiveTextureId && null !== e.emissiveTextureId) { if (!(a = this._textures[e.emissiveTextureId])) return void this.error(`Texture not found: ${e.emissiveTextureId} - ensure that you create it first with createTexture()`) } else a = this._textures.defaultEmissiveTexture; if (void 0 !== e.occlusionTextureId && null !== e.occlusionTextureId) { if (!(o = this._textures[e.occlusionTextureId])) return void this.error(`Texture not found: ${e.occlusionTextureId} - ensure that you create it first with createTexture()`) } else o = this._textures.defaultOcclusionTexture; e = new VBOSceneModelTextureSet({ id: t, model: this, colorTexture: i, metallicRoughnessTexture: s, normalsTexture: r, emissiveTexture: a, occlusionTexture: o }), this._textureSets[t] = e } } createMesh(e) { var t = e.id; if (null == t) this.error("Config missing: id"); else if (this._meshes[t]) this.error("VBOSceneModel already has a mesh with this ID: " + t); else { var i = e.geometryId; if ((m = void 0 !== e.geometryId) && !this._geometries[e.geometryId]) this.error(`Geometry not found: ${e.geometryId} - ensure that you create it first with createGeometry()`); else { var s = e.textureSetId || "defaultTextureSet"; if (s && !this._textureSets[s]) this.error(`Texture set not found: ${s} - ensure that you create it first with createTextureSet()`); else { let A; var r = e.color ? new Uint8Array([Math.floor(255 * e.color[0]), Math.floor(255 * e.color[1]), Math.floor(255 * e.color[2])]) : [255, 255, 255], a = void 0 !== e.opacity && null !== e.opacity ? Math.floor(255 * e.opacity) : 255, o = void 0 !== e.metallic && null !== e.metallic ? Math.floor(255 * e.metallic) : 0, n = void 0 !== e.roughness && null !== e.roughness ? Math.floor(255 * e.roughness) : 255, h = new VBOSceneModelMesh(this, t, r, a), l = h.pickId, c = new Uint8Array([255 & l, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255]), u = math.collapseAABB3(); let D; if (m) { l = this._worldMatrixNonIdentity ? this._worldMatrix : null; var p = e.matrix || (m = e.scale || defaultScale, d = e.position || defaultPosition, f = e.rotation || defaultRotation, math.eulerToQuaternion(f, "XYZ", defaultQuaternion), math.composeMat4(d, defaultQuaternion, m, tempMat4$1)), d = (f = e.origin || e.rtcCenter) ? math.addVec3(this._origin, f, tempVec3a$b) : this._origin, m = this._getInstancingLayer(d, s, i), f = (D = m, A = m.createPortion({ color: r, metallic: o, roughness: n, opacity: a, meshMatrix: p, worldMatrix: l, aabb: u, pickColor: c }), math.expandAABB3(this._aabb, u), Math.round(m.numIndices / 3)); this._numTriangles += f, h.numTriangles = f, h.origin = d } else { var g = e.primitive; if ("points" !== (g = null != g ? g : "triangles") && "lines" !== g && "triangles" !== g && "solid" !== g && "surface" !== g) return void this.error(`Unsupported value for 'primitive': '${g}'  ('geometryId' is absent) - supported values are 'points', 'lines', 'triangles', 'solid' and 'surface'.`); if (!e.positions && !e.positionsCompressed) return this.error("Param expected: 'positions' or 'positionsCompressed'  ('geometryId' is absent)"), null; if (e.positions && e.positionsCompressed) return this.error("Only one param expected, not both: 'positions' or 'positionsCompressed' ('geometryId' is absent)"), null; if (e.positionsCompressed && !e.positionsDecodeMatrix) return this.error("Param expected: 'positionsDecodeMatrix' (required for 'positionsCompressed'; 'geometryId' is absent)"), null; if (e.uvCompressed && !e.uvDecodeMatrix) return this.error("Param expected: `uvDecodeMatrix` (required for `uvCompressed'; 'geometryId' is absent)"), null; if (!e.indices && "points" !== g) return this.error(`Param expected: indices (required for '${g}' primitive type)`), null; if (!e.indices && "points" !== g) return this.error("Config expected: indices (no meshIds provided, so expecting geometry arrays instead)"), null; var _ = e.indices; let t = e.edgeIndices, p = e.origin || e.rtcCenter ? math.addVec3(this._origin, e.origin || e.rtcCenter, tempVec3a$b) : this._origin, R = e.positions, F = (R && worldToRTCPositions(R, l = [], i = math.vec3()) && (R = l, p = math.addVec3(p, i, i)), !1); if (this._lastOrigin ? math.compareVec3(this._lastOrigin, p) || (F = !0, this._lastOrigin.set(p)) : (F = !0, this._lastOrigin = math.vec3(p)), e.positionsDecodeMatrix && (this._lastPositionsDecodeMatrix ? math.compareMat4(this._lastPositionsDecodeMatrix, e.positionsDecodeMatrix) || (F = !0, this._lastPositionsDecodeMatrix.set(e.positionsDecodeMatrix)) : (F = !0, this._lastPositionsDecodeMatrix = math.mat4(e.positionsDecodeMatrix))), e.uvDecodeMatrix && (this._lastUVDecodeMatrix ? math.compareMat4(this._lastUVDecodeMatrix, e.uvDecodeMatrix) || (F = !0, this._lastUVDecodeMatrix.set(e.uvDecodeMatrix)) : (F = !0, this._lastUVDecodeMatrix = math.mat4(e.uvDecodeMatrix))), e.textureSetId && this._lastTextureSetId !== e.textureSetId && (F = !0, this._lastTextureSetId = e.textureSetId), F) { for (var v in this._currentBatchingLayers) this._currentBatchingLayers.hasOwnProperty(v) && this._currentBatchingLayers[v].finalize(); this._currentBatchingLayers = {} } var y = !!e.normals && 0 < e.normals.length; if ("triangles" === g || "solid" === g || "surface" === g) { if (null !== this._lastNormals && y !== this._lastNormals) for (var T in this._currentBatchingLayers) this._currentBatchingLayers[T] && (this._currentBatchingLayers[T].finalize(), delete this._currentBatchingLayers[T]); this._lastNormals = y } var I = this._worldMatrixNonIdentity ? this._worldMatrix : null; let w; e.positionsDecodeMatrix || (w = e.matrix || (m = e.scale || defaultScale, f = e.position || defaultPosition, d = e.rotation || defaultRotation, math.eulerToQuaternion(d, "XYZ", defaultQuaternion), math.composeMat4(f, defaultQuaternion, m, tempMat4$1))); var E = s ? this._textureSets[s] : null, C = `${g}-${e.normals && 0 < e.normals.length ? 1 : 0}-${e.normalsCompressed && 0 < e.normalsCompressed.length ? 1 : 0}-${e.colors && 0 < e.colors.length ? 1 : 0}-${e.colorsCompressed && 0 < e.colorsCompressed.length ? 1 : 0}-${e.uv && 0 < e.uv.length ? 1 : 0}-` + (e.uvCompressed && 0 < e.uvCompressed.length ? 1 : 0), P = (D = this._currentBatchingLayers[C], (R || e.positionsCompressed).length); switch (g) { case "triangles": case "solid": case "surface": D && !D.canCreatePortion(P, _.length) && (D.finalize(), delete this._currentBatchingLayers[C], D = null), D || (D = new TrianglesBatchingLayer({ model: this, textureSet: E, layerIndex: 0, scratchMemory: this._scratchMemory, positionsDecodeMatrix: e.positionsDecodeMatrix, uvDecodeMatrix: e.uvDecodeMatrix, origin: p, maxGeometryBatchSize: this._maxGeometryBatchSize, solid: "solid" === g, autoNormals: !y }), this._layerList.push(D), this._currentBatchingLayers[C] = D), t = t || buildEdgeIndices(R || e.positionsCompressed, _, null, this._edgeThreshold), A = D.createPortion({ positions: R, positionsCompressed: e.positionsCompressed, normals: e.normals, normalsCompressed: e.normalsCompressed, colors: e.colors, colorsCompressed: e.colorsCompressed, uv: e.uv, uvCompressed: e.uvCompressed, indices: _, edgeIndices: t, color: r, opacity: a, metallic: o, roughness: n, meshMatrix: w, worldMatrix: I, worldAABB: u, pickColor: c }); var b = Math.round(_.length / 3); this._numTriangles += b, h.numTriangles = b; break; case "lines": D && !D.canCreatePortion(P, _.length) && (D.finalize(), delete this._currentBatchingLayers[C], D = null), D || (D = new LinesBatchingLayer({ model: this, layerIndex: 0, scratchMemory: this._scratchMemory, positionsDecodeMatrix: e.positionsDecodeMatrix, origin: p, maxGeometryBatchSize: this._maxGeometryBatchSize }), this._layerList.push(D), this._currentBatchingLayers[C] = D), A = D.createPortion({ positions: R, positionsCompressed: e.positionsCompressed, indices: _, colors: e.colors, colorsCompressed: e.colorsCompressed, color: r, opacity: a, meshMatrix: w, worldMatrix: I, worldAABB: u, pickColor: c }), this._numLines += Math.round(_.length / 2); break; case "points": D && !D.canCreatePortion(P) && (D.finalize(), delete this._currentBatchingLayers[C], D = null), D || (D = new PointsBatchingLayer({ model: this, layerIndex: 0, scratchMemory: this._scratchMemory, positionsDecodeMatrix: e.positionsDecodeMatrix, origin: p, maxGeometryBatchSize: this._maxGeometryBatchSize }), this._layerList.push(D), this._currentBatchingLayers[C] = D), A = D.createPortion({ positions: R, positionsCompressed: e.positionsCompressed, colors: e.colors, colorsCompressed: e.colorsCompressed, color: r, opacity: a, meshMatrix: w, worldMatrix: I, worldAABB: u, pickColor: c }), this._numPoints += Math.round(P / 3) }math.expandAABB3(this._aabb, u), this.numGeometries++, h.origin = p } h.parent = null, h._layer = D, h._portionId = A, h.aabb = u, this._meshes[t] = h } } } } _getInstancingLayer(e, t, i) { var s = `${e[0]}.${e[1]}.${e[2]}.${t}.` + i; let r, a = this._instancingLayers[s]; if (a) return a; if (void 0 === t || (r = this._textureSets[t])) { var o = this._geometries[i]; if (this._geometries[i]) { switch (o.primitive) { case "triangles": case "surface": a = new TrianglesInstancingLayer({ model: this, textureSet: r, geometry: o, origin: e, layerIndex: 0, solid: !1 }); break; case "solid": a = new TrianglesInstancingLayer({ model: this, textureSet: r, geometry: o, origin: e, layerIndex: 0, solid: !0 }); break; case "lines": a = new LinesInstancingLayer({ model: this, textureSet: r, geometry: o, origin: e, layerIndex: 0 }); break; case "points": a = new PointsInstancingLayer({ model: this, textureSet: r, geometry: o, origin: e, layerIndex: 0 }) }return this._instancingLayers[s] = a, this._layerList.push(a), a } this.error(`Geometry not found: ${i} - ensure that you create it first with createGeometry()`) } else this.error(`TextureSet not found: ${t} - ensure that you create it first with createTextureSet()`) } createEntity(e) { let t = e.id; void 0 === t ? t = math.createUUID() : this.scene.components[t] && (this.error("Scene already has a Component with this ID: " + t + " - will assign random ID"), t = math.createUUID()); var i = e.meshIds; if (void 0 !== i) { var s = []; for (let e = 0, t = i.length; e < t; e++) { var r = i[e], a = this._meshes[r]; a ? a.parent ? this.error("Mesh with ID " + r + " already belongs to object with ID " + a.parent.id + " - ignoring this mesh") : s.push(a) : this.error("Mesh with this ID not found: " + r + " - ignoring this mesh") } let o, n = 0; if (this._visible && !1 !== e.visible && (n |= ENTITY_FLAGS.VISIBLE), this._pickable && !1 !== e.pickable && (n |= ENTITY_FLAGS.PICKABLE), this._culled && !1 !== e.culled && (n |= ENTITY_FLAGS.CULLED), this._clippable && !1 !== e.clippable && (n |= ENTITY_FLAGS.CLIPPABLE), this._collidable && !1 !== e.collidable && (n |= ENTITY_FLAGS.COLLIDABLE), this._edges && !1 !== e.edges && (n |= ENTITY_FLAGS.EDGES), this._xrayed && !1 !== e.xrayed && (n |= ENTITY_FLAGS.XRAYED), this._highlighted && !1 !== e.highlighted && (n |= ENTITY_FLAGS.HIGHLIGHTED), this._selected && !1 !== e.selected && (n |= ENTITY_FLAGS.SELECTED), 1 === s.length) o = s[0].aabb; else { o = math.collapseAABB3(); for (let e = 0, t = s.length; e < t; e++)math.expandAABB3(o, s[e].aabb) } return e = new VBOSceneModelNode(this, e.isObject, t, s, n, o), this._nodeList.push(e), this._nodes[t] = e, this.numEntities++, e } this.error("Config missing: meshIds") } finalize() { if (!this.destroyed) { for (const e in this._instancingLayers) this._instancingLayers.hasOwnProperty(e) && this._instancingLayers[e].finalize(); for (var e in this._currentBatchingLayers) this._currentBatchingLayers.hasOwnProperty(e) && this._currentBatchingLayers[e].finalize(); this._currentBatchingLayers = {}; for (let e = 0, t = this._nodeList.length; e < t; e++)this._nodeList[e]._finalize(); for (let e = 0, t = this._nodeList.length; e < t; e++)this._nodeList[e]._finalize2(); this._layerList.sort(((e, t) => e.sortId < t.sortId ? -1 : e.sortId > t.sortId ? 1 : 0)); for (let e = 0, t = this._layerList.length; e < t; e++)this._layerList[e].layerIndex = e; this.glRedraw(), this.scene._aabbDirty = !0 } } _rebuildAABB() { math.collapseAABB3(this._aabb); for (let t = 0, i = this._nodeList.length; t < i; t++) { var e = this._nodeList[t]; math.expandAABB3(this._aabb, e.aabb) } this._aabbDirty = !1 } stateSortCompare(e, t) { } rebuildRenderFlags() { this.renderFlags.reset(), this._updateRenderFlagsVisibleLayers(), 0 < this.renderFlags.numLayers && 0 === this.renderFlags.numVisibleLayers ? this.renderFlags.culled = !0 : this._updateRenderFlags() } _updateRenderFlagsVisibleLayers() { var e = this.renderFlags; e.numLayers = this._layerList.length; for (let i = e.numVisibleLayers = 0, s = this._layerList.length; i < s; i++) { var t = this._layerList[i]; this._getActiveSectionPlanesForLayer(t) && (e.visibleLayers[e.numVisibleLayers++] = i) } } _getActiveSectionPlanesForLayer(e) { var t = this.renderFlags, i = this.scene._sectionPlanesState.sectionPlanes, s = i.length, r = e.layerIndex * s; if (0 < s) for (let e = 0; e < s; e++)i[e].active ? (t.sectionPlanesActivePerLayer[r + e] = !0, t.sectioned = !0) : t.sectionPlanesActivePerLayer[r + e] = !1; return !0 } _updateRenderFlags() { var e, t; 0 !== this.numVisibleLayerPortions && this.numCulledLayerPortions !== this.numPortions && ((e = this.renderFlags).colorOpaque = this.numTransparentLayerPortions < this.numPortions, 0 < this.numTransparentLayerPortions && (e.colorTransparent = !0), 0 < this.numXRayedLayerPortions && ((t = this.scene.xrayMaterial._state).fill && (t.fillAlpha < 1 ? e.xrayedSilhouetteTransparent = !0 : e.xrayedSilhouetteOpaque = !0), t.edges) && (t.edgeAlpha < 1 ? e.xrayedEdgesTransparent = !0 : e.xrayedEdgesOpaque = !0), 0 < this.numEdgesLayerPortions && this.scene.edgeMaterial._state.edges && (e.edgesOpaque = this.numTransparentLayerPortions < this.numPortions, 0 < this.numTransparentLayerPortions) && (e.edgesTransparent = !0), 0 < this.numSelectedLayerPortions && ((t = this.scene.selectedMaterial._state).fill && (t.fillAlpha < 1 ? e.selectedSilhouetteTransparent = !0 : e.selectedSilhouetteOpaque = !0), t.edges) && (t.edgeAlpha < 1 ? e.selectedEdgesTransparent = !0 : e.selectedEdgesOpaque = !0), 0 < this.numHighlightedLayerPortions) && ((t = this.scene.highlightMaterial._state).fill && (t.fillAlpha < 1 ? e.highlightedSilhouetteTransparent = !0 : e.highlightedSilhouetteOpaque = !0), t.edges) && (t.edgeAlpha < 1 ? e.highlightedEdgesTransparent = !0 : e.highlightedEdgesOpaque = !0) } drawColorOpaque(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawColorOpaque(t, e) } } drawColorTransparent(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawColorTransparent(t, e) } } drawDepth(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawDepth(t, e) } } drawNormals(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawNormals(t, e) } } drawSilhouetteXRayed(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawSilhouetteXRayed(t, e) } } drawSilhouetteHighlighted(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawSilhouetteHighlighted(t, e) } } drawSilhouetteSelected(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawSilhouetteSelected(t, e) } } drawEdgesColorOpaque(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawEdgesColorOpaque(t, e) } } drawEdgesColorTransparent(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawEdgesColorTransparent(t, e) } } drawEdgesXRayed(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawEdgesXRayed(t, e) } } drawEdgesHighlighted(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawEdgesHighlighted(t, e) } } drawEdgesSelected(e) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawEdgesSelected(t, e) } } drawOcclusion(e) { if (0 !== this.numVisibleLayerPortions) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawOcclusion(t, e) } } } drawShadow(e) { if (0 !== this.numVisibleLayerPortions) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawShadow(t, e) } } } drawPickMesh(e) { if (0 !== this.numVisibleLayerPortions) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawPickMesh(t, e) } } } drawPickDepths(e) { if (0 !== this.numVisibleLayerPortions) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawPickDepths(t, e) } } } drawPickNormals(e) { if (0 !== this.numVisibleLayerPortions) { var t = this.renderFlags; for (let s = 0, r = t.visibleLayers.length; s < r; s++) { var i = t.visibleLayers[s]; this._layerList[i].drawPickNormals(t, e) } } } destroy() { for (var e in this._currentBatchingLayers) this._currentBatchingLayers.hasOwnProperty(e) && this._currentBatchingLayers[e].destroy(); this._currentBatchingLayers = {}, this.scene.camera.off(this._onCameraViewMatrix); for (let e = 0, t = this._layerList.length; e < t; e++)this._layerList[e].destroy(); for (let e = 0, t = this._nodeList.length; e < t; e++)this._nodeList[e]._destroy(); Object.entries(this._geometries).forEach((([, e]) => { e.destroy() })), this._geometries = {}, this._textures = {}, this._textureSets = {}, this._meshes = {}, this._nodes = {}, this.scene._aabbDirty = !0, this._isModel && this.scene._deregisterModel(this), putScratchMemory(), super.destroy() } } class PerformanceModel extends VBOSceneModel { constructor(e, t = {}) { super(e, t) } } class SectionPlane extends Component { get type() { return "SectionPlane" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ active: !0, pos: math.vec3(), dir: math.vec3(), dist: 0 }), this.active = t.active, this.pos = t.pos, this.dir = t.dir, this.scene._sectionPlaneCreated(this) } set active(e) { this._state.active = !1 !== e, this.glRedraw(), this.fire("active", this._state.active) } get active() { return this._state.active } set pos(e) { this._state.pos.set(e || [0, 0, 0]), this._state.dist = -math.dotVec3(this._state.pos, this._state.dir), this.fire("pos", this._state.pos) } get pos() { return this._state.pos } set dir(e) { this._state.dir.set(e || [0, 0, -1]), this._state.dist = -math.dotVec3(this._state.pos, this._state.dir), this.glRedraw(), this.fire("dir", this._state.dir) } get dir() { return this._state.dir } get dist() { return this._state.dist } flipDir() { var e = this._state.dir; e[0] *= -1, e[1] *= -1, e[2] *= -1, this._state.dist = -math.dotVec3(this._state.pos, this._state.dir), this.fire("dir", this._state.dir), this.glRedraw() } destroy() { this._state.destroy(), this.scene._sectionPlaneDestroyed(this), super.destroy() } } class Skybox extends Component { constructor(e, t = {}) { super(e, t), this._skyboxMesh = new Mesh(this, { geometry: new ReadableGeometry(this, { primitive: "triangles", positions: [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1], uv: [.5, .6666, .25, .6666, .25, .3333, .5, .3333, .5, .6666, .5, .3333, .75, .3333, .75, .6666, .5, .6666, .5, 1, .25, 1, .25, .6666, .25, .6666, 0, .6666, 0, .3333, .25, .3333, .25, 0, .5, 0, .5, .3333, .25, .3333, .75, .3333, 1, .3333, 1, .6666, .75, .6666], indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23] }), background: !0, scale: [2e3, 2e3, 2e3], rotation: [0, -90, 0], material: new PhongMaterial(this, { ambient: [0, 0, 0], diffuse: [0, 0, 0], specular: [0, 0, 0], emissive: [1, 1, 1], emissiveMap: new Texture(this, { src: t.src, flipY: !0, wrapS: "clampToEdge", wrapT: "clampToEdge", encoding: t.encoding || "sRGB" }), backfaces: !0 }), visible: !1, pickable: !1, clippable: !1, collidable: !1 }), this.size = t.size, this.active = t.active } set size(e) { this._size = e || 1e3, this._skyboxMesh.scale = [this._size, this._size, this._size] } get size() { return this._size } set active(e) { this._skyboxMesh.visible = e } get active() { return this._skyboxMesh.visible } } class TextureTranscoder { transcode(e, t, i = 0) { } destroy() { } } class Plugin { constructor(e, t, i) { this.id = i && i.id ? i.id : e, this.viewer = t, this._subIdMap = null, this._subIdEvents = null, this._eventSubs = null, this._eventSubsNum = null, this._events = null, this._eventCallDepth = 0, t.addPlugin(this) } fire(e, t, i) { this._events || (this._events = {}), this._eventSubs || (this._eventSubs = {}, this._eventSubsNum = {}), !0 !== i && (this._events[e] = t || !0); var s, r = this._eventSubs[e]; if (r) for (const i in r) r.hasOwnProperty(i) && (s = r[i], this._eventCallDepth++, this._eventCallDepth < 300 ? s.callback.call(s.scope, t) : this.error("fire: potential stack overflow from recursive event '" + e + "' - dropping this event"), this._eventCallDepth--) } on(e, t, i) { this._events || (this._events = {}), this._subIdMap || (this._subIdMap = new Map$1), this._subIdEvents || (this._subIdEvents = {}), this._eventSubs || (this._eventSubs = {}), this._eventSubsNum || (this._eventSubsNum = {}); let s = this._eventSubs[e]; s ? this._eventSubsNum[e]++ : (s = {}, this._eventSubs[e] = s, this._eventSubsNum[e] = 1); var r = this._subIdMap.addItem(); return s[r] = { callback: t, scope: i || this }, this._subIdEvents[r] = e, void 0 !== (e = this._events[e]) && t.call(i || this, e), r } off(e) { var t, i; null != e && this._subIdEvents && (t = this._subIdEvents[e]) && (delete this._subIdEvents[e], (i = this._eventSubs[t]) && (delete i[e], this._eventSubsNum[t]--), this._subIdMap.removeItem(e)) } once(e, t, i) { const s = this, r = this.on(e, (function (e) { s.off(r), t.call(i || this, e) }), i) } hasSubs(e) { return this._eventSubsNum && 0 < this._eventSubsNum[e] } log(e) { console.log(`[xeokit plugin ${this.id}]: ` + e) } warn(e) { console.warn(`[xeokit plugin ${this.id}]: ` + e) } error(e) { console.error(`[xeokit plugin ${this.id}]: ` + e) } send(e, t) { } destroy() { this.viewer.removePlugin(this) } } class Wire { constructor(e, t = {}) { this._color = t.color || "black", this._highlightClass = "viewer-ruler-wire-highlighted", this._wire = document.createElement("div"), this._wire.className += this._wire.className ? " viewer-ruler-wire" : "viewer-ruler-wire", this._wireClickable = document.createElement("div"), this._wireClickable.className += this._wireClickable.className ? " viewer-ruler-wire-clickable" : "viewer-ruler-wire-clickable", this._thickness = t.thickness || 1, this._thicknessClickable = t.thicknessClickable || 6; var i = this._wire, s = i.style; s.border = "solid " + this._thickness + "px " + this._color, s.position = "absolute", s["z-index"] = void 0 === t.zIndex ? "2000001" : t.zIndex, s.width = "0px", s.height = "0px", s.visibility = "visible", s.top = "0px", s.left = "0px", s["-webkit-transform-origin"] = "0 0", s["-moz-transform-origin"] = "0 0", s["-ms-transform-origin"] = "0 0", s["-o-transform-origin"] = "0 0", s["transform-origin"] = "0 0", s["-webkit-transform"] = "rotate(0deg)", s["-moz-transform"] = "rotate(0deg)", s["-ms-transform"] = "rotate(0deg)", s["-o-transform"] = "rotate(0deg)", s.transform = "rotate(0deg)", s.opacity = 1, t.onContextMenu, e.appendChild(i), (i = (s = this._wireClickable).style).border = "solid " + this._thicknessClickable + "px " + this._color, i.position = "absolute", i["z-index"] = void 0 === t.zIndex ? "2000002" : t.zIndex + 1, i.width = "0px", i.height = "0px", i.visibility = "visible", i.top = "0px", i.left = "0px", i["-webkit-transform-origin"] = "0 0", i["-moz-transform-origin"] = "0 0", i["-ms-transform-origin"] = "0 0", i["-o-transform-origin"] = "0 0", i["transform-origin"] = "0 0", i["-webkit-transform"] = "rotate(0deg)", i["-moz-transform"] = "rotate(0deg)", i["-ms-transform"] = "rotate(0deg)", i["-o-transform"] = "rotate(0deg)", i.transform = "rotate(0deg)", i.opacity = 0, i["pointer-events"] = "all", t.onContextMenu, e.appendChild(s), t.onMouseOver && s.addEventListener("mouseover", (e => { t.onMouseOver(e, this) })), t.onMouseLeave && s.addEventListener("mouseleave", (e => { t.onMouseLeave(e, this) })), t.onContextMenu && s.addEventListener("contextmenu", (e => { t.onContextMenu(e, this), e.preventDefault() })), this._x1 = 0, this._y1 = 0, this._x2 = 0, this._y2 = 0, this._update() } get _visible() { return "visible" === this._wire.style.visibility } _update() { var e = Math.abs(Math.sqrt((this._x1 - this._x2) * (this._x1 - this._x2) + (this._y1 - this._y2) * (this._y1 - this._y2))), t = 180 * Math.atan2(this._y2 - this._y1, this._x2 - this._x1) / Math.PI, i = this._wire.style; i.width = Math.round(e) + "px", i.left = Math.round(this._x1) + "px", i.top = Math.round(this._y1) + "px", i["-webkit-transform"] = "rotate(" + t + "deg)", i["-moz-transform"] = "rotate(" + t + "deg)", i["-ms-transform"] = "rotate(" + t + "deg)", i["-o-transform"] = "rotate(" + t + "deg)", i.transform = "rotate(" + t + "deg)", (i = this._wireClickable.style).width = Math.round(e) + "px", i.left = Math.round(this._x1) + "px", i.top = Math.round(this._y1) + "px", i["-webkit-transform"] = "rotate(" + t + "deg)", i["-moz-transform"] = "rotate(" + t + "deg)", i["-ms-transform"] = "rotate(" + t + "deg)", i["-o-transform"] = "rotate(" + t + "deg)", i.transform = "rotate(" + t + "deg)" } setStartAndEnd(e, t, i, s) { this._x1 = e, this._y1 = t, this._x2 = i, this._y2 = s, this._update() } setColor(e) { this._color = e || "black", this._wire.style.border = "solid " + this._thickness + "px " + this._color } setOpacity(e) { this._wire.style.opacity = e } setVisible(e) { this._visible !== (e = !!e) && (this._wire.style.visibility = e ? "visible" : "hidden") } setClickable(e) { this._wireClickable.style["pointer-events"] = e ? "all" : "none" } setHighlighted(e) { this._highlighted !== e && (this._highlighted = !!e, this._highlighted ? this._wire.classList.add(this._highlightClass) : this._wire.classList.remove(this._highlightClass)) } destroy(e) { this._wire.parentElement.removeChild(this._wire), this._wireClickable.parentElement.removeChild(this._wireClickable) } } class Dot { constructor(e, t = {}) { this._highlightClass = "viewer-ruler-dot-highlighted", this._x = 0, this._y = 0, this._visible = !0, this._dot = document.createElement("div"), this._dot.className += this._dot.className ? " viewer-ruler-dot" : "viewer-ruler-dot", this._dotClickable = document.createElement("div"), this._dotClickable.className += this._dotClickable.className ? " viewer-ruler-dot-clickable" : "viewer-ruler-dot-clickable"; var i = this._dot, s = i.style; s["border-radius"] = "25px", s.border = "solid 2px white", s.background = "lightgreen", s.position = "absolute", s["z-index"] = void 0 === t.zIndex ? "40000005" : t.zIndex, s.width = "8px", s.height = "8px", s.visibility = !1 !== t.visible ? "visible" : "hidden", s.top = "0px", s.left = "0px", s["box-shadow"] = "0 2px 5px 0 #182A3D;", s.opacity = 1, s["pointer-events"] = "none", t.onContextMenu, e.appendChild(i), (i = (s = this._dotClickable).style)["border-radius"] = "35px", i.border = "solid 10px white", i.position = "absolute", i["z-index"] = void 0 === t.zIndex ? "40000007" : t.zIndex + 1, i.width = "8px", i.height = "8px", i.visibility = "visible", i.top = "0px", i.left = "0px", i.opacity = 0, i["pointer-events"] = "none", t.onContextMenu, e.appendChild(s), t.onMouseOver && s.addEventListener("mouseover", (e => { t.onMouseOver(e, this) })), t.onMouseLeave && s.addEventListener("mouseleave", (e => { t.onMouseLeave(e, this) })), t.onContextMenu && s.addEventListener("contextmenu", (e => { t.onContextMenu(e, this), e.preventDefault() })), this.setPos(t.x || 0, t.y || 0), this.setFillColor(t.fillColor), this.setBorderColor(t.borderColor) } setPos(e, t) { this._x = e, this._y = t; var i = this._dot.style; i.left = Math.round(e) - 4 + "px", i.top = Math.round(t) - 4 + "px", (i = this._dotClickable.style).left = Math.round(e) - 9 + "px", i.top = Math.round(t) - 9 + "px" } setFillColor(e) { this._dot.style.background = e || "lightgreen" } setBorderColor(e) { this._dot.style.border = "solid 2px" + (e || "black") } setOpacity(e) { this._dot.style.opacity = e } setVisible(e) { this._visible !== e && (this._visible = !!e, this._dot.style.visibility = this._visible ? "visible" : "hidden") } setClickable(e) { this._dotClickable.style["pointer-events"] = e ? "all" : "none", this._dot.style["pointer-events"] = e ? "all" : "none" } setHighlighted(e) { this._highlighted !== e && (this._highlighted = !!e, this._highlighted ? this._dot.classList.add(this._highlightClass) : this._dot.classList.remove(this._highlightClass)) } destroy() { this.setVisible(!1), this._dot.parentElement.removeChild(this._dot), this._dotClickable.parentElement.removeChild(this._dotClickable) } } class Label { constructor(e, t = {}) { this._highlightClass = "viewer-ruler-label-highlighted", this._prefix = t.prefix || "", this._x = 0, this._y = 0, this._visible = !0, this._culled = !1, this._label = document.createElement("div"), this._label.className += this._label.className ? " viewer-ruler-label" : "viewer-ruler-label"; var i = this._label, s = i.style; s["border-radius"] = "5px", s.color = "white", s.padding = "4px", s.border = "solid 1px", s.background = "lightgreen", s.position = "absolute", s["z-index"] = void 0 === t.zIndex ? "5000005" : t.zIndex, s.width = "auto", s.height = "auto", s.visibility = "visible", s.top = "0px", s.left = "0px", s["pointer-events"] = "all", s.opacity = 1, t.onContextMenu, i.innerText = "", e.appendChild(i), this.setPos(t.x || 0, t.y || 0), this.setFillColor(t.fillColor), this.setBorderColor(t.fillColor), this.setText(t.text), t.onMouseOver && i.addEventListener("mouseover", (e => { t.onMouseOver(e, this), e.preventDefault() })), t.onMouseLeave && i.addEventListener("mouseleave", (e => { t.onMouseLeave(e, this), e.preventDefault() })), t.onContextMenu && i.addEventListener("contextmenu", (e => { t.onContextMenu(e, this), e.preventDefault() })) } setPos(e, t) { this._x = e, this._y = t; var i = this._label.style; i.left = Math.round(e) - 20 + "px", i.top = Math.round(t) - 12 + "px" } setPosOnWire(e, t, i, s) { s = t + .5 * (s - t), (t = this._label.style).left = Math.round(e + .5 * (i - e)) - 20 + "px", t.top = Math.round(s) - 12 + "px" } setPosBetweenWires(e, t, i, s, r, a) { t = (t + s + a) / 3, (s = this._label.style).left = Math.round((e + i + r) / 3) - 20 + "px", s.top = Math.round(t) - 12 + "px" } setText(e) { this._label.innerHTML = this._prefix + (e || "") } setFillColor(e) { this._fillColor = e || "lightgreen", this._label.style.background = this._fillColor } setBorderColor(e) { this._borderColor = e || "black", this._label.style.border = "solid 1px " + this._borderColor } setOpacity(e) { this._label.style.opacity = e } setVisible(e) { this._visible !== e && (this._visible = !!e, this._label.style.visibility = this._visible && !this._culled ? "visible" : "hidden") } setCulled(e) { this._culled !== e && (this._culled = !!e, this._label.style.visibility = this._visible && !this._culled ? "visible" : "hidden") } setHighlighted(e) { this._highlighted !== e && (this._highlighted = !!e, this._highlighted ? this._label.classList.add(this._highlightClass) : this._label.classList.remove(this._highlightClass)) } setClickable(e) { this._label.style["pointer-events"] = e ? "all" : "none" } destroy() { this._label.parentElement.removeChild(this._label) } } var originVec = math.vec3(), targetVec = math.vec3(); class AngleMeasurement extends Component { constructor(e, t = {}) { if (super(e.viewer.scene, t), this.plugin = e, this._container = t.container, !this._container) throw "config missing: container"; this._color = t.color || e.defaultColor; var i = this.plugin.viewer.scene, s = (this._originMarker = new Marker(i, t.origin), this._cornerMarker = new Marker(i, t.corner), this._targetMarker = new Marker(i, t.target), this._originWorld = math.vec3(), this._cornerWorld = math.vec3(), this._targetWorld = math.vec3(), this._wp = new Float64Array(12), this._vp = new Float64Array(12), this._pp = new Float64Array(12), this._cp = new Int16Array(6), t.onMouseOver ? e => { t.onMouseOver(e, this) } : null), r = t.onMouseLeave ? e => { t.onMouseLeave(e, this) } : null, a = t.onContextMenu ? e => { t.onContextMenu(e, this) } : null; this._originDot = new Dot(this._container, { fillColor: this._color, zIndex: void 0 !== e.zIndex ? e.zIndex + 2 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._cornerDot = new Dot(this._container, { fillColor: this._color, zIndex: void 0 !== e.zIndex ? e.zIndex + 2 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._targetDot = new Dot(this._container, { fillColor: this._color, zIndex: void 0 !== e.zIndex ? e.zIndex + 2 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._originWire = new Wire(this._container, { color: this._color || "blue", thickness: 1, zIndex: e.zIndex, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._targetWire = new Wire(this._container, { color: this._color || "red", thickness: 1, zIndex: void 0 !== e.zIndex ? e.zIndex + 1 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._angleLabel = new Label(this._container, { fillColor: this._color || "#00BBFF", prefix: "", text: "", zIndex: e.zIndex + 2, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._wpDirty = !1, this._vpDirty = !1, this._cpDirty = !1, this._visible = !1, this._originVisible = !1, this._cornerVisible = !1, this._targetVisible = !1, this._originWireVisible = !1, this._targetWireVisible = !1, this._angleVisible = !1, this._labelsVisible = !1, this._clickable = !1, this._originMarker.on("worldPos", (e => { this._originWorld.set(e || [0, 0, 0]), this._wpDirty = !0, this._needUpdate(0) })), this._cornerMarker.on("worldPos", (e => { this._cornerWorld.set(e || [0, 0, 0]), this._wpDirty = !0, this._needUpdate(0) })), this._targetMarker.on("worldPos", (e => { this._targetWorld.set(e || [0, 0, 0]), this._wpDirty = !0, this._needUpdate(0) })), this._onViewMatrix = i.camera.on("viewMatrix", (() => { this._vpDirty = !0, this._needUpdate(0) })), this._onProjMatrix = i.camera.on("projMatrix", (() => { this._cpDirty = !0, this._needUpdate() })), this._onCanvasBoundary = i.canvas.on("boundary", (() => { this._cpDirty = !0, this._needUpdate(0) })), this.approximate = t.approximate, this.visible = t.visible, this.originVisible = t.originVisible, this.cornerVisible = t.cornerVisible, this.targetVisible = t.targetVisible, this.originWireVisible = t.originWireVisible, this.targetWireVisible = t.targetWireVisible, this.angleVisible = t.angleVisible, this.labelsVisible = t.labelsVisible } _update() { if (this._visible) { var e = this.plugin.viewer.scene; if (this._wpDirty && (this._wp[0] = this._originWorld[0], this._wp[1] = this._originWorld[1], this._wp[2] = this._originWorld[2], this._wp[3] = 1, this._wp[4] = this._cornerWorld[0], this._wp[5] = this._cornerWorld[1], this._wp[6] = this._cornerWorld[2], this._wp[7] = 1, this._wp[8] = this._targetWorld[0], this._wp[9] = this._targetWorld[1], this._wp[10] = this._targetWorld[2], this._wp[11] = 1, this._wpDirty = !1, this._vpDirty = !0), this._vpDirty && (math.transformPositions4(e.camera.viewMatrix, this._wp, this._vp), this._vp[3] = 1, this._vp[7] = 1, this._vp[11] = 1, this._vpDirty = !1, this._cpDirty = !0), this._cpDirty) { var t = this._originMarker.viewPos[2], i = this._cornerMarker.viewPos[2], s = this._targetMarker.viewPos[2]; if (-.3 < t || -.3 < i || -.3 < s) this._originDot.setVisible(!1), this._cornerDot.setVisible(!1), this._targetDot.setVisible(!1), this._originWire.setVisible(!1), this._targetWire.setVisible(!1), this._angleLabel.setCulled(!0); else { math.transformPositions4(e.camera.project.matrix, this._vp, this._pp); for (var r = this._pp, a = this._cp, o = (t = e.canvas.canvas.getBoundingClientRect(), i = this._container.getBoundingClientRect(), t.top - i.top), n = t.left - i.left, h = (s = e.canvas.boundary)[2], l = s[3], c = 0, u = 0, p = r.length; u < p; u += 4)a[c] = n + Math.floor((1 + r[u + 0] / r[u + 3]) * h / 2), a[c + 1] = o + Math.floor((1 - r[u + 1] / r[u + 3]) * l / 2), c += 2; this._originDot.setPos(a[0], a[1]), this._cornerDot.setPos(a[2], a[3]), this._targetDot.setPos(a[4], a[5]), this._originWire.setStartAndEnd(a[0], a[1], a[2], a[3]), this._targetWire.setStartAndEnd(a[2], a[3], a[4], a[5]), this._angleLabel.setPosBetweenWires(a[0], a[1], a[2], a[3], a[4], a[5]), math.subVec3(this._originWorld, this._cornerWorld, originVec), math.subVec3(this._targetWorld, this._cornerWorld, targetVec), 0 === originVec[0] && 0 === originVec[1] && 0 === originVec[2] || 0 === targetVec[0] && 0 === targetVec[1] && 0 === targetVec[2] ? this._angleLabel.setText("") : (t = this._approximate ? " ~ " : " = ", math.normalizeVec3(originVec), math.normalizeVec3(targetVec), i = Math.abs(math.angleVec3(originVec, targetVec)), this._angle = i / math.DEGTORAD, this._angleLabel.setText(t + this._angle.toFixed(2) + "°")), this._originDot.setVisible(this._visible && this._originVisible), this._cornerDot.setVisible(this._visible && this._cornerVisible), this._targetDot.setVisible(this._visible && this._targetVisible), this._originWire.setVisible(this._visible && this._originWireVisible), this._targetWire.setVisible(this._visible && this._targetWireVisible), this._angleLabel.setCulled(!(this._visible && this._angleVisible && this.labelsVisible)), this._cpDirty = !1 } } } } set approximate(e) { this._approximate !== (e = !1 !== e) && (this._approximate = e, this._cpDirty = !0, this._needUpdate(0)) } get approximate() { return this._approximate } get origin() { return this._originMarker } get corner() { return this._cornerMarker } get target() { return this._targetMarker } get angle() { return this._update(), this._angle } get color() { return this._color } set color(e) { this._originDot.setFillColor(e), this._cornerDot.setFillColor(e), this._targetDot.setFillColor(e), this._originWire.setColor(e || "blue"), this._targetWire.setColor(e || "red"), this._angleLabel.setFillColor(e || "#00BBFF"), this._color = e } set visible(e) { this._visible = e = !1 !== e, this._originDot.setVisible(this._visible && this._originVisible), this._cornerDot.setVisible(this._visible && this._cornerVisible), this._targetDot.setVisible(this._visible && this._targetVisible), this._originWire.setVisible(this._visible && this._originWireVisible), this._targetWire.setVisible(this._visible && this._targetWireVisible), this._angleLabel.setVisible(this._visible && this._angleVisible), this._cpDirty = !0, this._needUpdate() } get visible() { return this._visible } set originVisible(e) { this._originVisible = e = !1 !== e, this._originDot.setVisible(this._visible && this._originVisible), this._cpDirty = !0, this._needUpdate() } get originVisible() { return this._originVisible } set cornerVisible(e) { this._cornerVisible = e = !1 !== e, this._cornerDot.setVisible(this._visible && this._cornerVisible), this._cpDirty = !0, this._needUpdate() } get cornerVisible() { return this._cornerVisible } set targetVisible(e) { this._targetVisible = e = !1 !== e, this._targetDot.setVisible(this._visible && this._targetVisible), this._cpDirty = !0, this._needUpdate() } get targetVisible() { return this._targetVisible } set originWireVisible(e) { this._originWireVisible = e = !1 !== e, this._originWire.setVisible(this._visible && this._originWireVisible), this._cpDirty = !0, this._needUpdate() } get originWireVisible() { return this._originWireVisible } set targetWireVisible(e) { this._targetWireVisible = e = !1 !== e, this._targetWire.setVisible(this._visible && this._targetWireVisible), this._cpDirty = !0, this._needUpdate() } get targetWireVisible() { return this._targetWireVisible } set angleVisible(e) { this._angleVisible = e = !1 !== e, this._angleLabel.setVisible(this._visible && this._angleVisible), this._cpDirty = !0, this._needUpdate() } get angleVisible() { return this._angleVisible } set labelsVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultLabelsVisible, this._labelsVisible = e, e = this._visible && this._labelsVisible, this._angleLabel.setVisible(e), this._cpDirty = !0, this._needUpdate() } get labelsVisible() { return this._labelsVisible } setHighlighted(e) { this._originDot.setHighlighted(e), this._cornerDot.setHighlighted(e), this._targetDot.setHighlighted(e), this._originWire.setHighlighted(e), this._targetWire.setHighlighted(e), this._angleLabel.setHighlighted(e) } set clickable(e) { this._clickable = e = !!e, this._originDot.setClickable(this._clickable), this._cornerDot.setClickable(this._clickable), this._targetDot.setClickable(this._clickable), this._originWire.setClickable(this._clickable), this._targetWire.setClickable(this._clickable), this._angleLabel.setClickable(this._clickable) } get clickable() { return this._clickable } destroy() { var e = this.plugin.viewer.scene; this._onViewMatrix && e.camera.off(this._onViewMatrix), this._onProjMatrix && e.camera.off(this._onProjMatrix), this._onCanvasBoundary && e.canvas.off(this._onCanvasBoundary), this._originDot.destroy(), this._cornerDot.destroy(), this._targetDot.destroy(), this._originWire.destroy(), this._targetWire.destroy(), this._angleLabel.destroy(), super.destroy() } } const FINDING_ORIGIN = 0, FINDING_CORNER = 1, FINDING_TARGET = 2; class AngleMeasurementsControl extends Component { constructor(e) { super(e.viewer.scene), this.plugin = e, this._active = !1, this._state = 0, this._currentAngleMeasurement = null, this._onMouseHoverSurface = null, this._onHoverNothing = null, this._onMouseHoverOff = null, this._onPickedNothing = null, this._onPickedSurface = null, this._onInputMouseDown = null, this._onInputMouseUp = null, this._onCanvasTouchStart = null, this._onCanvasTouchEnd = null } get active() { return this._active } activate() { if (!this._active) { var e = this.plugin; const i = this.scene, s = (e = e.viewer.cameraControl, i.canvas.canvas); var t = i.input; const r = i.pickSurfacePrecisionEnabled; let a = !1, o = null, n = math.vec3(); const h = math.vec2(); let l, c; const u = math.vec2(), p = math.vec2(); math.vec3(), this._onMouseHoverSurface = e.on("hoverSurface", (e => { if (a = !0, o = e.entity, n.set(e.worldPos), h.set(e.canvasPos), this._currentAngleMeasurement) switch (this._state) { case 1: this._currentAngleMeasurement.originWireVisible = !0, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.cornerVisible = !0, this._currentAngleMeasurement.angleVisible = !1, this._currentAngleMeasurement.corner.entity = e.entity, this._currentAngleMeasurement.corner.worldPos = e.worldPos, s.style.cursor = "pointer"; break; case 2: this._currentAngleMeasurement.targetWireVisible = !0, this._currentAngleMeasurement.targetVisible = !0, this._currentAngleMeasurement.angleVisible = !0, this._currentAngleMeasurement.target.entity = e.entity, this._currentAngleMeasurement.target.worldPos = e.worldPos, s.style.cursor = "pointer" } })), this._onInputMouseDown = t.on("mousedown", (e => { l = e[0], c = e[1] })), this._onInputMouseUp = t.on("mouseup", (e => { if (!(e[0] > l + 5 || e[0] < l - 5 || e[1] > c + 5 || e[1] < c - 5)) switch (this._state) { case 0: a && (r && (t = i.pick({ canvasPos: h, pickSurface: !0, pickSurfacePrecision: r })) && t.worldPos && worldPos.set(t.worldPos), this._currentAngleMeasurement = this.plugin.createMeasurement({ id: math.createUUID(), origin: { entity: o, worldPos: n }, corner: { entity: o, worldPos: n }, target: { entity: o, worldPos: n }, approximate: !0 }), this._currentAngleMeasurement.originVisible = !0, this._currentAngleMeasurement.originWireVisible = !0, this._currentAngleMeasurement.cornerVisible = !1, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.targetVisible = !1, this._currentAngleMeasurement.angleVisible = !1, this._state = 1, this.fire("measurementStart", this._currentAngleMeasurement)); break; case 1: a ? (r && (t = i.pick({ canvasPos: h, pickSurface: !0, pickSurfacePrecision: !0 })) && t.worldPos && (this._currentAngleMeasurement.corner.worldPos = t.worldPos), this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.targetVisible = !0, this._currentAngleMeasurement.angleVisible = !0, this._state = 2) : this._currentAngleMeasurement && (this._currentAngleMeasurement.destroy(), this._currentAngleMeasurement = null, this._state = 0, this.fire("measurementCancel", this._currentAngleMeasurement)); break; case 2: var t; a ? (r && (t = i.pick({ canvasPos: h, pickSurface: !0, pickSurfacePrecision: !0 })) && t.worldPos && (this._currentAngleMeasurement.target.worldPos = t.worldPos, this._currentAngleMeasurement.approximate = !1), this._currentAngleMeasurement.targetVisible = !0, this._currentAngleMeasurement.angleVisible = !0, this.fire("measurementEnd", this._currentAngleMeasurement), this._currentAngleMeasurement = null, this._state = 0) : this._currentAngleMeasurement && (this._currentAngleMeasurement.destroy(), this._currentAngleMeasurement = null, this._state = 0, this.fire("measurementCancel", this._currentAngleMeasurement)) } })), this._onHoverNothing = e.on("hoverOff", (e => { if (a = !1, this._currentAngleMeasurement) { switch (this._state) { case 0: this._currentAngleMeasurement.originVisible = !1; break; case 1: this._currentAngleMeasurement.cornerVisible = !1, this._currentAngleMeasurement.originWireVisible = !1, this._currentAngleMeasurement.targetVisible = !1, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.angleVisible = !1; break; case 2: this._currentAngleMeasurement.targetVisible = !1, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.angleVisible = !1 }s.style.cursor = "default" } })), s.addEventListener("touchstart", this._onCanvasTouchStart = e => { var t = e.touches; e = e.changedTouches; 1 === t.length && 1 === e.length && getCanvasPosFromEvent$5(t[0], u) }, { passive: !0 }), s.addEventListener("touchend", this._onCanvasTouchEnd = e => { var t = e.touches; e = e.changedTouches; if (0 === t.length && 1 === e.length && (getCanvasPosFromEvent$5(e[0], p), !(p[0] > u[0] + 5 || p[0] < u[0] - 5 || p[1] > u[1] + 5 || p[1] < u[1] - 5))) { var s = i.pick({ canvasPos: p, pickSurface: !0, pickSurfacePrecision: !1 }); if (s && s.worldPos) switch (this._state) { case 0: this._currentAngleMeasurement = this.plugin.createMeasurement({ id: math.createUUID(), origin: { entity: s.entity, worldPos: s.worldPos }, corner: { entity: s.entity, worldPos: s.worldPos }, target: { entity: s.entity, worldPos: s.worldPos }, approximate: !0 }), this._currentAngleMeasurement.originVisible = !0, this._currentAngleMeasurement.originWireVisible = !0, this._currentAngleMeasurement.cornerVisible = !1, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.targetVisible = !1, this._currentAngleMeasurement.angleVisible = !1, this._currentAngleMeasurement.clickable = !1, this._state = 1, this.fire("measurementStart", this._currentAngleMeasurement); break; case 1: this._currentAngleMeasurement.corner.worldPos = s.worldPos, this._currentAngleMeasurement.targetWireVisible = !1, this._currentAngleMeasurement.targetVisible = !0, this._currentAngleMeasurement.angleVisible = !0, this._state = 2; break; case 2: this._currentAngleMeasurement.target.worldPos = s.worldPos, this._currentAngleMeasurement.targetVisible = !0, this._currentAngleMeasurement.angleVisible = !0, this._currentAngleMeasurement.clickable = !0, this.fire("measurementEnd", this._currentAngleMeasurement), this._currentAngleMeasurement = null, this._state = 0 } else this._currentAngleMeasurement && (this._currentAngleMeasurement.destroy(), this._currentAngleMeasurement = null, this._state = 0, this.fire("measurementCancel", this._currentAngleMeasurement)) } }, { passive: !0 }), this._active = !0 } } deactivate() { var e, t, i; this._active && (this.reset(), e = this.plugin.viewer.scene.input, t = this.plugin.viewer.cameraControl, i = this.plugin.viewer.scene.canvas.canvas, e.off(this._onInputMouseDown), e.off(this._onInputMouseUp), t.off(this._onMouseHoverSurface), t.off(this._onPickedSurface), t.off(this._onHoverNothing), t.off(this._onPickedNothing), i.removeEventListener("touchstart", this._onCanvasTouchStart), i.removeEventListener("touchend", this._onCanvasTouchEnd), this._currentAngleMeasurement = null, this._active = !1) } reset() { this._active && (this._currentAngleMeasurement && (this._currentAngleMeasurement.destroy(), this._currentAngleMeasurement = null), this._state = 0) } destroy() { this.deactivate(), super.destroy() } } const getCanvasPosFromEvent$5 = function (e, t) { if (e) { let i = e.target, s = 0, r = 0; for (; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t }; class AngleMeasurementsPlugin extends Plugin { constructor(e, t = {}) { super("AngleMeasurements", e), this._container = t.container || document.body, this._control = new AngleMeasurementsControl(this), this._measurements = {}, this.defaultColor = void 0 !== t.defaultColor ? t.defaultColor : "#00BBFF", this.defaultLabelsVisible = !1 !== t.defaultLabelsVisible, this.zIndex = t.zIndex || 1e4, this._onMouseOver = (e, t) => { this.fire("mouseOver", { plugin: this, angleMeasurement: t, measurement: t, event: e }) }, this._onMouseLeave = (e, t) => { this.fire("mouseLeave", { plugin: this, angleMeasurement: t, measurement: t, event: e }) }, this._onContextMenu = (e, t) => { this.fire("contextMenu", { plugin: this, angleMeasurement: t, measurement: t, event: e }) } } send(e, t) { } get control() { return this._control } get measurements() { return this._measurements } createMeasurement(e = {}) { this.viewer.scene.components[e.id] && (this.error("Viewer scene component with this ID already exists: " + e.id), delete e.id); var t = e.origin, i = e.corner, s = e.target; const r = new AngleMeasurement(this, { id: e.id, plugin: this, container: this._container, origin: { entity: t.entity, worldPos: t.worldPos }, corner: { entity: i.entity, worldPos: i.worldPos }, target: { entity: s.entity, worldPos: s.worldPos }, visible: e.visible, originVisible: !0, originWireVisible: !0, cornerVisible: !0, targetWireVisible: !0, targetVisible: !0, onMouseOver: this._onMouseOver, onMouseLeave: this._onMouseLeave, onContextMenu: this._onContextMenu }); return (this._measurements[r.id] = r).on("destroyed", (() => { delete this._measurements[r.id] })), this.fire("measurementCreated", r), r } destroyMeasurement(e) { var t = this._measurements[e]; t ? (t.destroy(), this.fire("measurementDestroyed", t)) : this.log("AngleMeasurement not found: " + e) } setLabelsShown(e) { for (var [t, i] of Object.entries(this.measurements)) i.labelShown = e } clear() { for (var e = Object.keys(this._measurements), t = 0, i = e.length; t < i; t++)this.destroyMeasurement(e[t]) } destroy() { this.clear(), super.destroy() } } class Annotation extends Marker { constructor(e, t) { if (super(e, t), this.plugin = t.plugin, this._container = t.container, !this._container) throw "config missing: container"; if (!t.markerElement && !t.markerHTML) throw "config missing: need either markerElement or markerHTML"; if (!t.labelElement && !t.labelHTML) throw "config missing: need either labelElement or labelHTML"; this._htmlDirty = !1, t.markerElement ? (this._marker = t.markerElement, this._marker.addEventListener("click", this._onMouseClickedExternalMarker = () => { this.plugin.fire("markerClicked", this) }), this._marker.addEventListener("mouseenter", this._onMouseEnterExternalMarker = () => { this.plugin.fire("markerMouseEnter", this) }), this._marker.addEventListener("mouseleave", this._onMouseLeaveExternalMarker = () => { this.plugin.fire("markerMouseLeave", this) }), this._markerExternal = !0) : (this._markerHTML = t.markerHTML, this._htmlDirty = !0, this._markerExternal = !1), t.labelElement ? (this._label = t.labelElement, this._labelExternal = !0) : (this._labelHTML = t.labelHTML, this._htmlDirty = !0, this._labelExternal = !1), this._markerShown = !!t.markerShown, this._labelShown = !!t.labelShown, this._values = t.values || {}, this._layoutDirty = !0, this._visibilityDirty = !0, this._buildHTML(), this._onTick = this.scene.on("tick", (() => { this._htmlDirty && (this._buildHTML(), this._htmlDirty = !1, this._layoutDirty = !0, this._visibilityDirty = !0), (this._layoutDirty || this._visibilityDirty) && (this._markerShown || this._labelShown) && (this._updatePosition(), this._layoutDirty = !1), this._visibilityDirty && (this._marker.style.visibility = this.visible && this._markerShown ? "visible" : "hidden", this._label.style.visibility = this.visible && this._markerShown && this._labelShown ? "visible" : "hidden", this._visibilityDirty = !1) })), this.on("canvasPos", (() => { this._layoutDirty = !0 })), this.on("visible", (() => { this._visibilityDirty = !0 })), this.setMarkerShown(!1 !== t.markerShown), this.setLabelShown(t.labelShown), this.eye = t.eye ? t.eye.slice() : null, this.look = t.look ? t.look.slice() : null, this.up = t.up ? t.up.slice() : null, this.projection = t.projection } _buildHTML() { if (!this._markerExternal) { this._marker && (this._container.removeChild(this._marker), this._marker = null); let t = this._markerHTML || "<p></p>"; utils.isArray(t) && (t = t.join("")), t = this._renderTemplate(t); var e = document.createRange().createContextualFragment(t); this._marker = e.firstChild, this._container.appendChild(this._marker), this._marker.style.visibility = this._markerShown ? "visible" : "hidden", this._marker.addEventListener("click", (() => { this.plugin.fire("markerClicked", this) })), this._marker.addEventListener("mouseenter", (() => { this.plugin.fire("markerMouseEnter", this) })), this._marker.addEventListener("mouseleave", (() => { this.plugin.fire("markerMouseLeave", this) })) } if (!this._labelExternal) { this._label && (this._container.removeChild(this._label), this._label = null); let t = this._labelHTML || "<p></p>"; utils.isArray(t) && (t = t.join("")), t = this._renderTemplate(t), e = document.createRange().createContextualFragment(t), this._label = e.firstChild, this._container.appendChild(this._label), this._label.style.visibility = this._markerShown && this._labelShown ? "visible" : "hidden" } } _updatePosition() { var e = (t = this.scene.canvas.boundary)[0], t = t[1], i = this.canvasPos; this._marker.style.left = Math.floor(e + i[0]) - 12 + "px", this._marker.style.top = Math.floor(t + i[1]) - 12 + "px", this._marker.style["z-index"] = 90005 + Math.floor(this._viewPos[2]) + 1, this._label.style.left = 20 + Math.floor(e + i[0] + 20) + "px", this._label.style.top = Math.floor(t + i[1] + -17) + "px", this._label.style["z-index"] = 90005 + Math.floor(this._viewPos[2]) + 1 } _renderTemplate(e) { for (var t in this._values) { var i; this._values.hasOwnProperty(t) && (i = this._values[t], e = e.replace(new RegExp("{{" + t + "}}", "g"), i)) } return e } setMarkerShown(e) { this._markerShown !== (e = !!e) && (this._markerShown = e, this._visibilityDirty = !0) } getMarkerShown() { return this._markerShown } setLabelShown(e) { this._labelShown !== (e = !!e) && (this._labelShown = e, this._visibilityDirty = !0) } getLabelShown() { return this._labelShown } setField(e, t) { this._values[e] = t || "", this._htmlDirty = !0 } getField(e) { return this._values[e] } setValues(e) { for (var t in e) { var i; e.hasOwnProperty(t) && (i = e[t], this.setField(t, i)) } } getValues() { return this._values } destroy() { this._marker && (this._markerExternal ? (this._marker.removeEventListener("click", this._onMouseClickedExternalMarker), this._marker.removeEventListener("mouseenter", this._onMouseEnterExternalMarker), this._marker.removeEventListener("mouseleave", this._onMouseLeaveExternalMarker), this._marker = null) : this._marker.parentNode.removeChild(this._marker)), this._label && (this._labelExternal || this._label.parentNode.removeChild(this._label), this._label = null), this.scene.off(this._onTick), super.destroy() } } const tempVec3a$a = math.vec3(), tempVec3b$7 = math.vec3(), tempVec3c$6 = math.vec3(); class AnnotationsPlugin extends Plugin { constructor(e, t) { super("Annotations", e), this._labelHTML = t.labelHTML || "<div></div>", this._markerHTML = t.markerHTML || "<div></div>", this._container = t.container || document.body, this._values = t.values || {}, this.annotations = {}, this.surfaceOffset = t.surfaceOffset } send(e, t) { "clearAnnotations" === e && this.clear() } set surfaceOffset(e) { this._surfaceOffset = e = null == e ? .3 : e } get surfaceOffset() { return this._surfaceOffset } createAnnotation(e) { this.viewer.scene.components[e.id] && (this.error("Viewer component with this ID already exists: " + e.id), delete e.id), e.pickResult = e.pickResult || e.pickRecord, e.pickResult ? (s = e.pickResult).worldPos && s.worldNormal ? (t = math.normalizeVec3(s.worldNormal, tempVec3a$a), t = math.mulVec3Scalar(t, this._surfaceOffset, tempVec3b$7), t = math.addVec3(s.worldPos, t, tempVec3c$6), i = s.entity) : this.error("Param 'pickResult' does not have both worldPos and worldNormal") : (t = e.worldPos, i = e.entity); var t, i, s = null, r = (e.markerElementId && !(s = document.getElementById(e.markerElementId)) && this.error("Can't find DOM element for 'markerElementId' value '" + e.markerElementId + "' - defaulting to internally-generated empty DIV"), null); e.labelElementId && !(r = document.getElementById(e.labelElementId)) && this.error("Can't find DOM element for 'labelElementId' value '" + e.labelElementId + "' - defaulting to internally-generated empty DIV"); const a = new Annotation(this.viewer.scene, { id: e.id, plugin: this, entity: i, worldPos: t, container: this._container, markerElement: s, labelElement: r, markerHTML: e.markerHTML || this._markerHTML, labelHTML: e.labelHTML || this._labelHTML, occludable: e.occludable, values: utils.apply(e.values, utils.apply(this._values, {})), markerShown: e.markerShown, labelShown: e.labelShown, eye: e.eye, look: e.look, up: e.up, projection: e.projection, visible: !1 !== e.visible }); return (this.annotations[a.id] = a).on("destroyed", (() => { delete this.annotations[a.id], this.fire("annotationDestroyed", a.id) })), this.fire("annotationCreated", a.id), a } destroyAnnotation(e) { var t = this.annotations[e]; t ? t.destroy() : this.log("Annotation not found: " + e) } clear() { for (var e = Object.keys(this.annotations), t = 0, i = e.length; t < i; t++)this.destroyAnnotation(e[t]) } destroy() { this.clear(), super.destroy() } } const defaultCSS = ".sk-fading-circle {        background: transparent;        margin: 20px auto;        width: 50px;        height:50px;        position: relative;        }        .sk-fading-circle .sk-circle {        width: 120%;        height: 120%;        position: absolute;        left: 0;        top: 0;        }        .sk-fading-circle .sk-circle:before {        content: '';        display: block;        margin: 0 auto;        width: 15%;        height: 15%;        background-color: #ff8800;        border-radius: 100%;        -webkit-animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;        animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;        }        .sk-fading-circle .sk-circle2 {        -webkit-transform: rotate(30deg);        -ms-transform: rotate(30deg);        transform: rotate(30deg);    }    .sk-fading-circle .sk-circle3 {        -webkit-transform: rotate(60deg);        -ms-transform: rotate(60deg);        transform: rotate(60deg);    }    .sk-fading-circle .sk-circle4 {        -webkit-transform: rotate(90deg);        -ms-transform: rotate(90deg);        transform: rotate(90deg);    }    .sk-fading-circle .sk-circle5 {        -webkit-transform: rotate(120deg);        -ms-transform: rotate(120deg);        transform: rotate(120deg);    }    .sk-fading-circle .sk-circle6 {        -webkit-transform: rotate(150deg);        -ms-transform: rotate(150deg);        transform: rotate(150deg);    }    .sk-fading-circle .sk-circle7 {        -webkit-transform: rotate(180deg);        -ms-transform: rotate(180deg);        transform: rotate(180deg);    }    .sk-fading-circle .sk-circle8 {        -webkit-transform: rotate(210deg);        -ms-transform: rotate(210deg);        transform: rotate(210deg);    }    .sk-fading-circle .sk-circle9 {        -webkit-transform: rotate(240deg);        -ms-transform: rotate(240deg);        transform: rotate(240deg);    }    .sk-fading-circle .sk-circle10 {        -webkit-transform: rotate(270deg);        -ms-transform: rotate(270deg);        transform: rotate(270deg);    }    .sk-fading-circle .sk-circle11 {        -webkit-transform: rotate(300deg);        -ms-transform: rotate(300deg);        transform: rotate(300deg);    }    .sk-fading-circle .sk-circle12 {        -webkit-transform: rotate(330deg);        -ms-transform: rotate(330deg);        transform: rotate(330deg);    }    .sk-fading-circle .sk-circle2:before {        -webkit-animation-delay: -1.1s;        animation-delay: -1.1s;    }    .sk-fading-circle .sk-circle3:before {        -webkit-animation-delay: -1s;        animation-delay: -1s;    }    .sk-fading-circle .sk-circle4:before {        -webkit-animation-delay: -0.9s;        animation-delay: -0.9s;    }    .sk-fading-circle .sk-circle5:before {        -webkit-animation-delay: -0.8s;        animation-delay: -0.8s;    }    .sk-fading-circle .sk-circle6:before {        -webkit-animation-delay: -0.7s;        animation-delay: -0.7s;    }    .sk-fading-circle .sk-circle7:before {        -webkit-animation-delay: -0.6s;        animation-delay: -0.6s;    }    .sk-fading-circle .sk-circle8:before {        -webkit-animation-delay: -0.5s;        animation-delay: -0.5s;    }    .sk-fading-circle .sk-circle9:before {        -webkit-animation-delay: -0.4s;        animation-delay: -0.4s;    }    .sk-fading-circle .sk-circle10:before {        -webkit-animation-delay: -0.3s;        animation-delay: -0.3s;    }    .sk-fading-circle .sk-circle11:before {        -webkit-animation-delay: -0.2s;        animation-delay: -0.2s;    }    .sk-fading-circle .sk-circle12:before {        -webkit-animation-delay: -0.1s;        animation-delay: -0.1s;    }    @-webkit-keyframes sk-circleFadeDelay {        0%, 39%, 100% { opacity: 0; }        40% { opacity: 1; }    }    @keyframes sk-circleFadeDelay {        0%, 39%, 100% { opacity: 0; }        40% { opacity: 1; }    }"; class Spinner extends Component { get type() { return "Spinner" } constructor(e, t = {}) { super(e, t), this._canvas = t.canvas, this._element = null, this._isCustom = !1, t.elementId && (this._element = document.getElementById(t.elementId), this._element ? this._adjustPosition() : this.error("Can't find given Spinner HTML element: '" + t.elementId + "' - will automatically create default element")), this._element || this._createDefaultSpinner(), this.processes = 0 } _createDefaultSpinner() { this._injectDefaultCSS(); var e = document.createElement("div"), t = e.style; t["z-index"] = "9000", t.position = "absolute", e.innerHTML = '<div class="sk-fading-circle">                <div class="sk-circle1 sk-circle"></div>                <div class="sk-circle2 sk-circle"></div>                <div class="sk-circle3 sk-circle"></div>                <div class="sk-circle4 sk-circle"></div>                <div class="sk-circle5 sk-circle"></div>                <div class="sk-circle6 sk-circle"></div>                <div class="sk-circle7 sk-circle"></div>                <div class="sk-circle8 sk-circle"></div>                <div class="sk-circle9 sk-circle"></div>                <div class="sk-circle10 sk-circle"></div>                <div class="sk-circle11 sk-circle"></div>                <div class="sk-circle12 sk-circle"></div>                </div>', this._canvas.parentElement.appendChild(e), this._element = e, this._isCustom = !1, this._adjustPosition() } _injectDefaultCSS() { var e, t = "xeokit-spinner-css"; document.getElementById(t) || ((e = document.createElement("style")).innerHTML = defaultCSS, e.id = t, document.body.appendChild(e)) } _adjustPosition() { var e, t, i; this._isCustom || (e = this._canvas, (i = (t = this._element).style).left = e.offsetLeft + .5 * e.clientWidth - .5 * t.clientWidth + "px", i.top = e.offsetTop + .5 * e.clientHeight - .5 * t.clientHeight + "px") } set processes(e) { var t; this._processes === (e = e || 0) || e < 0 || (t = this._processes, this._processes = e, (e = this._element) && (e.style.visibility = 0 < this._processes ? "visible" : "hidden"), this.fire("processes", this._processes), 0 === this._processes && this._processes !== t && this.fire("zeroProcesses", this._processes)) } get processes() { return this._processes } _destroy() { this._element && !this._isCustom && (this._element.parentNode.removeChild(this._element), this._element = null); var e = document.getElementById("xeokit-spinner-css"); e && e.parentNode.removeChild(e) } } const WEBGL_CONTEXT_NAMES = ["webgl2", "experimental-webgl", "webkit-3d", "moz-webgl", "moz-glweb20"]; class Canvas extends Component { constructor(e, t = {}) { super(e, t), this._backgroundColor = math.vec3([t.backgroundColor ? t.backgroundColor[0] : 1, t.backgroundColor ? t.backgroundColor[1] : 1, t.backgroundColor ? t.backgroundColor[2] : 1]), this._backgroundColorFromAmbientLight = !!t.backgroundColorFromAmbientLight, this.canvas = t.canvas, this.gl = null, this.webgl2 = !1, this.transparent = !!t.transparent, this.optimizeResizeDetection = !0, this.contextAttr = t.contextAttr || {}, this.contextAttr.alpha = this.transparent, this.contextAttr.preserveDrawingBuffer = !!this.contextAttr.preserveDrawingBuffer, this.contextAttr.stencil = !1, this.contextAttr.premultipliedAlpha = !!this.contextAttr.premultipliedAlpha, this.contextAttr.antialias = !1 !== this.contextAttr.antialias, this.resolutionScale = t.resolutionScale, this.canvas.width = Math.round(this.canvas.clientWidth * this._resolutionScale), this.canvas.height = Math.round(this.canvas.clientHeight * this._resolutionScale), this.boundary = [this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight], this._initWebGL(t); const i = this; this.canvas.addEventListener("webglcontextlost", this._webglcontextlostListener = function (e) { console.time("webglcontextrestored"), i.scene._webglContextLost(), i.fire("webglcontextlost"), e.preventDefault() }, !1), this.canvas.addEventListener("webglcontextrestored", this._webglcontextrestoredListener = function (e) { i._initWebGL(), i.gl && (i.scene._webglContextRestored(i.gl), i.fire("webglcontextrestored", i.gl), e.preventDefault()), console.timeEnd("webglcontextrestored") }, !1); let s = null, r = null, a = null, o = null, n = null, h = null, l = null, c = null, u = 0; this._tick = this.scene.on("tick", (() => { if (u++, i._canvasSizeChanged = !1, !(i.optimizeResizeDetection && u < 10)) { u = 0; var e = this.canvas, t = this._resolutionScale !== s, p = window.innerWidth !== r || window.innerHeight !== a, d = e.clientWidth !== o || e.clientHeight !== n, m = e.offsetLeft !== h || e.offsetTop !== l, f = e.parentElement, g = f !== c; if (t || p || d || m || g) { if (i._canvasSizeChanged = !0, this._spinner._adjustPosition(), t || d || m) { g = e.clientWidth; var _, v = e.clientHeight; if (t || d) { let t = 0; for (const e in core.scenes) core.scenes.hasOwnProperty(e) && (_ = core.scenes[e], t += Math.round(_.canvas.canvas.clientWidth * this._resolutionScale * (_.canvas.canvas.clientHeight * this._resolutionScale))); stats.memory.pixels = t, e.width = Math.round(e.clientWidth * this._resolutionScale), e.height = Math.round(e.clientHeight * this._resolutionScale) } (d = this.boundary)[0] = e.offsetLeft, d[1] = e.offsetTop, d[2] = g, d[3] = v, t || this.fire("boundary", d), o = g, n = v } t && (s = this._resolutionScale), p && (r = window.innerWidth, a = window.innerHeight), m && (h = e.offsetLeft, l = e.offsetTop), c = f } } })), this._spinner = new Spinner(this.scene, { canvas: this.canvas, elementId: t.spinnerElementId }) } get type() { return "Canvas" } get backgroundColorFromAmbientLight() { return this._backgroundColorFromAmbientLight } set backgroundColorFromAmbientLight(e) { this._backgroundColorFromAmbientLight = !1 !== e, this.glRedraw() } get backgroundColor() { return this._backgroundColor } set backgroundColor(e) { e ? (this._backgroundColor[0] = e[0], this._backgroundColor[1] = e[1], this._backgroundColor[2] = e[2]) : (this._backgroundColor[0] = 1, this._backgroundColor[1] = 1, this._backgroundColor[2] = 1), this.glRedraw() } get resolutionScale() { return this._resolutionScale } set resolutionScale(e) { (e = e || 1) !== this._resolutionScale && (this._resolutionScale = e, (e = this.canvas).width = Math.round(e.clientWidth * this._resolutionScale), e.height = Math.round(e.clientHeight * this._resolutionScale), this.glRedraw()) } get spinner() { return this._spinner } _createCanvas() { var e = "xeokit-canvas-" + math.createUUID(), t = document.getElementsByTagName("body")[0], i = document.createElement("div"), s = i.style; s.height = "100%", s.width = "100%", s.padding = "0", s.margin = "0", s.background = "rgba(0,0,0,0);", s.float = "left", s.left = "0", s.top = "0", s.position = "absolute", s.opacity = "1.0", s["z-index"] = "-10000", i.innerHTML += '<canvas id="' + e + '" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>', t.appendChild(i), this.canvas = document.getElementById(e) } _getElementXY(e) { let t = 0, i = 0; for (; e;)t += e.offsetLeft - e.scrollLeft, i += e.offsetTop - e.scrollTop, e = e.offsetParent; return { x: t, y: i } } _initWebGL() { if (!this.gl) for (let e = 0; !this.gl && e < WEBGL_CONTEXT_NAMES.length; e++)try { this.gl = this.canvas.getContext(WEBGL_CONTEXT_NAMES[e], this.contextAttr) } catch (e) { } this.gl || (this.error("Failed to get a WebGL context"), this.fire("webglContextFailed", !0, !0)), this.gl && this.webgl2 && this.gl.hint(this.gl.FRAGMENT_SHADER_DERIVATIVE_HINT, this.gl.FASTEST) } getSnapshot(e) { throw "Canvas#getSnapshot() has been replaced by Viewer#getSnapshot() - use that method instead." } readPixels(e, t, i, s) { return this.scene._renderer.readPixels(e, t, i, s) } loseWebGLContext() { this.canvas.loseContext && this.canvas.loseContext() } destroy() { this.scene.off(this._tick), this._spinner._destroy(), this.canvas.removeEventListener("webglcontextlost", this._webglcontextlostListener), this.canvas.removeEventListener("webglcontextrestored", this._webglcontextrestoredListener), this.gl = null, super.destroy() } } class FrameContext { constructor(e) { this._scene = e, this._matPool = [], this._matPoolNextFreeIndex = 0, this._rtcViewMats = {}, this._rtcPickViewMats = {}, this.reset() } reset() { this._matPoolNextFreeIndex = 0, this._rtcViewMats = {}, this._rtcPickViewMats = {}, this.gl = this._scene.canvas.gl, this.lastProgramId = null, this.pbrEnabled = !1, this.colorTextureEnabled = !1, this.withSAO = !1, this.backfaces = !1, this.frontface = !0, this.textureUnit = 0, this.drawElements = 0, this.drawArrays = 0, this.useProgram = 0, this.bindTexture = 0, this.bindArray = 0, this.pass = 0, this.shadowViewMatrix = null, this.shadowProjMatrix = null, this.pickViewMatrix = null, this.pickProjMatrix = null, this.pickZNear = .01, this.pickZFar = 5e3, this.pickInvisible = !1, this.lineWidth = 1 } getRTCViewMatrix(e, t) { let i = this._rtcViewMats[e]; return i || (i = this._getNewMat(), createRTCViewMat(this._scene.camera.viewMatrix, t, i), this._rtcViewMats[e] = i), i } getRTCPickViewMatrix(e, t) { let i = this._rtcPickViewMats[e]; var s; return i || (i = this._getNewMat(), s = this.pickViewMatrix || this._scene.camera.viewMatrix, createRTCViewMat(s, t, i), this._rtcPickViewMats[e] = i), i } _getNewMat() { let e = this._matPool[this._matPoolNextFreeIndex]; return e || (e = math.mat4(), this._matPool[this._matPoolNextFreeIndex] = e), this._matPoolNextFreeIndex++, e } } class PickResult { constructor() { this.entity = null, this.primitive = null, this.primIndex = -1, this.pickSurfacePrecision = !1, this.touchInput = !1, this._canvasPos = new Int16Array([0, 0]), this._origin = new Float64Array([0, 0, 0]), this._direction = new Float64Array([0, 0, 0]), this._indices = new Int32Array(3), this._localPos = new Float64Array([0, 0, 0]), this._worldPos = new Float64Array([0, 0, 0]), this._viewPos = new Float64Array([0, 0, 0]), this._bary = new Float64Array([0, 0, 0]), this._worldNormal = new Float64Array([0, 0, 0]), this._uv = new Float64Array([0, 0]), this.reset() } get canvasPos() { return this._gotCanvasPos ? this._canvasPos : null } set canvasPos(e) { e ? (this._canvasPos[0] = e[0], this._canvasPos[1] = e[1], this._gotCanvasPos = !0) : this._gotCanvasPos = !1 } get origin() { return this._gotOrigin ? this._origin : null } set origin(e) { e ? (this._origin[0] = e[0], this._origin[1] = e[1], this._origin[2] = e[2], this._gotOrigin = !0) : this._gotOrigin = !1 } get direction() { return this._gotDirection ? this._direction : null } set direction(e) { e ? (this._direction[0] = e[0], this._direction[1] = e[1], this._direction[2] = e[2], this._gotDirection = !0) : this._gotDirection = !1 } get indices() { return this.entity && this._gotIndices ? this._indices : null } set indices(e) { e ? (this._indices[0] = e[0], this._indices[1] = e[1], this._indices[2] = e[2], this._gotIndices = !0) : this._gotIndices = !1 } get localPos() { return this.entity && this._gotLocalPos ? this._localPos : null } set localPos(e) { e ? (this._localPos[0] = e[0], this._localPos[1] = e[1], this._localPos[2] = e[2], this._gotLocalPos = !0) : this._gotLocalPos = !1 } get worldPos() { return this.entity && this._gotWorldPos ? this._worldPos : null } set worldPos(e) { e ? (this._worldPos[0] = e[0], this._worldPos[1] = e[1], this._worldPos[2] = e[2], this._gotWorldPos = !0) : this._gotWorldPos = !1 } get viewPos() { return this.entity && this._gotViewPos ? this._viewPos : null } set viewPos(e) { e ? (this._viewPos[0] = e[0], this._viewPos[1] = e[1], this._viewPos[2] = e[2], this._gotViewPos = !0) : this._gotViewPos = !1 } get bary() { return this.entity && this._gotBary ? this._bary : null } set bary(e) { e ? (this._bary[0] = e[0], this._bary[1] = e[1], this._bary[2] = e[2], this._gotBary = !0) : this._gotBary = !1 } get worldNormal() { return this.entity && this._gotWorldNormal ? this._worldNormal : null } set worldNormal(e) { e ? (this._worldNormal[0] = e[0], this._worldNormal[1] = e[1], this._worldNormal[2] = e[2], this._gotWorldNormal = !0) : this._gotWorldNormal = !1 } get uv() { return this.entity && this._gotUV ? this._uv : null } set uv(e) { e ? (this._uv[0] = e[0], this._uv[1] = e[1], this._gotUV = !0) : this._gotUV = !1 } reset() { this.entity = null, this.primIndex = -1, this.primitive = null, this.pickSurfacePrecision = !1, this._gotCanvasPos = !1, this._gotOrigin = !1, this._gotDirection = !1, this._gotIndices = !1, this._gotLocalPos = !1, this._gotWorldPos = !1, this._gotViewPos = !1, this._gotBary = !1, this._gotWorldNormal = !1, this._gotUV = !1, this.touchInput = !1 } } class OcclusionLayer { constructor(e, t) { this.scene = e, this.aabb = math.AABB3(), this.origin = math.vec3(t), this.originHash = this.origin.join(), this.numMarkers = 0, this.markers = {}, this.markerList = [], this.markerIndices = {}, this.positions = [], this.indices = [], this.positionsBuf = null, this.lenPositionsBuf = 0, this.indicesBuf = null, this.sectionPlanesActive = [], this.culledBySectionPlanes = !1, this.occlusionTestList = [], this.lenOcclusionTestList = 0, this.pixels = [], this.aabbDirty = !1, this.markerListDirty = !1, this.positionsDirty = !0, this.occlusionTestListDirty = !1 } addMarker(e) { this.markers[e.id] = e, this.markerListDirty = !0, this.numMarkers++ } markerWorldPosUpdated(e) { var t; this.markers[e.id] && (t = this.markerIndices[e.id], this.positions[3 * t + 0] = e.worldPos[0], this.positions[3 * t + 1] = e.worldPos[1], this.positions[3 * t + 2] = e.worldPos[2], this.positionsDirty = !0) } removeMarker(e) { delete this.markers[e.id], this.markerListDirty = !0, this.numMarkers-- } update() { this.markerListDirty && (this._buildMarkerList(), this.markerListDirty = !1, this.positionsDirty = !0, this.occlusionTestListDirty = !0), this.positionsDirty && (this._buildPositions(), this.positionsDirty = !1, this.aabbDirty = !0, this.vbosDirty = !0), this.aabbDirty && (this._buildAABB(), this.aabbDirty = !1), this.vbosDirty && (this._buildVBOs(), this.vbosDirty = !1), this.occlusionTestListDirty && this._buildOcclusionTestList(), this._updateActiveSectionPlanes() } _buildMarkerList() { for (var e in this.numMarkers = 0, this.markers) this.markers.hasOwnProperty(e) && (this.markerList[this.numMarkers] = this.markers[e], this.markerIndices[e] = this.numMarkers, this.numMarkers++); this.markerList.length = this.numMarkers } _buildPositions() { let e = 0; for (let i = 0; i < this.numMarkers; i++) { var t; this.markerList[i] && (t = this.markerList[i].worldPos, this.positions[e++] = t[0], this.positions[e++] = t[1], this.positions[e++] = t[2], this.indices[i] = i) } this.positions.length = 3 * this.numMarkers, this.indices.length = this.numMarkers } _buildAABB() { var e = this.aabb, t = (math.collapseAABB3(e), math.expandAABB3Points3(e, this.positions), this.origin); e[0] += t[0], e[1] += t[1], e[2] += t[2], e[3] += t[0], e[4] += t[1], e[5] += t[2] } _buildVBOs() { if (this.positionsBuf) { if (this.lenPositionsBuf === this.positions.length) return void this.positionsBuf.setData(this.positions); this.positionsBuf.destroy(), this.positionsBuf = null, this.indicesBuf.destroy(), this.indicesBuf = null } var e = this.scene.canvas.gl, t = 3 * this.numMarkers, i = this.numMarkers; this.positionsBuf = new ArrayBuf(e, e.ARRAY_BUFFER, new Float32Array(this.positions), t, 3, e.STATIC_DRAW), this.indicesBuf = new ArrayBuf(e, e.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), i, 1, e.STATIC_DRAW), this.lenPositionsBuf = this.positions.length } _buildOcclusionTestList() { var e = this.scene.canvas, t = this.scene.camera.perspective.near, i = (e = e.boundary)[2], s = e[3]; let r = 0; for (let e = this.lenOcclusionTestList = 0; e < this.numMarkers; e++) { var a, o, n = this.markerList[e]; n.viewPos[2] > -t || (a = (o = n.canvasPos)[0], o = o[1], a + 10 < 0) || o + 10 < 0 || i < a - 10 || s < o - 10 || n.entity && !n.entity.visible ? n._setVisible(!1) : n.occludable ? (this.occlusionTestList[this.lenOcclusionTestList++] = n, this.pixels[r++] = a, this.pixels[r++] = o) : n._setVisible(!0) } } _updateActiveSectionPlanes() { var e = this.scene._sectionPlanesState.sectionPlanes, t = e.length; if (0 < t) for (let s = 0; s < t; s++) { var i = e[s]; if (i.active) { if (-1 === (i = math.planeAABB3Intersect(i.dir, i.dist, this.aabb))) return void (this.culledBySectionPlanes = !0); this.sectionPlanesActive[s] = 0 === i } else this.sectionPlanesActive[s] = !1 } this.culledBySectionPlanes = !1 } destroy() { this.markers = {}, this.markerList.length = 0, this.positionsBuf && this.positionsBuf.destroy(), this.indicesBuf && this.indicesBuf.destroy() } } const MARKER_COLOR = math.vec3([1, 0, 0]), POINT_SIZE = 20, MARKER_SPRITE_CLIPZ_OFFSET = -.001, tempVec3a$9 = math.vec3(); class OcclusionTester { constructor(e, t) { this._scene = e, this._renderBufferManager = t, this._occlusionLayers = {}, this._occlusionLayersList = [], this._occlusionLayersListDirty = !1, this._shaderSource = null, this._program = null, this._shaderSourceHash = null, this._shaderSourceDirty = !0, this._programDirty = !1, this._markersToOcclusionLayersMap = {}, this._onCameraViewMatrix = e.camera.on("viewMatrix", (() => { this._occlusionTestListDirty = !0 })), this._onCameraProjMatrix = e.camera.on("projMatrix", (() => { this._occlusionTestListDirty = !0 })), this._onCanvasBoundary = e.canvas.on("boundary", (() => { this._occlusionTestListDirty = !0 })) } addMarker(e) { var t = e.origin.join(); let i = this._occlusionLayers[t]; i || (i = new OcclusionLayer(this._scene, e.origin), this._occlusionLayers[i.originHash] = i, this._occlusionLayersListDirty = !0), i.addMarker(e), this._markersToOcclusionLayersMap[e.id] = i, this._occlusionTestListDirty = !0 } markerWorldPosUpdated(e) { var t = this._markersToOcclusionLayersMap[e.id]; if (t) { var i = e.origin.join(); if (i !== t.originHash) { 1 === t.numMarkers ? (t.destroy(), delete this._occlusionLayers[t.originHash], this._occlusionLayersListDirty = !0) : t.removeMarker(e); let s = this._occlusionLayers[i]; s || (s = new OcclusionLayer(this._scene, e.origin), this._occlusionLayers[i] = t, this._occlusionLayersListDirty = !0), s.addMarker(e), this._markersToOcclusionLayersMap[e.id] = s } else t.markerWorldPosUpdated(e) } else e.error("Marker has not been added to OcclusionTester") } removeMarker(e) { var t = e.origin.join(); (t = this._occlusionLayers[t]) && (1 === t.numMarkers ? (t.destroy(), delete this._occlusionLayers[t.originHash], this._occlusionLayersListDirty = !0) : t.removeMarker(e), delete this._markersToOcclusionLayersMap[e.id]) } get needOcclusionTest() { return this._occlusionTestListDirty } bindRenderBuf() { var e = [this._scene.canvas.canvas.id, this._scene._sectionPlanesState.getHash()].join(";"); if (e !== this._shaderSourceHash && (this._shaderSourceHash = e, this._shaderSourceDirty = !0), this._shaderSourceDirty && (this._buildShaderSource(), this._shaderSourceDirty = !1, this._programDirty = !0), this._programDirty && (this._buildProgram(), this._programDirty = !1, this._occlusionTestListDirty = !0), this._occlusionLayersListDirty && (this._buildOcclusionLayersList(), this._occlusionLayersListDirty = !1), this._occlusionTestListDirty) { for (let e = 0, t = this._occlusionLayersList.length; e < t; e++)this._occlusionLayersList[e].occlusionTestListDirty = !0; this._occlusionTestListDirty = !1 } this._readPixelBuf = this._renderBufferManager.getRenderBuffer("occlusionReadPix"), this._readPixelBuf.bind(), this._readPixelBuf.clear() } _buildOcclusionLayersList() { let e = 0; for (var t in this._occlusionLayers) this._occlusionLayers.hasOwnProperty(t) && (this._occlusionLayersList[e++] = this._occlusionLayers[t]); this._occlusionLayersList.length = e } _buildShaderSource() { this._shaderSource = { vertex: this._buildVertexShaderSource(), fragment: this._buildFragmentShaderSource() } } _buildVertexShaderSource() { var e = this._scene, t = 0 < e._sectionPlanesState.sectionPlanes.length, i = []; return i.push("#version 300 es"), i.push("// OcclusionTester vertex shader"), i.push("in vec3 position;"), i.push("uniform mat4 modelMatrix;"), i.push("uniform mat4 viewMatrix;"), i.push("uniform mat4 projMatrix;"), e.logarithmicDepthBufferEnabled && (i.push("uniform float logDepthBufFC;"), i.push("out float vFragDepth;")), t && i.push("out vec4 vWorldPosition;"), i.push("void main(void) {"), i.push("vec4 worldPosition = vec4(position, 1.0); "), i.push("   vec4 viewPosition = viewMatrix * worldPosition;"), t && i.push("   vWorldPosition = worldPosition;"), i.push("   vec4 clipPos = projMatrix * viewPosition;"), i.push("   gl_PointSize = 20.0;"), e.logarithmicDepthBufferEnabled ? i.push("vFragDepth = 1.0 + clipPos.w;") : i.push("clipPos.z += -0.001;"), i.push("   gl_Position = clipPos;"), i.push("}"), i } _buildFragmentShaderSource() { var e = this._scene, t = e._sectionPlanesState, i = 0 < t.sectionPlanes.length, s = []; if (s.push("#version 300 es"), s.push("// OcclusionTester fragment shader"), s.push("#ifdef GL_FRAGMENT_PRECISION_HIGH"), s.push("precision highp float;"), s.push("precision highp int;"), s.push("#else"), s.push("precision mediump float;"), s.push("precision mediump int;"), s.push("#endif"), e.logarithmicDepthBufferEnabled && (s.push("uniform float logDepthBufFC;"), s.push("in float vFragDepth;")), i) { s.push("in vec4 vWorldPosition;"); for (let e = 0; e < t.sectionPlanes.length; e++)s.push("uniform bool sectionPlaneActive" + e + ";"), s.push("uniform vec3 sectionPlanePos" + e + ";"), s.push("uniform vec3 sectionPlaneDir" + e + ";") } if (s.push("out vec4 outColor;"), s.push("void main(void) {"), i) { s.push("  float dist = 0.0;"); for (var r = 0; r < t.sectionPlanes.length; r++)s.push("if (sectionPlaneActive" + r + ") {"), s.push("   dist += clamp(dot(-sectionPlaneDir" + r + ".xyz, vWorldPosition.xyz - sectionPlanePos" + r + ".xyz), 0.0, 1000.0);"), s.push("}"); s.push("  if (dist > 0.0) { discard; }") } return e.logarithmicDepthBufferEnabled && s.push("gl_FragDepth = log2( vFragDepth ) * logDepthBufFC * 0.5;"), s.push("   outColor = vec4(1.0, 0.0, 0.0, 1.0); "), s.push("}"), s } _buildProgram() { this._program && this._program.destroy(); var e = this._scene, t = e.canvas.gl, i = e._sectionPlanesState; if (this._program = new Program(t, this._shaderSource), this._program.errors) this.errors = this._program.errors; else { var s = this._program; this._uViewMatrix = s.getLocation("viewMatrix"), this._uProjMatrix = s.getLocation("projMatrix"), this._uSectionPlanes = []; for (let e = 0, t = i.sectionPlanes.length; e < t; e++)this._uSectionPlanes.push({ active: s.getLocation("sectionPlaneActive" + e), pos: s.getLocation("sectionPlanePos" + e), dir: s.getLocation("sectionPlaneDir" + e) }); this._aPosition = s.getAttribute("position"), e.logarithmicDepthBufferEnabled && (this._uLogDepthBufFC = s.getLocation("logDepthBufFC")) } } drawMarkers() { var e = this._scene, t = e.canvas.gl, i = this._program, s = e._sectionPlanesState, r = e.camera, a = e.camera.project; i.bind(), t.uniformMatrix4fv(this._uProjMatrix, !1, r._project._state.matrix), e.logarithmicDepthBufferEnabled && (i = 2 / (Math.log(a.far + 1) / Math.LN2), t.uniform1f(this._uLogDepthBufFC, i)); for (let e = 0, i = this._occlusionLayersList.length; e < i; e++) { var o = this._occlusionLayersList[e]; if (o.update(), !o.culledBySectionPlanes) { var n = o.origin, h = (t.uniformMatrix4fv(this._uViewMatrix, !1, createRTCViewMat(r.viewMatrix, n)), s.sectionPlanes.length); if (0 < h) { var l = s.sectionPlanes; for (let e = 0; e < h; e++) { var c, u = this._uSectionPlanes[e]; u && (c = o.sectionPlanesActive[e], t.uniform1i(u.active, c ? 1 : 0), c) && (c = l[e], t.uniform3fv(u.pos, getPlaneRTCPos(c.dist, c.dir, n, tempVec3a$9)), t.uniform3fv(u.dir, c.dir)) } } this._aPosition.bindArrayBuffer(o.positionsBuf); var p = o.indicesBuf; p.bind(), t.drawElements(t.POINTS, p.numItems, p.itemType, 0) } } } doOcclusionTest() { var e = this._scene.canvas.resolutionScale, t = 255 * MARKER_COLOR[0], i = 255 * MARKER_COLOR[1], s = 255 * MARKER_COLOR[2]; for (let n = 0, h = this._occlusionLayersList.length; n < h; n++) { var r = this._occlusionLayersList[n]; for (let n = 0; n < r.lenOcclusionTestList; n++) { var a = r.occlusionTestList[n], o = 2 * n; o = (o = this._readPixelBuf.read(Math.round(r.pixels[o] * e), Math.round(r.pixels[1 + o] * e)))[0] === t && o[1] === i && o[2] === s; a._setVisible(o) } } } unbindRenderBuf() { this._readPixelBuf.unbind() } destroy() { if (!this.destroyed) { for (let e = 0, t = this._occlusionLayersList.length; e < t; e++)this._occlusionLayersList[e].destroy(); this._program && this._program.destroy(), this._scene.camera.off(this._onCameraViewMatrix), this._scene.camera.off(this._onCameraProjMatrix), this._scene.canvas.off(this._onCanvasBoundary), this.destroyed = !0 } } } const tempVec2 = math.vec2(); class SAOOcclusionRenderer { constructor(e) { this._scene = e, this._numSamples = null, this._program = null, this._programError = !1, this._aPosition = null, this._aUV = null, this._uDepthTexture = "uDepthTexture", this._uCameraNear = null, this._uCameraFar = null, this._uCameraProjectionMatrix = null, this._uCameraInverseProjectionMatrix = null, this._uScale = null, this._uIntensity = null, this._uBias = null, this._uKernelRadius = null, this._uMinResolution = null, this._uRandomSeed = null, this._uvBuf = null, this._positionsBuf = null, this._indicesBuf = null } render(e) { if (this._build(), this._programError) return; this._getInverseProjectMat || (this._getInverseProjectMat = (() => { let e = !0; this._scene.camera.on("projMatrix", (function () { e = !0 })); const t = math.mat4(); return () => (e && math.inverseMat4(s.camera.projMatrix, t), t) })()); var t = this._scene.canvas.gl, i = this._program; const s = this._scene; var r = s.sao, a = t.drawingBufferWidth, o = t.drawingBufferHeight, n = (l = s.camera.project._state).near, h = l.far, l = l.matrix, c = this._getInverseProjectMat(), u = Math.random(), p = "perspective" === s.camera.projection; tempVec2[0] = a, tempVec2[1] = o, t.viewport(0, 0, a, o), t.clearColor(0, 0, 0, 1), t.disable(t.DEPTH_TEST), t.disable(t.BLEND), t.frontFace(t.CCW), t.clear(t.COLOR_BUFFER_BIT), i.bind(), t.uniform1f(this._uCameraNear, n), t.uniform1f(this._uCameraFar, h), t.uniformMatrix4fv(this._uCameraProjectionMatrix, !1, l), t.uniformMatrix4fv(this._uCameraInverseProjectionMatrix, !1, c), t.uniform1i(this._uPerspective, p), t.uniform1f(this._uScale, r.scale * (h / 5)), t.uniform1f(this._uIntensity, r.intensity), t.uniform1f(this._uBias, r.bias), t.uniform1f(this._uKernelRadius, r.kernelRadius), t.uniform1f(this._uMinResolution, r.minResolution), t.uniform2fv(this._uViewport, tempVec2), t.uniform1f(this._uRandomSeed, u), a = e.getDepthTexture(); i.bindTexture(this._uDepthTexture, a, 0), this._aUV.bindArrayBuffer(this._uvBuf), this._aPosition.bindArrayBuffer(this._positionsBuf), this._indicesBuf.bind(), t.drawElements(t.TRIANGLES, this._indicesBuf.numItems, this._indicesBuf.itemType, 0) } _build() { let e = !1; var t, i, s, r = this._scene.sao; r.numSamples !== this._numSamples && (this._numSamples = Math.floor(r.numSamples), e = !0), e && (r = this._scene.canvas.gl, this._program && (this._program.destroy(), this._program = null), this._program = new Program(r, { vertex: ["#version 300 es\n                    precision highp float;\n                    precision highp int;\n                    \n                    in vec3 aPosition;\n                    in vec2 aUV;            \n                    \n                    out vec2 vUV;\n                    \n                    void main () {\n                        gl_Position = vec4(aPosition, 1.0);\n                        vUV = aUV;\n                    }"], fragment: [`#version 300 es      \n                precision highp float;\n                precision highp int;           \n                \n                #define NORMAL_TEXTURE 0\n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n                #define NUM_SAMPLES ${this._numSamples}\n                #define NUM_RINGS 4              \n            \n                in vec2        vUV;\n            \n                uniform sampler2D   uDepthTexture;\n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;\n                uniform mat4        uProjectMatrix;\n                uniform mat4        uInverseProjectMatrix;\n                \n                uniform bool        uPerspective;\n\n                uniform float       uScale;\n                uniform float       uIntensity;\n                uniform float       uBias;\n                uniform float       uKernelRadius;\n                uniform float       uMinResolution;\n                uniform vec2        uViewport;\n                uniform float       uRandomSeed;\n\n                float pow2( const in float x ) { return x*x; }\n                \n                highp float rand( const in vec2 uv ) {\n                    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n                    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n                    return fract(sin(sn) * c);\n                }\n\n                vec3 packNormalToRGB( const in vec3 normal ) {\n                    return normalize( normal ) * 0.5 + 0.5;\n                }\n\n                vec3 unpackRGBToNormal( const in vec3 rgb ) {\n                    return 2.0 * rgb.xyz - 1.0;\n                }\n\n                const float packUpscale = 256. / 255.;\n                const float unpackDownScale = 255. / 256.; \n\n                const vec3 packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4 unPackFactors = unpackDownScale / vec4( packFactors, 1. );   \n\n                const float shiftRights = 1. / 256.;\n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float unpackRGBAToFloat( const in vec4 v ) {                   \n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unPackFactors );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n                    return ( near * far ) / ( ( far - near ) * invClipZ - far );\n                }\n\n                float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n                    return linearClipZ * ( near - far ) - near;\n                }\n                \n                float getDepth( const in vec2 screenPosition ) {\n                    return vec4(texture(uDepthTexture, screenPosition)).r;\n                }\n\n                float getViewZ( const in float depth ) {\n                     if (uPerspective) {\n                         return perspectiveDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     } else {\n                        return orthographicDepthToViewZ( depth, uCameraNear, uCameraFar );\n                     }\n                }\n\n                vec3 getViewPos( const in vec2 screenPos, const in float depth, const in float viewZ ) {\n                \tfloat clipW = uProjectMatrix[2][3] * viewZ + uProjectMatrix[3][3];\n                \tvec4 clipPosition = vec4( ( vec3( screenPos, depth ) - 0.5 ) * 2.0, 1.0 );\n                \tclipPosition *= clipW; \n                \treturn ( uInverseProjectMatrix * clipPosition ).xyz;\n                }\n\n                vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPos ) {               \n                    return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n                }\n\n                float scaleDividedByCameraFar;\n                float minResolutionMultipliedByCameraFar;\n\n                float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n                \tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n                \tfloat viewDistance = length( viewDelta );\n                \tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n                \treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - uBias) / (1.0 + pow2( scaledScreenDistance ) );\n                }\n\n                const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n                const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n                float getAmbientOcclusion( const in vec3 centerViewPosition ) {\n            \n                \tscaleDividedByCameraFar = uScale / uCameraFar;\n                \tminResolutionMultipliedByCameraFar = uMinResolution * uCameraFar;\n                \tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUV );\n\n                \tfloat angle = rand( vUV + uRandomSeed ) * PI2;\n                \tvec2 radius = vec2( uKernelRadius * INV_NUM_SAMPLES ) / uViewport;\n                \tvec2 radiusStep = radius;\n\n                \tfloat occlusionSum = 0.0;\n                \tfloat weightSum = 0.0;\n\n                \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n                \t\tvec2 sampleUv = vUV + vec2( cos( angle ), sin( angle ) ) * radius;\n                \t\tradius += radiusStep;\n                \t\tangle += ANGLE_STEP;\n\n                \t\tfloat sampleDepth = getDepth( sampleUv );\n                \t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n                \t\t\tcontinue;\n                \t\t}\n\n                \t\tfloat sampleViewZ = getViewZ( sampleDepth );\n                \t\tvec3 sampleViewPosition = getViewPos( sampleUv, sampleDepth, sampleViewZ );\n                \t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n                \t\tweightSum += 1.0;\n                \t}\n\n                \tif( weightSum == 0.0 ) discard;\n\n                \treturn occlusionSum * ( uIntensity / weightSum );\n                }\n\n                out vec4 outColor;\n   \n                void main() {\n                \n                \tfloat centerDepth = getDepth( vUV );\n                \t\n                \tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n                \t\tdiscard;\n                \t}\n\n                \tfloat centerViewZ = getViewZ( centerDepth );\n                \tvec3 viewPosition = getViewPos( vUV, centerDepth, centerViewZ );\n\n                \tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n                \n                \toutColor = packFloatToRGBA(  1.0- ambientOcclusion );\n                }`] }), this._program.errors ? (console.error(this._program.errors.join("\n")), this._programError = !0) : (t = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]), i = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]), s = new Uint8Array([0, 1, 2, 0, 2, 3]), this._positionsBuf = new ArrayBuf(r, r.ARRAY_BUFFER, i, i.length, 3, r.STATIC_DRAW), this._uvBuf = new ArrayBuf(r, r.ARRAY_BUFFER, t, t.length, 2, r.STATIC_DRAW), this._indicesBuf = new ArrayBuf(r, r.ELEMENT_ARRAY_BUFFER, s, s.length, 1, r.STATIC_DRAW), this._program.bind(), this._uCameraNear = this._program.getLocation("uCameraNear"), this._uCameraFar = this._program.getLocation("uCameraFar"), this._uCameraProjectionMatrix = this._program.getLocation("uProjectMatrix"), this._uCameraInverseProjectionMatrix = this._program.getLocation("uInverseProjectMatrix"), this._uPerspective = this._program.getLocation("uPerspective"), this._uScale = this._program.getLocation("uScale"), this._uIntensity = this._program.getLocation("uIntensity"), this._uBias = this._program.getLocation("uBias"), this._uKernelRadius = this._program.getLocation("uKernelRadius"), this._uMinResolution = this._program.getLocation("uMinResolution"), this._uViewport = this._program.getLocation("uViewport"), this._uRandomSeed = this._program.getLocation("uRandomSeed"), this._aPosition = this._program.getAttribute("aPosition"), this._aUV = this._program.getAttribute("aUV"), this._dirty = !1)) } destroy() { this._program && (this._program.destroy(), this._program = null) } } const blurStdDev = 4, blurDepthCutoff = .01, KERNEL_RADIUS = 16, sampleOffsetsVert = new Float32Array(createSampleOffsets(17, [0, 1])), sampleOffsetsHor = new Float32Array(createSampleOffsets(17, [1, 0])), sampleWeights = new Float32Array(createSampleWeights(17, 4)), tempVec2a$1 = new Float32Array(2); class SAODepthLimitedBlurRenderer { constructor(e) { this._scene = e, this._program = null, this._programError = !1, this._aPosition = null, this._aUV = null, this._uDepthTexture = "uDepthTexture", this._uOcclusionTexture = "uOcclusionTexture", this._uViewport = null, this._uCameraNear = null, this._uCameraFar = null, this._uCameraProjectionMatrix = null, this._uCameraInverseProjectionMatrix = null, this._uvBuf = null, this._positionsBuf = null, this._indicesBuf = null, this.init() } init() { var e, t, i, s = this._scene.canvas.gl; this._program = new Program(s, { vertex: ["#version 300 es\n                precision highp float;\n                precision highp int;\n                    \n                in vec3 aPosition;\n                in vec2 aUV;\n                uniform vec2 uViewport;\n                out vec2 vUV;\n                out vec2 vInvSize;\n                void main () {\n                    vUV = aUV;\n                    vInvSize = 1.0 / uViewport;\n                    gl_Position = vec4(aPosition, 1.0);\n                }"], fragment: ["#version 300 es\n                precision highp float;\n                precision highp int;\n                    \n                #define PI 3.14159265359\n                #define PI2 6.28318530718\n                #define EPSILON 1e-6\n\n                #define KERNEL_RADIUS 16\n\n                in vec2        vUV;\n                in vec2        vInvSize;\n            \n                uniform sampler2D   uDepthTexture;\n                uniform sampler2D   uOcclusionTexture;              \n               \n                uniform float       uCameraNear;\n                uniform float       uCameraFar;               \n                uniform float       uDepthCutoff;\n\n                uniform vec2        uSampleOffsets[ KERNEL_RADIUS + 1 ];\n                uniform float       uSampleWeights[ KERNEL_RADIUS + 1 ];\n\n                const float         unpackDownscale = 255. / 256.; \n\n                const vec3          packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n                const vec4          unpackFactors = unpackDownscale / vec4( packFactors, 1. );   \n\n                const float packUpscale = 256. / 255.;\n       \n                const float shiftRights = 1. / 256.;\n                \n                float unpackRGBAToFloat( const in vec4 v ) {\n                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unpackFactors );\n                }               \n\n                vec4 packFloatToRGBA( const in float v ) {\n                    vec4 r = vec4( fract( v * packFactors ), v );\n                    r.yzw -= r.xyz * shiftRights; \n                    return r * packUpscale;\n                }\n\n                float viewZToOrthographicDepth( const in float viewZ) {\n                    return ( viewZ + uCameraNear ) / ( uCameraNear - uCameraFar );\n                }\n              \n                float orthographicDepthToViewZ( const in float linearClipZ) {\n                    return linearClipZ * ( uCameraNear - uCameraFar ) - uCameraNear;\n                }\n\n                float viewZToPerspectiveDepth( const in float viewZ) {\n                    return (( uCameraNear + viewZ ) * uCameraFar ) / (( uCameraFar - uCameraNear ) * viewZ );\n                }\n                \n                float perspectiveDepthToViewZ( const in float invClipZ) {\n                    return ( uCameraNear * uCameraFar ) / ( ( uCameraFar - uCameraNear ) * invClipZ - uCameraFar );\n                }\n\n                float getDepth( const in vec2 screenPosition ) {\n                    return vec4(texture(uDepthTexture, screenPosition)).r;\n                }\n\n                float getViewZ( const in float depth ) {\n                     return perspectiveDepthToViewZ( depth );\n                }\n\n                out vec4 outColor;\n        \n                void main() {\n                \n                    float depth = getDepth( vUV );\n                    if( depth >= ( 1.0 - EPSILON ) ) {\n                        discard;\n                    }\n\n                    float centerViewZ = -getViewZ( depth );\n                    bool rBreak = false;\n                    bool lBreak = false;\n\n                    float weightSum = uSampleWeights[0];\n                    float occlusionSum = unpackRGBAToFloat(texture( uOcclusionTexture, vUV )) * weightSum;\n\n                    for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n                        float sampleWeight = uSampleWeights[i];\n                        vec2 sampleUVOffset = uSampleOffsets[i] * vInvSize;\n\n                        vec2 sampleUV = vUV + sampleUVOffset;\n                        float viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            rBreak = true;\n                        }\n\n                        if( ! rBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n\n                        sampleUV = vUV - sampleUVOffset;\n                        viewZ = -getViewZ( getDepth( sampleUV ) );\n\n                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {\n                            lBreak = true;\n                        }\n\n                        if( ! lBreak ) {\n                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;\n                            weightSum += sampleWeight;\n                        }\n                    }\n\n                    outColor = packFloatToRGBA(occlusionSum / weightSum);\n                }"] }), this._program.errors ? (console.error(this._program.errors.join("\n")), this._programError = !0) : (e = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]), t = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]), i = new Uint8Array([0, 1, 2, 0, 2, 3]), this._positionsBuf = new ArrayBuf(s, s.ARRAY_BUFFER, t, t.length, 3, s.STATIC_DRAW), this._uvBuf = new ArrayBuf(s, s.ARRAY_BUFFER, e, e.length, 2, s.STATIC_DRAW), this._indicesBuf = new ArrayBuf(s, s.ELEMENT_ARRAY_BUFFER, i, i.length, 1, s.STATIC_DRAW), this._program.bind(), this._uViewport = this._program.getLocation("uViewport"), this._uCameraNear = this._program.getLocation("uCameraNear"), this._uCameraFar = this._program.getLocation("uCameraFar"), this._uDepthCutoff = this._program.getLocation("uDepthCutoff"), this._uSampleOffsets = s.getUniformLocation(this._program.handle, "uSampleOffsets"), this._uSampleWeights = s.getUniformLocation(this._program.handle, "uSampleWeights"), this._aPosition = this._program.getAttribute("aPosition"), this._aUV = this._program.getAttribute("aUV")) } render(e, t, i) { if (this._programError) return; this._getInverseProjectMat || (this._getInverseProjectMat = (() => { let e = !0; this._scene.camera.on("projMatrix", (function () { e = !0 })); const t = math.mat4(); return () => (e && math.inverseMat4(a.camera.projMatrix, t), t) })()); var s = this._scene.canvas.gl, r = this._program; const a = this._scene; var o = s.drawingBufferWidth, n = s.drawingBufferHeight, h = (l = a.camera.project._state).near, l = l.far; s.viewport(0, 0, o, n), s.clearColor(0, 0, 0, 1), s.enable(s.DEPTH_TEST), s.disable(s.BLEND), s.frontFace(s.CCW), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), r.bind(), tempVec2a$1[0] = o, tempVec2a$1[1] = n, s.uniform2fv(this._uViewport, tempVec2a$1), s.uniform1f(this._uCameraNear, h), s.uniform1f(this._uCameraFar, l), s.uniform1f(this._uDepthCutoff, .01), 0 === i ? s.uniform2fv(this._uSampleOffsets, sampleOffsetsHor) : s.uniform2fv(this._uSampleOffsets, sampleOffsetsVert), s.uniform1fv(this._uSampleWeights, sampleWeights), o = e.getDepthTexture(), n = t.getTexture(); r.bindTexture(this._uDepthTexture, o, 0), r.bindTexture(this._uOcclusionTexture, n, 1), this._aUV.bindArrayBuffer(this._uvBuf), this._aPosition.bindArrayBuffer(this._positionsBuf), this._indicesBuf.bind(), s.drawElements(s.TRIANGLES, this._indicesBuf.numItems, this._indicesBuf.itemType, 0) } destroy() { this._program.destroy() } } function createSampleWeights(e, t) { var i = []; for (let s = 0; s <= e; s++)i.push(gaussian(s, t)); return i } function gaussian(e, t) { return Math.exp(-e * e / (t * t * 2)) / (Math.sqrt(2 * Math.PI) * t) } function createSampleOffsets(e, t) { var i = []; for (let s = 0; s <= e; s++)i.push(t[0] * s), i.push(t[1] * s); return i } class RenderBufferManager { constructor(e) { this.scene = e, this._renderBuffersBasic = {}, this._renderBuffersScaled = {} } getRenderBuffer(e, t) { var i = 1 === this.scene.canvas.resolutionScale ? this._renderBuffersBasic : this._renderBuffersScaled; let s = i[e]; return s || (s = new RenderBuffer(this.scene.canvas.canvas, this.scene.canvas.gl, t), i[e] = s), s } destroy() { for (var e in this._renderBuffersBasic) this._renderBuffersBasic[e].destroy(); for (var t in this._renderBuffersScaled) this._renderBuffersScaled[t].destroy() } } const Renderer = function (e, t) { t = t || {}; const i = new FrameContext(e), s = e.canvas.canvas, r = e.canvas.gl, a = !!t.transparent, o = t.alphaDepthMask, n = new Map$1({}); let h = {}, l = {}, c = !0, u = !0, p = !0, d = !0, m = !0, f = !0, g = !0, _ = !0; const v = new RenderBufferManager(e); let y = !1; const T = new SAOOcclusionRenderer(e), I = new SAODepthLimitedBlurRenderer(e); function E() { if (c) { for (var e in h) if (h.hasOwnProperty(e)) { var t, i = (e = h[e]).drawableMap, s = e.drawableListPreCull; let r = 0; for (t in i) i.hasOwnProperty(t) && (s[r++] = i[t]); s.length = r } c = !1, u = !0 } if (u) { for (var r in h) h.hasOwnProperty(r) && (r = h[r]).isStateSortable && r.drawableListPreCull.sort(r.stateSortCompare); u = !1, p = !0 } if (p) for (var a in h) if (h.hasOwnProperty(a)) { var o = (a = h[a]).drawableListPreCull, n = a.drawableList; let e = 0; for (let t = 0, i = o.length; t < i; t++) { var l = o[t]; l.rebuildRenderFlags(), l.renderFlags.culled || (n[e++] = l) } n.length = e } } this._occlusionTester = null, this.capabilities = { astcSupported: !!getExtension(r, "WEBGL_compressed_texture_astc"), etc1Supported: !0, etc2Supported: !!getExtension(r, "WEBGL_compressed_texture_etc"), dxtSupported: !!getExtension(r, "WEBGL_compressed_texture_s3tc"), bptcSupported: !!getExtension(r, "EXT_texture_compression_bptc"), pvrtcSupported: !(!getExtension(r, "WEBGL_compressed_texture_pvrtc") && !getExtension(r, "WEBKIT_WEBGL_compressed_texture_pvrtc")) }, this.setTransparentEnabled = function (e) { d = e, p = !0 }, this.setEdgesEnabled = function (e) { m = e, p = !0 }, this.setSAOEnabled = function (e) { f = e, p = !0 }, this.setPBREnabled = function (e) { g = e, p = !0 }, this.setColorTextureEnabled = function (e) { _ = e, p = !0 }, this.needStateSort = function () { u = !0 }, this.shadowsDirty = function () { }, this.imageDirty = function () { p = !0 }, this.webglContextLost = function () { }, this.webglContextRestored = function (e) { T.init(), I.init(), p = !0 }, this.addDrawable = function (e, t) { var i = t.type; if (i) { let s = h[i]; s || (s = { type: t.type, count: 0, isStateSortable: t.isStateSortable, stateSortCompare: t.stateSortCompare, drawableMap: {}, drawableListPreCull: [], drawableList: [] }, h[i] = s), s.count++, s.drawableMap[e] = t, l[e] = t, c = !0 } else console.error("Renderer#addDrawable() : drawable with ID " + e + " has no 'type' - ignoring") }, this.removeDrawable = function (e) { var t, i = l[e]; i ? (i = i.type, --(t = h[i]).count <= 0 ? delete h[i] : delete t.drawableMap[e], delete l[e], c = !0) : console.error("Renderer#removeDrawable() : drawable not found with ID " + e + " - ignoring") }, this.getPickID = function (e) { return n.addItem(e) }, this.putPickID = function (e) { n.removeItem(e) }, this.clear = function (t) { var i; r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), a ? r.clearColor(1, 1, 1, 1) : (i = e.canvas.backgroundColorFromAmbientLight ? this.lights.getAmbientColorAndIntensity() : e.canvas.backgroundColor, r.clearColor(i[0], i[1], i[2], 1)), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT) }, this.needsRender = function () { return p || c || u }, this.render = function (t) { if ((t = t || {}).force && (p = !0), E(), p) { var s = e.sao; if (f && s.possible) { s = t; var a, o = e.sao, n = v.getRenderBuffer("saoDepth", { depthTexture: !0 }), l = (n.bind(), n.clear(), s); for (a in i.reset(), i.pass = l.pass, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.frontFace(r.CCW), r.enable(r.CULL_FACE), r.depthMask(!0), !1 !== l.clear && r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), h) if (h.hasOwnProperty(a)) { var c = h[a].drawableList; for (let e = 0, t = c.length; e < t; e++) { var u = c[e]; !0 !== u.culled && !1 !== u.visible && u.drawDepth && u.renderFlags.colorOpaque && u.drawDepth(i) } } n.unbind(), (s = v.getRenderBuffer("saoOcclusion")).bind(), s.clear(), T.render(n), s.unbind(), o.blur && ((o = v.getRenderBuffer("saoOcclusion2")).bind(), o.clear(), I.render(n, s, 0), o.unbind(), s.bind(), s.clear(), I.render(n, o, 1), s.unbind()) } var d = e._lightsState.lights; for (let e = 0, t = d.length; e < t; e++) { var m = d[e]; if (m.castsShadow) { var g = void 0, _ = void 0, y = void 0; if (g = (g = m.castsShadow) && m.getShadowRenderBuf()) { for (var _ in g.bind(), i.reset(), i.backfaces = !0, i.frontface = !0, i.shadowViewMatrix = m.getShadowViewMatrix(), i.shadowProjMatrix = m.getShadowProjMatrix(), r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 1), r.enable(r.DEPTH_TEST), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), h) if (h.hasOwnProperty(_)) { var P = h[_].drawableList; for (let e = 0, t = P.length; e < t; e++)!1 !== (y = P[e]).visible && y.castsShadow && y.drawShadow && y.renderFlags.colorOpaque && y.drawShadow(i) } g.unbind() } } } C(t), stats.frame.frameCount++, p = !1 } }; const C = function () { const t = [], s = [], n = [], l = [], c = [], u = [], p = [], y = [], T = [], I = [], E = [], C = [], P = [], b = [], A = [], D = []; return function (R) { var F, w = e._lightsState.getAmbientColorAndIntensity(), M = (i.reset(), i.pass = R.pass, i.withSAO = !1, i.pbrEnabled = g && !!e.pbrEnabled, i.colorTextureEnabled = _ && !!e.colorTextureEnabled, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), a ? r.clearColor(0, 0, 0, 0) : (w = e.canvas.backgroundColorFromAmbientLight ? w : e.canvas.backgroundColor, r.clearColor(w[0], w[1], w[2], 1)), r.enable(r.DEPTH_TEST), r.frontFace(r.CCW), r.enable(r.CULL_FACE), r.depthMask(!0), r.lineWidth(1), i.lineWidth = 1, e.sao.possible); let S, x; f && M ? (w = v.getRenderBuffer("saoOcclusion"), i.occlusionTexture = w ? w.getTexture() : null) : i.occlusionTexture = null; var L; w = Date.now(); !1 !== R.clear && r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT); let O = 0, N = 0, B = 0, G = 0, U = 0, k = 0, V = 0, H = 0, j = 0, z = 0, W = 0, Y = 0, $ = 0, X = 0, K = 0, J = 0; for (L in h) if (h.hasOwnProperty(L)) { var Q, Z = h[L].drawableList; for (S = 0, F = Z.length; S < F; S++)!0 !== (x = Z[S]).culled && !1 !== x.visible && ((Q = x.renderFlags).colorOpaque && (f && M && x.saoEnabled ? t[O++] = x : x.drawColorOpaque(i)), d && Q.colorTransparent && (n[B++] = x), Q.xrayedSilhouetteTransparent && (p[V++] = x), Q.xrayedSilhouetteOpaque && (c[U++] = x), Q.highlightedSilhouetteTransparent && (E[W++] = x), Q.highlightedSilhouetteOpaque && (T[j++] = x), Q.selectedSilhouetteTransparent && (A[K++] = x), Q.selectedSilhouetteOpaque && (P[$++] = x), m && (Q.edgesOpaque && (s[N++] = x), Q.edgesTransparent) && (l[G++] = x), Q.selectedEdgesTransparent && (D[J++] = x), Q.selectedEdgesOpaque && (b[X++] = x), Q.xrayedEdgesTransparent && (y[H++] = x), Q.xrayedEdgesOpaque && (u[k++] = x), Q.highlightedEdgesTransparent && (C[Y++] = x), Q.highlightedEdgesOpaque) && (I[z++] = x) } if (0 < O) for (i.withSAO = !0, S = 0; S < O; S++)t[S].drawColorOpaque(i); if (0 < N) for (S = 0; S < N; S++)s[S].drawEdgesColorOpaque(i); if (0 < U) for (S = 0; S < U; S++)c[S].drawSilhouetteXRayed(i); if (0 < k) for (S = 0; S < k; S++)u[S].drawEdgesXRayed(i); if (0 < V || 0 < H || 0 < B || 0 < G) { if (r.enable(r.CULL_FACE), r.enable(r.BLEND), a ? (r.blendEquation(r.FUNC_ADD), r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA)) : (r.blendEquation(r.FUNC_ADD), r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA)), i.backfaces = !1, o || r.depthMask(!1), (0 < B || 0 < G) && r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), 0 < G) for (S = 0; S < G; S++)(x = l[S]).drawEdgesColorTransparent(i); if (0 < B) for (S = 0; S < B; S++)(x = n[S]).drawColorTransparent(i); if (0 < H) for (S = 0; S < H; S++)y[S].drawEdgesXRayed(i); if (0 < V) for (S = 0; S < V; S++)p[S].drawSilhouetteXRayed(i); r.disable(r.BLEND), o || r.depthMask(!0) } if (0 < j || 0 < z) { if (i.lastProgramId = null, e.highlightMaterial.glowThrough && r.clear(r.DEPTH_BUFFER_BIT), 0 < z) for (S = 0; S < z; S++)I[S].drawEdgesHighlighted(i); if (0 < j) for (S = 0; S < j; S++)T[S].drawSilhouetteHighlighted(i) } if (0 < W || 0 < Y || 0 < j) { if (i.lastProgramId = null, e.selectedMaterial.glowThrough && r.clear(r.DEPTH_BUFFER_BIT), r.enable(r.BLEND), a ? (r.blendEquation(r.FUNC_ADD), r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA)) : r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), r.enable(r.CULL_FACE), 0 < Y) for (S = 0; S < Y; S++)C[S].drawEdgesHighlighted(i); if (0 < W) for (S = 0; S < W; S++)E[S].drawSilhouetteHighlighted(i); r.disable(r.BLEND) } if (0 < $ || 0 < X) { if (i.lastProgramId = null, e.selectedMaterial.glowThrough && r.clear(r.DEPTH_BUFFER_BIT), 0 < X) for (S = 0; S < X; S++)b[S].drawEdgesSelected(i); if (0 < $) for (S = 0; S < $; S++)P[S].drawSilhouetteSelected(i) } if (0 < K || 0 < J) { if (i.lastProgramId = null, e.selectedMaterial.glowThrough && r.clear(r.DEPTH_BUFFER_BIT), r.enable(r.CULL_FACE), r.enable(r.BLEND), a ? (r.blendEquation(r.FUNC_ADD), r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA)) : r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), 0 < J) for (S = 0; S < J; S++)D[S].drawEdgesSelected(i); if (0 < K) for (S = 0; S < K; S++)A[S].drawSilhouetteSelected(i); r.disable(r.BLEND) } R = Date.now(); var q = stats.frame, ee = (q.renderTime = (R - w) / 1e3, q.drawElements = i.drawElements, q.drawArrays = i.drawArrays, q.useProgram = i.useProgram, q.bindTexture = i.bindTexture, q.bindArray = i.bindArray, WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS); for (let e = 0; e < ee; e++)r.activeTexture(r.TEXTURE0 + e); r.bindTexture(r.TEXTURE_CUBE_MAP, null), r.bindTexture(r.TEXTURE_2D, null); var te = WEBGL_INFO.MAX_VERTEX_ATTRIBS; for (let e = 0; e < te; e++)r.disableVertexAttribArray(e) } }(), P = (this.pick = function () { const t = math.vec3(), a = math.mat4(), o = math.mat4(), l = math.vec3(), c = math.vec3([0, 1, 0]), u = new PickResult, p = math.vec2(), d = math.vec3(), m = math.vec3(), f = math.vec3(), g = math.vec3(), _ = math.vec3(); return function (y, T = u) { T.reset(), E(); let I = null, C = null; T.pickSurface = y.pickSurface, y.canvasPos ? (d[0] = y.canvasPos[0], d[1] = y.canvasPos[1], I = e.camera.viewMatrix, C = e.camera.projMatrix, T.canvasPos = y.canvasPos) : (x = math.frustumMat4(-1, 1, -1, 1, .01, e.camera.project.far, a), y.matrix ? (I = y.matrix, C = x) : (m.set(y.origin || [0, 0, 0]), f.set(y.direction || [0, 0, 1]), S = math.addVec3(m, f, t), l[0] = Math.random(), l[1] = Math.random(), l[2] = Math.random(), math.normalizeVec3(l), math.cross3Vec3(f, l, c), I = math.lookAtMat4v(m, S, c, o), C = x, T.origin = m, T.direction = f), d[0] = .5 * s.clientWidth, d[1] = .5 * s.clientHeight); var b, A, D, R, F, w, M, S = v.getRenderBuffer("pick"), x = (S.bind(), function (t, s, a, o, l) { i.reset(), i.backfaces = !0, i.frontface = !0, i.pickViewMatrix = a, i.pickProjMatrix = o, i.pickInvisible = !!l.pickInvisible, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT); var c, u = l.includeEntityIds, p = l.excludeEntityIds; for (c in h) if (h.hasOwnProperty(c)) { var d = h[c].drawableList; for (let e = 0, t = d.length; e < t; e++) { var m = d[e]; !m.drawPickMesh || !0 === m.culled || !0 !== l.pickInvisible && !1 === m.visible || !1 === m.pickable || u && !u[m.id] || p && p[m.id] || m.drawPickMesh(i) } } if (a = e.canvas.resolutionScale, !((t = (o = t.read(Math.round(s[0] * a), Math.round(s[1] * a)))[0] + 256 * o[1] + 256 * o[2] * 256 + 256 * o[3] * 256 * 256) < 0)) return n.items[t] }(S, d, I, C, y)); return x && (b = x.delegatePickedEntity ? x.delegatePickedEntity() : x) ? (y.pickSurface && (y.pickSurfacePrecision && e.pickSurfacePrecisionEnabled ? (y.canvasPos && math.canvasPosToWorldRay(e.canvas.canvas, I, C, d, m, f), x.precisionRayPickSurface(m, f, g, _) && (T.worldPos = g, !1 !== y.pickSurfaceNormal && (T.worldNormal = _), T.pickSurfacePrecision = !0)) : x.canPickTriangle && x.canPickTriangle() ? (A = S, R = d, F = I, w = C, M = T, (D = x).drawPickTriangles && (i.reset(), i.backfaces = !0, i.frontface = !0, i.pickViewMatrix = F, i.pickProjMatrix = w, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), D.drawPickTriangles(i), F = e.canvas.resolutionScale, D = (w = A.read(Math.round(R[0] * F), Math.round(R[1] * F)))[0] + 256 * w[1] + 256 * w[2] * 256 + 256 * w[3] * 256 * 256, M.primIndex = D *= 3), x.pickTriangleSurface(I, C, T), T.pickSurfacePrecision = !1) : x.canPickWorldPos && x.canPickWorldPos() && (p[0] = e.camera.project.near, p[1] = e.camera.project.far, P(S, x, d, I, C, p, T), !1 !== y.pickSurfaceNormal && (A = S, R = x, F = d, w = I, M = C, D = T, i.reset(), i.backfaces = !0, i.frontface = !0, i.pickViewMatrix = w, i.pickProjMatrix = M, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), R.drawPickNormals(i), w = e.canvas.resolutionScale, R = [(M = A.read(Math.round(F[0] * w), Math.round(F[1] * w)))[0] / 256 - .5, M[1] / 256 - .5, M[2] / 256 - .5], math.normalizeVec3(R), D.worldNormal = R), T.pickSurfacePrecision = !1)), S.unbind(), T.entity = b, T) : (S.unbind(), null) } }(), function () { const t = math.vec4(), a = math.vec4(), o = math.vec4(), n = math.vec4(), h = math.vec4(), l = math.mat4(), c = math.mat4(), u = math.mat4(); return function (p, d, m, f, g, _, v) { i.reset(), i.backfaces = !0, i.frontface = !0, i.pickViewMatrix = f, i.pickProjMatrix = g, i.pickZNear = _[0], i.pickZFar = _[1], r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), d.drawPickDepths(i), _ = e.canvas.resolutionScale, y = [(y = p.read(Math.round(m[0] * _), Math.round(m[1] * _)))[0] / 256, y[1] / 256, y[2] / 256, y[3] / 256], p = math.dotVec4(y, [1 / 16777216, 1 / 65536, 1 / 256, 1]), _ = (m[0] - s.clientWidth / 2) / (s.clientWidth / 2), m = -(m[1] - s.clientHeight / 2) / (s.clientHeight / 2); var y = (d = d.origin) ? (T = createRTCViewMat(f, d, l), math.mulMat4(g, T, c)) : math.mulMat4(g, f, c), T = math.inverseMat4(y, u); t[0] = _, t[1] = m, t[2] = -1, t[3] = 1, g = math.transformVec4(T, t), g = math.mulVec4Scalar(g, 1 / g[3]), a[0] = _, a[1] = m, a[2] = 1, a[3] = 1, f = math.transformVec4(T, a), f = math.mulVec4Scalar(f, 1 / f[3]), _ = math.subVec3(f, g, o), m = math.addVec3(g, math.mulVec4Scalar(_, p, n), h); d && math.addVec3(m, d), v.worldPos = m } }()); this.addMarker = function (t) { this._occlusionTester = this._occlusionTester || new OcclusionTester(e, v), this._occlusionTester.addMarker(t), e.occlusionTestCountdown = 0 }, this.markerWorldPosUpdated = function (e) { this._occlusionTester.markerWorldPosUpdated(e) }, this.removeMarker = function (e) { this._occlusionTester.removeMarker(e) }, this.doOcclusionTest = function () { if (this._occlusionTester && this._occlusionTester.needOcclusionTest) { for (var e in E(), this._occlusionTester.bindRenderBuf(), i.reset(), i.backfaces = !0, i.frontface = !0, r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.clearColor(0, 0, 0, 0), r.enable(r.DEPTH_TEST), r.disable(r.CULL_FACE), r.disable(r.BLEND), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), h) if (h.hasOwnProperty(e)) { var t = h[e].drawableList; for (let e = 0, r = t.length; e < r; e++) { var s = t[e]; s.drawOcclusion && !0 !== s.culled && !1 !== s.visible && !1 !== s.pickable && s.drawOcclusion(i) } } this._occlusionTester.drawMarkers(i), this._occlusionTester.doOcclusionTest(), this._occlusionTester.unbindRenderBuf() } }, this.readPixels = function (e, t, i, s) { var r, a, o = v.getRenderBuffer("snapshot"); let n; for (o.bind(), o.clear(), this.render({ force: !0, opaqueOnly: s }), n = 0; n < i; n++)r = 2 * n, a = 4 * n, r = o.read(e[r], e[1 + r]), t[a] = r[0], t[1 + a] = r[1], t[2 + a] = r[2], t[3 + a] = r[3]; o.unbind(), p = !0 }, this.beginSnapshot = function () { var e = v.getRenderBuffer("snapshot"); e.bind(), e.clear(), y = !0 }, this.renderSnapshot = function () { y && (v.getRenderBuffer("snapshot").clear(), this.render({ force: !0, opaqueOnly: !1 }), p = !0) }, this.readSnapshot = function (e) { return v.getRenderBuffer("snapshot").readImage(e) }, this.endSnapshot = function () { y && (v.getRenderBuffer("snapshot").unbind(), y = !1) }, this.destroy = function () { h = {}, l = {}, v.destroy(), T.destroy(), I.destroy(), this._occlusionTester && this._occlusionTester.destroy() } }; class Input extends Component { constructor(e, t = {}) { super(e, t), this.KEY_BACKSPACE = 8, this.KEY_TAB = 9, this.KEY_ENTER = 13, this.KEY_SHIFT = 16, this.KEY_CTRL = 17, this.KEY_ALT = 18, this.KEY_PAUSE_BREAK = 19, this.KEY_CAPS_LOCK = 20, this.KEY_ESCAPE = 27, this.KEY_PAGE_UP = 33, this.KEY_PAGE_DOWN = 34, this.KEY_END = 35, this.KEY_HOME = 36, this.KEY_LEFT_ARROW = 37, this.KEY_UP_ARROW = 38, this.KEY_RIGHT_ARROW = 39, this.KEY_DOWN_ARROW = 40, this.KEY_INSERT = 45, this.KEY_DELETE = 46, this.KEY_NUM_0 = 48, this.KEY_NUM_1 = 49, this.KEY_NUM_2 = 50, this.KEY_NUM_3 = 51, this.KEY_NUM_4 = 52, this.KEY_NUM_5 = 53, this.KEY_NUM_6 = 54, this.KEY_NUM_7 = 55, this.KEY_NUM_8 = 56, this.KEY_NUM_9 = 57, this.KEY_A = 65, this.KEY_B = 66, this.KEY_C = 67, this.KEY_D = 68, this.KEY_E = 69, this.KEY_F = 70, this.KEY_G = 71, this.KEY_H = 72, this.KEY_I = 73, this.KEY_J = 74, this.KEY_K = 75, this.KEY_L = 76, this.KEY_M = 77, this.KEY_N = 78, this.KEY_O = 79, this.KEY_P = 80, this.KEY_Q = 81, this.KEY_R = 82, this.KEY_S = 83, this.KEY_T = 84, this.KEY_U = 85, this.KEY_V = 86, this.KEY_W = 87, this.KEY_X = 88, this.KEY_Y = 89, this.KEY_Z = 90, this.KEY_LEFT_WINDOW = 91, this.KEY_RIGHT_WINDOW = 92, this.KEY_SELECT_KEY = 93, this.KEY_NUMPAD_0 = 96, this.KEY_NUMPAD_1 = 97, this.KEY_NUMPAD_2 = 98, this.KEY_NUMPAD_3 = 99, this.KEY_NUMPAD_4 = 100, this.KEY_NUMPAD_5 = 101, this.KEY_NUMPAD_6 = 102, this.KEY_NUMPAD_7 = 103, this.KEY_NUMPAD_8 = 104, this.KEY_NUMPAD_9 = 105, this.KEY_MULTIPLY = 106, this.KEY_ADD = 107, this.KEY_SUBTRACT = 109, this.KEY_DECIMAL_POINT = 110, this.KEY_DIVIDE = 111, this.KEY_F1 = 112, this.KEY_F2 = 113, this.KEY_F3 = 114, this.KEY_F4 = 115, this.KEY_F5 = 116, this.KEY_F6 = 117, this.KEY_F7 = 118, this.KEY_F8 = 119, this.KEY_F9 = 120, this.KEY_F10 = 121, this.KEY_F11 = 122, this.KEY_F12 = 123, this.KEY_NUM_LOCK = 144, this.KEY_SCROLL_LOCK = 145, this.KEY_SEMI_COLON = 186, this.KEY_EQUAL_SIGN = 187, this.KEY_COMMA = 188, this.KEY_DASH = 189, this.KEY_PERIOD = 190, this.KEY_FORWARD_SLASH = 191, this.KEY_GRAVE_ACCENT = 192, this.KEY_OPEN_BRACKET = 219, this.KEY_BACK_SLASH = 220, this.KEY_CLOSE_BRACKET = 221, this.KEY_SINGLE_QUOTE = 222, this.KEY_SPACE = 32, this.element = t.element, this.altDown = !1, this.ctrlDown = !1, this.mouseDownLeft = !1, this.mouseDownMiddle = !1, this.mouseDownRight = !1, this.keyDown = [], this.enabled = !0, this.keyboardEnabled = !0, this.mouseover = !1, this.mouseCanvasPos = math.vec2(), this._keyboardEventsElement = t.keyboardEventsElement || document, this._bindEvents() } _bindEvents() { if (!this._eventsBound) { this._keyboardEventsElement.addEventListener("keydown", this._keyDownListener = e => { this.enabled && this.keyboardEnabled && "INPUT" !== e.target.tagName && "TEXTAREA" !== e.target.tagName && (e.keyCode === this.KEY_CTRL ? this.ctrlDown = !0 : e.keyCode === this.KEY_ALT ? this.altDown = !0 : e.keyCode === this.KEY_SHIFT && (this.shiftDown = !0), this.keyDown[e.keyCode] = !0, this.fire("keydown", e.keyCode, !0)) }, !1), this._keyboardEventsElement.addEventListener("keyup", this._keyUpListener = e => { this.enabled && this.keyboardEnabled && "INPUT" !== e.target.tagName && "TEXTAREA" !== e.target.tagName && (e.keyCode === this.KEY_CTRL ? this.ctrlDown = !1 : e.keyCode === this.KEY_ALT ? this.altDown = !1 : e.keyCode === this.KEY_SHIFT && (this.shiftDown = !1), this.keyDown[e.keyCode] = !1, this.fire("keyup", e.keyCode, !0)) }), this.element.addEventListener("mouseenter", this._mouseEnterListener = e => { this.enabled && (this.mouseover = !0, this._getMouseCanvasPos(e), this.fire("mouseenter", this.mouseCanvasPos, !0)) }), this.element.addEventListener("mouseleave", this._mouseLeaveListener = e => { this.enabled && (this.mouseover = !1, this._getMouseCanvasPos(e), this.fire("mouseleave", this.mouseCanvasPos, !0)) }), this.element.addEventListener("mousedown", this._mouseDownListener = e => { if (this.enabled) { switch (e.which) { case 1: this.mouseDownLeft = !0; break; case 2: this.mouseDownMiddle = !0; break; case 3: this.mouseDownRight = !0 }this._getMouseCanvasPos(e), this.element.focus(), this.fire("mousedown", this.mouseCanvasPos, !0), this.mouseover && e.preventDefault() } }), document.addEventListener("mouseup", this._mouseUpListener = e => { if (this.enabled) { switch (e.which) { case 1: this.mouseDownLeft = !1; break; case 2: this.mouseDownMiddle = !1; break; case 3: this.mouseDownRight = !1 }this.fire("mouseup", this.mouseCanvasPos, !0) } }, !0), document.addEventListener("click", this._clickListener = e => { if (this.enabled) { switch (e.which) { case 1: case 3: this.mouseDownLeft = !1, this.mouseDownRight = !1; break; case 2: this.mouseDownMiddle = !1 }this._getMouseCanvasPos(e), this.fire("click", this.mouseCanvasPos, !0), this.mouseover && e.preventDefault() } }), document.addEventListener("dblclick", this._dblClickListener = e => { if (this.enabled) { switch (e.which) { case 1: case 3: this.mouseDownLeft = !1, this.mouseDownRight = !1; break; case 2: this.mouseDownMiddle = !1 }this._getMouseCanvasPos(e), this.fire("dblclick", this.mouseCanvasPos, !0), this.mouseover && e.preventDefault() } }), this.element.addEventListener("mousemove", this._mouseMoveListener = e => { this.enabled && (this._getMouseCanvasPos(e), this.fire("mousemove", this.mouseCanvasPos, !0), this.mouseover) && e.preventDefault() }), this.element.addEventListener("wheel", this._mouseWheelListener = (e, t) => { this.enabled && (e = Math.max(-1, Math.min(1, 40 * -e.deltaY)), this.fire("mousewheel", e, !0)) }, { passive: !0 }); { let e, t; this.on("mousedown", (i => { e = i[0], t = i[1] })), this.on("mouseup", (i => { e >= i[0] - 2 && e <= i[0] + 2 && t >= i[1] - 2 && t <= i[1] + 2 && this.fire("mouseclicked", i, !0) })) } this._eventsBound = !0 } } _unbindEvents() { this._eventsBound && (this._keyboardEventsElement.removeEventListener("keydown", this._keyDownListener), this._keyboardEventsElement.removeEventListener("keyup", this._keyUpListener), this.element.removeEventListener("mouseenter", this._mouseEnterListener), this.element.removeEventListener("mouseleave", this._mouseLeaveListener), this.element.removeEventListener("mousedown", this._mouseDownListener), document.removeEventListener("mouseup", this._mouseDownListener), document.removeEventListener("click", this._clickListener), document.removeEventListener("dblclick", this._dblClickListener), this.element.removeEventListener("mousemove", this._mouseMoveListener), this.element.removeEventListener("wheel", this._mouseWheelListener), window.OrientationChangeEvent && window.removeEventListener("orientationchange", this._orientationchangedListener), window.DeviceMotionEvent && window.removeEventListener("devicemotion", this._deviceMotionListener), window.DeviceOrientationEvent && window.removeEventListener("deviceorientation", this._deviceOrientListener), this._eventsBound = !1) } _getMouseCanvasPos(e) { if (e) { let t = e.target, i = 0, s = 0; for (; t.offsetParent;)i += t.offsetLeft, s += t.offsetTop, t = t.offsetParent; this.mouseCanvasPos[0] = e.pageX - i, this.mouseCanvasPos[1] = e.pageY - s } else e = window.event, this.mouseCanvasPos[0] = e.x, this.mouseCanvasPos[1] = e.y } setEnabled(e) { this.enabled !== e && this.fire("enabled", this.enabled = e) } getEnabled() { return this.enabled } setKeyboardEnabled(e) { this.keyboardEnabled = e } getKeyboardEnabled() { return this.keyboardEnabled } destroy() { super.destroy(), this._unbindEvents() } } class Viewport extends Component { get type() { return "Viewport" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ boundary: [0, 0, 100, 100] }), this.boundary = t.boundary, this.autoBoundary = t.autoBoundary } set boundary(e) { var t; this._autoBoundary || (e = e || [0, 0, (t = this.scene.canvas.boundary)[2], t[3]], this._state.boundary = e, this.glRedraw(), this.fire("boundary", this._state.boundary)) } get boundary() { return this._state.boundary } set autoBoundary(e) { (e = !!e) !== this._autoBoundary && (this._autoBoundary = e, this._autoBoundary ? this._onCanvasSize = this.scene.canvas.on("boundary", (function (e) { var t = e[2]; e = e[3]; this._state.boundary = [0, 0, t, e], this.glRedraw(), this.fire("boundary", this._state.boundary) }), this) : this._onCanvasSize && (this.scene.canvas.off(this._onCanvasSize), this._onCanvasSize = null), this.fire("autoBoundary", this._autoBoundary)) } get autoBoundary() { return this._autoBoundary } _getState() { return this._state } destroy() { super.destroy(), this._state.destroy() } } class Perspective extends Component { get type() { return "Perspective" } constructor(e, t = {}) { super(e, t), this.camera = e, this._state = new RenderState({ matrix: math.mat4(), inverseMatrix: math.mat4(), transposedMatrix: math.mat4(), near: .1, far: 2e3 }), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this._fov = 60, this._canvasResized = this.scene.canvas.on("boundary", this._needUpdate, this), this.fov = t.fov, this.fovAxis = t.fovAxis, this.near = t.near, this.far = t.far } _update() { var e = (e = this.scene.viewport.boundary)[2] / e[3], t = this._fovAxis; let i = this._fov; ("x" === t || "min" === t && e < 1 || "max" === t && 1 < e) && (i /= e), i = Math.min(i, 120), math.perspectiveMat4(i * (Math.PI / 180), e, this._state.near, this._state.far, this._state.matrix), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.glRedraw(), this.fire("matrix", this._state.matrix) } set fov(e) { (e = null != e ? e : 60) !== this._fov && (this._fov = e, this._needUpdate(0), this.fire("fov", this._fov)) } get fov() { return this._fov } set fovAxis(e) { this._fovAxis !== (e = e || "min") && ("x" !== e && "y" !== e && "min" !== e && (this.error("Unsupported value for 'fovAxis': " + e + " - defaulting to 'min'"), e = "min"), this._fovAxis = e, this._needUpdate(0), this.fire("fovAxis", this._fovAxis)) } get fovAxis() { return this._fovAxis } set near(e) { this._state.near !== (e = null != e ? e : .1) && (this._state.near = e, this._needUpdate(0), this.fire("near", this._state.near)) } get near() { return this._state.near } set far(e) { this._state.far !== (e = null != e ? e : 2e3) && (this._state.far = e, this._needUpdate(0), this.fire("far", this._state.far)) } get far() { return this._state.far } get matrix() { return this._updateScheduled && this._doUpdate(), this._state.matrix } get inverseMatrix() { return this._updateScheduled && this._doUpdate(), this._inverseMatrixDirty && (math.inverseMat4(this._state.matrix, this._state.inverseMatrix), this._inverseMatrixDirty = !1), this._state.inverseMatrix } get transposedMatrix() { return this._updateScheduled && this._doUpdate(), this._transposedMatrixDirty && (math.transposeMat4(this._state.matrix, this._state.transposedMatrix), this._transposedMatrixDirty = !1), this._state.transposedMatrix } unproject(e, t, i, s, r) { var a = (o = this.scene.canvas.canvas).offsetWidth / 2, o = o.offsetHeight / 2; return i[0] = (e[0] - a) / a, i[1] = (e[1] - o) / o, i[2] = t, i[3] = 1, math.mulMat4v4(this.inverseMatrix, i, s), math.mulVec3Scalar(s, 1 / s[3]), s[3] = 1, s[1] *= -1, math.mulMat4v4(this.camera.inverseViewMatrix, s, r), r } destroy() { super.destroy(), this._state.destroy(), this.scene.canvas.off(this._canvasResized) } } class Ortho extends Component { get type() { return "Ortho" } constructor(e, t = {}) { super(e, t), this.camera = e, this._state = new RenderState({ matrix: math.mat4(), inverseMatrix: math.mat4(), transposedMatrix: math.mat4(), near: .1, far: 2e3 }), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.scale = t.scale, this.near = t.near, this.far = t.far, this._onCanvasBoundary = this.scene.canvas.on("boundary", this._needUpdate, this) } _update() { var e = this.scene, t = .5 * this._scale, i = (e = e.viewport.boundary)[2], s = i / (e = e[3]); let r, a, o, n; n = e < i ? (r = -t, a = t, o = t / s, -t / s) : (r = -t * s, a = t * s, -(o = t)), math.orthoMat4c(r, a, n, o, this._state.near, this._state.far, this._state.matrix), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.glRedraw(), this.fire("matrix", this._state.matrix) } set scale(e) { this._scale = e = (e = null == e ? 1 : e) <= 0 ? .01 : e, this._needUpdate(0), this.fire("scale", this._scale) } get scale() { return this._scale } set near(e) { this._state.near !== (e = null != e ? e : .1) && (this._state.near = e, this._needUpdate(0), this.fire("near", this._state.near)) } get near() { return this._state.near } set far(e) { this._state.far !== (e = null != e ? e : 2e3) && (this._state.far = e, this._needUpdate(0), this.fire("far", this._state.far)) } get far() { return this._state.far } get matrix() { return this._updateScheduled && this._doUpdate(), this._state.matrix } get inverseMatrix() { return this._updateScheduled && this._doUpdate(), this._inverseMatrixDirty && (math.inverseMat4(this._state.matrix, this._state.inverseMatrix), this._inverseMatrixDirty = !1), this._state.inverseMatrix } get transposedMatrix() { return this._updateScheduled && this._doUpdate(), this._transposedMatrixDirty && (math.transposeMat4(this._state.matrix, this._state.transposedMatrix), this._transposedMatrixDirty = !1), this._state.transposedMatrix } unproject(e, t, i, s, r) { var a = (o = this.scene.canvas.canvas).offsetWidth / 2, o = o.offsetHeight / 2; return i[0] = (e[0] - a) / a, i[1] = (e[1] - o) / o, i[2] = t, i[3] = 1, math.mulMat4v4(this.inverseMatrix, i, s), math.mulVec3Scalar(s, 1 / s[3]), s[3] = 1, s[1] *= -1, math.mulMat4v4(this.camera.inverseViewMatrix, s, r), r } destroy() { super.destroy(), this._state.destroy(), this.scene.canvas.off(this._onCanvasBoundary) } } class Frustum$1 extends Component { get type() { return "Frustum" } constructor(e, t = {}) { super(e, t), this.camera = e, this._state = new RenderState({ matrix: math.mat4(), inverseMatrix: math.mat4(), transposedMatrix: math.mat4(), near: .1, far: 1e4 }), this._left = -1, this._right = 1, this._bottom = -1, this._top = 1, this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.left = t.left, this.right = t.right, this.bottom = t.bottom, this.top = t.top, this.near = t.near, this.far = t.far } _update() { math.frustumMat4(this._left, this._right, this._bottom, this._top, this._state.near, this._state.far, this._state.matrix), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.glRedraw(), this.fire("matrix", this._state.matrix) } set left(e) { this._left = null != e ? e : -1, this._needUpdate(0), this.fire("left", this._left) } get left() { return this._left } set right(e) { this._right = null != e ? e : 1, this._needUpdate(0), this.fire("right", this._right) } get right() { return this._right } set top(e) { this._top = null != e ? e : 1, this._needUpdate(0), this.fire("top", this._top) } get top() { return this._top } set bottom(e) { this._bottom = null != e ? e : -1, this._needUpdate(0), this.fire("bottom", this._bottom) } get bottom() { return this._bottom } set near(e) { this._state.near = null != e ? e : .1, this._needUpdate(0), this.fire("near", this._state.near) } get near() { return this._state.near } set far(e) { this._state.far = null != e ? e : 1e4, this._needUpdate(0), this.fire("far", this._state.far) } get far() { return this._state.far } get matrix() { return this._updateScheduled && this._doUpdate(), this._state.matrix } get inverseMatrix() { return this._updateScheduled && this._doUpdate(), this._inverseMatrixDirty && (math.inverseMat4(this._state.matrix, this._state.inverseMatrix), this._inverseMatrixDirty = !1), this._state.inverseMatrix } get transposedMatrix() { return this._updateScheduled && this._doUpdate(), this._transposedMatrixDirty && (math.transposeMat4(this._state.matrix, this._state.transposedMatrix), this._transposedMatrixDirty = !1), this._state.transposedMatrix } unproject(e, t, i, s, r) { var a = (o = this.scene.canvas.canvas).offsetWidth / 2, o = o.offsetHeight / 2; return i[0] = (e[0] - a) / a, i[1] = (e[1] - o) / o, i[2] = t, i[3] = 1, math.mulMat4v4(this.inverseMatrix, i, s), math.mulVec3Scalar(s, 1 / s[3]), s[3] = 1, s[1] *= -1, math.mulMat4v4(this.camera.inverseViewMatrix, s, r), r } destroy() { super.destroy(), this._state.destroy(), super.destroy() } } class CustomProjection extends Component { get type() { return "CustomProjection" } constructor(e, t = {}) { super(e, t), this.camera = e, this._state = new RenderState({ matrix: math.mat4(), inverseMatrix: math.mat4(), transposedMatrix: math.mat4() }), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !1, this.matrix = t.matrix } set matrix(e) { this._state.matrix.set(e || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this._inverseMatrixDirty = !0, this._transposedMatrixDirty = !0, this.glRedraw(), this.fire("matrix", this._state.matrix) } get matrix() { return this._state.matrix } get inverseMatrix() { return this._updateScheduled && this._doUpdate(), this._inverseMatrixDirty && (math.inverseMat4(this._state.matrix, this._state.inverseMatrix), this._inverseMatrixDirty = !1), this._state.inverseMatrix } get transposedMatrix() { return this._updateScheduled && this._doUpdate(), this._transposedMatrixDirty && (math.transposeMat4(this._state.matrix, this._state.transposedMatrix), this._transposedMatrixDirty = !1), this._state.transposedMatrix } unproject(e, t, i, s, r) { var a = (o = this.scene.canvas.canvas).offsetWidth / 2, o = o.offsetHeight / 2; return i[0] = (e[0] - a) / a, i[1] = (e[1] - o) / o, i[2] = t, i[3] = 1, math.mulMat4v4(this.inverseMatrix, i, s), math.mulVec3Scalar(s, 1 / s[3]), s[3] = 1, s[1] *= -1, math.mulMat4v4(this.camera.inverseViewMatrix, s, r), r } destroy() { super.destroy(), this._state.destroy() } } const tempVec3$3 = math.vec3(), tempVec3b$6 = math.vec3(), tempVec3c$5 = math.vec3(), tempVec3d$1 = math.vec3(), tempVec3e = math.vec3(), tempVec3f = math.vec3(), tempMat = math.mat4(), tempMatb = math.mat4(), eyeLookVec = math.vec3(), eyeLookVecNorm = math.vec3(), eyeLookOffset = math.vec3(), offsetEye = math.vec3(); class Camera extends Component { get type() { return "Camera" } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ deviceMatrix: math.mat4(), hasDeviceMatrix: !1, matrix: math.mat4(), normalMatrix: math.mat4(), inverseMatrix: math.mat4() }), this._perspective = new Perspective(this), this._ortho = new Ortho(this), this._frustum = new Frustum$1(this), this._customProjection = new CustomProjection(this), this._project = this._perspective, this._eye = math.vec3([0, 0, 10]), this._look = math.vec3([0, 0, 0]), this._up = math.vec3([0, 1, 0]), this._worldUp = math.vec3([0, 1, 0]), this._worldRight = math.vec3([1, 0, 0]), this._worldForward = math.vec3([0, 0, -1]), this.deviceMatrix = t.deviceMatrix, this.eye = t.eye, this.look = t.look, this.up = t.up, this.worldAxis = t.worldAxis, this.gimbalLock = t.gimbalLock, this.constrainPitch = t.constrainPitch, this.projection = t.projection, this._perspective.on("matrix", (() => { "perspective" === this._projectionType && this.fire("projMatrix", this._perspective.matrix) })), this._ortho.on("matrix", (() => { "ortho" === this._projectionType && this.fire("projMatrix", this._ortho.matrix) })), this._frustum.on("matrix", (() => { "frustum" === this._projectionType && this.fire("projMatrix", this._frustum.matrix) })), this._customProjection.on("matrix", (() => { "customProjection" === this._projectionType && this.fire("projMatrix", this._customProjection.matrix) })) } _update() { var e = this._state, t = "ortho" === this.projection ? (math.subVec3(this._eye, this._look, eyeLookVec), math.normalizeVec3(eyeLookVec, eyeLookVecNorm), math.mulVec3Scalar(eyeLookVecNorm, 1e3, eyeLookOffset), math.addVec3(this._look, eyeLookOffset, offsetEye), offsetEye) : this._eye; e.hasDeviceMatrix ? (math.lookAtMat4v(t, this._look, this._up, tempMatb), math.mulMat4(e.deviceMatrix, tempMatb, e.matrix)) : math.lookAtMat4v(t, this._look, this._up, e.matrix), math.inverseMat4(this._state.matrix, this._state.inverseMatrix), math.transposeMat4(this._state.inverseMatrix, this._state.normalMatrix), this.glRedraw(), this.fire("matrix", this._state.matrix), this.fire("viewMatrix", this._state.matrix) } orbitYaw(e) { var t = math.subVec3(this._eye, this._look, tempVec3$3); math.rotationMat4v(.0174532925 * e, this._gimbalLock ? this._worldUp : this._up, tempMat), t = math.transformPoint3(tempMat, t, tempVec3b$6), this.eye = math.addVec3(this._look, t, tempVec3c$5), this.up = math.transformPoint3(tempMat, this._up, tempVec3d$1) } orbitPitch(e) { var t, i; this._constrainPitch && (e = math.dotVec3(this._up, this._worldUp) / math.DEGTORAD) < 1 || (t = math.subVec3(this._eye, this._look, tempVec3$3), i = math.cross3Vec3(math.normalizeVec3(t, tempVec3b$6), math.normalizeVec3(this._up, tempVec3c$5)), math.rotationMat4v(.0174532925 * e, i, tempMat), t = math.transformPoint3(tempMat, t, tempVec3d$1), this.up = math.transformPoint3(tempMat, this._up, tempVec3e), this.eye = math.addVec3(t, this._look, tempVec3f)) } yaw(e) { var t = math.subVec3(this._look, this._eye, tempVec3$3); math.rotationMat4v(.0174532925 * e, this._gimbalLock ? this._worldUp : this._up, tempMat), t = math.transformPoint3(tempMat, t, tempVec3b$6), this.look = math.addVec3(t, this._eye, tempVec3c$5), this._gimbalLock && (this.up = math.transformPoint3(tempMat, this._up, tempVec3d$1)) } pitch(e) { var t, i; this._constrainPitch && (e = math.dotVec3(this._up, this._worldUp) / math.DEGTORAD) < 1 || (t = math.subVec3(this._look, this._eye, tempVec3$3), i = math.cross3Vec3(math.normalizeVec3(t, tempVec3b$6), math.normalizeVec3(this._up, tempVec3c$5)), math.rotationMat4v(.0174532925 * e, i, tempMat), this.up = math.transformPoint3(tempMat, this._up, tempVec3f), t = math.transformPoint3(tempMat, t, tempVec3d$1), this.look = math.addVec3(t, this._eye, tempVec3e)) } pan(e) { var t, i = math.subVec3(this._eye, this._look, tempVec3$3), s = [0, 0, 0]; let r; 0 !== e[0] && (t = math.cross3Vec3(math.normalizeVec3(i, []), math.normalizeVec3(this._up, tempVec3b$6)), r = math.mulVec3Scalar(t, e[0]), s[0] += r[0], s[1] += r[1], s[2] += r[2]), 0 !== e[1] && (r = math.mulVec3Scalar(math.normalizeVec3(this._up, tempVec3c$5), e[1]), s[0] += r[0], s[1] += r[1], s[2] += r[2]), 0 !== e[2] && (r = math.mulVec3Scalar(math.normalizeVec3(i, tempVec3d$1), e[2]), s[0] += r[0], s[1] += r[1], s[2] += r[2]), this.eye = math.addVec3(this._eye, s, tempVec3e), this.look = math.addVec3(this._look, s, tempVec3f) } zoom(e) { var t = math.subVec3(this._eye, this._look, tempVec3$3), i = Math.abs(math.lenVec3(t, tempVec3b$6)); (i = Math.abs(i + e)) < .5 || (e = math.normalizeVec3(t, tempVec3c$5), this.eye = math.addVec3(this._look, math.mulVec3Scalar(e, i), tempVec3d$1)) } set eye(e) { this._eye.set(e || [0, 0, 10]), this._needUpdate(0), this.fire("eye", this._eye) } get eye() { return this._eye } set look(e) { this._look.set(e || [0, 0, 0]), this._needUpdate(0), this.fire("look", this._look) } get look() { return this._look } set up(e) { this._up.set(e || [0, 1, 0]), this._needUpdate(0), this.fire("up", this._up) } get up() { return this._up } set deviceMatrix(e) { this._state.deviceMatrix.set(e || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this._state.hasDeviceMatrix = !!e, this._needUpdate(0), this.fire("deviceMatrix", this._state.deviceMatrix) } get deviceMatrix() { return this._state.deviceMatrix } set worldAxis(e) { e = e || [1, 0, 0, 0, 1, 0, 0, 0, 1], this._worldAxis ? this._worldAxis.set(e) : this._worldAxis = math.vec3(e), this._worldRight[0] = this._worldAxis[0], this._worldRight[1] = this._worldAxis[1], this._worldRight[2] = this._worldAxis[2], this._worldUp[0] = this._worldAxis[3], this._worldUp[1] = this._worldAxis[4], this._worldUp[2] = this._worldAxis[5], this._worldForward[0] = this._worldAxis[6], this._worldForward[1] = this._worldAxis[7], this._worldForward[2] = this._worldAxis[8], this.fire("worldAxis", this._worldAxis) } get worldAxis() { return this._worldAxis } get worldUp() { return this._worldUp } get xUp() { return this._worldUp[0] > this._worldUp[1] && this._worldUp[0] > this._worldUp[2] } get yUp() { return this._worldUp[1] > this._worldUp[0] && this._worldUp[1] > this._worldUp[2] } get zUp() { return this._worldUp[2] > this._worldUp[0] && this._worldUp[2] > this._worldUp[1] } get worldRight() { return this._worldRight } get worldForward() { return this._worldForward } set gimbalLock(e) { this._gimbalLock = !1 !== e, this.fire("gimbalLock", this._gimbalLock) } get gimbalLock() { return this._gimbalLock } set constrainPitch(e) { this._constrainPitch = !!e, this.fire("constrainPitch", this._constrainPitch) } get eyeLookDist() { return math.lenVec3(math.subVec3(this._look, this._eye, tempVec3$3)) } get matrix() { return this._updateScheduled && this._doUpdate(), this._state.matrix } get viewMatrix() { return this._updateScheduled && this._doUpdate(), this._state.matrix } get normalMatrix() { return this._updateScheduled && this._doUpdate(), this._state.normalMatrix } get viewNormalMatrix() { return this._updateScheduled && this._doUpdate(), this._state.normalMatrix } get inverseViewMatrix() { return this._updateScheduled && this._doUpdate(), this._state.inverseMatrix } get projMatrix() { return this[this.projection].matrix } get perspective() { return this._perspective } get ortho() { return this._ortho } get frustum() { return this._frustum } get customProjection() { return this._customProjection } set projection(e) { this._projectionType !== (e = e || "perspective") && ("perspective" === e ? this._project = this._perspective : "ortho" === e ? this._project = this._ortho : "frustum" === e ? this._project = this._frustum : "customProjection" === e ? this._project = this._customProjection : (this.error("Unsupported value for 'projection': " + e + " defaulting to 'perspective'"), this._project = this._perspective, e = "perspective"), this._project._update(), this._projectionType = e, this.glRedraw(), this._update(), this.fire("dirty"), this.fire("projection", this._projectionType), this.fire("projMatrix", this._project.matrix)) } get projection() { return this._projectionType } get project() { return this._project } destroy() { super.destroy(), this._state.destroy() } } const unitsInfo = { meters: { abbrev: "m" }, metres: { abbrev: "m" }, centimeters: { abbrev: "cm" }, centimetres: { abbrev: "cm" }, millimeters: { abbrev: "mm" }, millimetres: { abbrev: "mm" }, yards: { abbrev: "yd" }, feet: { abbrev: "ft" }, inches: { abbrev: "in" } }; class Metrics extends Component { constructor(e, t = {}) { super(e, t), this._units = "meters", this._scale = 1, this._origin = math.vec3([0, 0, 0]), this.units = t.units, this.scale = t.scale, this.origin = t.origin } get unitsInfo() { return unitsInfo } set units(e) { unitsInfo[e = e || "meters"] || (this.error("Unsupported value for 'units': " + e + " defaulting to 'meters'"), e = "meters"), this._units = e, this.fire("units", this._units) } get units() { return this._units } set scale(e) { (e = e || 1) <= 0 ? this.error("scale value should be larger than zero") : (this._scale = e, this.fire("scale", this._scale)) } get scale() { return this._scale } set origin(e) { e ? (this._origin[0] = e[0], this._origin[1] = e[1], this._origin[2] = e[2], this.fire("origin", this._origin)) : (this._origin[0] = 0, this._origin[1] = 0, this._origin[2] = 0) } get origin() { return this._origin } worldToRealPos(e, t = math.vec3(3)) { t[0] = this._origin[0] + this._scale * e[0], t[1] = this._origin[1] + this._scale * e[1], t[2] = this._origin[2] + this._scale * e[2] } realToWorldPos(e, t = math.vec3(3)) { return t[0] = (e[0] - this._origin[0]) / this._scale, t[1] = (e[1] - this._origin[1]) / this._scale, t[2] = (e[2] - this._origin[2]) / this._scale, t } } class SAO extends Component { constructor(e, t = {}) { super(e, t), e = (e = navigator.userAgent.match(/(opera|chrome|safari|firefox|msie|mobile)\/?\s*(\.?\d+(\.\d+)*)/i)) && "safari" === e[1].toLowerCase(), this._supported = !e && WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_standard_derivatives, this.enabled = t.enabled, this.kernelRadius = t.kernelRadius, this.intensity = t.intensity, this.bias = t.bias, this.scale = t.scale, this.minResolution = t.minResolution, this.numSamples = t.numSamples, this.blur = t.blur, this.blendCutoff = t.blendCutoff, this.blendFactor = t.blendFactor } get supported() { return this._supported } set enabled(e) { this._enabled !== (e = !!e) && (this._enabled = e, this.glRedraw()) } get enabled() { return this._enabled } get possible() { var e; return !!this._supported && !!this._enabled && "customProjection" !== (e = this.scene.camera.projection) && "frustum" !== e } get active() { return this._active } set kernelRadius(e) { this._kernelRadius !== (e = null == e ? 100 : e) && (this._kernelRadius = e, this.glRedraw()) } get kernelRadius() { return this._kernelRadius } set intensity(e) { this._intensity !== (e = null == e ? .15 : e) && (this._intensity = e, this.glRedraw()) } get intensity() { return this._intensity } set bias(e) { this._bias !== (e = null == e ? .5 : e) && (this._bias = e, this.glRedraw()) } get bias() { return this._bias } set scale(e) { this._scale !== (e = null == e ? 1 : e) && (this._scale = e, this.glRedraw()) } get scale() { return this._scale } set minResolution(e) { this._minResolution !== (e = null == e ? 0 : e) && (this._minResolution = e, this.glRedraw()) } get minResolution() { return this._minResolution } set numSamples(e) { this._numSamples !== (e = null == e ? 10 : e) && (this._numSamples = e, this.glRedraw()) } get numSamples() { return this._numSamples } set blur(e) { this._blur !== (e = !1 !== e) && (this._blur = e, this.glRedraw()) } get blur() { return this._blur } set blendCutoff(e) { this._blendCutoff !== (e = null == e ? .3 : e) && (this._blendCutoff = e, this.glRedraw()) } get blendCutoff() { return this._blendCutoff } set blendFactor(e) { this._blendFactor !== (e = null == e ? 1 : e) && (this._blendFactor = e, this.glRedraw()) } get blendFactor() { return this._blendFactor } destroy() { super.destroy() } } const PRESETS$1 = { default: { pointSize: 4, roundPoints: !0, perspectivePoints: !0 }, square: { pointSize: 4, roundPoints: !1, perspectivePoints: !0 }, round: { pointSize: 4, roundPoints: !0, perspectivePoints: !0 } }; class PointsMaterial extends Material { get type() { return "PointsMaterial" } get presets() { return PRESETS$1 } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "PointsMaterial", pointSize: null, roundPoints: null, perspectivePoints: null, minPerspectivePointSize: null, maxPerspectivePointSize: null, filterIntensity: null, minIntensity: null, maxIntensity: null }), t.preset ? (this.preset = t.preset, void 0 !== t.pointSize && (this.pointSize = t.pointSize), void 0 !== t.roundPoints && (this.roundPoints = t.roundPoints), void 0 !== t.perspectivePoints && (this.perspectivePoints = t.perspectivePoints), void 0 !== t.minPerspectivePointSize && (this.minPerspectivePointSize = t.minPerspectivePointSize), void 0 !== t.maxPerspectivePointSize && (this.maxPerspectivePointSize = t.minPerspectivePointSize)) : (this._preset = "default", this.pointSize = t.pointSize, this.roundPoints = t.roundPoints, this.perspectivePoints = t.perspectivePoints, this.minPerspectivePointSize = t.minPerspectivePointSize, this.maxPerspectivePointSize = t.maxPerspectivePointSize), this.filterIntensity = t.filterIntensity, this.minIntensity = t.minIntensity, this.maxIntensity = t.maxIntensity } set pointSize(e) { this._state.pointSize = e || 2, this.glRedraw() } get pointSize() { return this._state.pointSize } set roundPoints(e) { this._state.roundPoints !== (e = !1 !== e) && (this._state.roundPoints = e, this.scene._needRecompile = !0, this.glRedraw()) } get roundPoints() { return this._state.roundPoints } set perspectivePoints(e) { this._state.perspectivePoints !== (e = !1 !== e) && (this._state.perspectivePoints = e, this.scene._needRecompile = !0, this.glRedraw()) } get perspectivePoints() { return this._state.perspectivePoints } set minPerspectivePointSize(e) { this._state.minPerspectivePointSize = e || 1, this.scene._needRecompile = !0, this.glRedraw() } get minPerspectivePointSize() { return this._state.minPerspectivePointSize } set maxPerspectivePointSize(e) { this._state.maxPerspectivePointSize = e || 6, this.scene._needRecompile = !0, this.glRedraw() } get maxPerspectivePointSize() { return this._state.maxPerspectivePointSize } set filterIntensity(e) { this._state.filterIntensity !== (e = !1 !== e) && (this._state.filterIntensity = e, this.scene._needRecompile = !0, this.glRedraw()) } get filterIntensity() { return this._state.filterIntensity } set minIntensity(e) { this._state.minIntensity = null != e ? e : 0, this.glRedraw() } get minIntensity() { return this._state.minIntensity } set maxIntensity(e) { this._state.maxIntensity = null != e ? e : 1, this.glRedraw() } get maxIntensity() { return this._state.maxIntensity } set preset(e) { var t; this._preset !== (e = e || "default") && ((t = PRESETS$1[e]) ? (this.pointSize = t.pointSize, this.roundPoints = t.roundPoints, this.perspectivePoints = t.perspectivePoints, this.minPerspectivePointSize = t.minPerspectivePointSize, this.maxPerspectivePointSize = t.maxPerspectivePointSize, this._preset = e) : this.error("unsupported preset: '" + e + "' - supported values are " + Object.keys(PRESETS$1).join(", "))) } get preset() { return this._preset } get hash() { return [this.pointSize, this.roundPoints, this.perspectivePoints, this.minPerspectivePointSize, this.maxPerspectivePointSize, this.filterIntensity].join(";") } destroy() { super.destroy(), this._state.destroy() } } const PRESETS = { default: { lineWidth: 1 }, thick: { lineWidth: 2 }, thicker: { lineWidth: 4 } }; class LinesMaterial extends Material { get type() { return "LinesMaterial" } get presets() { return PRESETS } constructor(e, t = {}) { super(e, t), this._state = new RenderState({ type: "LinesMaterial", lineWidth: null }), t.preset ? (this.preset = t.preset, void 0 !== t.lineWidth && (this.lineWidth = t.lineWidth)) : (this._preset = "default", this.lineWidth = t.lineWidth) } set lineWidth(e) { this._state.lineWidth = e || 1, this.glRedraw() } get lineWidth() { return this._state.lineWidth } set preset(e) { var t; this._preset !== (e = e || "default") && ((t = PRESETS[e]) ? (this.lineWidth = t.lineWidth, this._preset = e) : this.error("unsupported preset: '" + e + "' - supported values are " + Object.keys(PRESETS).join(", "))) } get preset() { return this._preset } get hash() { return ["" + this.lineWidth].join(";") } destroy() { super.destroy(), this._state.destroy() } } function getEntityIDMap(e, t) { var i, s, r = {}; for (let a = 0, o = t.length; a < o; a++)i = t[a], (s = e.component[i]) ? s.isEntity ? r[i] = !0 : e.warn("pick(): Component is not an Entity: " + i) : e.warn("pick(): Component not found: " + i); return r } class Scene extends Component { get type() { return "Scene" } constructor(e, t = {}) { super(null, t); var i = t.canvasElement || document.getElementById(t.canvasId); if (!(i instanceof HTMLCanvasElement)) throw "Mandatory config expected: valid canvasId or canvasElement"; var s = !!t.transparent, r = !!t.alphaDepthMask; this._aabbDirty = !0, this.viewer = e, this.occlusionTestCountdown = 0, this.loading = 0, this.startTime = (new Date).getTime(), this.models = {}, this.objects = {}, this._numObjects = 0, this.visibleObjects = {}, this._numVisibleObjects = 0, this.xrayedObjects = {}, this._numXRayedObjects = 0, this.highlightedObjects = {}, this._numHighlightedObjects = 0, this.selectedObjects = {}, this._numSelectedObjects = 0, this.colorizedObjects = {}, this._numColorizedObjects = 0, this.opacityObjects = {}, this._numOpacityObjects = 0, this.offsetObjects = {}, this._numOffsetObjects = 0, this._modelIds = null, this._objectIds = null, this._visibleObjectIds = null, this._xrayedObjectIds = null, this._highlightedObjectIds = null, this._selectedObjectIds = null, this._colorizedObjectIds = null, this._opacityObjectIds = null, this._offsetObjectIds = null, this._collidables = {}, this._compilables = {}, this._needRecompile = !1, this.types = {}, this.components = {}, this.sectionPlanes = {}, this.lights = {}, this.lightMaps = {}, this.reflectionMaps = {}, this.bitmaps = {}, this.lineSets = {}, this.realWorldOffset = t.realWorldOffset || new Float64Array([0, 0, 0]), this.canvas = new Canvas(this, { dontClear: !0, canvas: i, spinnerElementId: t.spinnerElementId, transparent: s, webgl2: !1 !== t.webgl2, contextAttr: t.contextAttr || {}, backgroundColor: t.backgroundColor, backgroundColorFromAmbientLight: t.backgroundColorFromAmbientLight, premultipliedAlpha: t.premultipliedAlpha }), this.canvas.on("boundary", (() => { this.glRedraw() })), this.canvas.on("webglContextFailed", (() => { alert("xeokit failed to find WebGL!") })), this._renderer = new Renderer(this, { transparent: s, alphaDepthMask: r }), this._sectionPlanesState = new function () { this.sectionPlanes = [], this.clippingCaps = !1; let e = null; this.getHash = function () { if (!e) { var t = this.sectionPlanes; if (0 === t.length) return this.hash = ";"; var i = []; for (let e = 0, s = t.length; e < s; e++)i.push("cp"); i.push(";"), e = i.join("") } return e }, this.addSectionPlane = function (t) { this.sectionPlanes.push(t), e = null }, this.removeSectionPlane = function (t) { for (let i = 0, s = this.sectionPlanes.length; i < s; i++)if (this.sectionPlanes[i].id === t.id) return this.sectionPlanes.splice(i, 1), void (e = null) } }, this._lightsState = new function () { const e = math.vec4([0, 0, 0, 0]), t = math.vec4(); this.lights = [], this.reflectionMaps = [], this.lightMaps = []; let i = null, s = null; this.getHash = function () { if (!i) { var e, t = [], s = this.lights; for (let i = 0, r = s.length; i < r; i++)e = s[i], t.push("/"), t.push(e.type), t.push("world" === e.space ? "w" : "v"), e.castsShadow && t.push("sh"); 0 < this.lightMaps.length && t.push("/lm"), 0 < this.reflectionMaps.length && t.push("/rm"), t.push(";"), i = t.join("") } return i }, this.addLight = function (e) { this.lights.push(e), s = null, i = null }, this.removeLight = function (e) { for (let t = 0, r = this.lights.length; t < r; t++)if (this.lights[t].id === e.id) return this.lights.splice(t, 1), s && s.id === e.id && (s = null), void (i = null) }, this.addReflectionMap = function (e) { this.reflectionMaps.push(e), i = null }, this.removeReflectionMap = function (e) { for (let t = 0, s = this.reflectionMaps.length; t < s; t++)if (this.reflectionMaps[t].id === e.id) return this.reflectionMaps.splice(t, 1), void (i = null) }, this.addLightMap = function (e) { this.lightMaps.push(e), i = null }, this.removeLightMap = function (e) { for (let t = 0, s = this.lightMaps.length; t < s; t++)if (this.lightMaps[t].id === e.id) return this.lightMaps.splice(t, 1), void (i = null) }, this.getAmbientColorAndIntensity = function () { if (!s) for (let e = 0, t = this.lights.length; e < t; e++) { var i = this.lights[e]; if ("ambient" === i.type) { s = i; break } } var r, a; return s ? (r = s.color, a = s.intensity, t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = a, t) : e } }, this.input = new Input(this, { dontClear: !0, element: this.canvas.canvas, keyboardEventsElement: t.keyboardEventsElement }), this.metrics = new Metrics(this, { units: t.units, scale: t.scale, origin: t.origin }), this.sao = new SAO(this, { enabled: t.saoEnabled }), this.ticksPerRender = t.ticksPerRender, this.ticksPerOcclusionTest = t.ticksPerOcclusionTest, this.passes = t.passes, this.clearEachPass = t.clearEachPass, this.gammaInput = t.gammaInput, this.gammaOutput = t.gammaOutput, this.gammaFactor = t.gammaFactor, this._entityOffsetsEnabled = !!t.entityOffsetsEnabled, this._pickSurfacePrecisionEnabled = !!t.pickSurfacePrecisionEnabled, this._logarithmicDepthBufferEnabled = !!t.logarithmicDepthBufferEnabled, this._pbrEnabled = !!t.pbrEnabled, this._colorTextureEnabled = !1 !== t.colorTextureEnabled, core._addScene(this), this._initDefaults(), this._viewport = new Viewport(this, { id: "default.viewport", autoBoundary: !0, dontClear: !0 }), this._camera = new Camera(this, { id: "default.camera", dontClear: !0 }), new AmbientLight(this, { color: [1, 1, 1], intensity: .7 }), new DirLight(this, { dir: [.8, -.5, -.5], color: [.67, .67, 1], intensity: .7, space: "world" }), new DirLight(this, { dir: [-.8, -1, .5], color: [1, 1, .9], intensity: .9, space: "world" }), this._camera.on("dirty", (() => { this._renderer.imageDirty() })) } _initDefaults() { } _addComponent(e) { if (e.id && this.components[e.id] && (this.error("Component " + utils.inQuotes(e.id) + " already exists in Scene - ignoring ID, will randomly-generate instead"), e.id = null), !e.id) for (void 0 === window.nextID && (window.nextID = 0), e.id = "__" + window.nextID++; this.components[e.id];)e.id = math.createUUID(); var t = (this.components[e.id] = e).type; let i = this.types[e.type]; ((i = i || (this.types[t] = {}))[e.id] = e).compile && (this._compilables[e.id] = e), e.isDrawable && (this._renderer.addDrawable(e.id, e), this._collidables[e.id] = e) } _removeComponent(e) { var t = e.id, i = e.type, s = (delete this.components[t], this.types[i]); s && (delete s[t], utils.isEmptyObject(s)) && delete this.types[i], e.compile && delete this._compilables[e.id], e.isDrawable && (this._renderer.removeDrawable(e.id), delete this._collidables[e.id]) } _sectionPlaneCreated(e) { this.sectionPlanes[e.id] = e, this.scene._sectionPlanesState.addSectionPlane(e._state), this.scene.fire("sectionPlaneCreated", e, !0), this._needRecompile = !0 } _bitmapCreated(e) { this.bitmaps[e.id] = e, this.scene.fire("bitmapCreated", e, !0) } _lineSetCreated(e) { this.lineSets[e.id] = e, this.scene.fire("lineSetCreated", e, !0) } _lightCreated(e) { this.lights[e.id] = e, this.scene._lightsState.addLight(e._state), this._needRecompile = !0 } _lightMapCreated(e) { this.lightMaps[e.id] = e, this.scene._lightsState.addLightMap(e._state), this._needRecompile = !0 } _reflectionMapCreated(e) { this.reflectionMaps[e.id] = e, this.scene._lightsState.addReflectionMap(e._state), this._needRecompile = !0 } _sectionPlaneDestroyed(e) { delete this.sectionPlanes[e.id], this.scene._sectionPlanesState.removeSectionPlane(e._state), this.scene.fire("sectionPlaneDestroyed", e, !0), this._needRecompile = !0 } _bitmapDestroyed(e) { delete this.bitmaps[e.id], this.scene.fire("bitmapDestroyed", e, !0) } _lineSetDestroyed(e) { delete this.lineSets[e.id], this.scene.fire("lineSetDestroyed", e, !0) } _lightDestroyed(e) { delete this.lights[e.id], this.scene._lightsState.removeLight(e._state), this._needRecompile = !0 } _lightMapDestroyed(e) { delete this.lightMaps[e.id], this.scene._lightsState.removeLightMap(e._state), this._needRecompile = !0 } _reflectionMapDestroyed(e) { delete this.reflectionMaps[e.id], this.scene._lightsState.removeReflectionMap(e._state), this._needRecompile = !0 } _registerModel(e) { this.models[e.id] = e, this._modelIds = null } _deregisterModel(e) { e = e.id, delete this.models[e], this._modelIds = null, this.fire("modelUnloaded", e) } _registerObject(e) { this.objects[e.id] = e, this._numObjects++, this._objectIds = null } _deregisterObject(e) { delete this.objects[e.id], this._numObjects--, this._objectIds = null } _objectVisibilityUpdated(e, t = !0) { e.visible ? (this.visibleObjects[e.id] = e, this._numVisibleObjects++) : (delete this.visibleObjects[e.id], this._numVisibleObjects--), this._visibleObjectIds = null, t && this.fire("objectVisibility", e, !0) } _objectXRayedUpdated(e, t = !0) { e.xrayed ? (this.xrayedObjects[e.id] = e, this._numXRayedObjects++) : (delete this.xrayedObjects[e.id], this._numXRayedObjects--), this._xrayedObjectIds = null, t && this.fire("objectXRayed", e, !0) } _objectHighlightedUpdated(e, t = !0) { e.highlighted ? (this.highlightedObjects[e.id] = e, this._numHighlightedObjects++) : (delete this.highlightedObjects[e.id], this._numHighlightedObjects--), this._highlightedObjectIds = null, t && this.fire("objectHighlighted", e, !0) } _objectSelectedUpdated(e, t = !0) { e.selected ? (this.selectedObjects[e.id] = e, this._numSelectedObjects++) : (delete this.selectedObjects[e.id], this._numSelectedObjects--), this._selectedObjectIds = null, t && this.fire("objectSelected", e, !0) } _objectColorizeUpdated(e, t) { t ? (this.colorizedObjects[e.id] = e, this._numColorizedObjects++) : (delete this.colorizedObjects[e.id], this._numColorizedObjects--), this._colorizedObjectIds = null } _objectOpacityUpdated(e, t) { t ? (this.opacityObjects[e.id] = e, this._numOpacityObjects++) : (delete this.opacityObjects[e.id], this._numOpacityObjects--), this._opacityObjectIds = null } _objectOffsetUpdated(e, t) { !t || 0 === t[0] && 0 === t[1] && 0 === t[2] ? (this.offsetObjects[e.id] = e, this._numOffsetObjects++) : (delete this.offsetObjects[e.id], this._numOffsetObjects--), this._offsetObjectIds = null } _webglContextLost() { this.canvas.spinner.processes++; for (const t in this.components) { var e; this.components.hasOwnProperty(t) && (e = this.components[t])._webglContextLost && e._webglContextLost() } this._renderer.webglContextLost() } _webglContextRestored() { var e, t = this.canvas.gl; for (const i in this.components) this.components.hasOwnProperty(i) && (e = this.components[i])._webglContextRestored && e._webglContextRestored(t); this._renderer.webglContextRestored(t), this.canvas.spinner.processes-- } get capabilities() { return this._renderer.capabilities } get entityOffsetsEnabled() { return this._entityOffsetsEnabled } get pickSurfacePrecisionEnabled() { return this._pickSurfacePrecisionEnabled } get logarithmicDepthBufferEnabled() { return this._logarithmicDepthBufferEnabled } set pbrEnabled(e) { this._pbrEnabled = !!e, this.glRedraw() } get pbrEnabled() { return this._pbrEnabled } set colorTextureEnabled(e) { this._colorTextureEnabled = !!e, this.glRedraw() } get colorTextureEnabled() { return this._colorTextureEnabled } doOcclusionTest() { this._needRecompile && (this._recompile(), this._needRecompile = !1), this._renderer.doOcclusionTest() } render(e) { e && core.runTasks(); var t = { sceneId: null, pass: 0 }; if (this._needRecompile && (this._recompile(), this._renderer.imageDirty(), this._needRecompile = !1), e || this._renderer.needsRender()) { t.sceneId = this.id; var i, s = this._passes, r = this._clearEachPass; let a; for (a = 0; a < s; a++)t.pass = a, this.fire("rendering", t, !0), i = r || 0 === a, this._renderer.render({ pass: a, clear: i, force: e }), this.fire("rendered", t, !0); this._saveAmbientColor() } } _recompile() { for (const e in this._compilables) this._compilables.hasOwnProperty(e) && this._compilables[e].compile(); this._renderer.shadowsDirty(), this.fire("compile", this, !0) } _saveAmbientColor() { var e, t = this.canvas; t.transparent || t.backgroundImage || t.backgroundColor ? this._lastAmbientColor = null : (e = this._lightsState.getAmbientColorAndIntensity(), this._lastAmbientColor && this._lastAmbientColor[0] === e[0] && this._lastAmbientColor[1] === e[1] && this._lastAmbientColor[2] === e[2] && this._lastAmbientColor[3] === e[3] || (t.backgroundColor = e, this._lastAmbientColor || (this._lastAmbientColor = math.vec4([0, 0, 0, 1])), this._lastAmbientColor.set(e))) } get modelIds() { return this._modelIds || (this._modelIds = Object.keys(this.models)), this._modelIds } get numObjects() { return this._numObjects } get objectIds() { return this._objectIds || (this._objectIds = Object.keys(this.objects)), this._objectIds } get numVisibleObjects() { return this._numVisibleObjects } get visibleObjectIds() { return this._visibleObjectIds || (this._visibleObjectIds = Object.keys(this.visibleObjects)), this._visibleObjectIds } get numXRayedObjects() { return this._numXRayedObjects } get xrayedObjectIds() { return this._xrayedObjectIds || (this._xrayedObjectIds = Object.keys(this.xrayedObjects)), this._xrayedObjectIds } get numHighlightedObjects() { return this._numHighlightedObjects } get highlightedObjectIds() { return this._highlightedObjectIds || (this._highlightedObjectIds = Object.keys(this.highlightedObjects)), this._highlightedObjectIds } get numSelectedObjects() { return this._numSelectedObjects } get selectedObjectIds() { return this._selectedObjectIds || (this._selectedObjectIds = Object.keys(this.selectedObjects)), this._selectedObjectIds } get numColorizedObjects() { return this._numColorizedObjects } get colorizedObjectIds() { return this._colorizedObjectIds || (this._colorizedObjectIds = Object.keys(this.colorizedObjects)), this._colorizedObjectIds } get opacityObjectIds() { return this._opacityObjectIds || (this._opacityObjectIds = Object.keys(this.opacityObjects)), this._opacityObjectIds } get offsetObjectIds() { return this._offsetObjectIds || (this._offsetObjectIds = Object.keys(this.offsetObjects)), this._offsetObjectIds } set ticksPerRender(e) { null == e ? e = 1 : (!utils.isNumeric(e) || e <= 0) && (this.error("Unsupported value for 'ticksPerRender': '" + e + "' - should be an integer greater than zero."), e = 1), e !== this._ticksPerRender && (this._ticksPerRender = e) } get ticksPerRender() { return this._ticksPerRender } set ticksPerOcclusionTest(e) { null == e ? e = 20 : (!utils.isNumeric(e) || e <= 0) && (this.error("Unsupported value for 'ticksPerOcclusionTest': '" + e + "' - should be an integer greater than zero."), e = 20), e !== this._ticksPerOcclusionTest && (this._ticksPerOcclusionTest = e) } get ticksPerOcclusionTest() { return this._ticksPerOcclusionTest } set passes(e) { null == e ? e = 1 : (!utils.isNumeric(e) || e <= 0) && (this.error("Unsupported value for 'passes': '" + e + "' - should be an integer greater than zero."), e = 1), e !== this._passes && (this._passes = e, this.glRedraw()) } get passes() { return this._passes } set clearEachPass(e) { (e = !!e) !== this._clearEachPass && (this._clearEachPass = e, this.glRedraw()) } get clearEachPass() { return this._clearEachPass } set gammaInput(e) { (e = !1 !== e) !== this._renderer.gammaInput && (this._renderer.gammaInput = e, this._needRecompile = !0, this.glRedraw()) } get gammaInput() { return this._renderer.gammaInput } set gammaOutput(e) { (e = !!e) !== this._renderer.gammaOutput && (this._renderer.gammaOutput = e, this._needRecompile = !0, this.glRedraw()) } get gammaOutput() { return this._renderer.gammaOutput } set gammaFactor(e) { (e = null == e ? 2.2 : e) !== this._renderer.gammaFactor && (this._renderer.gammaFactor = e, this.glRedraw()) } get gammaFactor() { return this._renderer.gammaFactor } get geometry() { return this.components["default.geometry"] || buildBoxGeometry(ReadableGeometry) } get material() { return this.components["default.material"] || new PhongMaterial(this, { id: "default.material", emissive: [.4, .4, .4], dontClear: !0 }) } get xrayMaterial() { return this.components["default.xrayMaterial"] || new EmphasisMaterial(this, { id: "default.xrayMaterial", preset: "sepia", dontClear: !0 }) } get highlightMaterial() { return this.components["default.highlightMaterial"] || new EmphasisMaterial(this, { id: "default.highlightMaterial", preset: "yellowHighlight", dontClear: !0 }) } get selectedMaterial() { return this.components["default.selectedMaterial"] || new EmphasisMaterial(this, { id: "default.selectedMaterial", preset: "greenSelected", dontClear: !0 }) } get edgeMaterial() { return this.components["default.edgeMaterial"] || new EdgeMaterial(this, { id: "default.edgeMaterial", preset: "default", edgeColor: [0, 0, 0], edgeAlpha: 1, edgeWidth: 1, dontClear: !0 }) } get pointsMaterial() { return this.components["default.pointsMaterial"] || new PointsMaterial(this, { id: "default.pointsMaterial", preset: "default", dontClear: !0 }) } get linesMaterial() { return this.components["default.linesMaterial"] || new LinesMaterial(this, { id: "default.linesMaterial", preset: "default", dontClear: !0 }) } get viewport() { return this._viewport } get camera() { return this._camera } get center() { var e; return !this._aabbDirty && this._center || (this._center && this._center || (this._center = math.vec3()), e = this.aabb, this._center[0] = (e[0] + e[3]) / 2, this._center[1] = (e[1] + e[4]) / 2, this._center[2] = (e[2] + e[5]) / 2), this._center } get aabb() { if (this._aabbDirty) { this._aabb || (this._aabb = math.AABB3()); let i = math.MAX_DOUBLE, s = math.MAX_DOUBLE, r = math.MAX_DOUBLE, a = math.MIN_DOUBLE, o = math.MIN_DOUBLE, n = math.MIN_DOUBLE; var e, t = this._collidables; let h = !1; for (const l in t) t.hasOwnProperty(l) && !1 !== (e = t[l]).collidable && ((e = e.aabb)[0] < i && (i = e[0]), e[1] < s && (s = e[1]), e[2] < r && (r = e[2]), e[3] > a && (a = e[3]), e[4] > o && (o = e[4]), e[5] > n && (n = e[5]), h = !0); h || (i = -100, s = -100, r = -100, a = 100, o = 100, n = 100), this._aabb[0] = i, this._aabb[1] = s, this._aabb[2] = r, this._aabb[3] = a, this._aabb[4] = o, this._aabb[5] = n, this._aabbDirty = !1 } return this._aabb } _setAABBDirty() { this._aabbDirty = !0, this.fire("boundary") } pick(e, t) { if (0 === this.canvas.boundary[2] || 0 === this.canvas.boundary[3]) return this.error("Picking not allowed while canvas has zero width or height"), null; (e = e || {}).pickSurface = e.pickSurface || e.rayPick, e.canvasPos || e.matrix || e.origin && e.direction || this.warn("picking without canvasPos, matrix, or ray origin and direction"); var i = e.includeEntities || e.include; return i && (e.includeEntityIds = getEntityIDMap(this, i)), (i = e.excludeEntities || e.exclude) && (e.excludeEntityIds = getEntityIDMap(this, i)), this._needRecompile && (this._recompile(), this._renderer.imageDirty(), this._needRecompile = !1), (t = this._renderer.pick(e, t)) ? (t.entity && t.entity.fire && t.entity.fire("picked", t), t) : void 0 } clear() { var e; for (const t in this.components) this.components.hasOwnProperty(t) && !(e = this.components[t])._dontClear && e.destroy() } clearLights() { var e = Object.keys(this.lights); for (let t = 0, i = e.length; t < i; t++)this.lights[e[t]].destroy() } clearSectionPlanes() { var e = Object.keys(this.sectionPlanes); for (let t = 0, i = e.length; t < i; t++)this.sectionPlanes[e[t]].destroy() } clearBitmaps() { var e = Object.keys(this.bitmaps); for (let t = 0, i = e.length; t < i; t++)this.bitmaps[e[t]].destroy() } clearLines() { var e = Object.keys(this.lineSets); for (let t = 0, i = e.length; t < i; t++)this.lineSets[e[t]].destroy() } getAABB(e) { if (void 0 === e) return this.aabb; if (utils.isString(e)) { var t = this.objects[e]; if (t && t.aabb) return t.aabb; e = [e] } if (0 === e.length) return this.aabb; let i, s = math.MAX_DOUBLE, r = math.MAX_DOUBLE, a = math.MAX_DOUBLE, o = math.MIN_DOUBLE, n = math.MIN_DOUBLE, h = math.MIN_DOUBLE; return this.withObjects(e, (e => { e.collidable && ((e = e.aabb)[0] < s && (s = e[0]), e[1] < r && (r = e[1]), e[2] < a && (a = e[2]), e[3] > o && (o = e[3]), e[4] > n && (n = e[4]), e[5] > h && (h = e[5]), i = !0) })), i ? ((t = math.AABB3())[0] = s, t[1] = r, t[2] = a, t[3] = o, t[4] = n, t[5] = h, t) : this.aabb } setObjectsVisible(e, t) { return this.withObjects(e, (e => { var i = e.visible !== t; return e.visible = t, i })) } setObjectsCollidable(e, t) { return this.withObjects(e, (e => { var i = e.collidable !== t; return e.collidable = t, i })) } setObjectsCulled(e, t) { return this.withObjects(e, (e => { var i = e.culled !== t; return e.culled = t, i })) } setObjectsSelected(e, t) { return this.withObjects(e, (e => { var i = e.selected !== t; return e.selected = t, i })) } setObjectsHighlighted(e, t) { return this.withObjects(e, (e => { var i = e.highlighted !== t; return e.highlighted = t, i })) } setObjectsXRayed(e, t) { return this.withObjects(e, (e => { var i = e.xrayed !== t; return e.xrayed = t, i })) } setObjectsEdges(e, t) { return this.withObjects(e, (e => { var i = e.edges !== t; return e.edges = t, i })) } setObjectsColorized(e, t) { return this.withObjects(e, (e => { e.colorize = t })) } setObjectsOpacity(e, t) { return this.withObjects(e, (e => { var i = e.opacity !== t; return e.opacity = t, i })) } setObjectsPickable(e, t) { return this.withObjects(e, (e => { var i = e.pickable !== t; return e.pickable = t, i })) } setObjectsOffset(e, t) { this.withObjects(e, (e => { e.offset = t })) } withObjects(e, t) { let i = !1; for (let o = 0, n = (e = utils.isString(e) ? [e] : e).length; o < n; o++) { var s = e[o]; let n = this.objects[s]; if (n) i = t(n) || i; else { var r = this.modelIds; for (let e = 0, o = r.length; e < o; e++) { var a = r[e]; a = math.globalizeObjectId(a, s); (n = this.objects[a]) && (i = t(n) || i) } } } return i } destroy() { super.destroy(); for (const e in this.components) this.components.hasOwnProperty(e) && this.components[e].destroy(); this.canvas.gl = null, this.components = null, this.models = null, this.objects = null, this.visibleObjects = null, this.xrayedObjects = null, this.highlightedObjects = null, this.selectedObjects = null, this.colorizedObjects = null, this.opacityObjects = null, this.sectionPlanes = null, this.lights = null, this.lightMaps = null, this.reflectionMaps = null, this._objectIds = null, this._visibleObjectIds = null, this._xrayedObjectIds = null, this._highlightedObjectIds = null, this._selectedObjectIds = null, this._colorizedObjectIds = null, this.types = null, this.components = null, this.canvas = null, this._renderer = null, this.input = null, this._viewport = null, this._camera = null } } class AxisGizmoPlugin extends Plugin { constructor(e, t) { super("AxisGizmo", e, t = t || {}); const i = e.scene.camera; t.canvasId || t.canvasElement || this.error("Config expected: either 'canvasId' or 'canvasElement'"); try { this._axisGizmoScene = new Scene(e, { canvasId: t.canvasId, canvasElement: t.canvasElement, transparent: !0 }) } catch (e) { return void this.error(e) } (e = this._axisGizmoScene).clearLights(), new AmbientLight(e, { color: [.45, .45, .5], intensity: .9 }), new DirLight(e, { dir: [-.5, .5, -.6], color: [.8, .8, .7], intensity: 1, space: "view" }), new DirLight(e, { dir: [.5, -.5, -.6], color: [.8, .8, .8], intensity: 1, space: "view" }); const s = e.camera; i.on("matrix", (function () { var e = i.eye, t = i.look, r = i.up; e = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(e, t, [])), 22); s.look = [0, 0, 0], s.eye = e, s.up = r })); var r = new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .01, radiusBottom: .6, height: 1.7, radialSegments: 20, heightSegments: 1, openEnded: !1 })), a = new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .2, radiusBottom: .2, height: 4.5, radialSegments: 20, heightSegments: 1, openEnded: !1 })), o = new PhongMaterial(e, { diffuse: [1, .3, .3], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), n = new PhongMaterial(e, { emissive: [1, .3, .3], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), h = new PhongMaterial(e, { diffuse: [.3, 1, .3], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), l = new PhongMaterial(e, { emissive: [.3, 1, .3], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), c = new PhongMaterial(e, { diffuse: [.3, .3, 1], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), u = new PhongMaterial(e, { emissive: [.3, .3, 1], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), p = new PhongMaterial(e, { diffuse: [.5, .5, .5], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }); this._meshes = [new Mesh(e, { geometry: new ReadableGeometry(e, buildSphereGeometry({ radius: 9, heightSegments: 60, widthSegments: 60 })), material: new PhongMaterial(e, { diffuse: [0, 0, 0], emissive: [.1, .1, .1], ambient: [.1, .1, .2], specular: [0, 0, 0], alpha: .4, alphaMode: "blend", frontface: "cw" }), pickable: !1, collidable: !1, visible: !1 !== t.visible }), new Mesh(e, { geometry: new ReadableGeometry(e, buildSphereGeometry({ radius: 1 })), material: p, pickable: !1, collidable: !1, visible: !1 !== t.visible }), new Mesh(e, { geometry: r, material: o, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [5, 0, 0], rotation: [0, 0, -90] }), new Mesh(e, { geometry: a, material: o, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [2, 0, 0], rotation: [0, 0, 90] }), new Mesh(e, { geometry: new ReadableGeometry(e, buildVectorTextGeometry({ text: "X", size: 1.5 })), material: n, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [7, 0, 0], billboard: "spherical" }), new Mesh(e, { geometry: r, material: h, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 5, 0] }), new Mesh(e, { geometry: a, material: h, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 2, 0] }), new Mesh(e, { geometry: new ReadableGeometry(e, buildVectorTextGeometry({ text: "Y", size: 1.5 })), material: l, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 7, 0], billboard: "spherical" }), new Mesh(e, { geometry: r, material: c, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 0, 5], rotation: [90, 0, 0] }), new Mesh(e, { geometry: a, material: c, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 0, 2], rotation: [90, 0, 0] }), new Mesh(e, { geometry: new ReadableGeometry(e, buildVectorTextGeometry({ text: "Z", size: 1.5 })), material: u, pickable: !1, collidable: !1, visible: !1 !== t.visible, position: [0, 0, 7], billboard: "spherical" })] } setVisible(e) { for (let t = 0; t < this._meshes.length; t++)this._meshes[t].visible = e } destroy() { this._axisGizmoCanvas = null, this._axisGizmoScene.destroy(), this._axisGizmoScene = null, super.destroy() } } const tempVec3$2 = math.vec3(), tempVec3a$8 = math.vec3(), tempVec3b$5 = math.vec3(), tempVec3c$4 = math.vec3(); class BCFViewpointsPlugin extends Plugin { constructor(e, t = {}) { super("BCFViewpoints", e, t), this.originatingSystem = t.originatingSystem || "xeokit.io", this.authoringTool = t.authoringTool || "xeokit.io" } getViewpoint(e = {}) { const t = this.viewer.scene; var i = t.camera, s = t.realWorldOffset, r = !0 === e.reverseClippingPlanes, a = {}; let o = math.normalizeVec3(math.subVec3(i.look, i.eye, math.vec3())), n = i.eye, h = i.up; i.yUp && (o = YToZ(o), n = YToZ(n), h = YToZ(h)); var l, c = xyzArrayToObject(math.addVec3(n, s)), u = ("ortho" === i.projection ? a.orthogonal_camera = { camera_view_point: c, camera_direction: xyzArrayToObject(o), camera_up_vector: xyzArrayToObject(h), view_to_world_scale: i.ortho.scale } : a.perspective_camera = { camera_view_point: c, camera_direction: xyzArrayToObject(o), camera_up_vector: xyzArrayToObject(h), field_of_view: i.perspective.fov }, t.sectionPlanes); for (l in u) if (u.hasOwnProperty(l)) { var p = u[l]; let e, t = p.pos; e = r ? math.negateVec3(p.dir, math.vec3()) : p.dir, i.yUp && (t = YToZ(t), e = YToZ(e)), math.addVec3(t, s), t = xyzArrayToObject(t), e = xyzArrayToObject(e), a.clipping_planes || (a.clipping_planes = []), a.clipping_planes.push({ location: t, direction: e }) } var d, m = t.lineSets; for (d in m) if (m.hasOwnProperty(d)) { var f = m[d], g = (a.lines || (a.lines = []), f.positions), _ = f.indices; for (let e = 0, t = _.length / 2; e < t; e++) { var v = _[2 * e], y = _[2 * e + 1]; a.lines.push({ start_point: { x: g[3 * v + 0], y: g[3 * v + 1], z: g[3 * v + 2] }, end_point: { x: g[3 * y + 0], y: g[3 * y + 1], z: g[3 * y + 2] } }) } } var T, I = t.bitmaps; for (T in I) if (I.hasOwnProperty(T)) { var E = I[T]; let e = E.pos, t = E.normal, r = E.up; i.yUp && (e = YToZ(e), t = YToZ(t), r = YToZ(r)), math.addVec3(e, s), a.bitmaps || (a.bitmaps = []), a.bitmaps.push({ bitmap_type: E.type, bitmap_data: E.imageData, location: xyzArrayToObject(e), normal: xyzArrayToObject(t), up: xyzArrayToObject(r), height: E.height }) } a.components = { visibility: { view_setup_hints: { spaces_visible: !!e.spacesVisible, space_boundaries_visible: !!e.spaceBoundariesVisible, openings_visible: !!e.openingsVisible } } }; const C = new Set(t.opacityObjectIds), P = new Set(t.xrayedObjectIds), b = new Set(t.colorizedObjectIds), A = (c = Object.values(t.objects).filter((e => C.has(e.id) || b.has(e.id) || P.has(e.id))).reduce(((e, i) => { let s, r = colorizeToRGB(i.colorize); i.xrayed ? (s = 0 === t.xrayMaterial.fillAlpha && 0 !== t.xrayMaterial.edgeAlpha ? .1 : t.xrayMaterial.fillAlpha, s = Math.round(255 * s).toString(16).padStart(2, "0"), r = s + r) : C.has(i.id) && (s = Math.round(255 * i.opacity).toString(16).padStart(2, "0"), r = s + r), e[r] || (e[r] = []); var a = i.id, o = { ifc_guid: i = i.originalSystemId, originating_system: this.originatingSystem }; return i !== a && (o.authoring_tool_id = a), e[r].push(o), e }), {}), c = Object.entries(c).map((([e, t]) => ({ color: e, components: t }))), a.components.coloring = c, c = t.objectIds, t.visibleObjects); var D = t.visibleObjectIds, R = (c = c.filter((e => !A[e])), t.selectedObjectIds); return e.defaultInvisible || D.length < c.length ? (a.components.visibility.exceptions = this._createBCFComponents(D), a.components.visibility.default_visibility = !1) : (a.components.visibility.exceptions = this._createBCFComponents(c), a.components.visibility.default_visibility = !0), a.components.selection = this._createBCFComponents(R), !1 !== e.snapshot && (a.snapshot = { snapshot_type: "png", snapshot_data: this.viewer.getSnapshot({ format: "png" }) }), a } _createBCFComponents(e) { var t = this.viewer.scene, i = []; for (let o = 0, n = e.length; o < n; o++) { var s, r = e[o], a = t.objects[r]; a && (s = { ifc_guid: a.originalSystemId, originating_system: this.originatingSystem }, a.originalSystemId !== r && (s.authoring_tool_id = r), i.push(s)) } return i } setViewpoint(e, t = {}) { if (e) { var i = this.viewer; const o = i.scene, n = o.camera; var s = !1 !== t.rayCast, r = !1 !== t.immediate, a = !1 !== t.reset; const h = o.realWorldOffset, l = !0 === t.reverseClippingPlanes; if (o.clearSectionPlanes(), e.clipping_planes && e.clipping_planes.forEach((function (e) { let t = xyzObjectToArray(e.location, tempVec3$2), i = xyzObjectToArray(e.direction, tempVec3$2); l && math.negateVec3(i), math.subVec3(t, h), n.yUp && (t = ZToY(t), i = ZToY(i)), new SectionPlane(o, { pos: t, dir: i }) })), o.clearLines(), e.lines) { const t = [], i = []; let s = 0; e.lines.forEach((e => { e.start_point && e.end_point && (t.push(e.start_point.x), t.push(e.start_point.y), t.push(e.start_point.z), t.push(e.end_point.x), t.push(e.end_point.y), t.push(e.end_point.z), i.push(s++), i.push(s++)) })), new LineSet(o, { positions: t, indices: i, clippable: !1, collidable: !0 }) } if (o.clearBitmaps(), e.bitmaps && e.bitmaps.forEach((function (e) { var t = e.bitmap_type || "jpg", i = e.bitmap_data; let s = xyzObjectToArray(e.location, tempVec3a$8), r = xyzObjectToArray(e.normal, tempVec3b$5), a = xyzObjectToArray(e.up, tempVec3c$4); e = e.height || 1, t && i && s && r && a && (n.yUp && (s = ZToY(s), r = ZToY(r), a = ZToY(a)), new Bitmap(o, { src: i, type: t, pos: s, normal: r, up: a, clippable: !1, collidable: !0, height: e })) })), a && (o.setObjectsXRayed(o.xrayedObjectIds, !1), o.setObjectsHighlighted(o.highlightedObjectIds, !1), o.setObjectsSelected(o.selectedObjectIds, !1)), e.components && (e.components.visibility && (e.components.visibility.default_visibility ? (o.setObjectsVisible(o.objectIds, !0), e.components.visibility.exceptions && e.components.visibility.exceptions.forEach((e => this._withBCFComponent(t, e, (e => e.visible = !1))))) : (o.setObjectsVisible(o.objectIds, !1), e.components.visibility.exceptions && e.components.visibility.exceptions.forEach((e => this._withBCFComponent(t, e, (e => e.visible = !0))))), a = e.components.visibility.view_setup_hints) && (!1 === a.spaces_visible && o.setObjectsVisible(i.metaScene.getObjectIDsByType("IfcSpace"), !1), !1 === a.openings_visible && o.setObjectsVisible(i.metaScene.getObjectIDsByType("IfcOpening"), !1), a.space_boundaries_visible), e.components.selection && (o.setObjectsSelected(o.selectedObjectIds, !1), e.components.selection.forEach((e => this._withBCFComponent(t, e, (e => e.selected = !0))))), e.components.coloring) && e.components.coloring.forEach((e => { let i = e.color, s = 0, r = !1; 8 === i.length && ((s = parseInt(i.substring(0, 2), 16) / 256) <= 1 && .95 <= s && (s = 1), i = i.substring(2), r = !0); const a = [parseInt(i.substring(0, 2), 16) / 256, parseInt(i.substring(2, 4), 16) / 256, parseInt(i.substring(4, 6), 16) / 256]; e.components.map((e => this._withBCFComponent(t, e, (e => { e.colorize = a, r && (e.opacity = s) })))) })), e.perspective_camera || e.orthogonal_camera) { let l, c, u, p; p = e.perspective_camera ? (l = xyzObjectToArray(e.perspective_camera.camera_view_point, tempVec3$2), c = xyzObjectToArray(e.perspective_camera.camera_direction, tempVec3$2), u = xyzObjectToArray(e.perspective_camera.camera_up_vector, tempVec3$2), n.perspective.fov = e.perspective_camera.field_of_view, "perspective") : (l = xyzObjectToArray(e.orthogonal_camera.camera_view_point, tempVec3$2), c = xyzObjectToArray(e.orthogonal_camera.camera_direction, tempVec3$2), u = xyzObjectToArray(e.orthogonal_camera.camera_up_vector, tempVec3$2), n.ortho.scale = e.orthogonal_camera.view_to_world_scale, "ortho"), math.subVec3(l, h), n.yUp && (l = ZToY(l), c = ZToY(c), u = ZToY(u)), c = s && (a = o.pick({ pickSurface: !0, origin: l, direction: c })) ? a.worldPos : math.addVec3(l, c, tempVec3$2), r ? (n.eye = l, n.look = c, n.up = u, n.projection = p) : i.cameraFlight.flyTo({ eye: l, look: c, up: u, duration: t.duration, projection: p }) } } } _withBCFComponent(e, t, i) { const s = this.viewer, r = s.scene; if (t.authoring_tool_id && t.originating_system === this.originatingSystem) { var a = t.authoring_tool_id, o = r.objects[a]; if (o) return void i(o); if (e.updateCompositeObjects && s.metaScene.metaObjects[a]) return void r.withObjects(s.metaScene.getObjectIDsInSubtree(a), i) } if (t.ifc_guid) { const a = t.ifc_guid; (o = r.objects[a]) ? i(o) : e.updateCompositeObjects && s.metaScene.metaObjects[a] ? r.withObjects(s.metaScene.getObjectIDsInSubtree(a), i) : Object.keys(r.models).forEach((t => { t = math.globalizeObjectId(t, a); var o = r.objects[t]; o ? i(o) : e.updateCompositeObjects && s.metaScene.metaObjects[t] && r.withObjects(s.metaScene.getObjectIDsInSubtree(t), i) })) } } destroy() { super.destroy() } } function xyzArrayToObject(e) { return { x: e[0], y: e[1], z: e[2] } } function xyzObjectToArray(e, t) { return (t = new Float64Array(3))[0] = e.x, t[1] = e.y, t[2] = e.z, t } function YToZ(e) { return new Float64Array([e[0], -e[2], e[1]]) } function ZToY(e) { return new Float64Array([e[0], e[2], -e[1]]) } function colorizeToRGB(e) { var t = ""; return (t += Math.round(255 * e[0]).toString(16).padStart(2, "0")) + Math.round(255 * e[1]).toString(16).padStart(2, "0") + Math.round(255 * e[2]).toString(16).padStart(2, "0") } var distVec3 = math.vec3(); const lengthWire = (e, t, i, s) => (e -= i, i = t - s, Math.sqrt(e * e + i * i)); class DistanceMeasurement extends Component { constructor(e, t = {}) { if (super(e.viewer.scene, t), this.plugin = e, this._container = t.container, !this._container) throw "config missing: container"; this._eventSubs = {}; var i = this.plugin.viewer.scene, s = (this._originMarker = new Marker(i, t.origin), this._targetMarker = new Marker(i, t.target), this._originWorld = math.vec3(), this._targetWorld = math.vec3(), this._wp = new Float64Array(24), this._vp = new Float64Array(24), this._pp = new Float64Array(24), this._cp = new Float64Array(8), this._xAxisLabelCulled = !1, this._yAxisLabelCulled = !1, this._zAxisLabelCulled = !1, this._color = t.color || this.plugin.defaultColor, t.onMouseOver ? e => { t.onMouseOver(e, this) } : null), r = t.onMouseLeave ? e => { t.onMouseLeave(e, this) } : null, a = t.onContextMenu ? e => { t.onContextMenu(e, this) } : null; this._originDot = new Dot(this._container, { fillColor: this._color, zIndex: void 0 !== e.zIndex ? e.zIndex + 2 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._targetDot = new Dot(this._container, { fillColor: this._color, zIndex: void 0 !== e.zIndex ? e.zIndex + 2 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._lengthWire = new Wire(this._container, { color: this._color, thickness: 2, thicknessClickable: 6, zIndex: void 0 !== e.zIndex ? e.zIndex + 1 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._xAxisWire = new Wire(this._container, { color: "#FF0000", thickness: 1, thicknessClickable: 6, zIndex: void 0 !== e.zIndex ? e.zIndex + 1 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._yAxisWire = new Wire(this._container, { color: "green", thickness: 1, thicknessClickable: 6, zIndex: void 0 !== e.zIndex ? e.zIndex + 1 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._zAxisWire = new Wire(this._container, { color: "blue", thickness: 1, thicknessClickable: 6, zIndex: void 0 !== e.zIndex ? e.zIndex + 1 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._lengthLabel = new Label(this._container, { fillColor: this._color, prefix: "", text: "", zIndex: void 0 !== e.zIndex ? e.zIndex + 4 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._xAxisLabel = new Label(this._container, { fillColor: "red", prefix: "X", text: "", zIndex: void 0 !== e.zIndex ? e.zIndex + 3 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._yAxisLabel = new Label(this._container, { fillColor: "green", prefix: "Y", text: "", zIndex: void 0 !== e.zIndex ? e.zIndex + 3 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._zAxisLabel = new Label(this._container, { fillColor: "blue", prefix: "Z", text: "", zIndex: void 0 !== e.zIndex ? e.zIndex + 3 : void 0, onMouseOver: s, onMouseLeave: r, onContextMenu: a }), this._wpDirty = !1, this._vpDirty = !1, this._cpDirty = !1, this._visible = !1, this._originVisible = !1, this._targetVisible = !1, this._wireVisible = !1, this._axisVisible = !1, this._xAxisVisible = !1, this._yAxisVisible = !1, this._zAxisVisible = !1, this._axisEnabled = !0, this._labelsVisible = !1, this._clickable = !1, this._originMarker.on("worldPos", (e => { this._originWorld.set(e || [0, 0, 0]), this._wpDirty = !0, this._needUpdate(0) })), this._targetMarker.on("worldPos", (e => { this._targetWorld.set(e || [0, 0, 0]), this._wpDirty = !0, this._needUpdate(0) })), this._onViewMatrix = i.camera.on("viewMatrix", (() => { this._vpDirty = !0, this._needUpdate(0) })), this._onProjMatrix = i.camera.on("projMatrix", (() => { this._cpDirty = !0, this._needUpdate() })), this._onCanvasBoundary = i.canvas.on("boundary", (() => { this._cpDirty = !0, this._needUpdate(0) })), this._onMetricsUnits = i.metrics.on("units", (() => { this._cpDirty = !0, this._needUpdate() })), this._onMetricsScale = i.metrics.on("scale", (() => { this._cpDirty = !0, this._needUpdate() })), this._onMetricsOrigin = i.metrics.on("origin", (() => { this._cpDirty = !0, this._needUpdate() })), this.approximate = t.approximate, this.visible = t.visible, this.originVisible = t.originVisible, this.targetVisible = t.targetVisible, this.wireVisible = t.wireVisible, this.axisVisible = t.axisVisible, this.xAxisVisible = t.xAxisVisible, this.yAxisVisible = t.yAxisVisible, this.zAxisVisible = t.zAxisVisible, this.labelsVisible = t.labelsVisible } _update() { if (this._visible) { var e = this.plugin.viewer.scene, t = (this._wpDirty && (this._wp[0] = this._originWorld[0], this._wp[1] = this._originWorld[1], this._wp[2] = this._originWorld[2], this._wp[3] = 1, this._wp[4] = this._targetWorld[0], this._wp[5] = this._originWorld[1], this._wp[6] = this._originWorld[2], this._wp[7] = 1, this._wp[8] = this._targetWorld[0], this._wp[9] = this._targetWorld[1], this._wp[10] = this._originWorld[2], this._wp[11] = 1, this._wp[12] = this._targetWorld[0], this._wp[13] = this._targetWorld[1], this._wp[14] = this._targetWorld[2], this._wp[15] = 1, this._wpDirty = !1, this._vpDirty = !0), this._vpDirty && (math.transformPositions4(e.camera.viewMatrix, this._wp, this._vp), this._vp[3] = 1, this._vp[7] = 1, this._vp[11] = 1, this._vp[15] = 1, this._vpDirty = !1, this._cpDirty = !0), this._originMarker.viewPos[2]), i = this._targetMarker.viewPos[2]; if (-.3 < t || -.3 < i) this._xAxisLabel.setCulled(!0), this._yAxisLabel.setCulled(!0), this._zAxisLabel.setCulled(!0), this._lengthLabel.setCulled(!0), this._xAxisWire.setVisible(!1), this._yAxisWire.setVisible(!1), this._zAxisWire.setVisible(!1), this._lengthWire.setVisible(!1), this._originDot.setVisible(!1), this._targetDot.setVisible(!1); else if (this._cpDirty) { math.transformPositions4(e.camera.project.matrix, this._vp, this._pp); for (var s, r, a, o, n = this._pp, h = this._cp, l = (t = e.canvas.canvas.getBoundingClientRect(), i = this._container.getBoundingClientRect(), t.top - i.top), c = t.left - i.left, u = (t = e.canvas.boundary)[2], p = t[3], d = 0, m = (e = (i = this.plugin.viewer.scene.metrics).scale, t = i.units, i = i.unitsInfo[t].abbrev, 0), f = n.length; m < f; m += 4)h[d] = c + Math.floor((1 + n[m + 0] / n[m + 3]) * u / 2), h[d + 1] = l + Math.floor((1 - n[m + 1] / n[m + 3]) * p / 2), d += 2; this._originDot.setPos(h[0], h[1]), this._targetDot.setPos(h[6], h[7]), this._lengthWire.setStartAndEnd(h[0], h[1], h[6], h[7]), this._xAxisWire.setStartAndEnd(h[0], h[1], h[2], h[3]), this._yAxisWire.setStartAndEnd(h[2], h[3], h[4], h[5]), this._zAxisWire.setStartAndEnd(h[4], h[5], h[6], h[7]), this.labelsVisible ? (this._lengthLabel.setPosOnWire(h[0], h[1], h[6], h[7]), this._xAxisLabel.setPosOnWire(h[0], h[1], h[2], h[3]), this._yAxisLabel.setPosOnWire(h[2], h[3], h[4], h[5]), this._zAxisLabel.setPosOnWire(h[4], h[5], h[6], h[7]), t = this._approximate ? " ~ " : " = ", this._length = Math.abs(math.lenVec3(math.subVec3(this._targetWorld, this._originWorld, distVec3))), this._lengthLabel.setText(t + (this._length * e).toFixed(2) + i), s = Math.abs(lengthWire(h[0], h[1], h[2], h[3])), r = Math.abs(lengthWire(h[2], h[3], h[4], h[5])), a = Math.abs(lengthWire(h[4], h[5], h[6], h[7])), o = this.plugin.labelMinAxisLength, this._xAxisLabelCulled = s < o, this._yAxisLabelCulled = r < o, this._zAxisLabelCulled = a < o, this._xAxisLabelCulled ? this._xAxisLabel.setCulled(!0) : (this._xAxisLabel.setText(t + Math.abs((this._targetWorld[0] - this._originWorld[0]) * e).toFixed(2) + i), this._xAxisLabel.setCulled(!this.axisVisible)), this._yAxisLabelCulled ? this._yAxisLabel.setCulled(!0) : (this._yAxisLabel.setText(t + Math.abs((this._targetWorld[1] - this._originWorld[1]) * e).toFixed(2) + i), this._yAxisLabel.setCulled(!this.axisVisible)), this._zAxisLabelCulled ? this._zAxisLabel.setCulled(!0) : (this._zAxisLabel.setText(t + Math.abs((this._targetWorld[2] - this._originWorld[2]) * e).toFixed(2) + i), this._zAxisLabel.setCulled(!this.axisVisible))) : (this._lengthLabel.setCulled(!0), this._xAxisLabel.setCulled(!0), this._yAxisLabel.setCulled(!0), this._zAxisLabel.setCulled(!0)), this._originDot.setVisible(this._visible && this._originVisible), this._targetDot.setVisible(this._visible && this._targetVisible), this._xAxisWire.setVisible(this.axisVisible && this.xAxisVisible), this._yAxisWire.setVisible(this.axisVisible && this.yAxisVisible), this._zAxisWire.setVisible(this.axisVisible && this.zAxisVisible), this._lengthWire.setVisible(this.wireVisible), this._lengthLabel.setCulled(!this.wireVisible), this._cpDirty = !1 } } } set approximate(e) { this._approximate !== (e = !1 !== e) && (this._approximate = e, this._cpDirty = !0, this._needUpdate(0)) } get approximate() { return this._approximate } get origin() { return this._originMarker } get target() { return this._targetMarker } get length() { this._update(); var e = this.plugin.viewer.scene.metrics.scale; return this._length * e } get color() { return this._color } set color(e) { this._color = e, this._originDot.setFillColor(e), this._targetDot.setFillColor(e), this._lengthWire.setColor(e), this._lengthLabel.setFillColor(e) } set visible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultVisible, this._visible = e, this._originDot.setVisible(this._visible && this._originVisible), this._targetDot.setVisible(this._visible && this._targetVisible), this._lengthWire.setVisible(this._visible && this._wireVisible), this._lengthLabel.setVisible(this._visible && this._wireVisible); e = this._visible && this._axisVisible && this._xAxisVisible; var t = this._visible && this._axisVisible && this._yAxisVisible, i = this._visible && this._axisVisible && this._zAxisVisible; this._xAxisWire.setVisible(e), this._yAxisWire.setVisible(t), this._zAxisWire.setVisible(i), this._xAxisLabel.setVisible(e && !this._xAxisLabelCulled), this._yAxisLabel.setVisible(t && !this._yAxisLabelCulled), this._zAxisLabel.setVisible(i && !this._zAxisLabelCulled), this._cpDirty = !0, this._needUpdate() } get visible() { return this._visible } set originVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultOriginVisible, this._originVisible = e, this._originDot.setVisible(this._visible && this._originVisible) } get originVisible() { return this._originVisible } set targetVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultTargetVisible, this._targetVisible = e, this._targetDot.setVisible(this._visible && this._targetVisible) } get targetVisible() { return this._targetVisible } set axisEnabled(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultAxisVisible, this._axisEnabled = e, e = this._visible && this._axisVisible && this._axisEnabled, this._xAxisWire.setVisible(e && this._xAxisVisible), this._yAxisWire.setVisible(e && this._yAxisVisible), this._zAxisWire.setVisible(e && this._zAxisVisible), this._xAxisLabel.setVisible(e && !this._xAxisLabelCulled && this._xAxisVisible), this._yAxisLabel.setVisible(e && !this._yAxisLabelCulled && this._xAxisVisible), this._zAxisLabel.setVisible(e && !this._zAxisLabelCulled && this._xAxisVisible), this._cpDirty = !0, this._needUpdate() } get axisEnabled() { return this._axisEnabled } set axisVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultAxisVisible, this._axisVisible = e, e = this._visible && this._axisVisible && this._axisEnabled, this._xAxisWire.setVisible(e && this._xAxisVisible), this._yAxisWire.setVisible(e && this._yAxisVisible), this._zAxisWire.setVisible(e && this._zAxisVisible), this._xAxisLabel.setVisible(e && !this._xAxisLabelCulled && this._xAxisVisible), this._yAxisLabel.setVisible(e && !this._yAxisLabelCulled && this._yAxisVisible), this._zAxisLabel.setVisible(e && !this._zAxisLabelCulled && this._zAxisVisible), this._cpDirty = !0, this._needUpdate() } get axisVisible() { return this._axisVisible } set xAxisVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultAxisVisible, this._xAxisVisible = e, e = this._visible && this._axisVisible && this._xAxisVisible && this._axisEnabled, this._xAxisWire.setVisible(e), this._xAxisLabel.setVisible(e && !this._xAxisLabelCulled), this._cpDirty = !0, this._needUpdate() } get xAxisVisible() { return this._xAxisVisible } set yAxisVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultAxisVisible, this._yAxisVisible = e, e = this._visible && this._axisVisible && this._yAxisVisible && this._axisEnabled, this._yAxisWire.setVisible(e), this._yAxisLabel.setVisible(e && !this._yAxisLabelCulled), this._cpDirty = !0, this._needUpdate() } get yAxisVisible() { return this._yAxisVisible } set zAxisVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultAxisVisible, this._zAxisVisible = e, e = this._visible && this._axisVisible && this._zAxisVisible && this._axisEnabled, this._zAxisWire.setVisible(e), this._zAxisLabel.setVisible(e && !this._zAxisLabelCulled), this._cpDirty = !0, this._needUpdate() } get zAxisVisible() { return this._zAxisVisible } set wireVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultWireVisible, this._wireVisible = e, e = this._visible && this._wireVisible, this._lengthLabel.setVisible(e), this._lengthWire.setVisible(e) } get wireVisible() { return this._wireVisible } set labelsVisible(e) { e = void 0 !== e ? Boolean(e) : this.plugin.defaultLabelsVisible, this._labelsVisible = e, e = this._visible && this._labelsVisible, this._xAxisLabel.setVisible(e && !this._xAxisLabelCulled && this._clickable && this._axisEnabled), this._yAxisLabel.setVisible(e && !this._yAxisLabelCulled && this._clickable && this._axisEnabled), this._zAxisLabel.setVisible(e && !this._zAxisLabelCulled && this._clickable && this._axisEnabled), this._lengthLabel.setVisible(e), this._cpDirty = !0, this._needUpdate() } get labelsVisible() { return this._labelsVisible } setHighlighted(e) { this._originDot.setHighlighted(e), this._targetDot.setHighlighted(e), this._xAxisWire.setHighlighted(e), this._yAxisWire.setHighlighted(e), this._zAxisWire.setHighlighted(e), this._xAxisLabel.setHighlighted(e), this._yAxisLabel.setHighlighted(e), this._zAxisLabel.setHighlighted(e), this._lengthWire.setHighlighted(e), this._lengthLabel.setHighlighted(e) } set clickable(e) { this._clickable = e = !!e, this._originDot.setClickable(this._clickable), this._targetDot.setClickable(this._clickable), this._xAxisWire.setClickable(this._clickable), this._yAxisWire.setClickable(this._clickable), this._zAxisWire.setClickable(this._clickable), this._lengthWire.setClickable(this._clickable), this._xAxisLabel.setClickable(this._clickable), this._yAxisLabel.setClickable(this._clickable), this._zAxisLabel.setClickable(this._clickable), this._lengthLabel.setClickable(this._clickable) } get clickable() { return this._clickable } destroy() { var e = this.plugin.viewer.scene, t = e.metrics; this._onViewMatrix && e.camera.off(this._onViewMatrix), this._onProjMatrix && e.camera.off(this._onProjMatrix), this._onCanvasBoundary && e.canvas.off(this._onCanvasBoundary), this._onMetricsUnits && t.off(this._onMetricsUnits), this._onMetricsScale && t.off(this._onMetricsScale), this._onMetricsOrigin && t.off(this._onMetricsOrigin), this._originDot.destroy(), this._targetDot.destroy(), this._xAxisWire.destroy(), this._yAxisWire.destroy(), this._zAxisWire.destroy(), this._lengthLabel.destroy(), this._xAxisLabel.destroy(), this._yAxisLabel.destroy(), this._zAxisLabel.destroy(), this._lengthWire.destroy(), super.destroy() } } class LocaleService { constructor(e = {}) { this._eventSubIDMap = null, this._eventSubEvents = null, this._eventSubs = null, this._events = null, this._locale = "en", this._messages = {}, this._locales = [], this._locale = "en", this.messages = e.messages, this.locale = e.locale } set messages(e) { this._messages = e || {}, this._locales = Object.keys(this._messages), this.fire("updated", this) } loadMessages(e = {}) { for (var t in e) this._messages[t] = e[t]; this.messages = this._messages } clearMessages() { this.messages = {} } get locales() { return this._locales } set locale(e) { this._locale !== (e = e || "de") && (this._locale = e, this.fire("updated", e)) } get locale() { return this._locale } translate(e, t) { var i = this._messages[this._locale]; return i && (e = resolvePath$1(e, i)) ? t ? vsprintf(e, t) : e : null } translatePlurals(e, t, i) { var s = this._messages[this._locale]; return s && (e = resolvePath$1(e, s), e = 0 === (t = parseInt("" + t, 10)) ? e.zero : 1 < t ? e.other : e.one) ? (e = vsprintf(e, [t]), i ? vsprintf(e, i) : e) : null } fire(e, t, i) { this._events || (this._events = {}), this._eventSubs || (this._eventSubs = {}), !0 !== i && (this._events[e] = t || !0); var s = this._eventSubs[e]; if (s) for (const e in s) s.hasOwnProperty(e) && s[e].callback(t) } on(e, t) { this._events || (this._events = {}), this._eventSubIDMap || (this._eventSubIDMap = new Map$1), this._eventSubEvents || (this._eventSubEvents = {}), this._eventSubs || (this._eventSubs = {}); let i = this._eventSubs[e]; i || (i = {}, this._eventSubs[e] = i); var s = this._eventSubIDMap.addItem(); return i[s] = { callback: t }, this._eventSubEvents[s] = e, void 0 !== (e = this._events[e]) && t(e), s } off(e) { var t; null != e && this._eventSubEvents && (t = this._eventSubEvents[e]) && (delete this._eventSubEvents[e], (t = this._eventSubs[t]) && delete t[e], this._eventSubIDMap.removeItem(e)) } } function resolvePath$1(e, t) { if (t[e]) return t[e]; var i = e.split("."); let s = t; for (let e = 0, t = i.length; s && e < t; e++) { s = s[i[e]] } return s } function vsprintf(e, t = []) { return e.replace(/\{\{|\}\}|\{(\d+)\}/g, (function (e, i) { return "{{" === e ? "{" : "}}" === e ? "}" : t[i] })) } const screenPos = math.vec4(), viewPos = math.vec4(), tempVec3a$7 = math.vec3(), tempVec3b$4 = math.vec3(), tempVec3c$3 = math.vec3(), tempVec4a$4 = math.vec4(), tempVec4b$4 = math.vec4(), tempVec4c$1 = math.vec4(); class PanController { constructor(e) { this._scene = e } dollyToCanvasPos(e, t, i) { let s = !1; var r, a = this._scene.camera; return e && (r = math.subVec3(e, a.eye, tempVec3a$7), s = (r = math.lenVec3(r)) < i), "perspective" === a.projection ? (a.ortho.scale = a.ortho.scale - i, r = this._unproject(t, tempVec4a$4), r = math.subVec3(r, a.eye, tempVec4c$1), r = math.mulVec3Scalar(math.normalizeVec3(r), -i, []), a.eye = [a.eye[0] - r[0], a.eye[1] - r[1], a.eye[2] - r[2]], a.look = [a.look[0] - r[0], a.look[1] - r[1], a.look[2] - r[2]], e && (r = math.subVec3(e, a.eye, tempVec3a$7), e = math.lenVec3(r), r = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(a.look, a.eye, tempVec3b$4)), e), a.look = [a.eye[0] + r[0], a.eye[1] + r[1], a.eye[2] + r[2]])) : "ortho" === a.projection && (e = this._unproject(t, tempVec4a$4), a.ortho.scale = a.ortho.scale - i, a.ortho._update(), r = this._unproject(t, tempVec4b$4), t = math.subVec3(r, e, tempVec4c$1), r = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(a.look, a.eye, tempVec3a$7)), -i, tempVec3b$4), e = math.addVec3(t, r, tempVec3c$3), a.eye = [a.eye[0] - e[0], a.eye[1] - e[1], a.eye[2] - e[2]], a.look = [a.look[0] - e[0], a.look[1] - e[1], a.look[2] - e[2]]), s } _unproject(e, t) { var i = this._scene.camera, s = (r = i.project.transposedMatrix).subarray(8, 12), r = r.subarray(12), a = [0, 0, -1, 1]; s = math.dotVec4(a, s) / math.dotVec4(a, r); return i.project.unproject(e, s, screenPos, viewPos, t), t } destroy() { } } const tempVec3a$6 = math.vec3(), tempVec3b$3 = math.vec3(), tempVec3c$2 = math.vec3(), tempVec4a$3 = math.vec4(), tempVec4b$3 = math.vec4(), tempVec4c = math.vec4(); class PivotController { constructor(e, t) { this._scene = e, this._configs = t, this._pivotWorldPos = math.vec3(), this._cameraOffset = math.vec3(), this._azimuth = 0, this._polar = 0, this._radius = 0, this._pivotPosSet = !1, this._pivoting = !1, this._shown = !1, this._pivotViewPos = math.vec4(), this._pivotProjPos = math.vec4(), this._pivotCanvasPos = math.vec2(), this._cameraDirty = !0, this._onViewMatrix = this._scene.camera.on("viewMatrix", (() => { this._cameraDirty = !0 })), this._onProjMatrix = this._scene.camera.on("projMatrix", (() => { this._cameraDirty = !0 })), this._onTick = this._scene.on("tick", (() => { this.updatePivotElement() })) } updatePivotElement() { var e, t = this._scene.camera, i = this._scene.canvas; this._pivoting && this._cameraDirty && (math.transformPoint3(t.viewMatrix, this.getPivotPos(), this._pivotViewPos), this._pivotViewPos[3] = 1, math.transformPoint4(t.projMatrix, this._pivotViewPos, this._pivotProjPos), e = (t = i.boundary)[2], t = t[3], this._pivotCanvasPos[0] = Math.floor((1 + this._pivotProjPos[0] / this._pivotProjPos[3]) * e / 2), this._pivotCanvasPos[1] = Math.floor((1 - this._pivotProjPos[1] / this._pivotProjPos[3]) * t / 2), e = i.canvas.getBoundingClientRect(), this._pivotElement && (this._pivotElement.style.left = Math.floor(e.left + this._pivotCanvasPos[0]) - this._pivotElement.clientWidth / 2 + window.scrollX + "px", this._pivotElement.style.top = Math.floor(e.top + this._pivotCanvasPos[1]) - this._pivotElement.clientHeight / 2 + window.scrollY + "px"), this._cameraDirty = !1) } setPivotElement(e) { this._pivotElement = e } startPivot() { if (this._cameraLookingDownwards()) return this._pivoting = !1; var e = this._scene.camera, t = math.lookAtMat4v(e.eye, e.look, e.worldUp), i = (math.transformPoint3(t, this.getPivotPos(), this._cameraOffset), this.getPivotPos()), s = (t = (this._cameraOffset[2] += math.distVec3(e.eye, i), t = math.inverseMat4(t), math.transformVec3(t, this._cameraOffset)), math.vec3()); math.subVec3(e.eye, i, s), math.addVec3(s, t), e.zUp && (i = s[1], s[1] = s[2], s[2] = i), this._radius = math.lenVec3(s), this._polar = Math.acos(s[1] / this._radius), this._azimuth = Math.atan2(s[0], s[2]), this._pivoting = !0 } _cameraLookingDownwards() { var e = this._scene.camera, t = math.normalizeVec3(math.subVec3(e.look, e.eye, tempVec3a$6)); t = math.cross3Vec3(t, e.worldUp, tempVec3b$3); return math.sqLenVec3(t) <= 1e-4 } getPivoting() { return this._pivoting } setPivotPos(e) { this._pivotWorldPos.set(e), this._pivotPosSet = !0 } setCanvasPivotPos(e) { var t = this._scene.camera, i = Math.abs(math.distVec3(this._scene.center, t.eye)), s = (r = t.project.transposedMatrix).subarray(8, 12), r = r.subarray(12), a = [0, 0, -1, 1]; s = math.dotVec4(a, s) / math.dotVec4(a, r), a = tempVec4a$3, t.project.unproject(e, s, tempVec4b$3, tempVec4c, a), r = math.normalizeVec3(math.subVec3(a, t.eye, tempVec3a$6)), e = math.addVec3(t.eye, math.mulVec3Scalar(r, i, tempVec3b$3), tempVec3c$2); this.setPivotPos(e) } getPivotPos() { return this._pivotPosSet ? this._pivotWorldPos : this._scene.camera.look } continuePivot(e, t) { var i, s; !this._pivoting || 0 === e && 0 === t || (e = -e, t = -t, 1 === (i = this._scene.camera).worldUp[2] && (e = -e), this._azimuth += .01 * -e, this._polar += .01 * t, this._polar = math.clamp(this._polar, .001, Math.PI - .001), e = [this._radius * Math.sin(this._polar) * Math.sin(this._azimuth), this._radius * Math.cos(this._polar), this._radius * Math.sin(this._polar) * Math.cos(this._azimuth)], 1 === i.worldUp[2] && (t = e[1], e[1] = e[2], e[2] = t), t = math.lenVec3(math.subVec3(i.look, i.eye, math.vec3())), s = this.getPivotPos(), math.addVec3(e, s), e = math.lookAtMat4v(e, s, i.worldUp), e = math.inverseMat4(e), s = math.transformVec3(e, this._cameraOffset), e[12] -= s[0], e[13] -= s[1], e[14] -= s[2], s = [e[8], e[9], e[10]], i.eye = [e[12], e[13], e[14]], math.subVec3(i.eye, math.mulVec3Scalar(s, t), i.look), i.up = [e[4], e[5], e[6]], this.showPivot()) } showPivot() { this._shown || (null !== this._hideTimeout && (window.clearTimeout(this._hideTimeout), this._hideTimeout = null), this._pivotElement && (this.updatePivotElement(), this._pivotElement.style.visibility = "visible", this._shown = !0, this._hideTimeout = window.setTimeout((() => { this.hidePivot() }), 1e3))) } hidePivot() { this._shown && (null !== this._hideTimeout && (window.clearTimeout(this._hideTimeout), this._hideTimeout = null), this._pivotElement && (this._pivotElement.style.visibility = "hidden"), this._shown = !1) } endPivot() { this._pivoting = !1 } destroy() { this._scene.camera.off(this._onViewMatrix), this._scene.camera.off(this._onProjMatrix), this._scene.off(this._onTick) } } class PickController { constructor(e, t) { this._scene = e.scene, this._cameraControl = e, this._scene.canvas.canvas.oncontextmenu = function (e) { e.preventDefault() }, this._configs = t, this.schedulePickEntity = !1, this.schedulePickSurface = !1, this.pickCursorPos = math.vec2(), this.picked = !1, this.pickedSurface = !1, this.pickResult = null, this._lastPickedEntityId = null, this._needFireEvents = !1 } update() { if (this._configs.pointerEnabled && (this.schedulePickEntity || this.schedulePickSurface)) { this.picked = !1, this.pickedSurface = !1, this._needFireEvents = !1; var e = this._cameraControl.hasSubs("hoverSurface"); if (this.schedulePickSurface && this.pickResult && this.pickResult.worldPos) { var t = this.pickResult.canvasPos; if (t[0] === this.pickCursorPos[0] && t[1] === this.pickCursorPos[1]) return this.picked = !0, this.pickedSurface = !0, this._needFireEvents = e, this.schedulePickEntity = !1, void (this.schedulePickSurface = !1) } this.schedulePickEntity && this.pickResult && (t = this.pickResult.canvasPos)[0] === this.pickCursorPos[0] && t[1] === this.pickCursorPos[1] ? (this.picked = !0, this.pickedSurface = !1, this._needFireEvents = !1) : this.schedulePickSurface ? (this.pickResult = this._scene.pick({ pickSurface: !0, pickSurfaceNormal: !1, canvasPos: this.pickCursorPos }), this.pickResult && (this.picked = !0, this.pickedSurface = !0, this._needFireEvents = !0)) : (this.pickResult = this._scene.pick({ canvasPos: this.pickCursorPos }), this.pickResult && (this.picked = !0, this.pickedSurface = !1, this._needFireEvents = !0)), this.schedulePickEntity = !1, this.schedulePickSurface = !1 } } fireEvents() { var e; this._needFireEvents && (this.picked && this.pickResult && this.pickResult.entity ? (e = this.pickResult.entity.id, this._lastPickedEntityId !== e && (void 0 !== this._lastPickedEntityId && this._cameraControl.fire("hoverOut", { entity: this._scene.objects[this._lastPickedEntityId] }, !0), this._cameraControl.fire("hoverEnter", this.pickResult, !0), this._lastPickedEntityId = e), this._cameraControl.fire("hover", this.pickResult, !0), this.pickResult.worldPos && (this.pickedSurface = !0, this._cameraControl.fire("hoverSurface", this.pickResult, !0))) : (void 0 !== this._lastPickedEntityId && (this._cameraControl.fire("hoverOut", { entity: this._scene.objects[this._lastPickedEntityId] }, !0), this._lastPickedEntityId = void 0), this._cameraControl.fire("hoverOff", { canvasPos: this.pickCursorPos }, !0)), this.pickResult = null, this._needFireEvents = !1) } destroy() { } } const canvasPos = math.vec2(), getCanvasPosFromEvent$4 = function (e, t) { if (e) { let i = e.target, s = 0, r = 0; for (; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t }; class MousePanRotateDollyHandler { constructor(e, t, i, s, r) { this._scene = e; const a = t.pickController; let o, n, h, l = 0, c = 0, u = 0, p = 0, d = !1; const m = math.vec3(); let f = !0; const g = this._scene.canvas.canvas, _ = []; function v(e = !0) { g.style.cursor = "move", l = s.pointerCanvasPos[0], c = s.pointerCanvasPos[1], u = s.pointerCanvasPos[0], p = s.pointerCanvasPos[1], e && (a.pickCursorPos = s.pointerCanvasPos, a.schedulePickSurface = !0, a.update(), a.picked && a.pickedSurface && a.pickResult && a.pickResult.worldPos ? (d = !0, m.set(a.pickResult.worldPos)) : d = !1) } document.addEventListener("keydown", this._documentKeyDownHandler = t => { i.active && i.pointerEnabled && e.input.keyboardEnabled && (t = t.keyCode, _[t] = !0) }), document.addEventListener("keyup", this._documentKeyUpHandler = t => { i.active && i.pointerEnabled && e.input.keyboardEnabled && (t = t.keyCode, _[t] = !1) }), g.addEventListener("mousedown", this._mouseDownHandler = t => { if (i.active && i.pointerEnabled) switch (t.which) { case 1: _[e.input.KEY_SHIFT] || i.planView ? (o = !0, v()) : v(!(o = !0)); break; case 2: n = !0, v(); break; case 3: h = !0, i.panRightClick && v() } }), document.addEventListener("mousemove", this._documentMouseMoveHandler = () => { var t, a, u, p, f, g, v, y; i.active && i.pointerEnabled && (o || n || h) && (t = (a = e.canvas.boundary)[2], a = a[3], u = s.pointerCanvasPos[0], p = s.pointerCanvasPos[1], _[e.input.KEY_SHIFT] || i.planView || !i.panRightClick && n || i.panRightClick && h ? (f = u - l, g = p - c, "perspective" === (v = e.camera).projection ? (y = Math.abs(d ? math.lenVec3(math.subVec3(m, e.camera.eye, [])) : e.camera.eyeLookDist) * Math.tan(v.perspective.fov / 2 * Math.PI / 180), r.panDeltaX += 1.5 * f * y / a, r.panDeltaY += 1.5 * g * y / a) : (r.panDeltaX += .5 * v.ortho.scale * (f / a), r.panDeltaY += .5 * v.ortho.scale * (g / a))) : !o || n || h || i.planView || (i.firstPerson ? (r.rotateDeltaY -= (u - l) / t * i.dragRotationRate / 2, r.rotateDeltaX += (p - c) / a * (i.dragRotationRate / 4)) : (r.rotateDeltaY -= (u - l) / t * (1.5 * i.dragRotationRate), r.rotateDeltaX += (p - c) / a * (1.5 * i.dragRotationRate))), l = u, c = p) }), g.addEventListener("mousemove", this._canvasMouseMoveHandler = e => { i.active && i.pointerEnabled && s.mouseover && (f = !0) }), document.addEventListener("mouseup", this._documentMouseUpHandler = e => { if (i.active && i.pointerEnabled) switch (e.which) { case 1: case 2: case 3: o = !1, n = !1, h = !1 } }), g.addEventListener("mouseup", this._mouseUpHandler = e => { var s, r; i.active && i.pointerEnabled && (3 === e.which && (getCanvasPosFromEvent$4(e, canvasPos), s = canvasPos[0], r = canvasPos[1], Math.abs(s - u) < 3) && Math.abs(r - p) < 3 && t.cameraControl.fire("rightClick", { pagePos: [Math.round(e.pageX), Math.round(e.pageY)], canvasPos: canvasPos, event: e }, !0), g.style.removeProperty("cursor")) }), g.addEventListener("mouseenter", this._mouseEnterHandler = () => { i.active && i.pointerEnabled }); let y = null; g.addEventListener("wheel", this._mouseWheelHandler = e => { var t, a; i.active && i.pointerEnabled && (a = performance.now() / 1e3, t = null !== y ? a - y : 0, y = a, (t = .05 < t ? .05 : t) < 1 / 60 && (t = 1 / 60), 0 !== (a = Math.max(-1, Math.min(1, 40 * -e.deltaY)))) && (e = a / Math.abs(a), r.dollyDelta += -e * t * i.mouseWheelDollyRate, f) && (s.followPointerDirty = !0, f = !1) }, { passive: !0 }) } reset() { } destroy() { var e = this._scene.canvas.canvas; document.removeEventListener("keydown", this._documentKeyDownHandler), document.removeEventListener("keyup", this._documentKeyUpHandler), e.removeEventListener("mousedown", this._mouseDownHandler), document.removeEventListener("mousemove", this._documentMouseMoveHandler), e.removeEventListener("mousemove", this._canvasMouseMoveHandler), document.removeEventListener("mouseup", this._documentMouseUpHandler), e.removeEventListener("mouseup", this._mouseUpHandler), e.removeEventListener("mouseenter", this._mouseEnterHandler), e.removeEventListener("wheel", this._mouseWheelHandler) } } const center = math.vec3(), tempVec3a$5 = math.vec3(), tempVec3b$2 = math.vec3(), tempVec3c$1 = math.vec3(), tempVec3d = math.vec3(), tempCameraTarget = { eye: math.vec3(), look: math.vec3(), up: math.vec3() }; class KeyboardAxisViewHandler { constructor(e, t, i, s) { this._scene = e; const r = t.cameraControl, a = e.camera; this._onSceneKeyDown = e.input.on("keydown", (() => { var o, n, h, l, c, u, p, d; i.active && i.pointerEnabled && e.input.keyboardEnabled && s.mouseover && (o = r._isKeyDownForAction(r.AXIS_VIEW_RIGHT), n = r._isKeyDownForAction(r.AXIS_VIEW_BACK), h = r._isKeyDownForAction(r.AXIS_VIEW_LEFT), l = r._isKeyDownForAction(r.AXIS_VIEW_FRONT), c = r._isKeyDownForAction(r.AXIS_VIEW_TOP), u = r._isKeyDownForAction(r.AXIS_VIEW_BOTTOM), o || n || h || l || c || u) && (p = e.aabb, d = math.getAABB3Diag(p), math.getAABB3Center(p, center), p = Math.abs(d / Math.tan(t.cameraFlight.fitFOV * math.DEGTORAD)), d *= 1.1, tempCameraTarget.orthoScale = d, o ? (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldRight, p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(a.worldUp)) : n ? (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldForward, p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(a.worldUp)) : h ? (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldRight, -p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(a.worldUp)) : l ? (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldForward, -p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(a.worldUp)) : c ? (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldUp, p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(a.worldForward, 1, tempVec3b$2), tempVec3c$1))) : u && (tempCameraTarget.eye.set(math.addVec3(center, math.mulVec3Scalar(a.worldUp, -p, tempVec3a$5), tempVec3d)), tempCameraTarget.look.set(center), tempCameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(a.worldForward, -1, tempVec3b$2)))), !i.firstPerson && i.followPointer && t.pivotController.setPivotPos(center), 0 < t.cameraFlight.duration ? t.cameraFlight.flyTo(tempCameraTarget, (() => { t.pivotController.getPivoting() && i.followPointer && t.pivotController.showPivot() })) : (t.cameraFlight.jumpTo(tempCameraTarget), t.pivotController.getPivoting() && i.followPointer && t.pivotController.showPivot())) })) } reset() { } destroy() { this._scene.input.off(this._onSceneKeyDown) } } class MousePickHandler { constructor(e, t, i, s, r) { this._scene = e; const a = t.pickController, o = t.pivotController, n = t.cameraControl; this._clicks = 0, this._timeout = null, this._lastPickedEntityId = null; let h = !1, l = !1; var c = this._scene.canvas.canvas; const u = i => { let s; i && i.worldPos && (s = i.worldPos); var r; i = (i && i.entity ? i.entity : e).aabb; s && (r = e.camera, math.subVec3(r.eye, r.look, [])), t.cameraFlight.flyTo({ aabb: i }) }; c.addEventListener("mousemove", this._canvasMouseMoveHandler = t => { var r, o, c, u; i.active && i.pointerEnabled && !h && !l && (u = n.hasSubs("hover"), r = n.hasSubs("hoverOut"), o = n.hasSubs("hoverOff"), c = n.hasSubs("hoverSurface"), u || r || o || c) && (a.pickCursorPos = s.pointerCanvasPos, a.schedulePickEntity = !0, a.schedulePickSurface = c, a.update(), a.pickResult ? (u = a.pickResult.entity.id, this._lastPickedEntityId !== u && (void 0 !== this._lastPickedEntityId && n.fire("hoverOut", { entity: e.objects[this._lastPickedEntityId] }, !0), n.fire("hoverEnter", a.pickResult, !0), this._lastPickedEntityId = u), n.fire("hover", a.pickResult, !0), a.pickResult.worldPos && n.fire("hoverSurface", a.pickResult, !0)) : (void 0 !== this._lastPickedEntityId && (n.fire("hoverOut", { entity: e.objects[this._lastPickedEntityId] }, !0), this._lastPickedEntityId = void 0), n.fire("hoverOff", { canvasPos: a.pickCursorPos }, !0))) }), c.addEventListener("mousedown", this._canvasMouseDownHandler = t => { 1 === t.which && (h = !0), 3 === t.which && (l = !0), 1 === t.which && i.active && i.pointerEnabled && (s.mouseDownClientX = t.clientX, s.mouseDownClientY = t.clientY, s.mouseDownCursorX = s.pointerCanvasPos[0], s.mouseDownCursorY = s.pointerCanvasPos[1], !i.firstPerson) && i.followPointer && (a.pickCursorPos = s.pointerCanvasPos, a.schedulePickSurface = !0, a.update(), 1 === t.which) && ((t = a.pickResult) && t.worldPos ? o.setPivotPos(t.worldPos) : i.smartPivot ? o.setCanvasPivotPos(s.pointerCanvasPos) : o.setPivotPos(e.camera.look), o.startPivot()) }), document.addEventListener("mouseup", this._documentMouseUpHandler = e => { 1 === e.which && (h = !1), 3 === e.which && (l = !1) }), c.addEventListener("mouseup", this._canvasMouseUpHandler = r => { if (i.active && i.pointerEnabled && 1 === r.which && (o.hidePivot(), !(3 < Math.abs(r.clientX - s.mouseDownClientX) || 3 < Math.abs(r.clientY - s.mouseDownClientY)))) { var h = n.hasSubs("picked"), l = (r = n.hasSubs("pickedNothing"), n.hasSubs("pickedSurface")), c = n.hasSubs("doublePicked"), p = n.hasSubs("doublePickedSurface"), d = n.hasSubs("doublePickedNothing"); if (i.doublePickFlyTo || c || p || d) if (this._clicks++, 1 === this._clicks) { a.pickCursorPos = s.pointerCanvasPos, a.schedulePickEntity = i.doublePickFlyTo, a.schedulePickSurface = l, a.update(); const e = a.pickResult, r = a.pickedSurface; this._timeout = setTimeout((() => { e ? (n.fire("picked", e, !0), r && (n.fire("pickedSurface", e, !0), !i.firstPerson) && i.followPointer && (t.pivotController.setPivotPos(e.worldPos), t.pivotController.startPivot()) && t.pivotController.showPivot()) : n.fire("pickedNothing", { canvasPos: s.pointerCanvasPos }, !0), this._clicks = 0 }), i.doubleClickTimeFrame) } else null !== this._timeout && (window.clearTimeout(this._timeout), this._timeout = null), a.pickCursorPos = s.pointerCanvasPos, a.schedulePickEntity = i.doublePickFlyTo || c || p, a.schedulePickSurface = a.schedulePickEntity && p, a.update(), a.pickResult ? (n.fire("doublePicked", a.pickResult, !0), a.pickedSurface && n.fire("doublePickedSurface", a.pickResult, !0), i.doublePickFlyTo && (u(a.pickResult), !i.firstPerson) && i.followPointer && (d = a.pickResult.entity.aabb, c = math.getAABB3Center(d), t.pivotController.setPivotPos(c), t.pivotController.startPivot()) && t.pivotController.showPivot()) : (n.fire("doublePickedNothing", { canvasPos: s.pointerCanvasPos }, !0), i.doublePickFlyTo && (u(), !i.firstPerson) && i.followPointer && (p = e.aabb, d = math.getAABB3Center(p), t.pivotController.setPivotPos(d), t.pivotController.startPivot()) && t.pivotController.showPivot()), this._clicks = 0; else (h || r || l) && (a.pickCursorPos = s.pointerCanvasPos, a.schedulePickEntity = !0, a.schedulePickSurface = l, a.update(), a.pickResult ? (n.fire("picked", a.pickResult, !0), a.pickedSurface && n.fire("pickedSurface", a.pickResult, !0)) : n.fire("pickedNothing", { canvasPos: s.pointerCanvasPos }, !0)), this._clicks = 0 } }, !1) } reset() { this._clicks = 0, this._lastPickedEntityId = null, this._timeout && (window.clearTimeout(this._timeout), this._timeout = null) } destroy() { var e = this._scene.canvas.canvas; e.removeEventListener("mousemove", this._canvasMouseMoveHandler), e.removeEventListener("mousedown", this._canvasMouseDownHandler), document.removeEventListener("mouseup", this._documentMouseUpHandler), e.removeEventListener("mouseup", this._canvasMouseUpHandler), this._timeout && (window.clearTimeout(this._timeout), this._timeout = null) } } class KeyboardPanRotateDollyHandler { constructor(e, t, i, s, r) { const a = (this._scene = e).input, o = [], n = e.canvas.canvas; let h = !0; this._onSceneMouseMove = a.on("mousemove", (() => { h = !0 })), this._onSceneKeyDown = a.on("keydown", (t => { i.active && i.pointerEnabled && e.input.keyboardEnabled && s.mouseover && (o[t] = !0, t === a.KEY_SHIFT) && (n.style.cursor = "move") })), this._onSceneKeyUp = a.on("keyup", (t => { i.active && i.pointerEnabled && e.input.keyboardEnabled && s.mouseover && (o[t] = !1, t === a.KEY_SHIFT) && (n.style.cursor = null) })), this._onTick = e.on("tick", (n => { var l, c, u, p, d, m; i.active && i.pointerEnabled && e.input.keyboardEnabled && s.mouseover && (m = t.cameraControl, n = n.deltaTime / 1e3, i.planView || (p = m._isKeyDownForAction(m.ROTATE_Y_POS, o), u = m._isKeyDownForAction(m.ROTATE_Y_NEG, o), d = m._isKeyDownForAction(m.ROTATE_X_POS, o), l = m._isKeyDownForAction(m.ROTATE_X_NEG, o), c = n * i.keyboardRotationRate, (p || u || d || l) && (!i.firstPerson && i.followPointer && t.pivotController.startPivot(), p ? r.rotateDeltaY += c : u && (r.rotateDeltaY -= c), d ? r.rotateDeltaX += c : l && (r.rotateDeltaX -= c), !i.firstPerson) && i.followPointer && t.pivotController.startPivot()), o[a.KEY_CTRL] || o[a.KEY_ALT] || (p = m._isKeyDownForAction(m.DOLLY_BACKWARDS, o), u = m._isKeyDownForAction(m.DOLLY_FORWARDS, o), (p || u) && (d = n * i.keyboardDollyRate, !i.firstPerson && i.followPointer && t.pivotController.startPivot(), u ? r.dollyDelta -= d : p && (r.dollyDelta += d), h) && (s.followPointerDirty = !0, h = !1)), l = m._isKeyDownForAction(m.PAN_FORWARDS, o), c = m._isKeyDownForAction(m.PAN_BACKWARDS, o), u = m._isKeyDownForAction(m.PAN_LEFT, o), p = m._isKeyDownForAction(m.PAN_RIGHT, o), d = m._isKeyDownForAction(m.PAN_UP, o), m = m._isKeyDownForAction(m.PAN_DOWN, o), n = (o[a.KEY_ALT] ? .3 : 1) * n * i.keyboardPanRate, l || c || u || p || d || m) && (!i.firstPerson && i.followPointer && t.pivotController.startPivot(), m ? r.panDeltaY += n : d && (r.panDeltaY += -n), p ? r.panDeltaX += -n : u && (r.panDeltaX += n), c ? r.panDeltaZ += n : l && (r.panDeltaZ += -n)) })) } reset() { } destroy() { this._scene.off(this._onTick), this._scene.input.off(this._onSceneMouseMove), this._scene.input.off(this._onSceneKeyDown), this._scene.input.off(this._onSceneKeyUp) } } const SCALE_DOLLY_EACH_FRAME = 1, EPSILON = .001, tempVec3$1 = math.vec3(); class CameraUpdater { constructor(e, t, i, s, r) { const a = (this._scene = e).camera, o = t.pickController, n = t.pivotController, h = t.panController; let l = 1, c = 1, u = null; this._onTick = e.on("tick", (() => { if (i.active && i.pointerEnabled) { let f = "default"; Math.abs(r.dollyDelta) < .001 && (r.dollyDelta = 0), Math.abs(r.rotateDeltaX) < .001 && (r.rotateDeltaX = 0), Math.abs(r.rotateDeltaY) < .001 && (r.rotateDeltaY = 0), 0 === r.rotateDeltaX && 0 === r.rotateDeltaY || (r.dollyDelta = 0), i.followPointer && --l <= 0 && (l = 1, 0 !== r.dollyDelta) && (0 === r.rotateDeltaY && 0 === r.rotateDeltaX && i.followPointer && s.followPointerDirty && (o.pickCursorPos = s.pointerCanvasPos, o.schedulePickSurface = !0, o.update(), u = o.pickResult && o.pickResult.worldPos ? o.pickResult.worldPos : (c = 1, null), s.followPointerDirty = !1), u && (t = Math.abs(math.lenVec3(math.subVec3(u, e.camera.eye, tempVec3$1))), c = t / i.dollyProximityThreshold), c < i.dollyMinSpeed) && (c = i.dollyMinSpeed); var t = r.dollyDelta * c; if (0 === r.rotateDeltaY && 0 === r.rotateDeltaX || (!i.firstPerson && i.followPointer && n.getPivoting() ? (n.continuePivot(r.rotateDeltaY, r.rotateDeltaX), n.showPivot()) : (0 !== r.rotateDeltaX && (i.firstPerson ? a.pitch(-r.rotateDeltaX) : a.orbitPitch(r.rotateDeltaX)), 0 !== r.rotateDeltaY && (i.firstPerson ? a.yaw(r.rotateDeltaY) : a.orbitYaw(r.rotateDeltaY))), r.rotateDeltaX *= i.rotationInertia, r.rotateDeltaY *= i.rotationInertia, f = "grabbing"), Math.abs(r.panDeltaX) < .001 && (r.panDeltaX = 0), Math.abs(r.panDeltaY) < .001 && (r.panDeltaY = 0), Math.abs(r.panDeltaZ) < .001 && (r.panDeltaZ = 0), 0 !== r.panDeltaX || 0 !== r.panDeltaY || 0 !== r.panDeltaZ) { var p, d, m = math.vec3(); let e, t; m[0] = r.panDeltaX, m[1] = r.panDeltaY, m[2] = r.panDeltaZ, i.constrainVertical ? (a.xUp ? (e = a.eye[0], t = a.look[0]) : a.yUp ? (e = a.eye[1], t = a.look[1]) : a.zUp && (e = a.eye[2], t = a.look[2]), a.pan(m), p = a.eye, d = a.look, a.xUp ? (p[0] = e, d[0] = t) : a.yUp ? (p[1] = e, d[1] = t) : a.zUp && (p[2] = e, d[2] = t), a.eye = p, a.look = d) : a.pan(m), f = "grabbing" } if (r.panDeltaX *= i.panInertia, r.panDeltaY *= i.panInertia, r.panDeltaZ *= i.panInertia, 0 != t) { if (f = t < 0 ? "zoom-in" : "zoom-out", i.firstPerson) { let e, r; i.constrainVertical && (a.xUp ? (e = a.eye[0], r = a.look[0]) : a.yUp ? (e = a.eye[1], r = a.look[1]) : a.zUp && (e = a.eye[2], r = a.look[2])), i.followPointer ? h.dollyToCanvasPos(u, s.pointerCanvasPos, -t) && (s.followPointerDirty = !0) : (a.pan([0, 0, t]), a.ortho.scale = a.ortho.scale - t), i.constrainVertical && (p = a.eye, d = a.look, a.xUp ? (p[0] = e, d[0] = r) : a.yUp ? (p[1] = e, d[1] = r) : a.zUp && (p[2] = e, d[2] = r), a.eye = p, a.look = d) } else i.planView, i.followPointer ? h.dollyToCanvasPos(u, s.pointerCanvasPos, -t) && (s.followPointerDirty = !0) : (a.ortho.scale = a.ortho.scale + t, a.zoom(t)); r.dollyDelta *= i.dollyInertia } o.fireEvents(), document.body.style.cursor = f } })) } destroy() { this._scene.off(this._onTick) } } class MouseMiscHandler { constructor(e, t, i, s, r) { this._scene = e; const a = this._scene.canvas.canvas; a.addEventListener("mouseenter", this._mouseEnterHandler = () => { s.mouseover = !0 }), a.addEventListener("mouseleave", this._mouseLeaveHandler = () => { s.mouseover = !1, a.style.cursor = null }), document.addEventListener("mousemove", this._mouseMoveHandler = e => { getCanvasPosFromEvent$3(e, a, s.pointerCanvasPos) }), a.addEventListener("mousedown", this._mouseDownHandler = e => { i.active && i.pointerEnabled && (getCanvasPosFromEvent$3(e, a, s.pointerCanvasPos), s.mouseover = !0) }), a.addEventListener("mouseup", this._mouseUpHandler = e => { i.active && i.pointerEnabled }) } reset() { } destroy() { var e = this._scene.canvas.canvas; document.removeEventListener("mousemove", this._mouseMoveHandler), e.removeEventListener("mouseenter", this._mouseEnterHandler), e.removeEventListener("mouseleave", this._mouseLeaveHandler), e.removeEventListener("mousedown", this._mouseDownHandler), e.removeEventListener("mouseup", this._mouseUpHandler) } } function getCanvasPosFromEvent$3(e, t, i) { var s; return e ? (({ x: t, y: s } = t.getBoundingClientRect()), i[0] = e.clientX - t, i[1] = e.clientY - s) : (e = window.event, i[0] = e.x, i[1] = e.y), i } const getCanvasPosFromEvent$2 = function (e, t) { if (e) { let i = e.target, s = 0, r = 0; for (; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t }; class TouchPanRotateAndDollyHandler { constructor(e, t, i, s, r) { this._scene = e; const a = t.pickController, o = t.pivotController, n = math.vec2(), h = math.vec2(), l = math.vec2(), c = math.vec2(), u = []; t = this._scene.canvas.canvas; let p = 0, d = !1; this._onTick = e.on("tick", (() => { d = !1 })), t.addEventListener("touchstart", this._canvasTouchStartHandler = t => { if (i.active && i.pointerEnabled) { t.preventDefault(); var r = t.touches; t = t.changedTouches; for (s.touchStartTime = Date.now(), 1 === r.length && 1 === t.length && (getCanvasPosFromEvent$2(r[0], n), i.followPointer) && (a.pickCursorPos = n, a.schedulePickSurface = !0, a.update(), i.planView || (a.picked && a.pickedSurface && a.pickResult && a.pickResult.worldPos ? o.setPivotPos(a.pickResult.worldPos) : i.smartPivot ? o.setCanvasPivotPos(s.pointerCanvasPos) : o.setPivotPos(e.camera.look), !i.firstPerson && o.startPivot() && o.showPivot())); u.length < r.length;)u.push(math.vec2()); for (let e = 0, t = r.length; e < t; ++e)getCanvasPosFromEvent$2(r[e], u[e]); p = r.length } }), t.addEventListener("touchmove", this._canvasTouchMoveHandler = t => { if (i.active && i.pointerEnabled && (t.stopPropagation(), t.preventDefault(), !d)) { d = !0; var o, n, m, f, g = (_ = e.canvas.boundary)[2], _ = _[3], v = t.touches; if (t.touches.length === p) { 1 === p ? (getCanvasPosFromEvent$2(v[0], h), math.subVec2(h, u[0], c), t = c[0], o = c[1], null !== s.longTouchTimeout && (Math.abs(t) > i.longTapRadius || Math.abs(o) > i.longTapRadius) && (clearTimeout(s.longTouchTimeout), s.longTouchTimeout = null), i.planView ? "perspective" === (f = e.camera).projection ? (m = Math.abs(e.camera.eyeLookDist) * Math.tan(f.perspective.fov / 2 * Math.PI / 180), r.panDeltaX += t * m / _ * i.touchPanRate, r.panDeltaY += o * m / _ * i.touchPanRate) : (r.panDeltaX += .5 * f.ortho.scale * (t / _) * i.touchPanRate, r.panDeltaY += .5 * f.ortho.scale * (o / _) * i.touchPanRate) : (r.rotateDeltaY -= t / g * +i.dragRotationRate, r.rotateDeltaX += o / _ * (1.5 * i.dragRotationRate))) : 2 === p && (m = v[0], f = v[1], getCanvasPosFromEvent$2(m, h), getCanvasPosFromEvent$2(f, l), t = math.geometricMeanVec2(u[0], u[1]), g = math.geometricMeanVec2(h, l), o = math.vec2(), math.subVec2(t, g, o), t = o[0], o = o[1], n = e.camera, m = math.distVec2([m.pageX, m.pageY], [f.pageX, f.pageY]), f = (math.distVec2(u[0], u[1]) - m) * i.touchDollyRate, r.dollyDelta = f, Math.abs(f) < 1 && ("perspective" === n.projection ? (m = a.pickResult ? a.pickResult.worldPos : e.center, f = Math.abs(math.lenVec3(math.subVec3(m, e.camera.eye, []))) * Math.tan(n.perspective.fov / 2 * Math.PI / 180), r.panDeltaX -= t * f / _ * i.touchPanRate, r.panDeltaY -= o * f / _ * i.touchPanRate) : (r.panDeltaX -= .5 * n.ortho.scale * (t / _) * i.touchPanRate, r.panDeltaY -= .5 * n.ortho.scale * (o / _) * i.touchPanRate)), s.pointerCanvasPos = g); for (let e = 0; e < p; ++e)getCanvasPosFromEvent$2(v[e], u[e]) } } }) } reset() { } destroy() { var e = this._scene.canvas.canvas; e.removeEventListener("touchstart", this._canvasTouchStartHandler), e.removeEventListener("touchmove", this._canvasTouchMoveHandler), this._scene.off(this._onTick) } } const TAP_INTERVAL = 150, DBL_TAP_INTERVAL = 325, TAP_DISTANCE_THRESHOLD = 4, getCanvasPosFromEvent$1 = function (e, t) { if (e) { let i = e.target, s = 0, r = 0; for (; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t }; class TouchPickHandler { constructor(e, t, i, s, r) { this._scene = e; const a = t.pickController, o = t.cameraControl; let n; const h = [], l = new Float32Array(2); let c = -1, u = -1; var p = this._scene.canvas.canvas; const d = i => { let s; i && i.worldPos && (s = i.worldPos); var r; i = (i ? i.entity : e).aabb; s && (r = e.camera, math.subVec3(r.eye, r.look, [])), t.cameraFlight.flyTo({ aabb: i }) }; p.addEventListener("touchstart", this._canvasTouchStartHandler = e => { if (i.active && i.pointerEnabled) { null !== s.longTouchTimeout && (clearTimeout(s.longTouchTimeout), s.longTouchTimeout = null); var r = e.touches, a = e.changedTouches; if (n = Date.now(), 1 === r.length && 1 === a.length) { c = n, getCanvasPosFromEvent$1(r[0], l); const a = l[0], o = l[1], h = r[0].pageX, u = r[0].pageY; s.longTouchTimeout = setTimeout((() => { t.cameraControl.fire("rightClick", { pagePos: [Math.round(h), Math.round(u)], canvasPos: [Math.round(a), Math.round(o)], event: e }, !0), s.longTouchTimeout = null }), i.longTapTimeout) } else c = -1; for (; h.length < r.length;)h.push(new Float32Array(2)); for (let e = 0, t = r.length; e < t; ++e)getCanvasPosFromEvent$1(r[e], h[e]); h.length = r.length } }, { passive: !0 }), p.addEventListener("touchend", this._canvasTouchEndHandler = e => { if (i.active && i.pointerEnabled) { var t = Date.now(), r = e.touches, n = (e = e.changedTouches, o.hasSubs("pickedSurface")); null !== s.longTouchTimeout && (clearTimeout(s.longTouchTimeout), s.longTouchTimeout = null), 0 === r.length && 1 === e.length && -1 < c && t - c < 150 && (-1 < u && c - u < 325 ? (getCanvasPosFromEvent$1(e[0], a.pickCursorPos), a.schedulePickEntity = !0, a.schedulePickSurface = n, a.update(), a.pickResult ? (a.pickResult.touchInput = !0, o.fire("doublePicked", a.pickResult), a.pickedSurface && o.fire("doublePickedSurface", a.pickResult), i.doublePickFlyTo && d(a.pickResult)) : (o.fire("doublePickedNothing"), i.doublePickFlyTo && d()), u = -1) : math.distVec2(h[0], l) < 4 && (getCanvasPosFromEvent$1(e[0], a.pickCursorPos), a.schedulePickEntity = !0, a.schedulePickSurface = n, a.update(), a.pickResult ? (a.pickResult.touchInput = !0, o.fire("picked", a.pickResult), a.pickedSurface && o.fire("pickedSurface", a.pickResult)) : o.fire("pickedNothing"), u = t), c = -1), h.length = r.length; for (let e = 0, t = r.length; e < t; ++e)h[e][0] = r[e].pageX, h[e][1] = r[e].pageY } }, { passive: !0 }) } reset() { } destroy() { var e = this._scene.canvas.canvas; e.removeEventListener("touchstart", this._canvasTouchStartHandler), e.removeEventListener("touchend", this._canvasTouchEndHandler) } } class CameraControl extends Component { constructor(e, t = {}) { super(e, t), this.PAN_LEFT = 0, this.PAN_RIGHT = 1, this.PAN_UP = 2, this.PAN_DOWN = 3, this.PAN_FORWARDS = 4, this.PAN_BACKWARDS = 5, this.ROTATE_X_POS = 6, this.ROTATE_X_NEG = 7, this.ROTATE_Y_POS = 8, this.ROTATE_Y_NEG = 9, this.DOLLY_FORWARDS = 10, this.DOLLY_BACKWARDS = 11, this.AXIS_VIEW_RIGHT = 12, this.AXIS_VIEW_BACK = 13, this.AXIS_VIEW_LEFT = 14, this.AXIS_VIEW_FRONT = 15, this.AXIS_VIEW_TOP = 16, this.AXIS_VIEW_BOTTOM = 17, this._keyMap = {}, this.scene.canvas.canvas.oncontextmenu = e => { e.preventDefault() }, this._configs = { longTapTimeout: 600, longTapRadius: 5, active: !0, keyboardLayout: "qwerty", navMode: "orbit", planView: !1, firstPerson: !1, followPointer: !0, doublePickFlyTo: !0, panRightClick: !0, showPivot: !1, pointerEnabled: !0, constrainVertical: !1, smartPivot: !1, doubleClickTimeFrame: 250, dragRotationRate: 360, keyboardRotationRate: 90, rotationInertia: 0, keyboardPanRate: 1, touchPanRate: 1, panInertia: .5, keyboardDollyRate: 10, mouseWheelDollyRate: 100, touchDollyRate: .2, dollyInertia: 0, dollyProximityThreshold: 30, dollyMinSpeed: .04 }, this._states = { pointerCanvasPos: math.vec2(), mouseover: !1, followPointerDirty: !0, mouseDownClientX: 0, mouseDownClientY: 0, mouseDownCursorX: 0, mouseDownCursorY: 0, touchStartTime: null, activeTouches: [], tapStartPos: math.vec2(), tapStartTime: -1, lastTapTime: -1, longTouchTimeout: null }, this._updates = { rotateDeltaX: 0, rotateDeltaY: 0, panDeltaX: 0, panDeltaY: 0, panDeltaZ: 0, dollyDelta: 0 }, e = this.scene, this._controllers = { cameraControl: this, pickController: new PickController(this, this._configs), pivotController: new PivotController(e, this._configs), panController: new PanController(e), cameraFlight: new CameraFlightAnimation(this, { duration: .5 }) }, this._handlers = [new MouseMiscHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new TouchPanRotateAndDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new MousePanRotateDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new KeyboardAxisViewHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new MousePickHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new TouchPickHandler(this.scene, this._controllers, this._configs, this._states, this._updates), new KeyboardPanRotateDollyHandler(this.scene, this._controllers, this._configs, this._states, this._updates)], this._cameraUpdater = new CameraUpdater(this.scene, this._controllers, this._configs, this._states, this._updates), this.navMode = t.navMode, t.planView && (this.planView = t.planView), this.constrainVertical = t.constrainVertical, t.keyboardLayout ? this.keyboardLayout = t.keyboardLayout : this.keyMap = t.keyMap, this.doublePickFlyTo = t.doublePickFlyTo, this.panRightClick = t.panRightClick, this.active = t.active, this.followPointer = t.followPointer, this.rotationInertia = t.rotationInertia, this.keyboardPanRate = t.keyboardPanRate, this.touchPanRate = t.touchPanRate, this.keyboardRotationRate = t.keyboardRotationRate, this.dragRotationRate = t.dragRotationRate, this.touchDollyRate = t.touchDollyRate, this.dollyInertia = t.dollyInertia, this.dollyProximityThreshold = t.dollyProximityThreshold, this.dollyMinSpeed = t.dollyMinSpeed, this.panInertia = t.panInertia, this.pointerEnabled = !0, this.keyboardDollyRate = t.keyboardDollyRate, this.mouseWheelDollyRate = t.mouseWheelDollyRate } set keyMap(e) { if (e = e || "qwerty", utils.isString(e)) { var t = this.scene.input, i = {}; switch (e) { default: this.error("Unsupported value for 'keyMap': " + e + " defaulting to 'qwerty'"); case "qwerty": i[this.PAN_LEFT] = [t.KEY_A], i[this.PAN_RIGHT] = [t.KEY_D], i[this.PAN_UP] = [t.KEY_Z], i[this.PAN_DOWN] = [t.KEY_X], i[this.PAN_BACKWARDS] = [], i[this.PAN_FORWARDS] = [], i[this.DOLLY_FORWARDS] = [t.KEY_W, t.KEY_ADD], i[this.DOLLY_BACKWARDS] = [t.KEY_S, t.KEY_SUBTRACT], i[this.ROTATE_X_POS] = [t.KEY_DOWN_ARROW], i[this.ROTATE_X_NEG] = [t.KEY_UP_ARROW], i[this.ROTATE_Y_POS] = [t.KEY_Q, t.KEY_LEFT_ARROW], i[this.ROTATE_Y_NEG] = [t.KEY_E, t.KEY_RIGHT_ARROW], i[this.AXIS_VIEW_RIGHT] = [t.KEY_NUM_1], i[this.AXIS_VIEW_BACK] = [t.KEY_NUM_2], i[this.AXIS_VIEW_LEFT] = [t.KEY_NUM_3], i[this.AXIS_VIEW_FRONT] = [t.KEY_NUM_4], i[this.AXIS_VIEW_TOP] = [t.KEY_NUM_5], i[this.AXIS_VIEW_BOTTOM] = [t.KEY_NUM_6]; break; case "azerty": i[this.PAN_LEFT] = [t.KEY_Q], i[this.PAN_RIGHT] = [t.KEY_D], i[this.PAN_UP] = [t.KEY_W], i[this.PAN_DOWN] = [t.KEY_X], i[this.PAN_BACKWARDS] = [], i[this.PAN_FORWARDS] = [], i[this.DOLLY_FORWARDS] = [t.KEY_Z, t.KEY_ADD], i[this.DOLLY_BACKWARDS] = [t.KEY_S, t.KEY_SUBTRACT], i[this.ROTATE_X_POS] = [t.KEY_DOWN_ARROW], i[this.ROTATE_X_NEG] = [t.KEY_UP_ARROW], i[this.ROTATE_Y_POS] = [t.KEY_A, t.KEY_LEFT_ARROW], i[this.ROTATE_Y_NEG] = [t.KEY_E, t.KEY_RIGHT_ARROW], i[this.AXIS_VIEW_RIGHT] = [t.KEY_NUM_1], i[this.AXIS_VIEW_BACK] = [t.KEY_NUM_2], i[this.AXIS_VIEW_LEFT] = [t.KEY_NUM_3], i[this.AXIS_VIEW_FRONT] = [t.KEY_NUM_4], i[this.AXIS_VIEW_TOP] = [t.KEY_NUM_5], i[this.AXIS_VIEW_BOTTOM] = [t.KEY_NUM_6] }this._keyMap = i } else { var s = e; this._keyMap = s } } get keyMap() { return this._keyMap } _isKeyDownForAction(e, t) { var i = this._keyMap[e]; if (i) { t = t || this.scene.input.keyDown; for (let e = 0, s = i.length; e < s; e++)if (t[i[e]]) return !0 } return !1 } set pivotElement(e) { this._controllers.pivotController.setPivotElement(e) } set active(e) { this._configs.active = !1 !== e } get active() { return this._configs.active } set navMode(e) { "firstPerson" !== (e = e || "orbit") && "orbit" !== e && "planView" !== e && (this.error("Unsupported value for navMode: " + e + " - supported values are 'orbit', 'firstPerson' and 'planView' - defaulting to 'orbit'"), e = "orbit"), this._configs.firstPerson = "firstPerson" === e, this._configs.planView = "planView" === e, (this._configs.firstPerson || this._configs.planView) && (this._controllers.pivotController.hidePivot(), this._controllers.pivotController.endPivot()), this._configs.navMode = e } get navMode() { return this._configs.navMode } set pointerEnabled(e) { this._reset(), this._configs.pointerEnabled = !!e } _reset() { for (let t = 0, i = this._handlers.length; t < i; t++) { var e = this._handlers[t]; e.reset && e.reset() } this._updates.panDeltaX = 0, this._updates.panDeltaY = 0, this._updates.rotateDeltaX = 0, this._updates.rotateDeltaY = 0, this._updates.dolyDelta = 0 } get pointerEnabled() { return this._configs.pointerEnabled } set followPointer(e) { this._configs.followPointer = !1 !== e } get followPointer() { return this._configs.followPointer } set pivotPos(e) { this._controllers.pivotController.setPivotPos(e) } get pivotPos() { return this._controllers.pivotController.getPivotPos() } set dollyToPointer(e) { this.warn("dollyToPointer property is deprecated - replaced with followPointer"), this.followPointer = e } get dollyToPointer() { return this.warn("dollyToPointer property is deprecated - replaced with followPointer"), this.followPointer } set panToPointer(e) { this.warn("panToPointer property is deprecated - replaced with followPointer") } get panToPointer() { return this.warn("panToPointer property is deprecated - replaced with followPointer"), !1 } set planView(e) { this._configs.planView = !!e, this._configs.firstPerson = !1, this._configs.planView && (this._controllers.pivotController.hidePivot(), this._controllers.pivotController.endPivot()), this.warn("planView property is deprecated - replaced with navMode") } get planView() { return this.warn("planView property is deprecated - replaced with navMode"), this._configs.planView } set firstPerson(e) { this.warn("firstPerson property is deprecated - replaced with navMode"), this._configs.firstPerson = !!e, this._configs.planView = !1, this._configs.firstPerson && (this._controllers.pivotController.hidePivot(), this._controllers.pivotController.endPivot()) } get firstPerson() { return this.warn("firstPerson property is deprecated - replaced with navMode"), this._configs.firstPerson } set constrainVertical(e) { this._configs.constrainVertical = !!e } get constrainVertical() { return this._configs.constrainVertical } set doublePickFlyTo(e) { this._configs.doublePickFlyTo = !1 !== e } get doublePickFlyTo() { return this._configs.doublePickFlyTo } set panRightClick(e) { this._configs.panRightClick = !1 !== e } get panRightClick() { return this._configs.panRightClick } set rotationInertia(e) { this._configs.rotationInertia = null != e ? e : 0 } get rotationInertia() { return this._configs.rotationInertia } set keyboardPanRate(e) { this._configs.keyboardPanRate = null != e ? e : 5 } set touchPanRate(e) { this._configs.touchPanRate = null != e ? e : 1 } get touchPanRate() { return this._configs.touchPanRate } get keyboardPanRate() { return this._configs.keyboardPanRate } set keyboardRotationRate(e) { this._configs.keyboardRotationRate = null != e ? e : 90 } get keyboardRotationRate() { return this._configs.keyboardRotationRate } set dragRotationRate(e) { this._configs.dragRotationRate = null != e ? e : 360 } get dragRotationRate() { return this._configs.dragRotationRate } set keyboardDollyRate(e) { this._configs.keyboardDollyRate = null != e ? e : 15 } get keyboardDollyRate() { return this._configs.keyboardDollyRate } set touchDollyRate(e) { this._configs.touchDollyRate = null != e ? e : .2 } get touchDollyRate() { return this._configs.touchDollyRate } set mouseWheelDollyRate(e) { this._configs.mouseWheelDollyRate = null != e ? e : 100 } get mouseWheelDollyRate() { return this._configs.mouseWheelDollyRate } set dollyInertia(e) { this._configs.dollyInertia = null != e ? e : 0 } get dollyInertia() { return this._configs.dollyInertia } set dollyProximityThreshold(e) { this._configs.dollyProximityThreshold = null != e ? e : 35 } get dollyProximityThreshold() { return this._configs.dollyProximityThreshold } set dollyMinSpeed(e) { this._configs.dollyMinSpeed = null != e ? e : .04 } get dollyMinSpeed() { return this._configs.dollyMinSpeed } set panInertia(e) { this._configs.panInertia = null != e ? e : .5 } get panInertia() { return this._configs.panInertia } set keyboardLayout(e) { "qwerty" !== (e = e || "qwerty") && "azerty" !== e && (this.error("Unsupported value for keyboardLayout - defaulting to 'qwerty'"), e = "qwerty"), this._configs.keyboardLayout = e, this.keyMap = this._configs.keyboardLayout } get keyboardLayout() { return this._configs.keyboardLayout } set smartPivot(e) { this._configs.smartPivot = !1 !== e } get smartPivot() { return this._configs.smartPivot } set doubleClickTimeFrame(e) { this._configs.doubleClickTimeFrame = null != e ? e : 250 } get doubleClickTimeFrame() { return this._configs.doubleClickTimeFrame } destroy() { this._destroyHandlers(), this._destroyControllers(), this._cameraUpdater.destroy(), super.destroy() } _destroyHandlers() { for (let t = 0, i = this._handlers.length; t < i; t++) { var e = this._handlers[t]; e.destroy && e.destroy() } } _destroyControllers() { for (let t = 0, i = this._controllers.length; t < i; t++) { var e = this._controllers[t]; e.destroy && e.destroy() } } } class MetaModel { constructor(e, t, i, s, r, a, o, n, h, l) { this.id = t, this.projectId = i, this.revisionId = s, this.author = r, this.createdAt = a, this.creatingApplication = o, this.schema = n, this.metaScene = e, this.propertySets = h, this.rootMetaObject = l } getJSON() { const e = []; return function t(i) { var s = { id: i.id, extId: i.extId, type: i.type, name: i.name }, r = (i.parent && (s.parent = i.parent.id), e.push(s), i.children); if (r) for (let e = 0, i = r.length; e < i; e++)t(r[e]) }(this.rootMetaObject), { id: this.id, projectId: this.projectId, revisionId: this.revisionId, metaObjects: e } } } class MetaObject { constructor(e, t, i, s, r, a, o, n, h) { this.metaModel = e, this.id = t, this.originalSystemId = i, this.name = this._decodeIfcName(s), this.type = r, this.propertySets = a, null != o && (this.parent = o), null != n && (this.children = n), null != h && (this.external = h) } _decodeIfcName(e) { try { return (e = (e = (e = e?.replace(/\\/g, ""))?.replace(/\'/g, ""))?.replace(/\"/g, ""))?.replace(/X2([0-9A-F]{4,16})X0/g, (function (e, t) { var i = []; for (let e = 0; e < t.length; e += 4) { var s = parseInt(t.substr(e, 4), 16).toString(16).padStart(4, "0"); i.push(s) } return String.fromCharCode.apply(null, i.map((e => parseInt(e, 16)))) })) } catch (t) { return e } } getObjectIDsInSubtree() { const e = []; return function t(i) { if (i) { e.push(i.id); var s = i.children; if (s) for (var r = 0, a = s.length; r < a; r++)t(s[r]) } }(this), e } withMetaObjectsInSubtree(e) { !function t(i) { if (i) { e(i); var s = i.children; if (s) for (var r = 0, a = s.length; r < a; r++)t(s[r]) } }(this) } getObjectIDsInSubtreeByType(e) { const t = {}; for (var i = 0, s = e.length; i < s; i++)t[e[i]] = e[i]; const r = []; return function e(i) { if (i) { t[i.type] && r.push(i.id); var s = i.children; if (s) for (var a = 0, o = s.length; a < o; a++)e(s[a]) } }(this), r } getJSON() { var e = { id: this.id, type: this.type, name: this.name }; return this.parent && (e.parent = this.parent.id), e } } class Property { constructor(e, t, i, s, r) { this.name = e, this.type = i, this.value = t, this.valueType = s, this.description = r } } class PropertySet { constructor(e, t, i, s, r) { if (this.id = e, this.originalSystemId = t, this.name = i, this.type = s, this.properties = [], r) for (let e = 0, t = r.length; e < t; e++) { var a = r[e]; this.properties.push(new Property(a.name, a.value, a.type, a.valueType, a.description)) } } } class MetaScene { constructor(e, t) { this.viewer = e, this.scene = t, this.metaModels = {}, this.propertySets = {}, this.metaObjects = {}, this.metaObjectsByType = {}, this._typeCounts = {}, this._eventSubs = {} } on(e, t) { let i = this._eventSubs[e]; i || (i = [], this._eventSubs[e] = i), i.push(t) } fire(e, t) { var i = this._eventSubs[e]; if (i) for (let e = 0, s = i.length; e < s; e++)i[e](t) } off(e) { } createMetaModel(e, t, i = {}) { var s = t.projectId || "none", r = t.revisionId || "none", a = t.propertySets || [], o = t.metaObjects || [], n = t.author, h = t.createdAt, l = t.creatingApplication, c = (t = t.schema, new MetaModel(this, e, s, r, n, h, l, t, [], null)); this.metaModels[e] = c; for (let e = 0, t = a.length; e < t; e++) { var u = (p = a[e]).id, p = new PropertySet(u, p.originalSystemId, p.name, p.type, p.properties); c.propertySets[u] = p, this.propertySets[u] = p } var d = []; for (let e = 0, t = o.length; e < t; e++) { var m = o[e]; void 0 !== m.parent && null !== m.parent || d.push(m) } if (0 === d.length) { this.scene.error("Cyclic containment hierarchy found in metamodel - will flatten the hierarchy and insert fake 'Model' root"); var f = { id: e + ".fakeRoot", name: e, type: "Model", parent: null }; for (let e = 0, t = o.length; e < t; e++)o[e].parent = f.id; o.push(f) } if (1 < d.length) { this.scene.error("Multiple containment hierarchy root found in metamodel - will insert fake 'Model' root"); var g = { id: e + ".fakeRoot", name: e, type: "Model", parent: null }; o.push(g); for (let e = 0, t = d.length; e < t; e++)d[e].parent = g.id } for (let t = 0, s = o.length; t < s; t++) { var _ = o[t], v = _.type, y = i.globalizeObjectIds ? math.globalizeObjectId(e, _.id) : _.id, T = _.id, I = _.name, E = []; if (_.propertySetIds && 0 < _.propertySetIds.length) for (let e = 0, t = _.propertySetIds.length; e < t; e++) { var C = _.propertySetIds[e]; (C = c.propertySets[C]) && E.push(C) } var P = _.external; T = new MetaObject(c, y, T, I, v, E, null, null, P); this.metaObjects[y] = T, (this.metaObjectsByType[v] || (this.metaObjectsByType[v] = {}))[y] = T, void 0 === this._typeCounts[v] ? this._typeCounts[v] = 1 : this._typeCounts[v]++ } for (let t = 0, s = o.length; t < s; t++) { var b = o[t], A = i.globalizeObjectIds ? math.globalizeObjectId(e, b.id) : b.id; (A = this.metaObjects[A]) && (void 0 === b.parent || null === b.parent ? c.rootMetaObject = A : b.parent && (b = i.globalizeObjectIds ? math.globalizeObjectId(e, b.parent) : b.parent, b = this.metaObjects[b]) && ((A.parent = b).children = b.children || [], b.children.push(A))) } return this.fire("metaModelCreated", e), c } destroyMetaModel(e) { var t = this.metaModels[e]; t && (this._removeMetaModel(t), this.fire("metaModelDestroyed", e)) } _removeMetaModel(e) { const t = this.metaObjects, i = this.metaObjectsByType; let s = e => { delete t[e.id]; var r = i[e.type], a = (r && r[e.id] && (delete r[e.id], 0 == --this._typeCounts[e.type]) && (delete this._typeCounts[e.type], delete i[e.type]), e.children); if (a) for (let e = 0, t = a.length; e < t; e++) { var o = a[e]; s(o) } }; for (var r in s(e.rootMetaObject), e.propertySets) e.propertySets.hasOwnProperty(r) && delete this.propertySets[r]; delete this.metaModels[e.id] } getObjectIDsByType(e) { return (e = this.metaObjectsByType[e]) ? Object.keys(e) : [] } getObjectIDsInSubtree(e, t, i) { const s = [], r = (e = this.metaObjects[e], t && 0 < t.length ? arrayToMap(t) : null), a = i && 0 < i.length ? arrayToMap(i) : null; return function e(t) { if (t) { a && a[t.type] || r && !r[t.type] || s.push(t.id); var i = t.children; if (i) for (var o = 0, n = i.length; o < n; o++)e(i[o]) } }(e), s } withMetaObjectsInSubtree(e, t) { (e = this.metaObjects[e]) && e.withMetaObjectsInSubtree(t) } } function arrayToMap(e) { for (var t = {}, i = 0, s = e.length; i < s; i++)t[e[i]] = !0; return t } class Viewer { constructor(e) { this.language = "en", this.localeService = e.localeService || new LocaleService, this.scene = new Scene(this, { canvasId: e.canvasId, canvasElement: e.canvasElement, keyboardEventsElement: e.keyboardEventsElement, contextAttr: { preserveDrawingBuffer: !1 !== e.preserveDrawingBuffer, premultipliedAlpha: !!e.premultipliedAlpha, antialias: !1 !== e.antialias }, spinnerElementId: e.spinnerElementId, transparent: !1 !== e.transparent, gammaInput: !0, gammaOutput: !1, backgroundColor: e.backgroundColor, backgroundColorFromAmbientLight: e.backgroundColorFromAmbientLight, ticksPerRender: 1, ticksPerOcclusionTest: 20, units: e.units, scale: e.scale, origin: e.origin, saoEnabled: e.saoEnabled, alphaDepthMask: !1 !== e.alphaDepthMask, entityOffsetsEnabled: !!e.entityOffsetsEnabled, pickSurfacePrecisionEnabled: !!e.pickSurfacePrecisionEnabled, logarithmicDepthBufferEnabled: !!e.logarithmicDepthBufferEnabled, pbrEnabled: !!e.pbrEnabled, colorTextureEnabled: !1 !== e.colorTextureEnabled }), this.metaScene = new MetaScene(this, this.scene), this.id = e.id || this.scene.id, this.camera = this.scene.camera, this.cameraFlight = new CameraFlightAnimation(this.scene, { duration: .5 }), this.cameraControl = new CameraControl(this.scene, { doublePickFlyTo: !0 }), this._plugins = [], this._eventSubs = {} } get capabilities() { return this.scene.capabilities } on(e, t) { let i = this._eventSubs[e]; i || (i = [], this._eventSubs[e] = i), i.push(t) } fire(e, t) { var i = this._eventSubs[e]; if (i) for (let e = 0, s = i.length; e < s; e++)i[e](t) } off(e) { } log(e) { console.log(`[xeokit viewer ${this.id}]: ` + e) } error(e) { console.error(`[xeokit viewer ${this.id}]: ` + e) } addPlugin(e) { this._plugins.push(e) } removePlugin(e) { for (let i = 0, s = this._plugins.length; i < s; i++) { var t = this._plugins[i]; if (t === e) return t.clear && t.clear(), void this._plugins.splice(i, 1) } } sendToPlugins(e, t) { for (let s = 0, r = this._plugins.length; s < r; s++) { var i = this._plugins[s]; i.send && i.send(e, t) } } clear() { throw 'Viewer#clear() no longer implemented - use \'#sendToPlugins("clear") instead' } resetView() { throw "Viewer#resetView() no longer implemented - use CameraMemento & ObjectsMemento classes instead" } beginSnapshot() { this._snapshotBegun || (this.scene._renderer.beginSnapshot(), this._snapshotBegun = !0) } getSnapshot(e = {}) { var t = !this._snapshotBegun, i = (this._snapshotBegun || this.beginSnapshot(), e.includeGizmos || this.sendToPlugins("snapshotStarting"), void 0 !== e.width && void 0 !== e.height), s = this.scene.canvas.canvas, r = s.clientWidth, a = s.clientHeight, o = s.style.width, n = s.style.height, h = e.width ? Math.floor(e.width) : s.width, l = e.height ? Math.floor(e.height) : s.height; i && (s.style.width = h + "px", s.style.height = l + "px"), this.scene._renderer.renderSnapshot(), h = this.scene._renderer.readSnapshot(e); return i && (s.style.width = o, s.style.height = n, s.width = r, s.height = a, this.scene.glRedraw()), e.includeGizmos || this.sendToPlugins("snapshotFinished"), t && this.endSnapshot(), h } endSnapshot() { this._snapshotBegun && (this.scene._renderer.endSnapshot(), this.scene._renderer.render({ force: !0 }), this._snapshotBegun = !1) } destroy() { var e = this._plugins.slice(); for (let t = 0, i = e.length; t < i; t++)e[t].destroy(); this.scene.destroy() } } class Configs { constructor() { } set doublePrecisionEnabled(e) { math.setDoublePrecisionEnabled(e) } get doublePrecisionEnabled() { return math.getDoublePrecisionEnabled() } } class DistanceMeasurementsControl extends Component { constructor(e) { super(e.viewer.scene), this.plugin = e, this._active = !1, this._currentDistanceMeasurementByMouse = null, this._currentDistanceMeasurementByMouseInittouchState = { wireVisible: null, axisVisible: null, xAxisVisible: null, yaxisVisible: null, zAxisVisible: null, targetVisible: null }, this._touchStartDot = new Dot(e._container, { fillColor: e.defaultColor, zIndex: e.zIndex + 1, visible: !1 }), this._touchStartMarker = new Marker(this, { id: "distanceMeasurementMarker" }), this._touchStartMarker.on("canvasPos", (e => { this._touchStartDot.setPos(e[0], e[1]) })), this._onMouseHoverSurface = null, this._onMouseHoverOff = null, this._onPickedNothing = null, this._onInputMouseDown = null, this._onInputMouseUp = null, this._onCanvasTouchStart = null, this._onCanvasTouchEnd = null } get active() { return this._active } activate() { if (!this._active) { const i = this.plugin, s = this.scene; var e = i.viewer.cameraControl; const r = s.canvas.canvas; var t = s.input; const a = this._touchStartDot, o = s.pickSurfacePrecisionEnabled; let n = null; const h = math.vec3(), l = math.vec2(); let c, u, p = 0; const d = math.vec2(), m = math.vec2(), f = math.vec3(); this._onMouseHoverSurface = e.on("hoverSurface", (e => { n = e.entity, h.set(e.worldPos), l.set(e.canvasPos), r.style.cursor = "pointer", this._currentDistanceMeasurementByMouse && (this._currentDistanceMeasurementByMouse.wireVisible = this._currentDistanceMeasurementByMouseInittouchState.wireVisible, this._currentDistanceMeasurementByMouse.axisVisible = this._currentDistanceMeasurementByMouseInittouchState.axisVisible && this.plugin.defaultAxisVisible, this._currentDistanceMeasurementByMouse.xAxisVisible = this._currentDistanceMeasurementByMouseInittouchState.xAxisVisible && this.plugin.defaultXAxisVisible, this._currentDistanceMeasurementByMouse.yAxisVisible = this._currentDistanceMeasurementByMouseInittouchState.yAxisVisible && this.plugin.defaultYAxisVisible, this._currentDistanceMeasurementByMouse.zAxisVisible = this._currentDistanceMeasurementByMouseInittouchState.zAxisVisible && this.plugin.defaultZAxisVisible, this._currentDistanceMeasurementByMouse.targetVisible = this._currentDistanceMeasurementByMouseInittouchState.targetVisible, this._currentDistanceMeasurementByMouse.target.entity = n, this._currentDistanceMeasurementByMouse.target.worldPos = h) })), this._onInputMouseDown = t.on("mousedown", (e => { c = e[0], u = e[1] })), this._onInputMouseUp = t.on("mouseup", (e => { e[0] > c + 5 || e[0] < c - 5 || e[1] > u + 5 || e[1] < u - 5 || (this._currentDistanceMeasurementByMouse ? (n ? (o && ((e = s.pick({ canvasPos: l, pickSurface: !0, pickSurfacePrecision: !0 })) && e.worldPos && (this._currentDistanceMeasurementByMouse.target.worldPos = e.worldPos), this._currentDistanceMeasurementByMouse.approximate = !1), this._currentDistanceMeasurementByMouse.clickable = !0, this.fire("measurementEnd", this._currentDistanceMeasurementByMouse)) : (this._currentDistanceMeasurementByMouse.destroy(), this.fire("measurementCancel", this._currentDistanceMeasurementByMouse)), this._currentDistanceMeasurementByMouse = null) : n && (o && (e = s.pick({ canvasPos: l, pickSurface: !0, pickSurfacePrecision: !0 })) && e.worldPos && h.set(e.worldPos), this._currentDistanceMeasurementByMouse = i.createMeasurement({ id: math.createUUID(), origin: { entity: n, worldPos: h }, target: { entity: n, worldPos: h }, approximate: !0 }), this._currentDistanceMeasurementByMouseInittouchState.axisVisible = this._currentDistanceMeasurementByMouse.axisVisible && this.plugin.defaultAxisVisible, this._currentDistanceMeasurementByMouseInittouchState.xAxisVisible = this._currentDistanceMeasurementByMouse.xAxisVisible && this.plugin.defaultXAxisVisible, this._currentDistanceMeasurementByMouseInittouchState.yAxisVisible = this._currentDistanceMeasurementByMouse.yAxisVisible && this.plugin.defaultYAxisVisible, this._currentDistanceMeasurementByMouseInittouchState.zAxisVisible = this._currentDistanceMeasurementByMouse.zAxisVisible && this.plugin.defaultZAxisVisible, this._currentDistanceMeasurementByMouseInittouchState.wireVisible = this._currentDistanceMeasurementByMouse.wireVisible, this._currentDistanceMeasurementByMouseInittouchState.targetVisible = this._currentDistanceMeasurementByMouse.targetVisible, this._currentDistanceMeasurementByMouse.clickable = !1, this.fire("measurementStart", this._currentDistanceMeasurementByMouse))) })), this._onMouseHoverOff = e.on("hoverOff", (e => { n = null, this._currentDistanceMeasurementByMouse && (this._currentDistanceMeasurementByMouse.wireVisible = !1, this._currentDistanceMeasurementByMouse.targetVisible = !1, this._currentDistanceMeasurementByMouse.axisVisible = !1), r.style.cursor = "default" })), this._onPickedNothing = e.on("pickedNothing", (e => { this._currentDistanceMeasurementByMouse && (this._currentDistanceMeasurementByMouse.destroy(), this._currentDistanceMeasurementByMouse = null), a.setVisible(!1), p = 0 })), r.addEventListener("touchstart", this._onCanvasTouchStart = e => { var t = e.touches; e = e.changedTouches; 1 === t.length && 1 === e.length && getCanvasPosFromEvent(t[0], d) }, { passive: !0 }), r.addEventListener("touchend", this._onCanvasTouchEnd = e => { var t = e.touches; e = e.changedTouches; if (0 === t.length && 1 === e.length && (getCanvasPosFromEvent(e[0], m), !(m[0] > d[0] + 5 || m[0] < d[0] - 5 || m[1] > d[1] + 5 || m[1] < d[1] - 5))) { var r = s.pick({ canvasPos: m, pickSurface: !0, pickSurfacePrecision: o }); if (r && r.worldPos) switch (p) { case 0: a.setVisible(!0), this._touchStartMarker.worldPos = r.worldPos, f.set(r.worldPos), p = 1; break; case 1: a.setVisible(!1), this._touchStartMarker.worldPos = r.worldPos, i.createMeasurement({ id: math.createUUID(), origin: { entity: n, worldPos: f }, target: { entity: n, worldPos: r.worldPos }, approximate: !o }).clickable = !0, p = 0 } else a.setVisible(!1), p = 0 } }, { passive: !0 }), this._active = !0 } } deactivate() { var e; this._active && (this._touchStartDot.setVisible(!1), this.reset(), (e = this.plugin.viewer.scene.input).off(this._onInputMouseDown), e.off(this._onInputMouseUp), (e = this.plugin.viewer.cameraControl).off(this._onMouseHoverSurface), e.off(this._onMouseHoverOff), e.off(this._onPickedNothing), (e = this.plugin.viewer.scene.canvas.canvas).removeEventListener("touchstart", this._onCanvasTouchStart), e.removeEventListener("touchend", this._onCanvasTouchEnd), this._currentDistanceMeasurementByMouse = null, this._active = !1) } reset() { this._active && this._currentDistanceMeasurementByMouse && (this._currentDistanceMeasurementByMouse.destroy(), this._currentDistanceMeasurementByMouse = null) } destroy() { this._touchStartDot.destroy(), this.deactivate(), super.destroy() } } const getCanvasPosFromEvent = function (e, t) { if (e) { let i = e.target, s = 0, r = 0; for (; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t }; class DistanceMeasurementsPlugin extends Plugin { constructor(e, t = {}) { super("DistanceMeasurements", e), this._container = t.container || document.body, this._control = new DistanceMeasurementsControl(this), this._measurements = {}, this.labelMinAxisLength = t.labelMinAxisLength, this.defaultVisible = !1 !== t.defaultVisible, this.defaultOriginVisible = !1 !== t.defaultOriginVisible, this.defaultTargetVisible = !1 !== t.defaultTargetVisible, this.defaultWireVisible = !1 !== t.defaultWireVisible, this.defaultLabelsVisible = !1 !== t.defaultLabelsVisible, this.defaultAxisVisible = !1 !== t.defaultAxisVisible, this.defaultXAxisVisible = !1 !== t.defaultXAxisVisible, this.defaultYAxisVisible = !1 !== t.defaultYAxisVisible, this.defaultZAxisVisible = !1 !== t.defaultZAxisVisible, this.defaultColor = void 0 !== t.defaultColor ? t.defaultColor : "#00BBFF", this.zIndex = t.zIndex || 1e4, this._onMouseOver = (e, t) => { this.fire("mouseOver", { plugin: this, distanceMeasurement: t, measurement: t, event: e }) }, this._onMouseLeave = (e, t) => { this.fire("mouseLeave", { plugin: this, distanceMeasurement: t, measurement: t, event: e }) }, this._onContextMenu = (e, t) => { this.fire("contextMenu", { plugin: this, distanceMeasurement: t, measurement: t, event: e }) } } send(e, t) { } get control() { return this._control } get measurements() { return this._measurements } set labelMinAxisLength(e) { e < 1 && (this.error("labelMinAxisLength must be >= 1; defaulting to 25"), e = 25), this._labelMinAxisLength = e || 25 } get labelMinAxisLength() { return this._labelMinAxisLength } createMeasurement(e = {}) { this.viewer.scene.components[e.id] && (this.error("Viewer scene component with this ID already exists: " + e.id), delete e.id); var t = e.origin, i = e.target; const s = new DistanceMeasurement(this, { id: e.id, plugin: this, container: this._container, origin: { entity: t.entity, worldPos: t.worldPos }, target: { entity: i.entity, worldPos: i.worldPos }, visible: e.visible, wireVisible: e.wireVisible, axisVisible: !1 !== e.axisVisible && !1 !== this.defaultAxisVisible, xAxisVisible: !1 !== e.xAxisVisible && !1 !== this.defaultXAxisVisible, yAxisVisible: !1 !== e.yAxisVisible && !1 !== this.defaultYAxisVisible, zAxisVisible: !1 !== e.zAxisVisible && !1 !== this.defaultZAxisVisible, labelsVisible: !1 !== e.labelsVisible && !1 !== this.defaultLabelsVisible, originVisible: e.originVisible, targetVisible: e.targetVisible, color: e.color, onMouseOver: this._onMouseOver, onMouseLeave: this._onMouseLeave, onContextMenu: this._onContextMenu }); return (this._measurements[s.id] = s).on("destroyed", (() => { delete this._measurements[s.id] })), this.fire("measurementCreated", s), s } destroyMeasurement(e) { var t = this._measurements[e]; t ? (t.destroy(), this.fire("measurementDestroyed", t)) : this.log("DistanceMeasurement not found: " + e) } setLabelsShown(e) { for (var [t, i] of Object.entries(this.measurements)) i.labelShown = e } clear() { for (var e = Object.keys(this._measurements), t = 0, i = e.length; t < i; t++)this.destroyMeasurement(e[t]) } destroy() { this.clear(), super.destroy() } } class FastNavPlugin extends Plugin { constructor(e, t = {}) { super("FastNav", e), this._hideColorTexture = !1 !== t.hideColorTexture, this._hidePBR = !1 !== t.hidePBR, this._hideSAO = !1 !== t.hideSAO, this._hideEdges = !1 !== t.hideEdges, this._hideTransparentObjects = !!t.hideTransparentObjects, this._scaleCanvasResolution = !!t.scaleCanvasResolution, this._scaleCanvasResolutionFactor = t.scaleCanvasResolutionFactor || .6, this._delayBeforeRestore = !1 !== t.delayBeforeRestore, this._delayBeforeRestoreSeconds = t.delayBeforeRestoreSeconds || .5; let i = 1e3 * this._delayBeforeRestoreSeconds, s = !1; const r = () => { i = 1e3 * this._delayBeforeRestoreSeconds, s || (e.scene._renderer.setColorTextureEnabled(!this._hideColorTexture), e.scene._renderer.setPBREnabled(!this._hidePBR), e.scene._renderer.setSAOEnabled(!this._hideSAO), e.scene._renderer.setTransparentEnabled(!this._hideTransparentObjects), e.scene._renderer.setEdgesEnabled(!this._hideEdges), this._scaleCanvasResolution ? e.scene.canvas.resolutionScale = this._scaleCanvasResolutionFactor : e.scene.canvas.resolutionScale = 1, s = !0) }; this._onCanvasBoundary = e.scene.canvas.on("boundary", r), this._onCameraMatrix = e.scene.camera.on("matrix", r), this._onSceneTick = e.scene.on("tick", (t => { s && (i -= t.deltaTime, !this._delayBeforeRestore || i <= 0) && (e.scene.canvas.resolutionScale = 1, e.scene._renderer.setEdgesEnabled(!0), e.scene._renderer.setColorTextureEnabled(!0), e.scene._renderer.setPBREnabled(!0), e.scene._renderer.setSAOEnabled(!0), e.scene._renderer.setTransparentEnabled(!0), s = !1) })); let a = !1; this._onSceneMouseDown = e.scene.input.on("mousedown", (() => { a = !0 })), this._onSceneMouseUp = e.scene.input.on("mouseup", (() => { a = !1 })), this._onSceneMouseMove = e.scene.input.on("mousemove", (() => { a && r() })) } get hideColorTexture() { return this._hideColorTexture } set hideColorTexture(e) { this._hideColorTexture = e } get hidePBR() { return this._hidePBR } set hidePBR(e) { this._hidePBR = e } get hideSAO() { return this._hideSAO } set hideSAO(e) { this._hideSAO = e } get hideEdges() { return this._hideEdges } set hideEdges(e) { this._hideEdges = e } get hideTransparentObjects() { return this._hideTransparentObjects } set hideTransparentObjects(e) { this._hideTransparentObjects = !1 !== e } get scaleCanvasResolution() { return this._scaleCanvasResolution } set scaleCanvasResolution(e) { this._scaleCanvasResolution = e } get scaleCanvasResolutionFactor() { return this._scaleCanvasResolutionFactor } set scaleCanvasResolutionFactor(e) { this._scaleCanvasResolutionFactor = e || .6 } get delayBeforeRestore() { return this._delayBeforeRestore } set delayBeforeRestore(e) { this._delayBeforeRestore = e } get delayBeforeRestoreSeconds() { return this._delayBeforeRestoreSeconds } set delayBeforeRestoreSeconds(e) { this._delayBeforeRestoreSeconds = null != e ? e : .5 } send(e, t) { } destroy() { this.viewer.scene.camera.off(this._onCameraMatrix), this.viewer.scene.canvas.off(this._onCanvasBoundary), this.viewer.scene.input.off(this._onSceneMouseDown), this.viewer.scene.input.off(this._onSceneMouseUp), this.viewer.scene.input.off(this._onSceneMouseMove), this.viewer.scene.off(this._onSceneTick), super.destroy() } } class GLTFDefaultDataSource { constructor() { } getMetaModel(e, t, i) { utils.loadJSON(e, (e => { t(e) }), (function (e) { i(e) })) } getGLTF(e, t, i) { utils.loadArraybuffer(e, (e => { t(e) }), (function (e) { i(e) })) } getGLB(e, t, i) { utils.loadArraybuffer(e, (e => { t(e) }), (function (e) { i(e) })) } getArrayBuffer(e, t, i, s) { loadArraybuffer(e, t, (e => { i(e) }), (function (e) { s(e) })) } } function loadArraybuffer(e, t, i, s) { var r = () => { }; if (i = i || r, s = s || r, r = t.match(/^data:(.*?)(;base64)?,(.*)$/)) { var a = !!r[2], o = r[3]; o = window.decodeURIComponent(o); a && (o = window.atob(o)); try { const e = new ArrayBuffer(o.length); for (var n = new Uint8Array(e), h = 0; h < o.length; h++)n[h] = o.charCodeAt(h); window.setTimeout((function () { i(e) }), 0) } catch (e) { window.setTimeout((function () { s(e) }), 0) } } else { r = getBasePath$1(e) + t; const a = new XMLHttpRequest; a.open("GET", r, !0), a.responseType = "arraybuffer", a.onreadystatechange = function () { 4 === a.readyState && (200 === a.status ? i(a.response) : s("loadArrayBuffer error : " + a.response)) }, a.send(null) } } function getBasePath$1(e) { var t = e.lastIndexOf("/"); return 0 !== t ? e.substring(0, t + 1) : "" } function assert$5(e, t) { if (!e) throw new Error(t || "loader assertion failed.") } const isBrowser$4 = Boolean("object" != typeof process || "[object process]" !== String(process) || process.browser), matches$1 = "undefined" != typeof process && process.version && /v([0-9]*)/.exec(process.version), VERSION$9 = (matches$1 && parseFloat(matches$1[1]), "3.2.6"); function assert$4(e, t) { if (!e) throw new Error(t || "loaders.gl assertion failed.") } const globals$2 = { self: "undefined" != typeof self && self, window: "undefined" != typeof window && window, global: "undefined" != typeof global && global, document: "undefined" != typeof document && document }, global_ = globals$2.global || globals$2.self || globals$2.window || {}, isBrowser$3 = "object" != typeof process || "[object process]" !== String(process) || process.browser, isWorker = "function" == typeof importScripts, isMobile = "undefined" != typeof window && void 0 !== window.orientation, matches = "undefined" != typeof process && process.version && /v([0-9]*)/.exec(process.version); function _defineProperty(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } matches && parseFloat(matches[1]); class WorkerJob { constructor(e, t) { _defineProperty(this, "name", void 0), _defineProperty(this, "workerThread", void 0), _defineProperty(this, "isRunning", !0), _defineProperty(this, "result", void 0), _defineProperty(this, "_resolve", (() => { })), _defineProperty(this, "_reject", (() => { })), this.name = e, this.workerThread = t, this.result = new Promise(((e, t) => { this._resolve = e, this._reject = t })) } postMessage(e, t) { this.workerThread.postMessage({ source: "loaders.gl", type: e, payload: t }) } done(e) { assert$4(this.isRunning), this.isRunning = !1, this._resolve(e) } error(e) { assert$4(this.isRunning), this.isRunning = !1, this._reject(e) } } class Worker$1 { } const workerURLCache = new Map; function getLoadableWorkerURL(e) { assert$4(e.source && !e.url || !e.source && e.url); let t = workerURLCache.get(e.source || e.url); return t || (e.url && (t = getLoadableWorkerURLFromURL(e.url), workerURLCache.set(e.url, t)), e.source && (t = getLoadableWorkerURLFromSource(e.source), workerURLCache.set(e.source, t))), assert$4(t), t } function getLoadableWorkerURLFromURL(e) { return e.startsWith("http") ? getLoadableWorkerURLFromSource(buildScriptSource(e)) : e } function getLoadableWorkerURLFromSource(e) { return e = new Blob([e], { type: "application/javascript" }), URL.createObjectURL(e) } function buildScriptSource(e) { return "try {\n  importScripts('".concat(e, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}") } function getTransferList(e, t = !0, i) { var s = i || new Set; if (e) if (isTransferable(e)) s.add(e); else if (isTransferable(e.buffer)) s.add(e.buffer); else if (!ArrayBuffer.isView(e) && t && "object" == typeof e) for (const i in e) getTransferList(e[i], t, s); return void 0 === i ? Array.from(s) : [] } function isTransferable(e) { return !!e && (e instanceof ArrayBuffer || "undefined" != typeof MessagePort && e instanceof MessagePort || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas) } const NOOP = () => { }; class WorkerThread { static isSupported() { return "undefined" != typeof Worker && isBrowser$3 || !0 } constructor(e) { _defineProperty(this, "name", void 0), _defineProperty(this, "source", void 0), _defineProperty(this, "url", void 0), _defineProperty(this, "terminated", !1), _defineProperty(this, "worker", void 0), _defineProperty(this, "onMessage", void 0), _defineProperty(this, "onError", void 0), _defineProperty(this, "_loadableURL", ""); var { name: e, source: t, url: i } = e; assert$4(t || i), this.name = e, this.source = t, this.url = i, this.onMessage = NOOP, this.onError = e => console.log(e), this.worker = isBrowser$3 ? this._createBrowserWorker() : this._createNodeWorker() } destroy() { this.onMessage = NOOP, this.onError = NOOP, this.worker.terminate(), this.terminated = !0 } get isRunning() { return Boolean(this.onMessage) } postMessage(e, t) { t = t || getTransferList(e), this.worker.postMessage(e, t) } _getErrorFromErrorEvent(e) { let t = "Failed to load "; return t += "worker ".concat(this.name, " from ").concat(this.url, ". "), e.message && (t += "".concat(e.message, " in ")), e.lineno && (t += ":".concat(e.lineno, ":").concat(e.colno)), new Error(t) } _createBrowserWorker() { this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url }); var e = new Worker(this._loadableURL, { name: this.name }); return e.onmessage = e => { e.data ? this.onMessage(e.data) : this.onError(new Error("No data received")) }, e.onerror = e => { this.onError(this._getErrorFromErrorEvent(e)), this.terminated = !0 }, e.onmessageerror = e => console.error(e), e } _createNodeWorker() { let e; if (this.url) { var t = this.url.includes(":/") || this.url.startsWith("/") ? this.url : "./".concat(this.url); e = new Worker$1(t, { eval: !1 }) } else { if (!this.source) throw new Error("no worker"); e = new Worker$1(this.source, { eval: !0 }) } return e.on("message", (e => { this.onMessage(e) })), e.on("error", (e => { this.onError(e) })), e.on("exit", (e => { })), e } } class WorkerPool { static isSupported() { return WorkerThread.isSupported() } constructor(e) { _defineProperty(this, "name", "unnamed"), _defineProperty(this, "source", void 0), _defineProperty(this, "url", void 0), _defineProperty(this, "maxConcurrency", 1), _defineProperty(this, "maxMobileConcurrency", 1), _defineProperty(this, "onDebug", (() => { })), _defineProperty(this, "reuseWorkers", !0), _defineProperty(this, "props", {}), _defineProperty(this, "jobQueue", []), _defineProperty(this, "idleQueue", []), _defineProperty(this, "count", 0), _defineProperty(this, "isDestroyed", !1), this.source = e.source, this.url = e.url, this.setProps(e) } destroy() { this.idleQueue.forEach((e => e.destroy())), this.isDestroyed = !0 } setProps(e) { this.props = { ...this.props, ...e }, void 0 !== e.name && (this.name = e.name), void 0 !== e.maxConcurrency && (this.maxConcurrency = e.maxConcurrency), void 0 !== e.maxMobileConcurrency && (this.maxMobileConcurrency = e.maxMobileConcurrency), void 0 !== e.reuseWorkers && (this.reuseWorkers = e.reuseWorkers), void 0 !== e.onDebug && (this.onDebug = e.onDebug) } async startJob(e, t = (e, t, i) => e.done(i), i = (e, t) => e.error(t)) { var s = new Promise((s => (this.jobQueue.push({ name: e, onMessage: t, onError: i, onStart: s }), this))); return this._startQueuedJob(), s } async _startQueuedJob() { if (this.jobQueue.length) { var e = this._getAvailableWorker(); if (e) { const t = this.jobQueue.shift(); if (t) { this.onDebug({ message: "Starting job", name: t.name, workerThread: e, backlog: this.jobQueue.length }); const i = new WorkerJob(t.name, e); e.onMessage = e => t.onMessage(i, e.type, e.payload), e.onError = e => t.onError(i, e), t.onStart(i); try { await i.result } finally { this.returnWorkerToQueue(e) } } } } } returnWorkerToQueue(e) { this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob() } _getAvailableWorker() { var e; return 0 < this.idleQueue.length ? this.idleQueue.shift() || null : this.count < this._getMaxConcurrency() ? (this.count++, e = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")"), new WorkerThread({ name: e, source: this.source, url: this.url })) : null } _getMaxConcurrency() { return isMobile ? this.maxMobileConcurrency : this.maxConcurrency } } const DEFAULT_PROPS = { maxConcurrency: 3, maxMobileConcurrency: 1, reuseWorkers: !0, onDebug: () => { } }; class WorkerFarm { static isSupported() { return WorkerThread.isSupported() } static getWorkerFarm(e = {}) { return WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({}), WorkerFarm._workerFarm.setProps(e), WorkerFarm._workerFarm } constructor(e) { _defineProperty(this, "props", void 0), _defineProperty(this, "workerPools", new Map), this.props = { ...DEFAULT_PROPS }, this.setProps(e), this.workerPools = new Map } destroy() { for (const e of this.workerPools.values()) e.destroy(); this.workerPools = new Map } setProps(e) { this.props = { ...this.props, ...e }; for (const e of this.workerPools.values()) e.setProps(this._getWorkerPoolProps()) } getWorkerPool(e) { var { name: e, source: t, url: i } = e; let s = this.workerPools.get(e); return s || ((s = new WorkerPool({ name: e, source: t, url: i })).setProps(this._getWorkerPoolProps()), this.workerPools.set(e, s)), s } _getWorkerPoolProps() { return { maxConcurrency: this.props.maxConcurrency, maxMobileConcurrency: this.props.maxMobileConcurrency, reuseWorkers: this.props.reuseWorkers, onDebug: this.props.onDebug } } } _defineProperty(WorkerFarm, "_workerFarm", void 0); const NPM_TAG = "latest"; function getWorkerURL(e, t = {}) { var i = t[e.id] || {}, s = "".concat(e.id, "-worker.js"); let r = i.workerUrl; return r || "compression" !== e.id || (r = t.workerUrl), (r = "test" === t._workerType ? "modules/".concat(e.module, "/dist/").concat(s) : r) || (i = (t = "latest" === (t = e.version) ? NPM_TAG : t) ? "@".concat(t) : "", r = "https://unpkg.com/@loaders.gl/".concat(e.module).concat(i, "/dist/").concat(s)), assert$4(r), r } function validateWorkerVersion(e, t = VERSION$9) { return assert$4(e, "no worker provided"), e = e.version, !(!t || !e) } var n, i, s, a, r, o, l, f, ChildProcessProxy = {}, node = Object.freeze({ __proto__: null, default: ChildProcessProxy }); const VERSION$8 = "3.2.6", loadLibraryPromises = {}; async function loadLibrary(e, t = null, i = {}) { return t && (e = getLibraryUrl(e, t, i)), loadLibraryPromises[e] = loadLibraryPromises[e] || loadLibraryFromFile(e), loadLibraryPromises[e] } function getLibraryUrl(e, t, i) { return e.startsWith("http") ? e : (i.modules || {})[e] || (isBrowser$3 ? i.CDN ? (assert$4(i.CDN.startsWith("http")), "".concat(i.CDN, "/").concat(t, "@").concat(VERSION$8, "/dist/libs/")) : isWorker ? "../src/libs/" : "modules/".concat(t, "/src/libs/") : "modules/".concat(t, "/dist/libs/")).concat(e) } async function loadLibraryFromFile(e) { if (e.endsWith("wasm")) { return (await fetch(e)).arrayBuffer() } if (!isBrowser$3) try { return node && void 0 } catch { return null } if (isWorker) return importScripts(e); const t = await fetch(e); return loadLibraryFromString(await t.text(), e) } function loadLibraryFromString(e, t) { if (isBrowser$3) { if (isWorker) eval.call(global_, e); else { var i = document.createElement("script"); i.id = t; try { i.appendChild(document.createTextNode(e)) } catch (t) { i.text = e } document.body.appendChild(i) } return null } } function canParseWithWorker(e, t) { return !!WorkerFarm.isSupported() && !!(isBrowser$3 || null != t && t._nodeWorkers) && e.worker && (null == t ? void 0 : t.worker) } async function parseWithWorker(e, t, i, s, r) { var a = e.id; e = getWorkerURL(e, i), a = WorkerFarm.getWorkerFarm(i).getWorkerPool({ name: a, url: e }); return i = JSON.parse(JSON.stringify(i)), s = JSON.parse(JSON.stringify(s || {})), (e = await a.startJob("process-on-worker", onMessage.bind(null, r))).postMessage("process", { input: t, options: i, context: s }), (a = await e.result).result } async function onMessage(e, t, i, s) { switch (i) { case "done": t.done(s); break; case "error": t.error(new Error(s.error)); break; case "process": var { id: r, input: a, options: o } = s; try { var n = await e(a, o); t.postMessage("done", { id: r, result: n }) } catch (e) { a = e instanceof Error ? e.message : "unknown error", t.postMessage("error", { id: r, error: a }) } break; default: console.warn("parse-with-worker unknown message ".concat(i)) } } function getFirstCharacters$1(e, t = 5) { return "string" == typeof e ? e.slice(0, t) : ArrayBuffer.isView(e) ? getMagicString$2(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? getMagicString$2(e, 0, t) : "" } function getMagicString$2(e, t, i) { if (e.byteLength <= t + i) return ""; var s = new DataView(e); let r = ""; for (let e = 0; e < i; e++)r += String.fromCharCode(s.getUint8(t + e)); return r } function parseJSON(e) { try { return JSON.parse(e) } catch (t) { throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters$1(e), '"')) } } function isBuffer$1(e) { return e && "object" == typeof e && e.isBuffer } function bufferToArrayBuffer(e) { return isBuffer$1(e) ? new Uint8Array(e.buffer, e.byteOffset, e.length).slice().buffer : e } function toArrayBuffer(e) { if (isBuffer$1(e)) return bufferToArrayBuffer(e); if (e instanceof ArrayBuffer) return e; if (ArrayBuffer.isView(e)) return 0 === e.byteOffset && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength); var t; if ("string" == typeof e) return t = e, (new TextEncoder).encode(t).buffer; if (e && "object" == typeof e && e._toArrayBuffer) return e._toArrayBuffer(); throw new Error("toArrayBuffer") } function compareArrayBuffers(e, t, i) { if (i = i || e.byteLength, e.byteLength < i || t.byteLength < i) return !1; var s = new Uint8Array(e), r = new Uint8Array(t); for (let e = 0; e < s.length; ++e)if (s[e] !== r[e]) return !1; return !0 } function concatenateArrayBuffers(...e) { var t = (e = e.map((e => e instanceof ArrayBuffer ? new Uint8Array(e) : e))).reduce(((e, t) => e + t.byteLength), 0), i = new Uint8Array(t); let s = 0; for (const t of e) i.set(t, s), s += t.byteLength; return i.buffer } function sliceArrayBuffer(e, t, i) { return i = void 0 !== i ? new Uint8Array(e).subarray(t, t + i) : new Uint8Array(e).subarray(t), new Uint8Array(i).buffer } function padToNBytes(e, t) { return assert$5(0 <= e), assert$5(0 < t), e + (t - 1) & ~(t - 1) } function copyToArray(e, t, i) { var s, r; e = e instanceof ArrayBuffer ? new Uint8Array(e) : (s = e.byteOffset, r = e.byteLength, new Uint8Array(e.buffer || e.arrayBuffer, s, r)); return t.set(e, i), i + padToNBytes(e.byteLength, 4) } async function concatenateArrayBuffersAsync(e) { var t = []; for await (const i of e) t.push(i); return concatenateArrayBuffers(...t) } let pathPrefix = ""; const fileAliases = {}; function resolvePath(e) { for (const i in fileAliases) { var t; e.startsWith(i) && (t = fileAliases[i], e = e.replace(i, t)) } return e.startsWith("http://") || e.startsWith("https://") ? e : "".concat(pathPrefix).concat(e) } function filename(e) { var t = e && e.lastIndexOf("/"); return 0 <= t ? e.substr(t + 1) : "" } const isBoolean = e => "boolean" == typeof e, isFunction = e => "function" == typeof e, isObject = e => null !== e && "object" == typeof e, isPureObject = e => isObject(e) && e.constructor === {}.constructor, isIterable = e => e && "function" == typeof e[Symbol.iterator], isAsyncIterable = e => e && "function" == typeof e[Symbol.asyncIterator], isResponse = e => "undefined" != typeof Response && e instanceof Response || e && e.arrayBuffer && e.text && e.json, isBlob = e => "undefined" != typeof Blob && e instanceof Blob, isBuffer = e => e && "object" == typeof e && e.isBuffer, isReadableDOMStream = e => "undefined" != typeof ReadableStream && e instanceof ReadableStream || isObject(e) && isFunction(e.tee) && isFunction(e.cancel) && isFunction(e.getReader), isReadableNodeStream = e => isObject(e) && isFunction(e.read) && isFunction(e.pipe) && isBoolean(e.readable), isReadableStream = e => isReadableDOMStream(e) || isReadableNodeStream(e), DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/; function parseMIMEType(e) { var t = MIME_TYPE_PATTERN.exec(e); return t ? t[1] : e } function parseMIMETypeFromURL(e) { return (e = DATA_URL_PATTERN.exec(e)) ? e[1] : "" } const QUERY_STRING_PATTERN = /\?.*/; function getResourceUrlAndType(e) { var t; return isResponse(e) ? { url: t = stripQueryString(e.url || ""), type: parseMIMEType(e.headers.get("content-type") || "") || parseMIMETypeFromURL(t) } : isBlob(e) ? { url: stripQueryString(e.name || ""), type: e.type || "" } : "string" == typeof e ? { url: stripQueryString(e), type: parseMIMETypeFromURL(e) } : { url: "", type: "" } } function getResourceContentLength(e) { return isResponse(e) ? e.headers["content-length"] || -1 : isBlob(e) ? e.size : "string" == typeof e ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1 } function stripQueryString(e) { return e.replace(QUERY_STRING_PATTERN, "") } async function makeResponse(e) { var t, i, s; return isResponse(e) ? e : (t = {}, ({ url: i, type: s } = (0 <= (i = getResourceContentLength(e)) && (t["content-length"] = String(i)), getResourceUrlAndType(e))), s && (t["content-type"] = s), (s = await getInitialDataUrl(e)) && (t["x-first-bytes"] = s), "string" == typeof e && (e = (new TextEncoder).encode(e)), s = new Response(e, { headers: t }), Object.defineProperty(s, "url", { value: i }), s) } async function checkResponse(e) { if (!e.ok) throw e = await getResponseError(e), new Error(e) } async function getResponseError(e) { let t = "Failed to fetch resource ".concat(e.url, " (").concat(e.status, "): "); try { var i = e.headers.get("Content-Type"); let s = e.statusText; i.includes("application/json") && (s += " ".concat(await e.text())), t = 60 < (t += s).length ? "".concat(t.slice(0, 60), "...") : t } catch (e) { } return t } async function getInitialDataUrl(e) { if ("string" == typeof e) return "data:,".concat(e.slice(0, 5)); if (e instanceof Blob) { const t = e.slice(0, 5); return new Promise((e => { var i = new FileReader; i.onload = t => e(null == t || null == (t = t.target) ? void 0 : t.result), i.readAsDataURL(t) })) } return e instanceof ArrayBuffer ? (e = arrayBufferToBase64(e.slice(0, 5)), "data:base64,".concat(e)) : null } function arrayBufferToBase64(e) { let t = ""; var i = new Uint8Array(e); for (let e = 0; e < i.byteLength; e++)t += String.fromCharCode(i[e]); return btoa(t) } async function fetchFile(e, t) { if ("string" != typeof e) return makeResponse(e); { e = resolvePath(e); let i = t; return null != t && t.fetch && "function" != typeof (null == t ? void 0 : t.fetch) && (i = t.fetch), fetch(e, i) } } function isElectron$1(e) { var t; return "undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type || !("undefined" == typeof process || "object" != typeof process.versions || !Boolean(process.versions.electron)) || (t = "object" == typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent, !!((e = e || t) && 0 <= e.indexOf("Electron"))) } function isBrowser$2() { return !("object" == typeof process && "[object process]" === String(process) && !process.browser) || isElectron$1() } const globals$1 = { self: "undefined" != typeof self && self, window: "undefined" != typeof window && window, global: "undefined" != typeof global && global, document: "undefined" != typeof document && document, process: "object" == typeof process && process }, window_$1 = globals$1.window || globals$1.self || globals$1.global, process_$1 = globals$1.process || {}, VERSION$7 = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source", isBrowser$1 = isBrowser$2(); function getStorage$1(e) { try { var t = window[e], i = "__storage_test__"; return t.setItem(i, i), t.removeItem(i), t } catch (e) { return null } } class LocalStorage$1 { constructor(e, t, i = "sessionStorage") { this.storage = getStorage$1(i), this.id = e, this.config = {}, Object.assign(this.config, t), this._loadConfiguration() } getConfiguration() { return this.config } setConfiguration(e) { return this.config = {}, this.updateConfiguration(e) } updateConfiguration(e) { return Object.assign(this.config, e), this.storage && (e = JSON.stringify(this.config), this.storage.setItem(this.id, e)), this } _loadConfiguration() { let e = {}; var t; return this.storage && (e = (t = this.storage.getItem(this.id)) ? JSON.parse(t) : {}), Object.assign(this.config, e), this } } function formatTime$1(e) { return e < 10 ? "".concat(e.toFixed(2), "ms") : e < 100 ? "".concat(e.toFixed(1), "ms") : e < 1e3 ? "".concat(e.toFixed(0), "ms") : "".concat((e / 1e3).toFixed(2), "s") } function leftPad$1(e, t = 8) { return t = Math.max(t - e.length, 0), "".concat(" ".repeat(t)).concat(e) } function formatImage$1(e, t, i, s = 600) { var r = e.src.replace(/\(/g, "%28").replace(/\)/g, "%29"); e.width > s && (i = Math.min(i, s / e.width)), s = e.width * i, e = e.height * i, i = ["font-size:1px;", "padding:".concat(Math.floor(e / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(e, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(s, "px ").concat(e, "px;"), "color:transparent;"].join(""); return ["".concat(t, " %c+"), i] } const COLOR$1 = { BLACK: 30, RED: 31, GREEN: 32, YELLOW: 33, BLUE: 34, MAGENTA: 35, CYAN: 36, WHITE: 37, BRIGHT_BLACK: 90, BRIGHT_RED: 91, BRIGHT_GREEN: 92, BRIGHT_YELLOW: 93, BRIGHT_BLUE: 94, BRIGHT_MAGENTA: 95, BRIGHT_CYAN: 96, BRIGHT_WHITE: 97 }; function getColor$1(e) { return "string" == typeof e ? COLOR$1[e.toUpperCase()] || COLOR$1.WHITE : e } function addColor$1(e, t, i) { return isBrowser$1 || "string" != typeof e || (t && (t = getColor$1(t), e = "[".concat(t, "m").concat(e, "[39m")), i && (t = getColor$1(i), e = "[".concat(i + 10, "m").concat(e, "[49m"))), e } function autobind$1(e, t = ["constructor"]) { var i = Object.getPrototypeOf(e); for (const s of Object.getOwnPropertyNames(i)) "function" != typeof e[s] || t.find((e => s === e)) || (e[s] = e[s].bind(e)) } function assert$3(e, t) { if (!e) throw new Error(t || "Assertion failed") } function getHiResTimestamp$1() { var e; return isBrowser$1 && window_$1.performance ? window_$1.performance.now() : process_$1.hrtime ? 1e3 * (e = process_$1.hrtime())[0] + e[1] / 1e6 : Date.now() } const originalConsole$1 = { debug: isBrowser$1 && console.debug || console.log, log: console.log, info: console.info, warn: console.warn, error: console.error }, DEFAULT_SETTINGS$1 = { enabled: !0, level: 0 }; function noop$1() { } const cache$1 = {}, ONCE$1 = { once: !0 }; function getTableHeader$1(e) { for (const t in e) for (const i in e[t]) return i || "untitled"; return "empty" } class Log$1 { constructor({ id: e } = { id: "" }) { this.id = e, this.VERSION = VERSION$7, this._startTs = getHiResTimestamp$1(), this._deltaTs = getHiResTimestamp$1(), this.LOG_THROTTLE_TIMEOUT = 0, this._storage = new LocalStorage$1("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS$1), this.userData = {}, this.timeStamp("".concat(this.id, " started")), autobind$1(this), Object.seal(this) } set level(e) { this.setLevel(e) } get level() { return this.getLevel() } isEnabled() { return this._storage.config.enabled } getLevel() { return this._storage.config.level } getTotal() { return Number((getHiResTimestamp$1() - this._startTs).toPrecision(10)) } getDelta() { return Number((getHiResTimestamp$1() - this._deltaTs).toPrecision(10)) } set priority(e) { this.level = e } get priority() { return this.level } getPriority() { return this.level } enable(e = !0) { return this._storage.updateConfiguration({ enabled: e }), this } setLevel(e) { return this._storage.updateConfiguration({ level: e }), this } assert(e, t) { assert$3(e, t) } warn(e) { return this._getLogFunction(0, e, originalConsole$1.warn, arguments, ONCE$1) } error(e) { return this._getLogFunction(0, e, originalConsole$1.error, arguments) } deprecated(e, t) { return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead")) } removed(e, t) { return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead")) } probe(e, t) { return this._getLogFunction(e, t, originalConsole$1.log, arguments, { time: !0, once: !0 }) } log(e, t) { return this._getLogFunction(e, t, originalConsole$1.debug, arguments) } info(e, t) { return this._getLogFunction(e, t, console.info, arguments) } once(e, t) { return this._getLogFunction(e, t, originalConsole$1.debug || originalConsole$1.info, arguments, ONCE$1) } table(e, t, i) { return t ? this._getLogFunction(e, t, console.table || noop$1, i && [i], { tag: getTableHeader$1(t) }) : noop$1 } image({ logLevel: e, priority: t, image: i, message: s = "", scale: r = 1 }) { return this._shouldLog(e || t) ? (isBrowser$1 ? logImageInBrowser$1 : logImageInNode$1)({ image: i, message: s, scale: r }) : noop$1 } settings() { console.table ? console.table(this._storage.config) : console.log(this._storage.config) } get(e) { return this._storage.config[e] } set(e, t) { this._storage.updateConfiguration({ [e]: t }) } time(e, t) { return this._getLogFunction(e, t, console.time || console.info) } timeEnd(e, t) { return this._getLogFunction(e, t, console.timeEnd || console.info) } timeStamp(e, t) { return this._getLogFunction(e, t, console.timeStamp || noop$1) } group(e, t, i = { collapsed: !1 }) { return e = (i = normalizeArguments$1({ logLevel: e, message: t, opts: i })).collapsed, i.method = (e ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i) } groupCollapsed(e, t, i = {}) { return this.group(e, t, Object.assign({}, i, { collapsed: !0 })) } groupEnd(e) { return this._getLogFunction(e, "", console.groupEnd || noop$1) } withGroup(e, t, i) { this.group(e, t)(); try { i() } finally { this.groupEnd(e)() } } trace() { console.trace && console.trace() } _shouldLog(e) { return this.isEnabled() && this.getLevel() >= normalizeLogLevel$1(e) } _getLogFunction(e, t, i, s = [], r) { if (this._shouldLog(e)) { if (r = normalizeArguments$1({ logLevel: e, message: t, args: s, opts: r }), assert$3(i = i || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = getHiResTimestamp$1(), e = r.tag || r.message, r.once) { if (cache$1[e]) return noop$1; cache$1[e] = getHiResTimestamp$1() } return t = decorateMessage$1(this.id, r.message, r), i.bind(console, t, ...r.args) } return noop$1 } } function normalizeLogLevel$1(e) { if (!e) return 0; let t; switch (typeof e) { case "number": t = e; break; case "object": t = e.logLevel || e.priority || 0; break; default: return 0 }return assert$3(Number.isFinite(t) && 0 <= t), t } function normalizeArguments$1(e) { for (var { logLevel: t, message: i } = e, s = (e.logLevel = normalizeLogLevel$1(t), e.args ? Array.from(e.args) : []); s.length && s.shift() !== i;); switch (e.args = s, typeof t) { case "string": case "function": void 0 !== i && s.unshift(i), e.message = t; break; case "object": Object.assign(e, t) }"function" == typeof e.message && (e.message = e.message()); var r = typeof e.message; return assert$3("string" == r || "object" == r), Object.assign(e, e.opts) } function decorateMessage$1(e, t, i) { var s; return "string" == typeof t && (s = i.time ? leftPad$1(formatTime$1(i.total)) : "", t = addColor$1(t = (i.time ? "".concat(e, ": ").concat(s, "  ") : "".concat(e, ": ")).concat(t), i.color, i.background)), t } function logImageInNode$1({ image: e, scale: t = 1 }) { let i = null; try { i = module.require("asciify-image") } catch (e) { } return i ? () => i(e, { fit: "box", width: "".concat(Math.round(80 * t), "%") }).then((e => console.log(e))) : noop$1 } function logImageInBrowser$1({ image: e, message: t = "", scale: i = 1 }) { if ("string" == typeof e) { const s = new Image; s.onload = () => { var e = formatImage$1(s, t, i); console.log(...e) }, s.src = e } else { var s = e.nodeName || ""; if ("img" === s.toLowerCase()) console.log(...formatImage$1(e, t, i)); else if ("canvas" === s.toLowerCase()) { const s = new Image; s.onload = () => console.log(...formatImage$1(s, t, i)), s.src = e.toDataURL() } } return noop$1 } Log$1.VERSION = VERSION$7; const probeLog = new Log$1({ id: "loaders.gl" }); class NullLog { log() { return () => { } } info() { return () => { } } warn() { return () => { } } error() { return () => { } } } class ConsoleLog { constructor() { _defineProperty(this, "console", void 0), this.console = console } log(...e) { return this.console.log.bind(this.console, ...e) } info(...e) { return this.console.info.bind(this.console, ...e) } warn(...e) { return this.console.warn.bind(this.console, ...e) } error(...e) { return this.console.error.bind(this.console, ...e) } } const DEFAULT_LOADER_OPTIONS = { fetch: null, mimeType: void 0, nothrow: !1, log: new ConsoleLog, CDN: "https://unpkg.com/@loaders.gl", worker: !0, maxConcurrency: 3, maxMobileConcurrency: 1, reuseWorkers: isBrowser$4, _nodeWorkers: !1, _workerType: "", limit: 0, _limitMB: 0, batchSize: "auto", batchDebounceMs: 0, metadata: !1, transforms: [] }, REMOVED_LOADER_OPTIONS = { throws: "nothrow", dataType: "(no longer used)", uri: "baseUri", method: "fetch.method", headers: "fetch.headers", body: "fetch.body", mode: "fetch.mode", credentials: "fetch.credentials", cache: "fetch.cache", redirect: "fetch.redirect", referrer: "fetch.referrer", referrerPolicy: "fetch.referrerPolicy", integrity: "fetch.integrity", keepalive: "fetch.keepalive", signal: "fetch.signal" }; function getGlobalLoaderState() { globalThis.loaders = globalThis.loaders || {}; var e = globalThis.loaders; return e._state = e._state || {}, e._state } const getGlobalLoaderOptions = () => { var e = getGlobalLoaderState(); return e.globalOptions = e.globalOptions || { ...DEFAULT_LOADER_OPTIONS }, e.globalOptions }; function normalizeOptions(e, t, i, s) { return i = i || [], validateOptions(e, i = Array.isArray(i) ? i : [i]), normalizeOptionsInternal(t, e, s) } function getFetchFunction(e, t) { var i = getGlobalLoaderOptions(); const s = e || i; return "function" == typeof s.fetch ? s.fetch : isObject(s.fetch) ? e => fetchFile(e, s) : null != t && t.fetch ? null == t ? void 0 : t.fetch : fetchFile } function validateOptions(e, t) { validateOptionsObject(e, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, t); for (const a of t) { var i = e && e[a.id] || {}, s = a.options && a.options[a.id] || {}, r = a.deprecatedOptions && a.deprecatedOptions[a.id] || {}; validateOptionsObject(i, a.id, s, r, t) } } function validateOptionsObject(e, t, i, s, r) { var a = t || "Top level", o = t ? "".concat(t, ".") : ""; for (const l in e) { var n = !t && isObject(e[l]), h = "baseUri" === l && !t; l in i || h || "workerUrl" === l && t || (l in s ? probeLog.warn("".concat(a, " loader option '").concat(o).concat(l, "' no longer supported, use '").concat(s[l], "'"))() : n || (h = findSimilarOption(l, r), probeLog.warn("".concat(a, " loader option '").concat(o).concat(l, "' not recognized. ").concat(h))())) } } function findSimilarOption(e, t) { var i = e.toLowerCase(); let s = ""; for (const a of t) for (const t in a.options) { if (e === t) return "Did you mean '".concat(a.id, ".").concat(t, "'?"); var r = t.toLowerCase(); (i.startsWith(r) || r.startsWith(i)) && (s = s || "Did you mean '".concat(a.id, ".").concat(t, "'?")) } return s } function normalizeOptionsInternal(e, t, i) { return addUrlOptions(e = { ...e.options || {} }, i), null === e.log && (e.log = new NullLog), mergeNestedFields(e, getGlobalLoaderOptions()), mergeNestedFields(e, t), e } function mergeNestedFields(e, t) { for (const s in t) { var i; s in t && (i = t[s], isPureObject(i) && isPureObject(e[s]) ? e[s] = { ...e[s], ...t[s] } : e[s] = t[s]) } } function addUrlOptions(e, t) { !t || "baseUri" in e || (e.baseUri = t) } function isLoaderObject(e) { return !!e && (Array.isArray(e) && (e = e[0]), Array.isArray(null == e ? void 0 : e.extensions)) } function normalizeLoader(e) { var t; return assert$5(e, "null loader"), assert$5(isLoaderObject(e), "invalid loader"), Array.isArray(e) && (t = e[1], e = { ...e = e[0], options: { ...e.options, ...t } }), (null != (t = e) && t.parseTextSync || null != (t = e) && t.parseText) && (e.text = !0), e.text || (e.binary = !0), e } const getGlobalLoaderRegistry = () => { var e = getGlobalLoaderState(); return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry }; function getRegisteredLoaders() { return getGlobalLoaderRegistry() } function isElectron(e) { var t; return "undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type || !("undefined" == typeof process || "object" != typeof process.versions || !Boolean(process.versions.electron)) || (t = "object" == typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent, !!((e = e || t) && 0 <= e.indexOf("Electron"))) } function isBrowser() { return !("object" == typeof process && "[object process]" === String(process) && !process.browser) || isElectron() } const globals = { self: "undefined" != typeof self && self, window: "undefined" != typeof window && window, global: "undefined" != typeof global && global, document: "undefined" != typeof document && document, process: "object" == typeof process && process }, window_ = globals.window || globals.self || globals.global, process_ = globals.process || {}, VERSION$6 = "undefined" != typeof __VERSION__ ? __VERSION__ : "untranspiled source"; function getStorage(e) { try { var t = window[e], i = "__storage_test__"; return t.setItem(i, i), t.removeItem(i), t } catch (e) { return null } } isBrowser(); class LocalStorage { constructor(e) { var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "sessionStorage"; _defineProperty(this, "storage", void 0), _defineProperty(this, "id", void 0), _defineProperty(this, "config", {}), this.storage = getStorage(i), this.id = e, this.config = {}, Object.assign(this.config, t), this._loadConfiguration() } getConfiguration() { return this.config } setConfiguration(e) { return this.config = {}, this.updateConfiguration(e) } updateConfiguration(e) { return Object.assign(this.config, e), this.storage && (e = JSON.stringify(this.config), this.storage.setItem(this.id, e)), this } _loadConfiguration() { let e = {}; var t; return this.storage && (e = (t = this.storage.getItem(this.id)) ? JSON.parse(t) : {}), Object.assign(this.config, e), this } } function formatTime(e) { return e < 10 ? "".concat(e.toFixed(2), "ms") : e < 100 ? "".concat(e.toFixed(1), "ms") : e < 1e3 ? "".concat(e.toFixed(0), "ms") : "".concat((e / 1e3).toFixed(2), "s") } function leftPad(e) { var t = Math.max((1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 8) - e.length, 0); return "".concat(" ".repeat(t)).concat(e) } function formatImage(e, t, i) { var s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 600, r = e.src.replace(/\(/g, "%28").replace(/\)/g, "%29"), a = (s = (e.width > s && (i = Math.min(i, s / e.width)), e.width * i), e.height * i); r = ["font-size:1px;", "padding:".concat(Math.floor(a / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(a, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(s, "px ").concat(a, "px;"), "color:transparent;"].join(""); return ["".concat(t, " %c+"), r] } let COLOR; function getColor(e) { return "string" == typeof e ? COLOR[e.toUpperCase()] || COLOR.WHITE : e } function addColor(e, t, i) { return isBrowser || "string" != typeof e || (t && (t = getColor(t), e = "[".concat(t, "m").concat(e, "[39m")), i && (t = getColor(i), e = "[".concat(i + 10, "m").concat(e, "[49m"))), e } function autobind(e) { var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : ["constructor"], i = Object.getPrototypeOf(e); for (const s of Object.getOwnPropertyNames(i)) "function" != typeof e[s] || t.find((e => s === e)) || (e[s] = e[s].bind(e)) } function assert$2(e, t) { if (!e) throw new Error(t || "Assertion failed") } function getHiResTimestamp() { var e, t; return isBrowser && "performance" in window_ ? null == window_ || null == (t = window_.performance) || null == (e = t.now) ? void 0 : e.call(t) : "hrtime" in process_ ? 1e3 * (t = null == process_ || null == (e = process_.hrtime) ? void 0 : e.call(process_))[0] + t[1] / 1e6 : Date.now() } !function (e) { e[e.BLACK = 30] = "BLACK", e[e.RED = 31] = "RED", e[e.GREEN = 32] = "GREEN", e[e.YELLOW = 33] = "YELLOW", e[e.BLUE = 34] = "BLUE", e[e.MAGENTA = 35] = "MAGENTA", e[e.CYAN = 36] = "CYAN", e[e.WHITE = 37] = "WHITE", e[e.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", e[e.BRIGHT_RED = 91] = "BRIGHT_RED", e[e.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", e[e.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", e[e.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", e[e.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", e[e.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", e[e.BRIGHT_WHITE = 97] = "BRIGHT_WHITE" }(COLOR = COLOR || {}); const originalConsole = { debug: isBrowser && console.debug || console.log, log: console.log, info: console.info, warn: console.warn, error: console.error }, DEFAULT_SETTINGS = { enabled: !0, level: 0 }; function noop() { } const cache = {}, ONCE = { once: !0 }; class Log { constructor() { var e = (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : { id: "" }).id; _defineProperty(this, "id", void 0), _defineProperty(this, "VERSION", VERSION$6), _defineProperty(this, "_startTs", getHiResTimestamp()), _defineProperty(this, "_deltaTs", getHiResTimestamp()), _defineProperty(this, "_storage", void 0), _defineProperty(this, "userData", {}), _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = e, this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS), this.userData = {}, this.timeStamp("".concat(this.id, " started")), autobind(this), Object.seal(this) } set level(e) { this.setLevel(e) } get level() { return this.getLevel() } isEnabled() { return this._storage.config.enabled } getLevel() { return this._storage.config.level } getTotal() { return Number((getHiResTimestamp() - this._startTs).toPrecision(10)) } getDelta() { return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10)) } set priority(e) { this.level = e } get priority() { return this.level } getPriority() { return this.level } enable() { return this._storage.updateConfiguration({ enabled: !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0] }), this } setLevel(e) { return this._storage.updateConfiguration({ level: e }), this } get(e) { return this._storage.config[e] } set(e, t) { this._storage.updateConfiguration({ [e]: t }) } settings() { console.table ? console.table(this._storage.config) : console.log(this._storage.config) } assert(e, t) { assert$2(e, t) } warn(e) { return this._getLogFunction(0, e, originalConsole.warn, arguments, ONCE) } error(e) { return this._getLogFunction(0, e, originalConsole.error, arguments) } deprecated(e, t) { return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead")) } removed(e, t) { return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead")) } probe(e, t) { return this._getLogFunction(e, t, originalConsole.log, arguments, { time: !0, once: !0 }) } log(e, t) { return this._getLogFunction(e, t, originalConsole.debug, arguments) } info(e, t) { return this._getLogFunction(e, t, console.info, arguments) } once(e, t) { for (var i = arguments.length, s = new Array(2 < i ? i - 2 : 0), r = 2; r < i; r++)s[r - 2] = arguments[r]; return this._getLogFunction(e, t, originalConsole.debug || originalConsole.info, arguments, ONCE) } table(e, t, i) { return t ? this._getLogFunction(e, t, console.table || noop, i && [i], { tag: getTableHeader(t) }) : noop } image(e) { var { logLevel: e, priority: t, image: i, message: s = "", scale: r = 1 } = e; return this._shouldLog(e || t) ? (isBrowser ? logImageInBrowser : logImageInNode)({ image: i, message: s, scale: r }) : noop } time(e, t) { return this._getLogFunction(e, t, console.time || console.info) } timeEnd(e, t) { return this._getLogFunction(e, t, console.timeEnd || console.info) } timeStamp(e, t) { return this._getLogFunction(e, t, console.timeStamp || noop) } group(e, t) { var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : { collapsed: !1 }; e = normalizeArguments({ logLevel: e, message: t, opts: i }), t = i.collapsed; return e.method = (t ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(e) } groupCollapsed(e, t) { return this.group(e, t, Object.assign({}, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, { collapsed: !0 })) } groupEnd(e) { return this._getLogFunction(e, "", console.groupEnd || noop) } withGroup(e, t, i) { this.group(e, t)(); try { i() } finally { this.groupEnd(e)() } } trace() { console.trace && console.trace() } _shouldLog(e) { return this.isEnabled() && this.getLevel() >= normalizeLogLevel(e) } _getLogFunction(e, t, i, s, r) { if (this._shouldLog(e)) { if (r = normalizeArguments({ logLevel: e, message: t, args: s, opts: r }), assert$2(i = i || r.method), r.total = this.getTotal(), r.delta = this.getDelta(), this._deltaTs = getHiResTimestamp(), e = r.tag || r.message, r.once) { if (cache[e]) return noop; cache[e] = getHiResTimestamp() } return t = decorateMessage(this.id, r.message, r), i.bind(console, t, ...r.args) } return noop } } function normalizeLogLevel(e) { if (!e) return 0; let t; switch (typeof e) { case "number": t = e; break; case "object": t = e.logLevel || e.priority || 0; break; default: return 0 }return assert$2(Number.isFinite(t) && 0 <= t), t } function normalizeArguments(e) { for (var { logLevel: t, message: i } = e, s = (e.logLevel = normalizeLogLevel(t), e.args ? Array.from(e.args) : []); s.length && s.shift() !== i;); switch (typeof t) { case "string": case "function": void 0 !== i && s.unshift(i), e.message = t; break; case "object": Object.assign(e, t) }"function" == typeof e.message && (e.message = e.message()); var r = typeof e.message; return assert$2("string" == r || "object" == r), Object.assign(e, { args: s }, e.opts) } function decorateMessage(e, t, i) { var s; return "string" == typeof t && (s = i.time ? leftPad(formatTime(i.total)) : "", t = addColor(t = (i.time ? "".concat(e, ": ").concat(s, "  ") : "".concat(e, ": ")).concat(t), i.color, i.background)), t } function logImageInNode(e) { let { image: t, scale: i = 1 } = e, s = null; try { s = module.require("asciify-image") } catch (e) { } return s ? () => s(t, { fit: "box", width: "".concat(Math.round(80 * i), "%") }).then((e => console.log(e))) : noop } function logImageInBrowser(e) { let { image: t, message: i = "", scale: s = 1 } = e; if ("string" == typeof t) { const e = new Image; e.onload = () => { var t = formatImage(e, i, s); console.log(...t) }, e.src = t } else if ("img" === (e = t.nodeName || "").toLowerCase()) console.log(...formatImage(t, i, s)); else if ("canvas" === e.toLowerCase()) { const e = new Image; e.onload = () => console.log(...formatImage(e, i, s)), e.src = t.toDataURL() } return noop } function getTableHeader(e) { for (const t in e) for (const i in e[t]) return i || "untitled"; return "empty" } _defineProperty(Log, "VERSION", VERSION$6); const log = new Log({ id: "loaders.gl" }), EXT_PATTERN = /\.([^.]+)$/; async function selectLoader(e, t = [], i, s) { if (!validHTTPResponse(e)) return null; let r = selectLoaderSync(e, t, { ...i, nothrow: !0 }, s); if (r) return r; if (isBlob(e) && (r = selectLoaderSync(e = await e.slice(0, 10).arrayBuffer(), t, i, s)), r || null != i && i.nothrow) return r; throw new Error(getNoValidLoaderMessage(e)) } function selectLoaderSync(e, t = [], i, s) { if (!validHTTPResponse(e)) return null; if (t && !Array.isArray(t)) return normalizeLoader(t); let r = []; if (t && (r = r.concat(t)), null != i && i.ignoreRegisteredLoaders || r.push(...getRegisteredLoaders()), normalizeLoaders(r), (t = selectLoaderInternal(e, r, i, s)) || null != i && i.nothrow) return t; throw new Error(getNoValidLoaderMessage(e)) } function selectLoaderInternal(e, t, i, s) { var { url: r, type: a } = getResourceUrlAndType(e), r = r || (null == s ? void 0 : s.url); let o = null, n = ""; return null != i && i.mimeType && (o = findLoaderByMIMEType(t, null == i ? void 0 : i.mimeType), n = "match forced by supplied MIME type ".concat(null == i ? void 0 : i.mimeType)), o = o || findLoaderByUrl(t, r), n = n || (o ? "matched url ".concat(r) : ""), o = o || findLoaderByMIMEType(t, a), n = n || (o ? "matched MIME type ".concat(a) : ""), o = o || findLoaderByInitialBytes(t, e), n = n || (o ? "matched initial data ".concat(getFirstCharacters(e)) : ""), o = o || findLoaderByMIMEType(t, null == i ? void 0 : i.fallbackMimeType), (n = n || (o ? "matched fallback MIME type ".concat(a) : "")) && log.log(1, "selectLoader selected ".concat(null == (s = o) ? void 0 : s.name, ": ").concat(n, ".")), o } function validHTTPResponse(e) { return !(e instanceof Response && 204 === e.status) } function getNoValidLoaderMessage(e) { var { url: t, type: i } = getResourceUrlAndType(e), s = "No valid loader found (", t = (s = (s += t ? "".concat(filename(t), ", ") : "no url provided, ") + "MIME type: ".concat(i ? '"'.concat(i, '"') : "not provided", ", "), e ? getFirstCharacters(e) : ""); return s + (t ? ' first bytes: "'.concat(t, '"') : "first bytes: not available") + ")" } function normalizeLoaders(e) { for (const t of e) normalizeLoader(t) } function findLoaderByUrl(e, t) { return (t = (t = t && EXT_PATTERN.exec(t)) && t[1]) ? findLoaderByExtension(e, t) : null } function findLoaderByExtension(e, t) { t = t.toLowerCase(); for (const i of e) for (const e of i.extensions) if (e.toLowerCase() === t) return i; return null } function findLoaderByMIMEType(e, t) { for (const i of e) { if (i.mimeTypes && i.mimeTypes.includes(t)) return i; if (t === "application/x.".concat(i.id)) return i } return null } function findLoaderByInitialBytes(e, t) { if (t) for (const i of e) if ("string" == typeof t) { if (testDataAgainstText(t, i)) return i } else if (ArrayBuffer.isView(t)) { if (testDataAgainstBinary(t.buffer, t.byteOffset, i)) return i } else if (t instanceof ArrayBuffer && testDataAgainstBinary(t, 0, i)) return i; return null } function testDataAgainstText(e, t) { return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some((t => e.startsWith(t))) } function testDataAgainstBinary(e, t, i) { return (Array.isArray(i.tests) ? i.tests : [i.tests]).some((s => testBinary(e, t, i, s))) } function testBinary(e, t, i, s) { if (s instanceof ArrayBuffer) return compareArrayBuffers(s, e, s.byteLength); switch (typeof s) { case "function": return s(e, i); case "string": return s === getMagicString$1(e, t, s.length); default: return !1 } } function getFirstCharacters(e, t = 5) { return "string" == typeof e ? e.slice(0, t) : ArrayBuffer.isView(e) ? getMagicString$1(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? getMagicString$1(e, 0, t) : "" } function getMagicString$1(e, t, i) { if (e.byteLength < t + i) return ""; var s = new DataView(e); let r = ""; for (let e = 0; e < i; e++)r += String.fromCharCode(s.getUint8(t + e)); return r } const DEFAULT_CHUNK_SIZE$2 = 262144; function* makeStringIterator(e, t) { var i = (null == t ? void 0 : t.chunkSize) || DEFAULT_CHUNK_SIZE$2; let s = 0; for (var r = new TextEncoder; s < e.length;) { var a = Math.min(e.length - s, i), o = e.slice(s, s + a); s += a, yield r.encode(o) } } const DEFAULT_CHUNK_SIZE$1 = 262144; function* makeArrayBufferIterator(e, t = {}) { var { chunkSize: i = DEFAULT_CHUNK_SIZE$1 } = t; let s = 0; for (; s < e.byteLength;) { var r = Math.min(e.byteLength - s, i), a = new ArrayBuffer(r), o = new Uint8Array(e, s, r); new Uint8Array(a).set(o), s += r, yield a } } const DEFAULT_CHUNK_SIZE = 1048576; async function* makeBlobIterator(e, t) { var i = (null == t ? void 0 : t.chunkSize) || DEFAULT_CHUNK_SIZE; let s = 0; for (; s < e.size;) { var r = s + i, a = await e.slice(s, r).arrayBuffer(); s = r, yield a } } function makeStreamIterator(e, t) { return isBrowser$4 ? makeBrowserStreamIterator(e, t) : makeNodeStreamIterator(e) } async function* makeBrowserStreamIterator(e, t) { var i = e.getReader(); let s; try { for (; ;) { var r = s || i.read(), { done: a, value: o } = (null != t && t._streamReadAhead && (s = i.read()), await r); if (a) return; yield toArrayBuffer(o) } } catch (e) { i.releaseLock() } } async function* makeNodeStreamIterator(e, t) { for await (const t of e) yield toArrayBuffer(t) } function makeIterator(e, t) { if ("string" == typeof e) return makeStringIterator(e, t); if (e instanceof ArrayBuffer) return makeArrayBufferIterator(e, t); if (isBlob(e)) return makeBlobIterator(e, t); if (isReadableStream(e)) return makeStreamIterator(e, t); if (isResponse(e)) return makeStreamIterator(e.body, t); throw new Error("makeIterator") } const ERR_DATA = "Cannot convert supplied data type"; function getArrayBufferOrStringFromDataSync(e, t, i) { if (t.text && "string" == typeof e) return e; if ((e = isBuffer(e) ? e.buffer : e) instanceof ArrayBuffer) return s = e, t.text && !t.binary ? new TextDecoder("utf8").decode(s) : s; if (ArrayBuffer.isView(e)) { if (t.text && !t.binary) return new TextDecoder("utf8").decode(e); let i = e.buffer; var s = e.byteLength || e.length; return i = 0 === e.byteOffset && s === i.byteLength ? i : i.slice(e.byteOffset, e.byteOffset + s) } throw new Error(ERR_DATA) } async function getArrayBufferOrStringFromData(e, t, i) { var s = e instanceof ArrayBuffer || ArrayBuffer.isView(e); if ("string" == typeof e || s) return getArrayBufferOrStringFromDataSync(e, t); if (isBlob(e) && (e = await makeResponse(e)), isResponse(e)) return await checkResponse(s = e), t.binary ? await s.arrayBuffer() : await s.text(); if (isReadableStream(e) && (e = makeIterator(e, i)), isIterable(e) || isAsyncIterable(e)) return concatenateArrayBuffersAsync(e); throw new Error(ERR_DATA) } function getLoaderContext(e, t, i = null) { return i || (i = { fetch: getFetchFunction(t, e), ...e }, Array.isArray(i.loaders) || (i.loaders = null), i) } function getLoadersFromContext(e, t) { if (!t && e && !Array.isArray(e)) return e; let i; return e && (i = Array.isArray(e) ? e : [e]), t && t.loaders && (e = Array.isArray(t.loaders) ? t.loaders : [t.loaders], i = i ? [...i, ...e] : e), i && i.length ? i : null } async function parse$3(e, t, i, s) { assert$4(!s || "object" == typeof s), !t || Array.isArray(t) || isLoaderObject(t) || (i = t, t = s = void 0), i = i || {}; var r = getResourceUrlAndType(e = await e).url, a = await selectLoader(e, t = getLoadersFromContext(t, s), i); return a ? parseWithLoader(a, e, i = normalizeOptions(i, a, t, r), s = getLoaderContext({ url: r, parse: parse$3, loaders: t }, i, s)) : null } async function parseWithLoader(e, t, i, s) { var r, a, o, n, h, l, c; if (validateWorkerVersion(e), isResponse(t) && (({ ok: r, redirected: a, status: o, statusText: n, type: h, url: l } = c = t), c = Object.fromEntries(c.headers.entries()), s.response = { headers: c, ok: r, redirected: a, status: o, statusText: n, type: h, url: l }), t = await getArrayBufferOrStringFromData(t, e, i), e.parseTextSync && "string" == typeof t) return i.dataType = "text", e.parseTextSync(t, i, s, e); if (canParseWithWorker(e, i)) return parseWithWorker(e, t, i, s, parse$3); if (e.parseText && "string" == typeof t) return e.parseText(t, i, s, e); if (e.parse) return e.parse(t, i, s, e); throw assert$4(!e.parseSync), new Error("".concat(e.id, " loader - no parser found and worker is disabled")) } const VERSION$5 = "3.2.6", VERSION$4 = "3.2.6", VERSION$3 = "3.2.6", BASIS_CDN_ENCODER_WASM = "https://unpkg.com/@loaders.gl/textures@".concat("3.2.6", "/dist/libs/basis_encoder.wasm"), BASIS_CDN_ENCODER_JS = "https://unpkg.com/@loaders.gl/textures@".concat("3.2.6", "/dist/libs/basis_encoder.js"); let loadBasisTranscoderPromise, loadBasisEncoderPromise; async function loadBasisTrascoderModule(e) { return (e.modules || {}).basis || (loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(e)) } async function loadBasisTrascoder(e) { var t = null, i = null; return [t, i] = await Promise.all([await loadLibrary("basis_transcoder.js", "textures", e), await loadLibrary("basis_transcoder.wasm", "textures", e)]), initializeBasisTrascoderModule(t = t || globalThis.BASIS, i) } function initializeBasisTrascoderModule(e, t) { const i = {}; return t && (i.wasmBinary = t), new Promise((t => { e(i).then((e => { var { BasisFile: e, initializeBasis: i } = e; i(), t({ BasisFile: e }) })) })) } async function loadBasisEncoderModule(e) { return (e.modules || {}).basisEncoder || (loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(e)) } async function loadBasisEncoder(e) { var t = null, i = null; return [t, i] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", e), await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", e)]), initializeBasisEncoderModule(t = t || globalThis.BASIS, i) } function initializeBasisEncoderModule(e, t) { const i = {}; return t && (i.wasmBinary = t), new Promise((t => { e(i).then((e => { var { BasisFile: e, KTX2File: i, initializeBasis: s, BasisEncoder: r } = e; s(), t({ BasisFile: e, KTX2File: i, BasisEncoder: r }) })) })) } const GL_EXTENSIONS_CONSTANTS = { COMPRESSED_RGB_S3TC_DXT1_EXT: 33776, COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777, COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778, COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779, COMPRESSED_R11_EAC: 37488, COMPRESSED_SIGNED_R11_EAC: 37489, COMPRESSED_RG11_EAC: 37490, COMPRESSED_SIGNED_RG11_EAC: 37491, COMPRESSED_RGB8_ETC2: 37492, COMPRESSED_RGBA8_ETC2_EAC: 37493, COMPRESSED_SRGB8_ETC2: 37494, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497, COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840, COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842, COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841, COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843, COMPRESSED_RGB_ETC1_WEBGL: 36196, COMPRESSED_RGB_ATC_WEBGL: 35986, COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987, COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798, COMPRESSED_RGBA_ASTC_4X4_KHR: 37808, COMPRESSED_RGBA_ASTC_5X4_KHR: 37809, COMPRESSED_RGBA_ASTC_5X5_KHR: 37810, COMPRESSED_RGBA_ASTC_6X5_KHR: 37811, COMPRESSED_RGBA_ASTC_6X6_KHR: 37812, COMPRESSED_RGBA_ASTC_8X5_KHR: 37813, COMPRESSED_RGBA_ASTC_8X6_KHR: 37814, COMPRESSED_RGBA_ASTC_8X8_KHR: 37815, COMPRESSED_RGBA_ASTC_10X5_KHR: 37816, COMPRESSED_RGBA_ASTC_10X6_KHR: 37817, COMPRESSED_RGBA_ASTC_10X8_KHR: 37818, COMPRESSED_RGBA_ASTC_10X10_KHR: 37819, COMPRESSED_RGBA_ASTC_12X10_KHR: 37820, COMPRESSED_RGBA_ASTC_12X12_KHR: 37821, COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840, COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841, COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842, COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843, COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844, COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845, COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846, COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847, COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848, COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849, COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850, COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851, COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852, COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853, COMPRESSED_RED_RGTC1_EXT: 36283, COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284, COMPRESSED_RED_GREEN_RGTC2_EXT: 36285, COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286, COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916, COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917, COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918, COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919 }, BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"], WEBGL_EXTENSIONS = { WEBGL_compressed_texture_s3tc: "dxt", WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb", WEBGL_compressed_texture_etc1: "etc1", WEBGL_compressed_texture_etc: "etc2", WEBGL_compressed_texture_pvrtc: "pvrtc", WEBGL_compressed_texture_atc: "atc", WEBGL_compressed_texture_astc: "astc", EXT_texture_compression_rgtc: "rgtc" }; let formats = null; function getSupportedGPUTextureFormats(e) { if (!formats) { e = e || getWebGLContext() || void 0, formats = new Set; for (const i of BROWSER_PREFIXES) for (const s in WEBGL_EXTENSIONS) { var t; e && e.getExtension("".concat(i).concat(s)) && (t = WEBGL_EXTENSIONS[s], formats.add(t)) } } return formats } function getWebGLContext() { try { return document.createElement("canvas").getContext("webgl") } catch (e) { return null } } !function (e) { e[e.NONE = 0] = "NONE", e[e.BASISLZ = 1] = "BASISLZ", e[e.ZSTD = 2] = "ZSTD", e[e.ZLIB = 3] = "ZLIB" }(n = n || {}), (i = i || {})[i.BASICFORMAT = 0] = "BASICFORMAT", function (e) { e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.ETC1S = 163] = "ETC1S", e[e.UASTC = 166] = "UASTC" }(s = s || {}), function (e) { e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.SRGB = 1] = "SRGB" }(a = a || {}), function (e) { e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LINEAR = 1] = "LINEAR", e[e.SRGB = 2] = "SRGB", e[e.ITU = 3] = "ITU", e[e.NTSC = 4] = "NTSC", e[e.SLOG = 5] = "SLOG", e[e.SLOG2 = 6] = "SLOG2" }(r = r || {}), function (e) { e[e.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", e[e.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED" }(o = o || {}), function (e) { e[e.RGB = 0] = "RGB", e[e.RRR = 3] = "RRR", e[e.GGG = 4] = "GGG", e[e.AAA = 15] = "AAA" }(l = l || {}), function (e) { e[e.RGB = 0] = "RGB", e[e.RGBA = 3] = "RGBA", e[e.RRR = 4] = "RRR", e[e.RRRG = 5] = "RRRG" }(f = f || {}); const KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function isKTX(e) { return !((e = new Uint8Array(e)).byteLength < KTX2_ID.length || e[0] !== KTX2_ID[0] || e[1] !== KTX2_ID[1] || e[2] !== KTX2_ID[2] || e[3] !== KTX2_ID[3] || e[4] !== KTX2_ID[4] || e[5] !== KTX2_ID[5] || e[6] !== KTX2_ID[6] || e[7] !== KTX2_ID[7] || e[8] !== KTX2_ID[8] || e[9] !== KTX2_ID[9] || e[10] !== KTX2_ID[10] || e[11] !== KTX2_ID[11]) } const OutputFormat = { etc1: { basisFormat: 0, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL }, etc2: { basisFormat: 1, compressed: !0 }, bc1: { basisFormat: 2, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT }, bc3: { basisFormat: 3, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT }, bc4: { basisFormat: 4, compressed: !0 }, bc5: { basisFormat: 5, compressed: !0 }, "bc7-m6-opaque-only": { basisFormat: 6, compressed: !0 }, "bc7-m5": { basisFormat: 7, compressed: !0 }, "pvrtc1-4-rgb": { basisFormat: 8, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG }, "pvrtc1-4-rgba": { basisFormat: 9, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG }, "astc-4x4": { basisFormat: 10, compressed: !0, format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR }, "atc-rgb": { basisFormat: 11, compressed: !0 }, "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: !0 }, rgba32: { basisFormat: 13, compressed: !1 }, rgb565: { basisFormat: 14, compressed: !1 }, bgr565: { basisFormat: 15, compressed: !1 }, rgba4444: { basisFormat: 16, compressed: !1 } }; async function parseBasis(e, t) { var i; return "auto" === t.basis.containerFormat ? isKTX(e) ? parseKTX2File((await loadBasisEncoderModule(t)).KTX2File, e, t) : parseBasisFile(i = (await loadBasisTrascoderModule(t)).BasisFile, e, t) : "encoder" === t.basis.module ? (i = await loadBasisEncoderModule(t), "ktx2" !== t.basis.containerFormat ? parseBasisFile(i.BasisFile, e, t) : parseKTX2File(i.KTX2File, e, t)) : parseBasisFile(i = (await loadBasisTrascoderModule(t)).BasisFile, e, t) } function parseBasisFile(e, t, i) { var s = new e(new Uint8Array(t)); try { if (!s.startTranscoding()) throw new Error("Failed to start basis transcoding"); var r = s.getNumImages(), a = []; for (let e = 0; e < r; e++) { var o = s.getNumLevels(e), n = []; for (let t = 0; t < o; t++)n.push(transcodeImage(s, e, t, i)); a.push(n) } return a } finally { s.close(), s.delete() } } function transcodeImage(e, t, i, s) { var r = e.getImageWidth(t, i), a = e.getImageHeight(t, i), o = e.getHasAlpha(), { compressed: s, format: n, basisFormat: h } = getBasisOptions(s, o), l = e.getImageTranscodedSizeInBytes(t, i, h); l = new Uint8Array(l); if (e.transcodeImage(l, t, i, h, 0, 0)) return { width: r, height: a, data: l, compressed: s, format: n, hasAlpha: o }; throw new Error("failed to start Basis transcoding") } function parseKTX2File(e, t, i) { var s = new e(new Uint8Array(t)); try { if (!s.startTranscoding()) throw new Error("failed to start KTX2 transcoding"); var r = s.getLevels(), a = []; for (let e = 0; e < r; e++) { a.push(transcodeKTX2Image(s, e, i)); break } return [a] } finally { s.close(), s.delete() } } function transcodeKTX2Image(e, t, i) { var { alphaFlag: s, height: r, width: a } = e.getImageLevelInfo(t, 0, 0), { compressed: i, format: o, basisFormat: n } = getBasisOptions(i, s), h = e.getImageTranscodedSizeInBytes(t, 0, 0, n); h = new Uint8Array(h); if (e.transcodeImage(h, t, 0, 0, n, 0, -1, -1)) return { width: a, height: r, data: h, compressed: i, hasAlpha: s, format: o }; throw new Error("Failed to transcode KTX2 image") } function getBasisOptions(e, t) { let i = e && e.basis && e.basis.format; return i = (i = "object" == typeof (i = "auto" === i ? selectSupportedBasisFormat() : i) ? t ? i.alpha : i.noAlpha : i).toLowerCase(), OutputFormat[i] } function selectSupportedBasisFormat() { var e = getSupportedGPUTextureFormats(); return e.has("astc") ? "astc-4x4" : e.has("dxt") ? { alpha: "bc3", noAlpha: "bc1" } : e.has("pvrtc") ? { alpha: "pvrtc1-4-rgba", noAlpha: "pvrtc1-4-rgb" } : e.has("etc1") ? "etc1" : e.has("etc2") ? "etc2" : "rgb565" } const BasisWorkerLoader = { name: "Basis", id: "basis", module: "textures", version: "3.2.6", worker: !0, extensions: ["basis", "ktx2"], mimeTypes: ["application/octet-stream", "image/ktx2"], tests: ["sB"], binary: !0, options: { basis: { format: "auto", libraryPath: "libs/", containerFormat: "auto", module: "transcoder" } } }, BasisLoader = { ...BasisWorkerLoader, parse: parseBasis }, VERSION$2 = "3.2.6", { _parseImageNode: _parseImageNode } = globalThis, IMAGE_SUPPORTED = "undefined" != typeof Image, IMAGE_BITMAP_SUPPORTED = "undefined" != typeof ImageBitmap, NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode), DATA_SUPPORTED = !!isBrowser$4 || NODE_IMAGE_SUPPORTED; function isImageTypeSupported(e) { switch (e) { case "auto": return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED; case "imagebitmap": return IMAGE_BITMAP_SUPPORTED; case "image": return IMAGE_SUPPORTED; case "data": return DATA_SUPPORTED; default: throw new Error("@loaders.gl/images: image ".concat(e, " not supported in this environment")) } } function getDefaultImageType() { if (IMAGE_BITMAP_SUPPORTED) return "imagebitmap"; if (IMAGE_SUPPORTED) return "image"; if (DATA_SUPPORTED) return "data"; throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js") } function getImageType(e) { if (e = getImageTypeOrNull(e)) return e; throw new Error("Not an image") } function getImageData(e) { switch (getImageType(e)) { case "data": return e; case "image": case "imagebitmap": var t = document.createElement("canvas"), i = t.getContext("2d"); if (i) return t.width = e.width, t.height = e.height, i.drawImage(e, 0, 0), i.getImageData(0, 0, e.width, e.height); throw new Error("getImageData"); default: throw new Error("getImageData") } } function getImageTypeOrNull(e) { return "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? "imagebitmap" : "undefined" != typeof Image && e instanceof Image ? "image" : e && "object" == typeof e && e.data && e.width && e.height ? "data" : null } const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/, SVG_URL_PATTERN = /\.svg((\?|#).*)?$/; function isSVG(e) { return e && (SVG_DATA_URL_PATTERN.test(e) || SVG_URL_PATTERN.test(e)) } function getBlobOrSVGDataUrl(e, t) { if (isSVG(t)) { let i = (new TextDecoder).decode(e); try { "function" == typeof unescape && "function" == typeof encodeURIComponent && (i = unescape(encodeURIComponent(i))) } catch (t) { throw new Error(t.message) } return "data:image/svg+xml;base64,".concat(btoa(i)) } return getBlob(e, t) } function getBlob(e, t) { if (isSVG(t)) throw new Error("SVG cannot be parsed directly to imagebitmap"); return new Blob([new Uint8Array(e)]) } async function parseToImage(e, t, i) { e = getBlobOrSVGDataUrl(e, i), i = self.URL || self.webkitURL; var s = "string" != typeof e && i.createObjectURL(e); try { return await loadToImage(s || e, t) } finally { s && i.revokeObjectURL(s) } } async function loadToImage(e, t) { const i = new Image; return i.src = e, t.image && t.image.decode && i.decode ? (await i.decode(), i) : new Promise(((t, s) => { try { i.onload = () => t(i), i.onerror = t => s(new Error("Could not load image ".concat(e, ": ").concat(t))) } catch (t) { s(t) } })) } const EMPTY_OBJECT = {}; let imagebitmapOptionsSupported = !0; async function parseToImageBitmap(e, t, i) { return safeCreateImageBitmap(isSVG(i) ? await parseToImage(e, t, i) : getBlob(e, i), e = t && t.imagebitmap) } async function safeCreateImageBitmap(e, t = null) { if (t = !isEmptyObject(t) && imagebitmapOptionsSupported ? t : null) try { return await createImageBitmap(e, t) } catch (e) { console.warn(e), imagebitmapOptionsSupported = !1 } return createImageBitmap(e) } function isEmptyObject(e) { for (const t in e || EMPTY_OBJECT) return !1; return !0 } const BIG_ENDIAN = !1, LITTLE_ENDIAN = !0; function getBinaryImageMetadata(e) { return getPngMetadata(e = toDataView(e)) || getJpegMetadata(e) || getGifMetadata(e) || getBmpMetadata(e) } function getPngMetadata(e) { return 24 <= (e = toDataView(e)).byteLength && 2303741511 === e.getUint32(0, BIG_ENDIAN) ? { mimeType: "image/png", width: e.getUint32(16, BIG_ENDIAN), height: e.getUint32(20, BIG_ENDIAN) } : null } function getGifMetadata(e) { return 10 <= (e = toDataView(e)).byteLength && 1195984440 === e.getUint32(0, BIG_ENDIAN) ? { mimeType: "image/gif", width: e.getUint16(6, LITTLE_ENDIAN), height: e.getUint16(8, LITTLE_ENDIAN) } : null } function getBmpMetadata(e) { return 14 <= (e = toDataView(e)).byteLength && 16973 === e.getUint16(0, BIG_ENDIAN) && e.getUint32(2, LITTLE_ENDIAN) === e.byteLength ? { mimeType: "image/bmp", width: e.getUint32(18, LITTLE_ENDIAN), height: e.getUint32(22, LITTLE_ENDIAN) } : null } function getJpegMetadata(e) { var t = toDataView(e); if (3 <= t.byteLength && 65496 === t.getUint16(0, BIG_ENDIAN) && 255 === t.getUint8(2)) { var { tableMarkers: i, sofMarkers: s } = getJpegMarkers(); let e = 2; for (; e + 9 < t.byteLength;) { var r = t.getUint16(e, BIG_ENDIAN); if (s.has(r)) return { mimeType: "image/jpeg", height: t.getUint16(e + 5, BIG_ENDIAN), width: t.getUint16(e + 7, BIG_ENDIAN) }; if (!i.has(r)) return null; e = (e += 2) + t.getUint16(e, BIG_ENDIAN) } } return null } function getJpegMarkers() { var e = new Set([65499, 65476, 65484, 65501, 65534]); for (let t = 65504; t < 65520; ++t)e.add(t); return { tableMarkers: e, sofMarkers: new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]) } } function toDataView(e) { if (e instanceof DataView) return e; if (ArrayBuffer.isView(e)) return new DataView(e.buffer); if (e instanceof ArrayBuffer) return new DataView(e); throw new Error("toDataView") } async function parseToNodeImage(e, t) { var i = (getBinaryImageMetadata(e) || {}).mimeType, s = globalThis._parseImageNode; return assert$5(s), s(e, i) } async function parseImage(e, t, i) { var s = ((t = t || {}).image || {}).type || "auto", r = (i || {}).url; let a; switch (getLoadableImageType(s)) { case "imagebitmap": a = await parseToImageBitmap(e, t, r); break; case "image": a = await parseToImage(e, t, r); break; case "data": a = await parseToNodeImage(e); break; default: assert$5(!1) }return "data" === s ? getImageData(a) : a } function getLoadableImageType(e) { switch (e) { case "auto": case "data": return getDefaultImageType(); default: return isImageTypeSupported(e), e } } const EXTENSIONS$1 = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"], MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], DEFAULT_IMAGE_LOADER_OPTIONS = { image: { type: "auto", decode: !0 } }, ImageLoader = { id: "image", module: "images", name: "Images", version: "3.2.6", mimeTypes: MIME_TYPES, extensions: EXTENSIONS$1, parse: parseImage, tests: [e => Boolean(getBinaryImageMetadata(new DataView(e)))], options: DEFAULT_IMAGE_LOADER_OPTIONS }, NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"], mimeTypeSupported = {}; function _isImageFormatSupported(e) { return void 0 === mimeTypeSupported[e] && (mimeTypeSupported[e] = checkFormatSupport(e)), mimeTypeSupported[e] } function checkFormatSupport(e) { switch (e) { case "image/webp": return checkWebPSupport(); case "image/svg": return isBrowser$4; default: var t; return !!isBrowser$4 || (t = globalThis._parseImageNode, Boolean(t) && NODE_FORMAT_SUPPORT.includes(e)) } } function checkWebPSupport() { if (!isBrowser$4) return !1; try { return 0 === document.createElement("canvas").toDataURL("image/webp").indexOf("data:image/webp") } catch { return !1 } } function assert$1(e, t) { if (!e) throw new Error(t || "assert failed: gltf") } function resolveUrl(e, t) { if (e.startsWith("data:") || e.startsWith("http:") || e.startsWith("https:")) return e; if (t = t.baseUri || t.uri) return t.substr(0, t.lastIndexOf("/") + 1) + e; throw new Error("'baseUri' must be provided to resolve relative url ".concat(e)) } function getTypedArrayForBufferView(e, t, i) { return assert$1(e = e.bufferViews[i]), assert$1(t = t[i = e.buffer]), i = (e.byteOffset || 0) + t.byteOffset, new Uint8Array(t.arrayBuffer, i, e.byteLength) } const TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"], ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT), ATTRIBUTE_TYPE_TO_COMPONENTS = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 }, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }; function getAccessorTypeFromSize(e) { return TYPES[e - 1] || TYPES[0] } function getComponentTypeFromArray(e) { if (e = ARRAY_TO_COMPONENT_TYPE.get(e.constructor)) return e; throw new Error("Illegal typed array") } function getAccessorArrayTypeAndLength(e, t) { var i = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[e.componentType], s = ATTRIBUTE_TYPE_TO_COMPONENTS[e.type], r = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[e.componentType], a = e.count * s; return assert$1(0 <= (e = e.count * s * r) && e <= t.byteLength), { ArrayType: i, length: a, byteLength: e } } const DEFAULT_GLTF_JSON = { asset: { version: "2.0", generator: "loaders.gl" }, buffers: [] }; class GLTFScenegraph { constructor(e) { _defineProperty(this, "gltf", void 0), _defineProperty(this, "sourceBuffers", void 0), _defineProperty(this, "byteLength", void 0), this.gltf = e || { json: { ...DEFAULT_GLTF_JSON }, buffers: [] }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]) } get json() { return this.gltf.json } getApplicationData(e) { return this.json[e] } getExtraData(e) { return (this.json.extras || {})[e] } getExtension(e) { var t = this.getUsedExtensions().find((t => t === e)), i = this.json.extensions || {}; return t ? i[e] || !0 : null } getRequiredExtension(e) { return this.getRequiredExtensions().find((t => t === e)) ? this.getExtension(e) : null } getRequiredExtensions() { return this.json.extensionsRequired || [] } getUsedExtensions() { return this.json.extensionsUsed || [] } getObjectExtension(e, t) { return (e.extensions || {})[t] } getScene(e) { return this.getObject("scenes", e) } getNode(e) { return this.getObject("nodes", e) } getSkin(e) { return this.getObject("skins", e) } getMesh(e) { return this.getObject("meshes", e) } getMaterial(e) { return this.getObject("materials", e) } getAccessor(e) { return this.getObject("accessors", e) } getTexture(e) { return this.getObject("textures", e) } getSampler(e) { return this.getObject("samplers", e) } getImage(e) { return this.getObject("images", e) } getBufferView(e) { return this.getObject("bufferViews", e) } getBuffer(e) { return this.getObject("buffers", e) } getObject(e, t) { if ("object" == typeof t) return t; var i = this.json[e] && this.json[e][t]; if (i) return i; throw new Error("glTF file error: Could not find ".concat(e, "[").concat(t, "]")) } getTypedArrayForBufferView(e) { var t = (e = this.getBufferView(e)).buffer, i = (assert$1(t = this.gltf.buffers[t]), (e.byteOffset || 0) + t.byteOffset); return new Uint8Array(t.arrayBuffer, i, e.byteLength) } getTypedArrayForAccessor(e) { e = this.getAccessor(e); var t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, { ArrayType: s, length: r } = getAccessorArrayTypeAndLength(e, t); return new s(i, t.byteOffset + e.byteOffset, r) } getTypedArrayForImageData(e) { e = this.getAccessor(e); e = this.getBufferView(e.bufferView); var t = this.getBuffer(e.buffer).data, i = e.byteOffset || 0; return new Uint8Array(t, i, e.byteLength) } addApplicationData(e, t) { return this.json[e] = t, this } addExtraData(e, t) { return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this } addObjectExtension(e, t, i) { return e.extensions = e.extensions || {}, e.extensions[t] = i, this.registerUsedExtension(t), this } setObjectExtension(e, t, i) { (e.extensions || {})[t] = i } removeObjectExtension(e, t) { var i = (e = e.extensions || {})[t]; return delete e[t], i } addExtension(e, t = {}) { return assert$1(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t } addRequiredExtension(e, t = {}) { return assert$1(t), this.addExtension(e, t), this.registerRequiredExtension(e), t } registerUsedExtension(e) { this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t => t === e)) || this.json.extensionsUsed.push(e) } registerRequiredExtension(e) { this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t => t === e)) || this.json.extensionsRequired.push(e) } removeExtension(e) { this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e), this.json.extensions && delete this.json.extensions[e] } setDefaultScene(e) { this.json.scene = e } addScene(e) { return e = e.nodeIndices, this.json.scenes = this.json.scenes || [], this.json.scenes.push({ nodes: e }), this.json.scenes.length - 1 } addNode(e) { var { meshIndex: e, matrix: t } = e; this.json.nodes = this.json.nodes || [], e = { mesh: e }; return t && (e.matrix = t), this.json.nodes.push(e), this.json.nodes.length - 1 } addMesh(e) { var { attributes: e, indices: t, material: i, mode: s = 4 } = e; e = { primitives: [{ attributes: this._addAttributes(e), mode: s }] }; return t && (s = this._addIndices(t), e.primitives[0].indices = s), Number.isFinite(i) && (e.primitives[0].material = i), this.json.meshes = this.json.meshes || [], this.json.meshes.push(e), this.json.meshes.length - 1 } addPointCloud(e) { return e = { primitives: [{ attributes: this._addAttributes(e), mode: 0 }] }, this.json.meshes = this.json.meshes || [], this.json.meshes.push(e), this.json.meshes.length - 1 } addImage(e, t) { var i = getBinaryImageMetadata(e); t = t || (null == i ? void 0 : i.mimeType), i = { bufferView: this.addBufferView(e), mimeType: t }; return this.json.images = this.json.images || [], this.json.images.push(i), this.json.images.length - 1 } addBufferView(e) { var t = e.byteLength; assert$1(Number.isFinite(t)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e), e = { buffer: 0, byteOffset: this.byteLength, byteLength: t }; return this.byteLength += padToNBytes(t, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(e), this.json.bufferViews.length - 1 } addAccessor(e, t) { return e = { bufferView: e, type: getAccessorTypeFromSize(t.size), componentType: t.componentType, count: t.count, max: t.max, min: t.min }, this.json.accessors = this.json.accessors || [], this.json.accessors.push(e), this.json.accessors.length - 1 } addBinaryBuffer(e, t = { size: 3 }) { var i = this.addBufferView(e); let s = { min: t.min, max: t.max }; return s.min && s.max || (s = this._getAccessorMinMax(e, t.size)), e = { size: t.size, componentType: getComponentTypeFromArray(e), count: Math.round(e.length / t.size), min: s.min, max: s.max }, this.addAccessor(i, Object.assign(e, t)) } addTexture(e) { return e = { source: e = e.imageIndex }, this.json.textures = this.json.textures || [], this.json.textures.push(e), this.json.textures.length - 1 } addMaterial(e) { return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1 } createBinaryChunk() { this.gltf.buffers = []; var e, t = this.byteLength, i = new ArrayBuffer(t), s = new Uint8Array(i); let r = 0; for (const e of this.sourceBuffers || []) r = copyToArray(e, s, r); null != (e = this.json) && null != (e = e.buffers) && e[0] ? this.json.buffers[0].byteLength = t : this.json.buffers = [{ byteLength: t }], this.gltf.binary = i, this.sourceBuffers = [i] } _removeStringFromArray(e, t) { let i = !0; for (; i;) { var s = e.indexOf(t); -1 < s ? e.splice(s, 1) : i = !1 } } _addAttributes(e = {}) { var t = {}; for (const r in e) { var i = e[r], s = this._getGltfAttributeName(r); i = this.addBinaryBuffer(i.value, i); t[s] = i } return t } _addIndices(e) { return this.addBinaryBuffer(e, { size: 1 }) } _getGltfAttributeName(e) { switch (e.toLowerCase()) { case "position": case "positions": case "vertices": return "POSITION"; case "normal": case "normals": return "NORMAL"; case "color": case "colors": return "COLOR_0"; case "texcoord": case "texcoords": return "TEXCOORD_0"; default: return e } } _getAccessorMinMax(e, t) { var i = { min: null, max: null }; if (!(e.length < t)) { i.min = [], i.max = []; for (const s of e.subarray(0, t)) i.min.push(s), i.max.push(s); for (let s = t; s < e.length; s += t)for (let r = 0; r < t; r++)i.min[0 + r] = Math.min(i.min[0 + r], e[s + r]), i.max[0 + r] = Math.max(i.max[0 + r], e[s + r]) } return i } } const wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), FILTERS = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, DECODERS = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; async function meshoptDecodeGltfBuffer(e, t, i, s, r, a = "NONE") { var o = await loadWasmInstance(); decode$5(o, o.exports[DECODERS[r]], e, t, i, s, o.exports[FILTERS[a || "NONE"]]) } let wasmPromise; async function loadWasmInstance() { return wasmPromise = wasmPromise || loadWasmModule() } async function loadWasmModule() { let e = wasm_base; WebAssembly.validate(detector) && (e = wasm_simd, console.log("Warning: meshopt_decoder is using experimental SIMD support")); var t = await WebAssembly.instantiate(unpack(e), {}); return await t.instance.exports.__wasm_call_ctors(), t.instance } function unpack(e) { var t = new Uint8Array(e.length); for (let s = 0; s < e.length; ++s) { var i = e.charCodeAt(s); t[s] = 96 < i ? i - 71 : 64 < i ? i - 65 : 47 < i ? i + 4 : 46 < i ? 63 : 62 } let s = 0; for (let i = 0; i < e.length; ++i)t[s++] = t[i] < 60 ? wasmpack[t[i]] : 64 * (t[i] - 60) + t[++i]; return t.buffer.slice(0, s) } function decode$5(e, t, i, s, r, a, o) { var n = e.exports.sbrk, h = s + 3 & -4, l = n(h * r), c = n(a.length); if ((e = new Uint8Array(e.exports.memory.buffer)).set(a, c), 0 === (t = t(l, s, r, c, a.length)) && o && o(l, h, r), i.set(e.subarray(l, l + s * r)), n(l - n(0)), 0 !== t) throw new Error("Malformed buffer data: ".concat(t)) } const EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression", name$6 = EXT_MESHOPT_COMPRESSION; async function decode$4(e, t) { var i = new GLTFScenegraph(e); if (null != t && null != (t = t.gltf) && t.decompressMeshes) { var s = []; for (const t of e.json.bufferViews || []) s.push(decodeMeshoptBufferView(i, t)); await Promise.all(s), i.removeExtension(EXT_MESHOPT_COMPRESSION) } } async function decodeMeshoptBufferView(e, t) { var i, s, r, a, o, n, h = e.getObjectExtension(t, EXT_MESHOPT_COMPRESSION); return h ? (({ byteOffset: h = 0, byteLength: i = 0, byteStride: s, count: r, mode: a, filter: o = "NONE", buffer: n } = h), n = e.gltf.buffers[n], n = new Uint8Array(n.arrayBuffer, n.byteOffset + h, i), await meshoptDecodeGltfBuffer(h = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength), r, s, n, a, o), h) : null } var EXT_meshopt_compression = Object.freeze({ __proto__: null, name: name$6, decode: decode$4 }); const EXT_TEXTURE_WEBP = "EXT_texture_webp", name$5 = EXT_TEXTURE_WEBP; function preprocess$3(e, t) { var i = new GLTFScenegraph(e); if (_isImageFormatSupported("image/webp")) { for (const t of (e = i.json).textures || []) { var s = i.getObjectExtension(t, EXT_TEXTURE_WEBP); s && (t.source = s.source), i.removeObjectExtension(t, EXT_TEXTURE_WEBP) } i.removeExtension(EXT_TEXTURE_WEBP) } else if (i.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP, " not supported by browser")) } var EXT_texture_webp = Object.freeze({ __proto__: null, name: name$5, preprocess: preprocess$3 }); const KHR_TEXTURE_BASISU = "KHR_texture_basisu", name$4 = KHR_TEXTURE_BASISU; function preprocess$2(e, t) { var i = new GLTFScenegraph(e); for (const t of (e = i.json).textures || []) { var s = i.getObjectExtension(t, KHR_TEXTURE_BASISU); s && (t.source = s.source), i.removeObjectExtension(t, KHR_TEXTURE_BASISU) } i.removeExtension(KHR_TEXTURE_BASISU) } var KHR_texture_basisu = Object.freeze({ __proto__: null, name: name$4, preprocess: preprocess$2 }); const VERSION$1 = "3.2.6", DEFAULT_DRACO_OPTIONS = { draco: { decoderType: "object" == typeof WebAssembly ? "wasm" : "js", libraryPath: "libs/", extraAttributes: {}, attributeNameEntry: void 0 } }, DracoLoader$1 = { name: "Draco", id: "draco", module: "draco", shapes: ["mesh"], version: "3.2.6", worker: !0, extensions: ["drc"], mimeTypes: ["application/octet-stream"], binary: !0, tests: ["DRACO"], options: DEFAULT_DRACO_OPTIONS }; function getMeshBoundingBox(e) { let t = 1 / 0, i = 1 / 0, s = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0; var n = e.POSITION ? e.POSITION.value : [], h = n && n.length; for (let e = 0; e < h; e += 3) { var l = n[e], c = n[e + 1], u = n[e + 2]; t = l < t ? l : t, i = c < i ? c : i, s = u < s ? u : s, r = l > r ? l : r, a = c > a ? c : a, o = u > o ? u : o } return [[t, i, s], [r, a, o]] } function assert(e, t) { if (!e) throw new Error(t || "loader assertion failed.") } class Schema { constructor(e, t) { _defineProperty(this, "fields", void 0), _defineProperty(this, "metadata", void 0), assert(Array.isArray(e)), checkNames(e), this.fields = e, this.metadata = t || new Map } compareTo(e) { if (this.metadata !== e.metadata) return !1; if (this.fields.length !== e.fields.length) return !1; for (let t = 0; t < this.fields.length; ++t)if (!this.fields[t].compareTo(e.fields[t])) return !1; return !0 } select(...e) { const t = Object.create(null); for (const i of e) t[i] = !0; return e = this.fields.filter((e => t[e.name])), new Schema(e, this.metadata) } selectAt(...e) { return e = e.map((e => this.fields[e])).filter(Boolean), new Schema(e, this.metadata) } assign(e) { let t, i = this.metadata; e instanceof Schema ? (t = (r = e).fields, i = mergeMaps(mergeMaps(new Map, this.metadata), r.metadata)) : t = e; var s = Object.create(null); for (const e of this.fields) s[e.name] = e; for (const e of t) s[e.name] = e; var r = Object.values(s); return new Schema(r, i) } } function checkNames(e) { var t = {}; for (const i of e) t[i.name] && console.warn("Schema: duplicated field name", i.name, i), t[i.name] = !0 } function mergeMaps(e, t) { return new Map([...e || new Map, ...t || new Map]) } class Field { constructor(e, t, i = !1, s = new Map) { _defineProperty(this, "name", void 0), _defineProperty(this, "type", void 0), _defineProperty(this, "nullable", void 0), _defineProperty(this, "metadata", void 0), this.name = e, this.type = t, this.nullable = i, this.metadata = s } get typeId() { return this.type && this.type.typeId } clone() { return new Field(this.name, this.type, this.nullable, this.metadata) } compareTo(e) { return this.name === e.name && this.type === e.type && this.nullable === e.nullable && this.metadata === e.metadata } toString() { return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "") } } let Type, _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag7; !function (e) { e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth" }(Type = Type || {}); class DataType { static isNull(e) { return e && e.typeId === Type.Null } static isInt(e) { return e && e.typeId === Type.Int } static isFloat(e) { return e && e.typeId === Type.Float } static isBinary(e) { return e && e.typeId === Type.Binary } static isUtf8(e) { return e && e.typeId === Type.Utf8 } static isBool(e) { return e && e.typeId === Type.Bool } static isDecimal(e) { return e && e.typeId === Type.Decimal } static isDate(e) { return e && e.typeId === Type.Date } static isTime(e) { return e && e.typeId === Type.Time } static isTimestamp(e) { return e && e.typeId === Type.Timestamp } static isInterval(e) { return e && e.typeId === Type.Interval } static isList(e) { return e && e.typeId === Type.List } static isStruct(e) { return e && e.typeId === Type.Struct } static isUnion(e) { return e && e.typeId === Type.Union } static isFixedSizeBinary(e) { return e && e.typeId === Type.FixedSizeBinary } static isFixedSizeList(e) { return e && e.typeId === Type.FixedSizeList } static isMap(e) { return e && e.typeId === Type.Map } static isDictionary(e) { return e && e.typeId === Type.Dictionary } get typeId() { return Type.NONE } compareTo(e) { return this === e } } _Symbol$toStringTag = Symbol.toStringTag; class Int extends DataType { constructor(e, t) { super(), _defineProperty(this, "isSigned", void 0), _defineProperty(this, "bitWidth", void 0), this.isSigned = e, this.bitWidth = t } get typeId() { return Type.Int } get [_Symbol$toStringTag]() { return "Int" } toString() { return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth) } } class Int8 extends Int { constructor() { super(!0, 8) } } class Int16 extends Int { constructor() { super(!0, 16) } } class Int32 extends Int { constructor() { super(!0, 32) } } class Uint8 extends Int { constructor() { super(!1, 8) } } class Uint16 extends Int { constructor() { super(!1, 16) } } class Uint32 extends Int { constructor() { super(!1, 32) } } const Precision = { HALF: 16, SINGLE: 32, DOUBLE: 64 }; _Symbol$toStringTag2 = Symbol.toStringTag; class Float extends DataType { constructor(e) { super(), _defineProperty(this, "precision", void 0), this.precision = e } get typeId() { return Type.Float } get [_Symbol$toStringTag2]() { return "Float" } toString() { return "Float".concat(this.precision) } } class Float32 extends Float { constructor() { super(Precision.SINGLE) } } class Float64 extends Float { constructor() { super(Precision.DOUBLE) } } _Symbol$toStringTag7 = Symbol.toStringTag; class FixedSizeList extends DataType { constructor(e, t) { super(), _defineProperty(this, "listSize", void 0), _defineProperty(this, "children", void 0), this.listSize = e, this.children = [t] } get typeId() { return Type.FixedSizeList } get valueType() { return this.children[0].type } get valueField() { return this.children[0] } get [_Symbol$toStringTag7]() { return "FixedSizeList" } toString() { return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">") } } function getArrowTypeFromTypedArray(e) { switch (e.constructor) { case Int8Array: return new Int8; case Uint8Array: return new Uint8; case Int16Array: return new Int16; case Uint16Array: return new Uint16; case Int32Array: return new Int32; case Uint32Array: return new Uint32; case Float32Array: return new Float32; case Float64Array: return new Float64; default: throw new Error("array type not supported") } } function deduceMeshField(e, t, i) { var s = getArrowTypeFromTypedArray(t.value); i = i || makeMeshAttributeMetadata(t); return new Field(e, new FixedSizeList(t.size, new Field("value", s)), !1, i) } function makeMeshAttributeMetadata(e) { var t = new Map; return "byteOffset" in e && t.set("byteOffset", e.byteOffset.toString(10)), "byteStride" in e && t.set("byteStride", e.byteStride.toString(10)), "normalized" in e && t.set("normalized", e.normalized.toString()), t } function getDracoSchema(e, t, i) { var s = makeMetadata(t.metadata), r = [], a = transformAttributesLoaderData(t.attributes); for (const t in e) { var o = getArrowFieldFromAttribute(t, o = e[t], a[t]); r.push(o) } return i && (t = getArrowFieldFromAttribute("indices", i), r.push(t)), new Schema(r, s) } function transformAttributesLoaderData(e) { var t = {}; for (const s in e) { var i = e[s]; t[i.name || "undefined"] = i } return t } function getArrowFieldFromAttribute(e, t, i) { return deduceMeshField(e, t, i ? makeMetadata(i.metadata) : void 0) } function makeMetadata(e) { var t = new Map; for (const i in e) t.set("".concat(i, ".string"), JSON.stringify(e[i])); return t } const DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = { POSITION: "POSITION", NORMAL: "NORMAL", COLOR: "COLOR_0", TEX_COORD: "TEXCOORD_0" }, DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = { 1: Int8Array, 2: Uint8Array, 3: Int16Array, 4: Uint16Array, 5: Int32Array, 6: Uint32Array, 9: Float32Array }, INDEX_ITEM_SIZE = 4; class DracoParser { constructor(e) { _defineProperty(this, "draco", void 0), _defineProperty(this, "decoder", void 0), _defineProperty(this, "metadataQuerier", void 0), this.draco = e, this.decoder = new this.draco.Decoder, this.metadataQuerier = new this.draco.MetadataQuerier } destroy() { this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier) } parseSync(e, t = {}) { var i, s, r, a, o, n = new this.draco.DecoderBuffer, h = (n.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t), new ((e = this.decoder.GetEncodedGeometryType(n)) === this.draco.TRIANGULAR_MESH ? this.draco.Mesh : this.draco.PointCloud)); try { let l; switch (e) { case this.draco.TRIANGULAR_MESH: l = this.decoder.DecodeBufferToMesh(n, h); break; case this.draco.POINT_CLOUD: l = this.decoder.DecodeBufferToPointCloud(n, h); break; default: throw new Error("DRACO: Unknown geometry type.") }if (l.ok() && h.ptr) return s = this._getDracoLoaderData(h, e, t), a = getMeshBoundingBox((r = this._getMeshData(h, s, t)).attributes), o = getDracoSchema(r.attributes, s, r.indices), { loader: "draco", loaderData: s, header: { vertexCount: h.num_points(), boundingBox: a }, ...r, schema: o }; throw i = "DRACO decompression failed: ".concat(l.error_msg()), new Error(i) } finally { this.draco.destroy(n), h && this.draco.destroy(h) } } _getDracoLoaderData(e, t, i) { var s = this._getTopLevelMetadata(e); i = this._getDracoAttributes(e, i); return { geometry_type: t, num_attributes: e.num_attributes(), num_points: e.num_points(), num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0, metadata: s, attributes: i } } _getDracoAttributes(e, t) { var i = {}; for (let a = 0; a < e.num_attributes(); a++) { var s = this.decoder.GetAttribute(e, a), r = this._getAttributeMetadata(e, a); i[s.unique_id()] = { unique_id: s.unique_id(), attribute_type: s.attribute_type(), data_type: s.data_type(), num_components: s.num_components(), byte_offset: s.byte_offset(), byte_stride: s.byte_stride(), normalized: s.normalized(), attribute_index: a, metadata: r }, (r = this._getQuantizationTransform(s, t)) && (i[s.unique_id()].quantization_transform = r), (r = this._getOctahedronTransform(s, t)) && (i[s.unique_id()].octahedron_transform = r) } return i } _getMeshData(e, t, i) { if ((t = this._getMeshAttributes(t, e, i)).POSITION) return e instanceof this.draco.Mesh ? "triangle-strip" !== i.topology ? { topology: "triangle-list", mode: 5, attributes: t, indices: { value: this._getTriangleListIndices(e), size: 1 } } : { topology: "triangle-strip", mode: 4, attributes: t, indices: { value: this._getTriangleStripIndices(e), size: 1 } } : { topology: "point-list", mode: 0, attributes: t }; throw new Error("DRACO: No position attribute found.") } _getMeshAttributes(e, t, i) { var s = {}; for (const n of Object.values(e.attributes)) { var r = this._deduceAttributeName(n, i), { value: a, size: o } = (n.name = r, this._getAttributeValues(t, n)); s[r] = { value: a, size: o, byteOffset: n.byte_offset, byteStride: n.byte_stride, normalized: n.normalized } } return s } _getTriangleListIndices(e) { var t = 3 * e.num_faces(), i = 4 * t, s = this.draco._malloc(i); try { return this.decoder.GetTrianglesUInt32Array(e, i, s), new Uint32Array(this.draco.HEAPF32.buffer, s, t).slice() } finally { this.draco._free(s) } } _getTriangleStripIndices(e) { var t = new this.draco.DracoInt32Array; try { return this.decoder.GetTriangleStripsFromMesh(e, t), getUint32Array(t) } finally { this.draco.destroy(t) } } _getAttributeValues(e, t) { var i = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[t.data_type], s = t.num_components, r = e.num_points() * s, a = r * i.BYTES_PER_ELEMENT, o = getDracoDataType(this.draco, i); let n; var h = this.draco._malloc(a); try { var l = this.decoder.GetAttribute(e, t.attribute_index); this.decoder.GetAttributeDataArrayForAllPoints(e, l, o, a, h), n = new i(this.draco.HEAPF32.buffer, h, r).slice() } finally { this.draco._free(h) } return { value: n, size: s } } _deduceAttributeName(e, t) { var i, s, r = e.unique_id; for ([i, s] of Object.entries(t.extraAttributes || {})) if (s === r) return i; var a = e.attribute_type; for (const e in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) if (this.draco[e] === a) return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[e]; return t = t.attributeNameEntry || "name", e.metadata[t] ? e.metadata[t].string : "CUSTOM_ATTRIBUTE_".concat(r) } _getTopLevelMetadata(e) { return e = this.decoder.GetMetadata(e), this._getDracoMetadata(e) } _getAttributeMetadata(e, t) { return e = this.decoder.GetAttributeMetadata(e, t), this._getDracoMetadata(e) } _getDracoMetadata(e) { if (!e || !e.ptr) return {}; var t = {}, i = this.metadataQuerier.NumEntries(e); for (let r = 0; r < i; r++) { var s = this.metadataQuerier.GetEntryName(e, r); t[s] = this._getDracoMetadataField(e, s) } return t } _getDracoMetadataField(e, t) { var i = new this.draco.DracoInt32Array; try { this.metadataQuerier.GetIntEntryArray(e, t, i); var s = getInt32Array(i); return { int: this.metadataQuerier.GetIntEntry(e, t), string: this.metadataQuerier.GetStringEntry(e, t), double: this.metadataQuerier.GetDoubleEntry(e, t), intArray: s } } finally { this.draco.destroy(i) } } _disableAttributeTransforms(e) { var { quantizedAttributes: e = [], octahedronAttributes: t = [] } = e; for (const i of [...e, ...t]) this.decoder.SkipAttributeTransform(this.draco[i]) } _getQuantizationTransform(e, t) { var { quantizedAttributes: t = [] } = t, i = e.attribute_type(); if (t.map((e => this.decoder[e])).includes(i)) { const t = new this.draco.AttributeQuantizationTransform; try { if (t.InitFromAttribute(e)) return { quantization_bits: t.quantization_bits(), range: t.range(), min_values: new Float32Array([1, 2, 3]).map((e => t.min_value(e))) } } finally { this.draco.destroy(t) } } return null } _getOctahedronTransform(e, t) { var { octahedronAttributes: t = [] } = t, i = e.attribute_type(); if (t.map((e => this.decoder[e])).includes(i)) { t = new this.draco.AttributeQuantizationTransform; try { if (t.InitFromAttribute(e)) return { quantization_bits: t.quantization_bits() } } finally { this.draco.destroy(t) } } return null } } function getDracoDataType(e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32; default: return e.DT_INVALID } } function getInt32Array(e) { var t = e.size(), i = new Int32Array(t); for (let s = 0; s < t; s++)i[s] = e.GetValue(s); return i } function getUint32Array(e) { var t = e.size(), i = new Int32Array(t); for (let s = 0; s < t; s++)i[s] = e.GetValue(s); return i } const DRACO_VERSION = "1.4.1", DRACO_JS_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat("1.4.1", "/draco_decoder.js"), DRACO_WASM_WRAPPER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat("1.4.1", "/draco_wasm_wrapper.js"), DRACO_WASM_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat("1.4.1", "/draco_decoder.wasm"); let loadDecoderPromise; async function loadDracoDecoderModule(e) { var t = e.modules || {}; return loadDecoderPromise = t.draco3d ? loadDecoderPromise || t.draco3d.createDecoderModule({}).then((e => ({ draco: e }))) : loadDecoderPromise || loadDracoDecoder(e) } async function loadDracoDecoder(e) { let t, i; return "js" === (e.draco && e.draco.decoderType) ? t = await loadLibrary(DRACO_JS_DECODER_URL, "draco", e) : [t, i] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, "draco", e), await loadLibrary(DRACO_WASM_DECODER_URL, "draco", e)]), initializeDracoDecoder(t = t || globalThis.DracoDecoderModule, i) } function initializeDracoDecoder(e, t) { const i = {}; return t && (i.wasmBinary = t), new Promise((t => { e({ ...i, onModuleLoaded: e => t({ draco: e }) }) })) } const DracoLoader = { ...DracoLoader$1, parse: parse$2 }; async function parse$2(e, t) { var i = (await loadDracoDecoderModule(t)).draco; i = new DracoParser(i); try { return i.parseSync(e, null == t ? void 0 : t.draco) } finally { i.destroy() } } function getGLTFAccessors(e) { var t = {}; for (const s in e) { var i = e[s]; "indices" !== s && (i = getGLTFAccessor(i), t[s] = i) } return t } function getGLTFAccessor(e) { var { buffer: e, size: t, count: i } = getAccessorData(e); return { value: e, size: t, byteOffset: 0, count: i, type: getAccessorTypeFromSize(t), componentType: getComponentTypeFromArray(e) } } function getAccessorData(e) { let t = e, i = 1, s = 0; return e && e.value && (t = e.value, i = e.size || 1), t && (ArrayBuffer.isView(t) || (t = toTypedArray(t, Float32Array)), s = t.length / i), { buffer: t, size: i, count: s } } function toTypedArray(e, t, i = !1) { return e ? Array.isArray(e) || i && !(e instanceof t) ? new t(e) : e : null } const KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression", name$3 = KHR_DRACO_MESH_COMPRESSION; function preprocess$1(e, t, i) { var s = new GLTFScenegraph(e); for (const e of makeMeshPrimitiveIterator(s)) s.getObjectExtension(e, KHR_DRACO_MESH_COMPRESSION) } async function decode$3(e, t, i) { var s; if (null != t && null != (s = t.gltf) && s.decompressMeshes) { var r = new GLTFScenegraph(e), a = []; for (const e of makeMeshPrimitiveIterator(r)) r.getObjectExtension(e, KHR_DRACO_MESH_COMPRESSION) && a.push(decompressPrimitive(r, e, t, i)); await Promise.all(a), r.removeExtension(KHR_DRACO_MESH_COMPRESSION) } } function encode$3(e, t = 0) { var i = new GLTFScenegraph(e); for (const e of i.json.meshes || []) compressMesh(e), i.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION) } async function decompressPrimitive(e, t, i, s) { if (n = e.getObjectExtension(t, KHR_DRACO_MESH_COMPRESSION)) { var r, a, o, n = sliceArrayBuffer((n = e.getTypedArrayForBufferView(n.bufferView)).buffer, n.byteOffset), h = s.parse; for ([r, a] of (delete (i = { ...i })["3d-tiles"], n = getGLTFAccessors((h = await h(n, DracoLoader, i, s)).attributes), Object.entries(n))) r in t.attributes && (o = t.attributes[r], null != (o = e.getAccessor(o))) && o.min && null != o && o.max && (a.min = o.min, a.max = o.max); t.attributes = n, h.indices && (t.indices = getGLTFAccessor(h.indices)), checkPrimitive(t) } } function compressMesh(e, t, i = 4, s, r) { var a, o; if (s.DracoWriter) return a = s.DracoWriter.encodeSync({ attributes: e }), o = null == r || null == (o = r.parseSync) ? void 0 : o.call(r, { attributes: e }), r = s._addFauxAttributes(o.attributes), e = s.addBufferView(a), { primitives: [{ attributes: r, mode: i, extensions: { [KHR_DRACO_MESH_COMPRESSION]: { bufferView: e, attributes: r } } }] }; throw new Error("options.gltf.DracoWriter not provided") } function checkPrimitive(e) { if (!e.attributes && 0 < Object.keys(e.attributes).length) throw new Error("glTF: Empty primitive detected: Draco decompression failure?") } function* makeMeshPrimitiveIterator(e) { for (const t of e.json.meshes || []) for (const e of t.primitives) yield e } var KHR_draco_mesh_compression = Object.freeze({ __proto__: null, name: name$3, preprocess: preprocess$1, decode: decode$3, encode: encode$3 }); const KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual", name$2 = KHR_LIGHTS_PUNCTUAL; async function decode$2(e) { var t = new GLTFScenegraph(e), i = (e = t.json, t.getExtension(KHR_LIGHTS_PUNCTUAL)); i && (t.json.lights = i.lights, t.removeExtension(KHR_LIGHTS_PUNCTUAL)); for (const i of e.nodes || []) { var s = t.getObjectExtension(i, KHR_LIGHTS_PUNCTUAL); s && (i.light = s.light), t.removeObjectExtension(i, KHR_LIGHTS_PUNCTUAL) } } async function encode$2(e) { var t, i = new GLTFScenegraph(e); if ((e = i.json).lights && (assert$1(!(t = i.addExtension(KHR_LIGHTS_PUNCTUAL)).lights), t.lights = e.lights, delete e.lights), i.json.lights) { for (const e of i.json.lights) { var s = e.node; i.addObjectExtension(s, KHR_LIGHTS_PUNCTUAL, e) } delete i.json.lights } } var KHR_lights_punctual = Object.freeze({ __proto__: null, name: name$2, decode: decode$2, encode: encode$2 }); const KHR_MATERIALS_UNLIT = "KHR_materials_unlit", name$1 = KHR_MATERIALS_UNLIT; async function decode$1(e) { var t = new GLTFScenegraph(e); e = t.json; t.removeExtension(KHR_MATERIALS_UNLIT); for (const i of e.materials || []) i.extensions && i.extensions.KHR_materials_unlit && (i.unlit = !0), t.removeObjectExtension(i, KHR_MATERIALS_UNLIT) } function encode$1(e) { var t = new GLTFScenegraph(e); e = t.json; if (t.materials) for (const i of e.materials || []) i.unlit && (delete i.unlit, t.addObjectExtension(i, KHR_MATERIALS_UNLIT, {}), t.addExtension(KHR_MATERIALS_UNLIT)) } var KHR_materials_unlit = Object.freeze({ __proto__: null, name: name$1, decode: decode$1, encode: encode$1 }); const KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl", name = KHR_TECHNIQUES_WEBGL; async function decode(e) { var t = new GLTFScenegraph(e), i = (e = t.json, t.getExtension(KHR_TECHNIQUES_WEBGL)); if (i) { var s = resolveTechniques(i, t); for (const i of e.materials || []) { var r = t.getObjectExtension(i, KHR_TECHNIQUES_WEBGL); r && (i.technique = Object.assign({}, r, s[r.technique]), i.technique.values = resolveValues(i.technique, t)), t.removeObjectExtension(i, KHR_TECHNIQUES_WEBGL) } t.removeExtension(KHR_TECHNIQUES_WEBGL) } } async function encode(e, t) { } function resolveTechniques(e, t) { const { programs: i = [], shaders: s = [], techniques: r = [] } = e, a = new TextDecoder; return s.forEach((e => { if (!Number.isFinite(e.bufferView)) throw new Error("KHR_techniques_webgl: no shader code"); e.code = a.decode(t.getTypedArrayForBufferView(e.bufferView)) })), i.forEach((e => { e.fragmentShader = s[e.fragmentShader], e.vertexShader = s[e.vertexShader] })), r.forEach((e => { e.program = i[e.program] })), r } function resolveValues(e, t) { const i = Object.assign({}, e.values); return Object.keys(e.uniforms || {}).forEach((t => { !e.uniforms[t].value || t in i || (i[t] = e.uniforms[t].value) })), Object.keys(i).forEach((e => { "object" == typeof i[e] && void 0 !== i[e].index && (i[e].texture = t.getTexture(i[e].index)) })), i } var KHR_techniques_webgl = Object.freeze({ __proto__: null, name: name, decode: decode, encode: encode }); const EXTENSIONS = [EXT_meshopt_compression, EXT_texture_webp, KHR_texture_basisu, KHR_draco_mesh_compression, KHR_lights_punctual, KHR_materials_unlit, KHR_techniques_webgl]; function preprocessExtensions(e, t = {}, i) { var s; for (const r of EXTENSIONS.filter((e => useExtension(e.name, t)))) null != (s = r.preprocess) && s.call(r, e, t, i) } async function decodeExtensions(e, t = {}, i) { var s; for (const r of EXTENSIONS.filter((e => useExtension(e.name, t)))) await (null == (s = r.decode) ? void 0 : s.call(r, e, t, i)) } function useExtension(e, t) { return !(e in (t = (null == t || null == (t = t.gltf) ? void 0 : t.excludeExtensions) || {}) && !t[e]) } const KHR_BINARY_GLTF = "KHR_binary_glTF"; function preprocess(e) { var t = new GLTFScenegraph(e); for (const s of (e = t.json).images || []) { var i = t.getObjectExtension(s, KHR_BINARY_GLTF); i && Object.assign(s, i), t.removeObjectExtension(s, KHR_BINARY_GLTF) } e.buffers && e.buffers[0] && delete e.buffers[0].uri, t.removeExtension(KHR_BINARY_GLTF) } const GLTF_ARRAYS = { accessors: "accessor", animations: "animation", buffers: "buffer", bufferViews: "bufferView", images: "image", materials: "material", meshes: "mesh", nodes: "node", samplers: "sampler", scenes: "scene", skins: "skin", textures: "texture" }, GLTF_KEYS = { accessor: "accessors", animations: "animation", buffer: "buffers", bufferView: "bufferViews", image: "images", material: "materials", mesh: "meshes", node: "nodes", sampler: "samplers", scene: "scenes", skin: "skins", texture: "textures" }; class GLTFV1Normalizer { constructor() { _defineProperty(this, "idToIndexMap", { animations: {}, accessors: {}, buffers: {}, bufferViews: {}, images: {}, materials: {}, meshes: {}, nodes: {}, samplers: {}, scenes: {}, skins: {}, textures: {} }), _defineProperty(this, "json", void 0) } normalize(e, t) { this.json = e.json; var i = e.json; switch (i.asset && i.asset.version) { case "2.0": return; case void 0: case "1.0": break; default: return void console.warn("glTF: Unknown version ".concat(i.asset.version)) }if (!t.normalize) throw new Error("glTF v1 is not supported."); console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(i), this._convertTopLevelObjectsToArrays(i), preprocess(e), this._convertObjectIdsToArrayIndices(i), this._updateObjects(i), this._updateMaterial(i) } _addAsset(e) { e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl" } _convertTopLevelObjectsToArrays(e) { for (const t in GLTF_ARRAYS) this._convertTopLevelObjectToArray(e, t) } _convertTopLevelObjectToArray(e, t) { var i = e[t]; if (i && !Array.isArray(i)) { e[t] = []; for (const a in i) { var s = i[a], r = (s.id = s.id || a, e[t].length); e[t].push(s), this.idToIndexMap[t][a] = r } } } _convertObjectIdsToArrayIndices(e) { for (const t in GLTF_ARRAYS) this._convertIdsToIndices(e, t); "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene")); for (const t of e.textures) this._convertTextureIds(t); for (const t of e.meshes) this._convertMeshIds(t); for (const t of e.nodes) this._convertNodeIds(t); for (const t of e.scenes) this._convertSceneIds(t) } _convertTextureIds(e) { e.source && (e.source = this._convertIdToIndex(e.source, "image")) } _convertMeshIds(e) { for (const r of e.primitives) { var { attributes: t, indices: i, material: s } = r; for (const e in t) t[e] = this._convertIdToIndex(t[e], "accessor"); i && (r.indices = this._convertIdToIndex(i, "accessor")), s && (r.material = this._convertIdToIndex(s, "material")) } } _convertNodeIds(e) { e.children && (e.children = e.children.map((e => this._convertIdToIndex(e, "node")))), e.meshes && (e.meshes = e.meshes.map((e => this._convertIdToIndex(e, "mesh")))) } _convertSceneIds(e) { e.nodes && (e.nodes = e.nodes.map((e => this._convertIdToIndex(e, "node")))) } _convertIdsToIndices(e, t) { e[t] || (console.warn("gltf v1: json doesn't contain attribute ".concat(t)), e[t] = []); for (const s of e[t]) for (const e in s) { var i = s[e]; i = this._convertIdToIndex(i, e); s[e] = i } } _convertIdToIndex(e, t) { var i = GLTF_KEYS[t]; if (i in this.idToIndexMap) { if (i = this.idToIndexMap[i][e], Number.isFinite(i)) return i; throw new Error("gltf v1: failed to resolve ".concat(t, " with id ").concat(e)) } return e } _updateObjects(e) { for (const e of this.json.buffers) delete e.type } _updateMaterial(e) { for (const i of e.materials) { i.pbrMetallicRoughness = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 }; const s = (null == (t = i.values) ? void 0 : t.tex) || (null == (t = i.values) ? void 0 : t.texture2d_0); var t = e.textures.findIndex((e => e.id === s)); -1 !== t && (i.pbrMetallicRoughness.baseColorTexture = { index: t }) } } } function normalizeGLTFV1(e, t = {}) { return (new GLTFV1Normalizer).normalize(e, t) } const COMPONENTS = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, BYTES = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 }, GL_SAMPLER = { TEXTURE_MAG_FILTER: 10240, TEXTURE_MIN_FILTER: 10241, TEXTURE_WRAP_S: 10242, TEXTURE_WRAP_T: 10243, REPEAT: 10497, LINEAR: 9729, NEAREST_MIPMAP_LINEAR: 9986 }, SAMPLER_PARAMETER_GLTF_TO_GL = { magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER, minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER, wrapS: GL_SAMPLER.TEXTURE_WRAP_S, wrapT: GL_SAMPLER.TEXTURE_WRAP_T }, DEFAULT_SAMPLER = { [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR, [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR, [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT, [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT }; function getBytesFromComponentType(e) { return BYTES[e] } function getSizeFromAccessorType(e) { return COMPONENTS[e] } class GLTFPostProcessor { constructor() { _defineProperty(this, "baseUri", ""), _defineProperty(this, "json", {}), _defineProperty(this, "buffers", []), _defineProperty(this, "images", []) } postProcess(e, t = {}) { var { json: e, buffers: i = [], images: s = [], baseUri: r = "" } = e; return assert$1(e), this.baseUri = r, this.json = e, this.buffers = i, this.images = s, this._resolveTree(this.json, t), this.json } _resolveTree(e, t = 0) { e.bufferViews && (e.bufferViews = e.bufferViews.map(((e, t) => this._resolveBufferView(e, t)))), e.images && (e.images = e.images.map(((e, t) => this._resolveImage(e, t)))), e.samplers && (e.samplers = e.samplers.map(((e, t) => this._resolveSampler(e, t)))), e.textures && (e.textures = e.textures.map(((e, t) => this._resolveTexture(e, t)))), e.accessors && (e.accessors = e.accessors.map(((e, t) => this._resolveAccessor(e, t)))), e.materials && (e.materials = e.materials.map(((e, t) => this._resolveMaterial(e, t)))), e.meshes && (e.meshes = e.meshes.map(((e, t) => this._resolveMesh(e, t)))), e.nodes && (e.nodes = e.nodes.map(((e, t) => this._resolveNode(e, t)))), e.skins && (e.skins = e.skins.map(((e, t) => this._resolveSkin(e, t)))), e.scenes && (e.scenes = e.scenes.map(((e, t) => this._resolveScene(e, t)))), void 0 !== e.scene && (e.scene = e.scenes[this.json.scene]) } getScene(e) { return this._get("scenes", e) } getNode(e) { return this._get("nodes", e) } getSkin(e) { return this._get("skins", e) } getMesh(e) { return this._get("meshes", e) } getMaterial(e) { return this._get("materials", e) } getAccessor(e) { return this._get("accessors", e) } getCamera(e) { return null } getTexture(e) { return this._get("textures", e) } getSampler(e) { return this._get("samplers", e) } getImage(e) { return this._get("images", e) } getBufferView(e) { return this._get("bufferViews", e) } getBuffer(e) { return this._get("buffers", e) } _get(e, t) { var i; return "object" == typeof t ? t : ((i = this.json[e] && this.json[e][t]) || console.warn("glTF file error: Could not find ".concat(e, "[").concat(t, "]")), i) } _resolveScene(e, t) { return e.id = e.id || "scene-".concat(t), e.nodes = (e.nodes || []).map((e => this.getNode(e))), e } _resolveNode(e, t) { return e.id = e.id || "node-".concat(t), e.children && (e.children = e.children.map((e => this.getNode(e)))), void 0 !== e.mesh ? e.mesh = this.getMesh(e.mesh) : void 0 !== e.meshes && e.meshes.length && (e.mesh = e.meshes.reduce(((e, t) => (t = this.getMesh(t), e.id = t.id, e.primitives = e.primitives.concat(t.primitives), e)), { primitives: [] })), void 0 !== e.camera && (e.camera = this.getCamera(e.camera)), void 0 !== e.skin && (e.skin = this.getSkin(e.skin)), e } _resolveSkin(e, t) { return e.id = e.id || "skin-".concat(t), e.inverseBindMatrices = this.getAccessor(e.inverseBindMatrices), e } _resolveMesh(e, t) { return e.id = e.id || "mesh-".concat(t), e.primitives && (e.primitives = e.primitives.map((e => { var t = (e = { ...e }).attributes; e.attributes = {}; for (const i in t) e.attributes[i] = this.getAccessor(t[i]); return void 0 !== e.indices && (e.indices = this.getAccessor(e.indices)), void 0 !== e.material && (e.material = this.getMaterial(e.material)), e }))), e } _resolveMaterial(e, t) { return e.id = e.id || "material-".concat(t), e.normalTexture && (e.normalTexture = { ...e.normalTexture }, e.normalTexture.texture = this.getTexture(e.normalTexture.index)), e.occlusionTexture && (e.occlustionTexture = { ...e.occlustionTexture }, e.occlusionTexture.texture = this.getTexture(e.occlusionTexture.index)), e.emissiveTexture && (e.emmisiveTexture = { ...e.emmisiveTexture }, e.emissiveTexture.texture = this.getTexture(e.emissiveTexture.index)), e.emissiveFactor || (e.emissiveFactor = e.emmisiveTexture ? [1, 1, 1] : [0, 0, 0]), e.pbrMetallicRoughness && (e.pbrMetallicRoughness = { ...e.pbrMetallicRoughness }, (t = e.pbrMetallicRoughness).baseColorTexture && (t.baseColorTexture = { ...t.baseColorTexture }, t.baseColorTexture.texture = this.getTexture(t.baseColorTexture.index)), t.metallicRoughnessTexture) && (t.metallicRoughnessTexture = { ...t.metallicRoughnessTexture }, t.metallicRoughnessTexture.texture = this.getTexture(t.metallicRoughnessTexture.index)), e } _resolveAccessor(e, t) { if (e.id = e.id || "accessor-".concat(t), void 0 !== e.bufferView && (e.bufferView = this.getBufferView(e.bufferView)), e.bytesPerComponent = getBytesFromComponentType(e.componentType), e.components = getSizeFromAccessorType(e.type), e.bytesPerElement = e.bytesPerComponent * e.components, e.bufferView) { t = e.bufferView.buffer; var { ArrayType: i, byteLength: s } = getAccessorArrayTypeAndLength(e, e.bufferView), r = (e.bufferView.byteOffset || 0) + (e.byteOffset || 0) + t.byteOffset; let a = t.arrayBuffer.slice(r, r + s); e.bufferView.byteStride && (a = this._getValueFromInterleavedBuffer(t, r, e.bufferView.byteStride, e.bytesPerElement, e.count)), e.value = new i(a) } return e } _getValueFromInterleavedBuffer(e, t, i, s, r) { var a = new Uint8Array(r * s); for (let n = 0; n < r; n++) { var o = t + n * i; a.set(new Uint8Array(e.arrayBuffer.slice(o, o + s)), n * s) } return a.buffer } _resolveTexture(e, t) { return e.id = e.id || "texture-".concat(t), e.sampler = "sampler" in e ? this.getSampler(e.sampler) : DEFAULT_SAMPLER, e.source = this.getImage(e.source), e } _resolveSampler(e, t) { e.id = e.id || "sampler-".concat(t), e.parameters = {}; for (const t in e) { var i = this._enumSamplerParameter(t); void 0 !== i && (e.parameters[i] = e[t]) } return e } _enumSamplerParameter(e) { return SAMPLER_PARAMETER_GLTF_TO_GL[e] } _resolveImage(e, t) { return e.id = e.id || "image-".concat(t), void 0 !== e.bufferView && (e.bufferView = this.getBufferView(e.bufferView)), (t = this.images[t]) && (e.image = t), e } _resolveBufferView(e, t) { var i = e.buffer, s = (t = { id: "bufferView-".concat(t), ...e, buffer: this.buffers[i] }, this.buffers[i].arrayBuffer); let r = this.buffers[i].byteOffset || 0; return "byteOffset" in e && (r += e.byteOffset), t.data = new Uint8Array(s, r, e.byteLength), t } _resolveCamera(e, t) { return e.id = e.id || "camera-".concat(t), e.perspective, e.orthographic, e } } function postProcessGLTF(e, t) { return (new GLTFPostProcessor).postProcess(e, t) } const MAGIC_glTF = 1735152710, GLB_FILE_HEADER_SIZE = 12, GLB_CHUNK_HEADER_SIZE = 8, GLB_CHUNK_TYPE_JSON = 1313821514, GLB_CHUNK_TYPE_BIN = 5130562, GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0, GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1, GLB_V1_CONTENT_FORMAT_JSON = 0, LE = !0; function getMagicString(e, t = 0) { return "".concat(String.fromCharCode(e.getUint8(t + 0))).concat(String.fromCharCode(e.getUint8(t + 1))).concat(String.fromCharCode(e.getUint8(t + 2))).concat(String.fromCharCode(e.getUint8(t + 3))) } function isGLB(e, t = 0, i = {}) { e = new DataView(e); var { magic: i = MAGIC_glTF } = i; return (e = e.getUint32(t, !1)) === i || e === MAGIC_glTF } function parseGLBSync(e, t, i = 0, s) { var r = new DataView(t), a = (t = getMagicString(r, i + 0), r.getUint32(i + 4, LE)), o = r.getUint32(i + 8, LE); switch (Object.assign(e, { header: { byteOffset: i, byteLength: o, hasBinChunk: !1 }, type: t, version: a, json: {}, binChunks: [] }), i += GLB_FILE_HEADER_SIZE, e.version) { case 1: return parseGLBV1(e, r, i); case 2: return parseGLBV2(e, r, i, {}); default: throw new Error("Invalid GLB version ".concat(e.version, ". Only supports v1 and v2.")) } } function parseGLBV1(e, t, i) { assert$5(e.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE); var s = t.getUint32(i + 0, LE), r = t.getUint32(i + 4, LE); return i += GLB_CHUNK_HEADER_SIZE, assert$5(r === GLB_V1_CONTENT_FORMAT_JSON), parseJSONChunk(e, t, i, s), (i += s) + parseBINChunk(e, t, i, e.header.byteLength) } function parseGLBV2(e, t, i, s) { return assert$5(e.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE), parseGLBChunksSync(e, t, i, s), i + e.header.byteLength } function parseGLBChunksSync(e, t, i, s) { for (; i + 8 <= e.header.byteLength;) { var r = t.getUint32(i + 0, LE), a = t.getUint32(i + 4, LE); switch (i += GLB_CHUNK_HEADER_SIZE, a) { case GLB_CHUNK_TYPE_JSON: parseJSONChunk(e, t, i, r); break; case GLB_CHUNK_TYPE_BIN: parseBINChunk(e, t, i, r); break; case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED: s.strict || parseJSONChunk(e, t, i, r); break; case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED: s.strict || parseBINChunk(e, t, i, r) }i += padToNBytes(r, 4) } return i } function parseJSONChunk(e, t, i, s) { return t = new Uint8Array(t.buffer, i, s), i = new TextDecoder("utf8").decode(t), e.json = JSON.parse(i), padToNBytes(s, 4) } function parseBINChunk(e, t, i, s) { return e.header.hasBinChunk = !0, e.binChunks.push({ byteOffset: i, byteLength: s, arrayBuffer: t.buffer }), padToNBytes(s, 4) } async function parseGLTF$1(e, t, i = 0, s, r) { if (parseGLTFContainerSync(e, t, i, s), normalizeGLTFV1(e, { normalize: null == s || null == (t = s.gltf) ? void 0 : t.normalize }), preprocessExtensions(e, s, r), i = [], null != s && null != (t = s.gltf) && t.loadBuffers && e.json.buffers && await loadBuffers(e, s, r), null != s && null != (t = s.gltf) && t.loadImages) { const t = loadImages(e, s, r); i.push(t) } const a = decodeExtensions(e, s, r); return i.push(a), await Promise.all(i), null != s && null != (t = s.gltf) && t.postProcess ? postProcessGLTF(e, s) : e } function parseGLTFContainerSync(e, t, i, s) { s.uri && (e.baseUri = s.uri), "string" == typeof (t = t instanceof ArrayBuffer && !isGLB(t, i, s) ? (new TextDecoder).decode(t) : t) ? e.json = parseJSON(t) : t instanceof ArrayBuffer ? (i = parseGLBSync(r = {}, t, i, s.glb), assert$1("glTF" === r.type, "Invalid GLB magic string ".concat(r.type)), e._glb = r, e.json = r.json) : assert$1(!1, "GLTF: must be ArrayBuffer or string"); var r; t = e.json.buffers || [], e.buffers = new Array(t.length).fill(null), e._glb && e._glb.header.hasBinChunk && (s = e._glb.binChunks, e.buffers[0] = { arrayBuffer: s[0].arrayBuffer, byteOffset: s[0].byteOffset, byteLength: s[0].byteLength }), i = e.json.images || []; e.images = new Array(i.length).fill({}) } async function loadBuffers(e, t, i) { var s = e.json.buffers || []; for (let n = 0; n < s.length; ++n) { var r, a, o = s[n]; o.uri ? (assert$1(a = i.fetch), a = resolveUrl(o.uri, t), a = await (null == (r = await (null == i || null == (r = i.fetch) ? void 0 : r.call(i, a))) || null == (a = r.arrayBuffer) ? void 0 : a.call(r)), e.buffers[n] = { arrayBuffer: a, byteOffset: 0, byteLength: a.byteLength }, delete o.uri) : null === e.buffers[n] && (e.buffers[n] = { arrayBuffer: new ArrayBuffer(o.byteLength), byteOffset: 0, byteLength: o.byteLength }) } } async function loadImages(e, t, i) { var s = getReferencesImageIndices(e), r = e.json.images || [], a = []; for (const o of s) a.push(loadImage(e, r[o], o, t, i)); return Promise.all(a) } function getReferencesImageIndices(e) { var t = new Set; for (const i of e.json.textures || []) void 0 !== i.source && t.add(i.source); return Array.from(t).sort() } async function loadImage(e, t, i, s, r) { var { fetch: a, parse: o } = r; let n, h = (t.uri && (a = await a(resolveUrl(t.uri, s)), n = await a.arrayBuffer()), Number.isFinite(t.bufferView) && (n = sliceArrayBuffer((a = getTypedArrayForBufferView(e.json, e.buffers, t.bufferView)).buffer, a.byteOffset, a.byteLength)), assert$1(n, "glTF image has no data"), await o(n, [ImageLoader, BasisLoader], { mimeType: t.mimeType, basis: s.basis || { format: selectSupportedBasisFormat() } }, r)); h && h[0] && (h = { compressed: !0, mipmaps: !1, width: h[0].width, height: h[0].height, data: h[0] }), e.images = e.images || [], e.images[i] = h } const GLTFLoader = { name: "glTF", id: "gltf", module: "gltf", version: "3.2.6", extensions: ["gltf", "glb"], mimeTypes: ["model/gltf+json", "model/gltf-binary"], text: !0, binary: !0, tests: ["glTF"], parse: parse$1, options: { gltf: { normalize: !0, loadBuffers: !0, loadImages: !0, decompressMeshes: !0, postProcess: !0 }, log: console }, deprecatedOptions: { fetchImages: "gltf.loadImages", createImages: "gltf.loadImages", decompress: "gltf.decompressMeshes", postProcess: "gltf.postProcess", gltf: { decompress: "gltf.decompressMeshes" } } }; async function parse$1(e, t = {}, i) { (t = { ...GLTFLoader.options, ...t }).gltf = { ...GLTFLoader.options.gltf, ...t.gltf }; var { byteOffset: s = 0 } = t; return parseGLTF$1({}, e, s, t, i) } class GLTFVBOSceneModelLoader { constructor(e) { } load(e, t, i, s, r, a, o) { loadGLTF(e, t, i, s = s || {}, r, (function () { core.scheduleTask((function () { r.scene.fire("modelLoaded", r.id), r.fire("loaded", !0, !1) })), a && a() }), (function (t) { e.error(t), o && o(t), r.fire("error", t) })) } parse(e, t, i, s, r, a, o) { parseGLTF(e, "", t, i, s = s || {}, r, (function () { r.scene.fire("modelLoaded", r.id), r.fire("loaded", !0, !1), a && a() })) } } function getMetaModelCorrections(e) { var t = {}, i = {}, s = e.metaObjects || [], r = {}; for (let e = 0, t = s.length; e < t; e++) { var a = s[e]; r[a.id] = a } for (let e = 0, a = s.length; e < a; e++) { var o = s[e]; if (void 0 !== o.parent && null !== o.parent) { var n = r[o.parent]; if (o.type === n.type) { let e = n; for (; e.parent && r[e.parent].type === e.type;)e = r[e.parent]; (t[e.id] || (t[e.id] = { numChildren: 0, countChildren: 0 })).numChildren++, i[o.id] = e } } } return { metaObjectsMap: r, eachRootStats: t, eachChildRoot: i } } function loadGLTF(e, t, i, s, r, a, o) { const n = e.viewer.scene.canvas.spinner; n.processes++, "glb" === t.split(".").pop() ? e.dataSource.getGLB(t, (o => { s.basePath = getBasePath(t), parseGLTF(e, t, o, i, s, r, a), n.processes-- }), (e => { n.processes--, o(e) })) : e.dataSource.getGLTF(t, (o => { s.basePath = getBasePath(t), parseGLTF(e, t, o, i, s, r, a), n.processes-- }), (e => { n.processes--, o(e) })) } function getBasePath(e) { var t = e.lastIndexOf("/"); return 0 !== t ? e.substring(0, t + 1) : "" } function parseGLTF(e, t, i, s, r, a, o) { const n = e.viewer.scene.canvas.spinner; n.processes++, parse$3(i, GLTFLoader, { baseUri: r.basePath }).then((i => { loadTextures(i = { src: t, metaModelCorrections: s ? getMetaModelCorrections(s) : null, loadBuffer: r.loadBuffer, basePath: r.basePath, handlenode: r.handlenode, gltfData: i, scene: a.scene, plugin: e, sceneModel: a, numObjects: 0, nodes: [], nextId: 0, log: t => { e.log(t) } }), loadMaterials(i), loadDefaultScene(i), a.finalize(), n.processes--, o() })) } function loadTextures(e) { var t = e.gltfData.textures; if (t) for (let i = 0, s = t.length; i < s; i++)loadTexture(e, t[i]) } function loadTexture(e, t) { if (t.source && t.source.image) { var i = "texture-" + e.nextId++; let s = NearestMipMapLinearFilter; switch (t.sampler.minFilter) { case 9728: s = NearestFilter; break; case 9729: s = LinearFilter; break; case 9984: s = NearestMipMapNearestFilter; break; case 9985: s = LinearMipMapNearestFilter; break; case 9986: s = NearestMipMapLinearFilter; break; case 9987: s = LinearMipMapLinearFilter }let r = LinearFilter; switch (t.sampler.magFilter) { case 9728: r = NearestFilter; break; case 9729: r = LinearFilter }let a = RepeatWrapping; switch (t.sampler.wrapS) { case 33071: a = ClampToEdgeWrapping; break; case 33648: a = MirroredRepeatWrapping; break; case 10497: a = RepeatWrapping }let o = RepeatWrapping; switch (t.sampler.wrapT) { case 33071: o = ClampToEdgeWrapping; break; case 33648: o = MirroredRepeatWrapping; break; case 10497: o = RepeatWrapping }let n = RepeatWrapping; switch (t.sampler.wrapR) { case 33071: n = ClampToEdgeWrapping; break; case 33648: n = MirroredRepeatWrapping; break; case 10497: n = RepeatWrapping }e.sceneModel.createTexture({ id: i, image: t.source.image, flipY: !!t.flipY, minFilter: s, magFilter: r, wrapS: a, wrapT: o, wrapR: n, encoding: sRGBEncoding }), t._textureId = i } } function loadMaterials(e) { var t = e.gltfData.materials; if (t) for (let s = 0, r = t.length; s < r; s++) { var i = t[s]; i._textureSetId = loadTextureSet(e, i), i._attributes = loadMaterialAttributes(e, i) } } function loadTextureSet(e, t) { var i = {}, s = (t.normalTexture && (i.normalTextureId = t.normalTexture.texture._textureId), t.occlusionTexture && (i.occlusionTextureId = t.occlusionTexture.texture._textureId), t.emissiveTexture && (i.emissiveTextureId = t.emissiveTexture.texture._textureId), t.pbrMetallicRoughness), r = (t.pbrMetallicRoughness && ((r = (r = t.pbrMetallicRoughness).baseColorTexture || r.colorTexture) && (r.texture ? i.colorTextureId = r.texture._textureId : i.colorTextureId = e.gltfData.textures[r.index]._textureId), s.metallicRoughnessTexture) && (i.metallicRoughnessTextureId = s.metallicRoughnessTexture.texture._textureId), t.extensions); return r && (s = r.KHR_materials_pbrSpecularGlossiness) && (s.specularTexture, null != (t = s.specularColorTexture)) && (i.colorTextureId = e.gltfData.textures[t.index]._textureId), void 0 !== i.normalTextureId || void 0 !== i.occlusionTextureId || void 0 !== i.emissiveTextureId || void 0 !== i.colorTextureId || void 0 !== i.metallicRoughnessTextureId ? (i.id = `textureSet-${e.nextId++};`, e.sceneModel.createTextureSet(i), i.id) : null } function loadMaterialAttributes(e, t) { var i, s, r = t.extensions, a = { color: new Float32Array([1, 1, 1, 1]), opacity: 1, metallic: 0, roughness: 1 }; return r && ((i = r.KHR_materials_pbrSpecularGlossiness) && null != (i = i.diffuseFactor) && a.color.set(i), i = r.KHR_materials_common) && (r = i.technique, !(s = (i = i.values || {}).diffuse) || "BLINN" !== r && "PHONG" !== r && "LAMBERT" !== r || utils.isString(s) || a.color.set(s), null != (r = i.transparency) && (a.opacity = r), null != (s = i.transparent)) && (a.opacity = s), (r = t.pbrMetallicRoughness) && ((i = r.baseColorFactor) && (a.color[0] = i[0], a.color[1] = i[1], a.color[2] = i[2], a.opacity = i[3]), null != (s = r.metallicFactor) && (a.metallic = s), null != (t = r.roughnessFactor)) && (a.roughness = t), a } function loadDefaultScene(e) { var t = e.gltfData; (t = t.scene || t.scenes[0]) ? loadScene(e, t) : error(e, "glTF has no default scene") } function loadScene(e, t) { var i = t.nodes; if (i) { for (let t = 0, s = i.length; t < s; t++)countMeshUsage(e, i[t]); for (let t = 0, s = i.length; t < s; t++)loadNode(e, i[t], 0, null) } } function countMeshUsage(e, t) { var i = t.mesh; if (i && (i.instances = i.instances ? i.instances + 1 : 1), t.children) { var s = t.children; for (let t = 0, i = s.length; t < i; t++) { var r = s[t]; r ? countMeshUsage(e, r) : error(e, "Node not found: " + t) } } } const deferredMeshIds = []; function loadNode(e, t, i, s) { let r; e.gltfData, t.matrix && (r = t.matrix, s = s ? math.mulMat4(s, r, math.mat4()) : r), t.translation && (r = math.translationMat4v(t.translation), s = s ? math.mulMat4(s, r, math.mat4()) : r), t.rotation && (r = math.quaternionToMat4(t.rotation), s = s ? math.mulMat4(s, r, math.mat4()) : r), t.scale && (r = math.scalingMat4v(t.scale), s = s ? math.mulMat4(s, r, math.mat4()) : r); var a, o = e.sceneModel; if (t.mesh) { var n = t.mesh; if (e.handlenode) { var h = {}; if (!e.handlenode(e.sceneModel.id, t, h)) return } var l = s ? s.slice() : math.identityMat4(), c = n.primitives.length; if (0 < c) for (let t = 0; t < c; t++) { var u = n.primitives[t]; if (!(u.mode < 4)) { var p = { id: o.id + "." + e.numObjects++ }; switch (u.mode) { case 0: p.primitive = "points"; break; case 1: case 2: case 3: p.primitive = "lines"; break; default: p.primitive = "triangles" }var d = u.attributes.POSITION; d && (p.localPositions = d.value, p.positions = new Float64Array(p.localPositions.length), u.attributes.NORMAL && (p.normals = u.attributes.NORMAL.value), u.attributes.TEXCOORD_0 && (p.uv = u.attributes.TEXCOORD_0.value), u.indices && (p.indices = u.indices.value), math.transformPositions3(l, p.localPositions, p.positions), d = math.vec3(), worldToRTCPositions(p.positions, p.positions, d) && (p.origin = d), (d = u.material) ? (p.textureSetId = d._textureSetId, p.color = d._attributes.color, p.opacity = d._attributes.opacity, p.metallic = d._attributes.metallic, p.roughness = d._attributes.roughness) : (p.color = new Float32Array([1, 1, 1]), p.opacity = 1), o.createMesh(p), deferredMeshIds.push(p.id)) } } } if (t.children) { var m = t.children; for (let t = 0, r = m.length; t < r; t++)loadNode(e, m[t], i + 1, s) } (null != (h = t.name) || 0 === i) && 0 < deferredMeshIds.length && (null == h && e.log("Warning: 'name' properties not found on glTF scene nodes - will randomly-generate object IDs in XKT"), t = h, e.metaModelCorrections ? (h = e.metaModelCorrections.eachChildRoot[t]) ? ((a = e.metaModelCorrections.eachRootStats[h.id]).countChildren++, a.countChildren >= a.numChildren && (o.createEntity({ id: h.id, meshIds: deferredMeshIds }), deferredMeshIds.length = 0)) : e.metaModelCorrections.metaObjectsMap[t] && (o.createEntity({ id: t, meshIds: deferredMeshIds }), deferredMeshIds.length = 0) : (o.createEntity({ id: t, meshIds: deferredMeshIds }), deferredMeshIds.length = 0)) } function error(e, t) { e.plugin.error(t) } const IFCObjectDefaults = { IfcOpeningElement: { pickable: !1, visible: !1 }, IfcSpace: { colorize: [.137255, .403922, .870588], pickable: !1, visible: !1, opacity: .4 }, IfcWindow: { colorize: [.137255, .403922, .870588], opacity: .3 }, IfcPlate: { colorize: [.8470588235, .427450980392, 0, .5], opacity: .3 }, DEFAULT: {} }; class GLTFLoaderPlugin extends Plugin { constructor(e, t = {}) { super("GLTFLoader", e, t), this._sceneModelLoader = new GLTFVBOSceneModelLoader(this, t), this.dataSource = t.dataSource, this.objectDefaults = t.objectDefaults } set dataSource(e) { this._dataSource = e || new GLTFDefaultDataSource } get dataSource() { return this._dataSource } set objectDefaults(e) { this._objectDefaults = e || IFCObjectDefaults } get objectDefaults() { return this._objectDefaults } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); const t = new VBOSceneModel(this.viewer.scene, utils.apply(e, { isModel: !0 })), i = t.id; if (e.src || e.gltf) { if (e.metaModelSrc || e.metaModelJSON) { const s = e.objectDefaults || this._objectDefaults || IFCObjectDefaults, r = r => { let a; if (this.viewer.metaScene.createMetaModel(i, r, { includeTypes: e.includeTypes, excludeTypes: e.excludeTypes }), this.viewer.scene.canvas.spinner.processes--, e.includeTypes) { a = {}; for (let t = 0, i = e.includeTypes.length; t < i; t++)a[e.includeTypes[t]] = !0 } if (e.excludeTypes) { a = a || {}; for (let t = 0, i = e.excludeTypes.length; t < i; t++)a[e.excludeTypes[t]] = !0 } e.readableGeometry = !1, e.handleGLTFNode = (e, t, i) => { var r; return (t = t.name) && (r = ((r = this.viewer.metaScene.metaObjects[t]) ? r.type : "DEFAULT") || "DEFAULT", i.createEntity = { id: t, isObject: !0 }, t = s[r]) && (!1 === t.visible && (i.createEntity.visible = !1), t.colorize && (i.createEntity.colorize = t.colorize), !1 === t.pickable && (i.createEntity.pickable = !1), void 0 !== t.opacity) && null !== t.opacity && (i.createEntity.opacity = t.opacity), !0 }, e.src ? this._sceneModelLoader.load(this, e.src, r, e, t) : this._sceneModelLoader.parse(this, e.gltf, r, e, t) }; if (e.metaModelSrc) { const t = e.metaModelSrc; this.viewer.scene.canvas.spinner.processes++, this._dataSource.getMetaModel(t, (e => { this.viewer.scene.canvas.spinner.processes--, r(e) }), (e => { this.error(`load(): Failed to load model metadata for model '${i} from  '${t}' - ` + e), this.viewer.scene.canvas.spinner.processes-- })) } else e.metaModelJSON && r(e.metaModelJSON) } else e.handleGLTFNode = (e, t, i) => ((t = t.name) && (i.createEntity = { id: t, isObject: !0 }), !0), e.src ? this._sceneModelLoader.load(this, e.src, null, e, t) : this._sceneModelLoader.parse(this, e.gltf, null, e, t); t.once("destroyed", (() => { this.viewer.metaScene.destroyMetaModel(i) })) } else this.error("load() param expected: src or gltf"); return t } destroy() { super.destroy() } } function CubeTextureCanvas(e, t = {}) { const i = "lightgrey", s = t.hoverColor || "rgba(0,0,0,0.4)", r = 500 + 500 / 3, a = r / 24, o = [{ boundary: [6, 6, 6, 6], color: t.frontColor || t.color || "#55FF55" }, { boundary: [18, 6, 6, 6], color: t.backColor || t.color || "#55FF55" }, { boundary: [12, 6, 6, 6], color: t.leftColor || t.color || "#FF5555" }, { boundary: [0, 6, 6, 6], color: t.rightColor || t.color || "#FF5555" }, { boundary: [6, 0, 6, 6], color: t.topColor || t.color || "#7777FF" }, { boundary: [6, 12, 6, 6], color: t.bottomColor || t.color || "#7777FF" }], n = [{ label: "NavCube.front", boundaries: [[7, 7, 4, 4]], dir: [0, 1, 0], up: [0, 0, 1] }, { label: "NavCube.back", boundaries: [[19, 7, 4, 4]], dir: [0, -1, 0], up: [0, 0, 1] }, { label: "NavCube.right", boundaries: [[13, 7, 4, 4]], dir: [-1, 0, 0], up: [0, 0, 1] }, { label: "NavCube.left", boundaries: [[1, 7, 4, 4]], dir: [1, 0, 0], up: [0, 0, 1] }, { label: "NavCube.top", boundaries: [[7, 1, 4, 4]], dir: [0, 0, -1], up: [0, 1, 0] }, { label: "NavCube.bottom", boundaries: [[7, 13, 4, 4]], dir: [0, 0, 1], up: [0, -1, 0] }, { boundaries: [[7, 5, 4, 2]], dir: [0, 1, -1], up: [0, 1, 1] }, { boundaries: [[1, 6, 4, 1], [6, 1, 1, 4]], dir: [1, 0, -1], up: [1, 0, 1] }, { boundaries: [[7, 0, 4, 1], [19, 6, 4, 1]], dir: [0, -1, -1], up: [0, -1, 1] }, { boundaries: [[13, 6, 4, 1], [11, 1, 1, 4]], dir: [-1, 0, -1], up: [-1, 0, 1] }, { boundaries: [[7, 11, 4, 2]], dir: [0, 1, 1], up: [0, -1, 1] }, { boundaries: [[1, 11, 4, 1], [6, 13, 1, 4]], dir: [1, 0, 1], up: [-1, 0, 1] }, { boundaries: [[7, 17, 4, 1], [19, 11, 4, 1]], dir: [0, -1, 1], up: [0, 1, 1] }, { boundaries: [[13, 11, 4, 1], [11, 13, 1, 4]], dir: [-1, 0, 1], up: [1, 0, 1] }, { boundaries: [[5, 7, 2, 4]], dir: [1, 1, 0], up: [0, 0, 1] }, { boundaries: [[11, 7, 2, 4]], dir: [-1, 1, 0], up: [0, 0, 1] }, { boundaries: [[17, 7, 2, 4]], dir: [-1, -1, 0], up: [0, 0, 1] }, { boundaries: [[0, 7, 1, 4], [23, 7, 1, 4]], dir: [1, -1, 0], up: [0, 0, 1] }, { boundaries: [[5, 11, 2, 2]], dir: [1, 1, 1], up: [-1, -1, 1] }, { boundaries: [[23, 11, 1, 1], [6, 17, 1, 1], [0, 11, 1, 1]], dir: [1, -1, 1], up: [-1, 1, 1] }, { boundaries: [[5, 5, 2, 2]], dir: [1, 1, -1], up: [1, 1, 1] }, { boundaries: [[11, 17, 1, 1], [17, 11, 2, 1]], dir: [-1, -1, 1], up: [1, 1, 1] }, { boundaries: [[17, 6, 2, 1], [11, 0, 1, 1]], dir: [-1, -1, -1], up: [-1, -1, 1] }, { boundaries: [[11, 11, 2, 2]], dir: [-1, 1, 1], up: [1, -1, 1] }, { boundaries: [[0, 6, 1, 1], [6, 0, 1, 1], [23, 6, 1, 1]], dir: [1, -1, -1], up: [1, -1, 1] }, { boundaries: [[11, 5, 2, 2]], dir: [-1, 1, -1], up: [-1, 1, 1] }], h = (t.frontColor || t.color, t.backColor || t.color, t.leftColor || t.color, t.rightColor || t.color, t.topColor || t.color, t.bottomColor || t.color, [{ yUp: "", label: "NavCube.front", boundaries: [[7, 7, 4, 4]], dir: [0, 0, -1], up: [0, 1, 0] }, { label: "NavCube.back", boundaries: [[19, 7, 4, 4]], dir: [0, 0, 1], up: [0, 1, 0] }, { label: "NavCube.right", boundaries: [[13, 7, 4, 4]], dir: [-1, 0, 0], up: [0, 1, 0] }, { label: "NavCube.left", boundaries: [[1, 7, 4, 4]], dir: [1, 0, 0], up: [0, 1, 0] }, { label: "NavCube.top", boundaries: [[7, 1, 4, 4]], dir: [0, -1, 0], up: [0, 0, -1] }, { label: "NavCube.bottom", boundaries: [[7, 13, 4, 4]], dir: [0, 1, 0], up: [0, 0, 1] }, { boundaries: [[7, 5, 4, 2]], dir: [0, -.7071, -.7071], up: [0, .7071, -.7071] }, { boundaries: [[1, 6, 4, 1], [6, 1, 1, 4]], dir: [1, -1, 0], up: [1, 1, 0] }, { boundaries: [[7, 0, 4, 1], [19, 6, 4, 1]], dir: [0, -.7071, .7071], up: [0, .7071, .7071] }, { boundaries: [[13, 6, 4, 1], [11, 1, 1, 4]], dir: [-1, -1, 0], up: [-1, 1, 0] }, { boundaries: [[7, 11, 4, 2]], dir: [0, 1, -1], up: [0, 1, 1] }, { boundaries: [[1, 11, 4, 1], [6, 13, 1, 4]], dir: [1, 1, 0], up: [-1, 1, 0] }, { boundaries: [[7, 17, 4, 1], [19, 11, 4, 1]], dir: [0, 1, 1], up: [0, 1, -1] }, { boundaries: [[13, 11, 4, 1], [11, 13, 1, 4]], dir: [-1, 1, 0], up: [1, 1, 0] }, { boundaries: [[5, 7, 2, 4]], dir: [1, 0, -1], up: [0, 1, 0] }, { boundaries: [[11, 7, 2, 4]], dir: [-1, 0, -1], up: [0, 1, 0] }, { boundaries: [[17, 7, 2, 4]], dir: [-1, 0, 1], up: [0, 1, 0] }, { boundaries: [[0, 7, 1, 4], [23, 7, 1, 4]], dir: [1, 0, 1], up: [0, 1, 0] }, { boundaries: [[5, 11, 2, 2]], dir: [.5, .7071, -.5], up: [-.5, .7071, .5] }, { boundaries: [[23, 11, 1, 1], [6, 17, 1, 1], [0, 11, 1, 1]], dir: [.5, .7071, .5], up: [-.5, .7071, -.5] }, { boundaries: [[5, 5, 2, 2]], dir: [.5, -.7071, -.5], up: [.5, .7071, -.5] }, { boundaries: [[11, 17, 1, 1], [17, 11, 2, 1]], dir: [-.5, .7071, .5], up: [.5, .7071, -.5] }, { boundaries: [[17, 6, 2, 1], [11, 0, 1, 1]], dir: [-.5, -.7071, .5], up: [-.5, .7071, .5] }, { boundaries: [[11, 11, 2, 2]], dir: [-.5, .7071, -.5], up: [.5, .7071, .5] }, { boundaries: [[0, 6, 1, 1], [6, 0, 1, 1], [23, 6, 1, 1]], dir: [.5, -.7071, .5], up: [.5, .7071, .5] }, { boundaries: [[11, 5, 2, 2]], dir: [-.5, -.7071, -.5], up: [-.5, .7071, -.5] }]); for (let e = 0, t = n.length; e < t; e++)math.normalizeVec3(n[e].dir, n[e].dir), math.normalizeVec3(n[e].up, n[e].up); for (let e = 0, t = h.length; e < t; e++)math.normalizeVec3(h[e].dir, h[e].dir), math.normalizeVec3(h[e].up, h[e].up); var l = h; this._textureCanvas = document.createElement("canvas"), this._textureCanvas.width = r, this._textureCanvas.height = 500, this._textureCanvas.style.width = r + "px", this._textureCanvas.style.height = "500px", this._textureCanvas.style.padding = "0", this._textureCanvas.style.margin = "0", this._textureCanvas.style.top = "0", this._textureCanvas.style.background = i, this._textureCanvas.style.position = "absolute", this._textureCanvas.style.opacity = "1.0", this._textureCanvas.style.visibility = "hidden", this._textureCanvas.style["z-index"] = 2e6, document.getElementsByTagName("body")[0].appendChild(this._textureCanvas); const c = this._textureCanvas.getContext("2d"); let u = !1; function p() { for (let e = 0, i = o.length; e < i; e++) { var t = o[e], r = t.boundary, n = Math.round(r[0] * a), h = Math.round(r[1] * a), u = Math.round(r[2] * a); r = Math.round(r[3] * a); c.fillStyle = t.color, c.fillRect(n, h, u, r) } for (let e = 0, t = l.length; e < t; e++) { let t, r, o, n; for (var p, m, f = l[e], g = f.boundaries, _ = 0, v = g.length; _ < v; _++) { var y = g[_]; t = Math.round(y[0] * a), r = Math.round(y[1] * a), o = Math.round(y[2] * a), n = Math.round(y[3] * a), f.highlighted && (c.fillStyle = f.highlighted ? s : f.color || i, c.fillRect(t, r, o, n)) } f.label && (c.fillStyle = "black", c.font = "60px sans-serif", c.textAlign = "center", p = t + .5 * o, m = r + .7 * n, c.fillText(d(f.label), p, m, 80)) } e.scene.glRedraw() } const d = function () { const t = { "NavCube.front": "NavCube.front", "NavCube.back": "NavCube.back", "NavCube.right": "NavCube.right", "NavCube.left": "NavCube.left", "NavCube.top": "NavCube.top", "NavCube.bottom": "NavCube.bottom" }, i = { "NavCube.front": "NavCube.front", "NavCube.back": "NavCube.back", "NavCube.right": "NavCube.right", "NavCube.left": "NavCube.left", "NavCube.top": "NavCube.top", "NavCube.bottom": "NavCube.bottom" }, s = { "NavCube.front": "FRONT", "NavCube.back": "BACK", "NavCube.right": "RIGHT", "NavCube.left": "LEFT", "NavCube.top": "TOP", "NavCube.bottom": "BOTTOM" }; return function (r) { var a = u ? i : t; return (a = a ? a[r] : null) ? e.localeService.translate(a) || s[a] || a : r } }(); this.setZUp = function () { u = !0, l = n, this.clear() }, this.setYUp = function () { u = !1, l = h, this.clear() }, this.clear = function () { c.fillStyle = i, c.fillRect(0, 0, r, 500); for (var e = 0, t = l.length; e < t; e++)l[e].highlighted = !1; p() }, this.getArea = function (e) { for (var t = e[0] * r, i = 500 - 500 * e[1], s = 0, o = l.length; s < o; s++)for (var n = l[s].boundaries, h = 0, c = n.length; h < c; h++) { var u = n[h]; if (t >= u[0] * a && t <= (u[0] + u[2]) * a && i >= u[1] * a && i <= (u[1] + u[3]) * a) return s } return -1 }, this.setAreaHighlighted = function (e, t) { var i = l[e]; if (!i) throw "Area not found: " + e; i.highlighted = !!t, p() }, this.getAreaDir = function (e) { var t = l[e]; if (t) return t.dir; throw "Unknown area: " + e }, this.getAreaUp = function (e) { var t = l[e]; if (t) return t.up; throw "Unknown area: " + e }, this.getImage = function () { return this._textureCanvas }, this.destroy = function () { this._textureCanvas && (this._textureCanvas.parentNode.removeChild(this._textureCanvas), this._textureCanvas = null) } } class NavCubePlugin extends Plugin { constructor(e, t = {}) { super("NavCube", e, t), e.navCube = this; try { this._navCubeScene = new Scene(e, { canvasId: t.canvasId, canvasElement: t.canvasElement, transparent: !0 }), this._navCubeCanvas = this._navCubeScene.canvas.canvas, this._navCubeScene.input.keyboardEnabled = !1 } catch (t) { return void this.error(t) } const i = this._navCubeScene; i.clearLights(), new DirLight(i, { dir: [.4, -.4, .8], color: [.8, 1, 1], intensity: 1, space: "view" }), new DirLight(i, { dir: [-.8, -.3, -.4], color: [.8, .8, .8], intensity: 1, space: "view" }), new DirLight(i, { dir: [.8, -.6, -.8], color: [1, 1, 1], intensity: 1, space: "view" }), this._navCubeCamera = i.camera, this._navCubeCamera.ortho.scale = 7, this._navCubeCamera.ortho.near = .1, this._navCubeCamera.ortho.far = 2e3, i.edgeMaterial.edgeColor = [.2, .2, .2], i.edgeMaterial.edgeAlpha = .6, this._zUp = Boolean(e.camera.zUp); var s, r, a, o, n = this, h = (this._synchCamera = (s = math.rotationMat4c(-90 * math.DEGTORAD, 1, 0, 0), r = math.vec3(), a = math.vec3(), o = math.vec3(), function () { var t = e.camera.eye, i = e.camera.look, h = e.camera.up; r = math.mulVec3Scalar(math.normalizeVec3(math.subVec3(t, i, r)), 5), n._zUp ? (math.transformVec3(s, r, a), math.transformVec3(s, h, o), n._navCubeCamera.look = [0, 0, 0], n._navCubeCamera.eye = math.transformVec3(s, r, a), n._navCubeCamera.up = math.transformPoint3(s, h, o)) : (n._navCubeCamera.look = [0, 0, 0], n._navCubeCamera.eye = r, n._navCubeCamera.up = h) }), this._cubeTextureCanvas = new CubeTextureCanvas(e, t), this._cubeSampler = new Texture(i, { image: this._cubeTextureCanvas.getImage(), flipY: !0, wrapS: ClampToEdgeWrapping, wrapT: ClampToEdgeWrapping }), this._cubeMesh = new Mesh(i, { geometry: new ReadableGeometry(i, { primitive: "triangles", normals: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1], positions: [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1], uv: [.5, .6666, .25, .6666, .25, .3333, .5, .3333, .5, .6666, .5, .3333, .75, .3333, .75, .6666, .5, .6666, .5, 1, .25, 1, .25, .6666, .25, .6666, 0, .6666, 0, .3333, .25, .3333, .25, 0, .5, 0, .5, .3333, .25, .3333, .75, .3333, 1, .3333, 1, .6666, .75, .6666], indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23] }), material: new PhongMaterial(i, { diffuse: [.4, .4, .4], specular: [.4, .4, .4], emissive: [.6, .6, .6], diffuseMap: this._cubeSampler, emissiveMap: this._cubeSampler }), visible: !0, edges: !0 }), this._shadow = !1 === t.shadowVisible ? null : new Mesh(i, { geometry: new ReadableGeometry(i, buildCylinderGeometry({ center: [0, 0, 0], radiusTop: .001, radiusBottom: 1.4, height: .01, radialSegments: 20, heightSegments: 1, openEnded: !0 })), material: new PhongMaterial(i, { diffuse: [0, 0, 0], specular: [0, 0, 0], emissive: [0, 0, 0], alpha: .5 }), position: [0, -1.5, 0], visible: !0, pickable: !1, backfaces: !1 }), this._onCameraMatrix = e.camera.on("matrix", this._synchCamera), this._onCameraWorldAxis = e.camera.on("worldAxis", (() => { e.camera.zUp ? (this._zUp = !0, this._cubeTextureCanvas.setZUp(), this._repaint(), this._synchCamera()) : e.camera.yUp && (this._zUp = !1, this._cubeTextureCanvas.setYUp(), this._repaint(), this._synchCamera()) })), this._onCameraFOV = e.camera.perspective.on("fov", (e => { this._synchProjection && (this._navCubeCamera.perspective.fov = e) })), this._onCameraProjection = e.camera.on("projection", (e => { this._synchProjection && (this._navCubeCamera.projection = "ortho" === e || "perspective" === e ? e : "perspective") })), -1); function l(e) { var t = [0, 0]; if (e) { for (var i = e.target, s = 0, r = 0; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; t[0] = e.pageX - s, t[1] = e.pageY - r } else e = window.event, t[0] = e.x, t[1] = e.y; return t } var c, u, p, d = null, m = null, f = !1, g = !1, _ = (n._navCubeCanvas.addEventListener("mouseenter", n._onMouseEnter = function (e) { g = !0 }), n._navCubeCanvas.addEventListener("mouseleave", n._onMouseLeave = function (e) { g = !1 }), n._navCubeCanvas.addEventListener("mousedown", n._onMouseDown = function (e) { 1 === e.which && (d = e.x, m = e.y, c = e.clientX, u = e.clientY, e = l(e), e = i.pick({ canvasPos: e }), f = !!e) }), document.addEventListener("mouseup", n._onMouseUp = function (e) { var t, s; 1 === e.which && (f = !1, null !== d) && (s = l(e), s = i.pick({ canvasPos: s, pickSurface: !0 })) && s.uv && 0 <= (t = n._cubeTextureCanvas.getArea(s.uv)) && (document.body.style.cursor = "pointer", 0 <= h && (n._cubeTextureCanvas.setAreaHighlighted(h, !1), n._repaint(), h = -1), 0 <= t) && (n._cubeTextureCanvas.setAreaHighlighted(t, !0), h = t, n._repaint(), e.x < d - 3 || e.x > d + 3 || e.y < m - 3 || e.y > m + 3 || (s = n._cubeTextureCanvas.getAreaDir(t)) && (e = n._cubeTextureCanvas.getAreaUp(t), _(s, e, (function () { 0 <= h && (n._cubeTextureCanvas.setAreaHighlighted(h, !1), n._repaint(), h = -1), document.body.style.cursor = "pointer", 0 <= h && (n._cubeTextureCanvas.setAreaHighlighted(h, !1), n._repaint(), h = -1), 0 <= t && (n._cubeTextureCanvas.setAreaHighlighted(t, !1), h = -1, n._repaint()) })))) }), document.addEventListener("mousemove", n._onMouseMove = function (t) { var s, r, a, o; 0 <= h && (n._cubeTextureCanvas.setAreaHighlighted(h, !1), n._repaint(), h = -1), 1 === t.buttons && !f || (f ? (o = t.clientX, s = t.clientY, document.body.style.cursor = "move", r = -.5 * (o - c), a = -.5 * (s - u), e.camera.orbitYaw(r), e.camera.orbitPitch(-a), c = o, u = s) : g && (r = l(t), (a = i.pick({ canvasPos: r, pickSurface: !0 })) ? a.uv && (document.body.style.cursor = "pointer", (o = n._cubeTextureCanvas.getArea(a.uv)) !== h) && (0 <= h && n._cubeTextureCanvas.setAreaHighlighted(h, !1), 0 <= o) && (n._cubeTextureCanvas.setAreaHighlighted(o, !0), n._repaint(), h = o) : (document.body.style.cursor = "default", 0 <= h && (n._cubeTextureCanvas.setAreaHighlighted(h, !1), n._repaint(), h = -1)))) }), p = math.vec3(), function (t, i, s) { var r = n._fitVisible ? e.scene.getAABB(e.scene.visibleObjectIds) : e.scene.aabb, a = math.getAABB3Diag(r); math.getAABB3Center(r, p), r = Math.abs(a / Math.tan(n._cameraFitFOV * math.DEGTORAD)); e.cameraControl.pivotPos = p, n._cameraFly ? e.cameraFlight.flyTo({ look: p, eye: [p[0] - r * t[0], p[1] - r * t[1], p[2] - r * t[2]], up: i || [0, 1, 0], orthoScale: 1.1 * a, fitFOV: n._cameraFitFOV, duration: n._cameraFlyDuration }, s) : e.cameraFlight.jumpTo({ look: p, eye: [p[0] - r * t[0], p[1] - r * t[1], p[2] - r * t[2]], up: i || [0, 1, 0], orthoScale: 1.1 * a, fitFOV: n._cameraFitFOV }, s) }); this._onUpdated = e.localeService.on("updated", (() => { this._cubeTextureCanvas.clear(), this._repaint() })), this.setVisible(t.visible), this.setCameraFitFOV(t.cameraFitFOV), this.setCameraFly(t.cameraFly), this.setCameraFlyDuration(t.cameraFlyDuration), this.setFitVisible(t.fitVisible), this.setSynchProjection(t.synchProjection) } send(e, t) { "language" === e && (this._cubeTextureCanvas.clear(), this._repaint()) } _repaint() { var e = this._cubeTextureCanvas.getImage(); this._cubeMesh.material.diffuseMap.image = e, this._cubeMesh.material.emissiveMap.image = e } setVisible(e = !0) { this._navCubeCanvas && (this._cubeMesh.visible = e, this._shadow && (this._shadow.visible = e), this._navCubeCanvas.style.visibility = e ? "visible" : "hidden") } getVisible() { return !!this._navCubeCanvas && this._cubeMesh.visible } setFitVisible(e = !1) { this._fitVisible = e } getFitVisible() { return this._fitVisible } setCameraFly(e = !0) { this._cameraFly = e } getCameraFly() { return this._cameraFly } setCameraFitFOV(e = 45) { this._cameraFitFOV = e } getCameraFitFOV() { return this._cameraFitFOV } setCameraFlyDuration(e = .5) { this._cameraFlyDuration = e } getCameraFlyDuration() { return this._cameraFlyDuration } setSynchProjection(e = !1) { this._synchProjection = e } getSynchProjection() { return this._synchProjection } destroy() { this._navCubeCanvas && (this.viewer.localeService.off(this._onUpdated), this.viewer.camera.off(this._onCameraMatrix), this.viewer.camera.off(this._onCameraWorldAxis), this.viewer.camera.perspective.off(this._onCameraFOV), this.viewer.camera.off(this._onCameraProjection), this._navCubeCanvas.removeEventListener("mouseenter", this._onMouseEnter), this._navCubeCanvas.removeEventListener("mouseleave", this._onMouseLeave), this._navCubeCanvas.removeEventListener("mousedown", this._onMouseDown), document.removeEventListener("mousemove", this._onMouseMove), document.removeEventListener("mouseup", this._onMouseUp), this._navCubeCanvas = null, this._cubeTextureCanvas.destroy(), this._cubeTextureCanvas = null, this._onMouseEnter = null, this._onMouseLeave = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null), this._navCubeScene.destroy(), this._navCubeScene = null, this._cubeMesh = null, this._shadow = null, super.destroy() } } const tempVec3a$4 = math.vec3(); class OBJSceneGraphLoader { load(e, t, i = 0) { var s = e.scene.canvas.spinner; s.processes++, loadOBJ(e, t, (function (t) { loadMTLs(e, t, (function () { createMeshes(e, t), s.processes--, core.scheduleTask((function () { e.fire("loaded", !0, !1) })) })) })) } parse(e, t, i, s) { t ? (t = parseOBJ(e, t, null), i && parseMTL(e, i, s), createMeshes(e, t), e.src = null, e.fire("loaded", !0, !1)) : this.warn("load() param expected: objText") } } var loadOBJ = function (e, t, i) { loadFile(t, (function (s) { s = parseOBJ(e, s, t), i(s) }), (function (t) { e.error(t) })) }, parseOBJ = function () { const e = { vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/, normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/, uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/, face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/, face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/, face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/, face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/, object_pattern: /^[og]\s*(.+)?/, smoothing_pattern: /^s\s+(\d+|on|off)/, material_library_pattern: /^mtllib /, material_use_pattern: /^usemtl / }; return function (s, a, o) { for (var n, l, c = { src: o = o || "", basePath: -1 === (n = o.lastIndexOf("/")) ? o : o.substring(0, n + 1), objects: [], object: {}, positions: [], normals: [], uv: [], materialLibraries: {} }, u = (t(c, "", !1), (a = -1 !== a.indexOf("\r\n") ? a.replace("\r\n", "\n") : a).split("\n")), p = "", d = [], m = "function" == typeof "".trimLeft, f = 0, g = u.length; f < g; f++)if (p = u[f], 0 !== (p = m ? p.trimLeft() : p.trim()).length && "#" !== (l = p.charAt(0))) if ("v" === l) if (" " === (U = p.charAt(1)) && null !== (d = e.vertex_pattern.exec(p))) c.positions.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])); else if ("n" === U && null !== (d = e.normal_pattern.exec(p))) c.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])); else { if ("t" !== U || null === (d = e.uv_pattern.exec(p))) return void s.error("Unexpected vertex/normal/uv line: '" + p + "'"); c.uv.push(parseFloat(d[1]), parseFloat(d[2])) } else if ("f" === l) if (null !== (d = e.face_vertex_uv_normal.exec(p))) h(c, d[1], d[4], d[7], d[10], d[2], d[5], d[8], d[11], d[3], d[6], d[9], d[12]); else if (null !== (d = e.face_vertex_uv.exec(p))) h(c, d[1], d[3], d[5], d[7], d[2], d[4], d[6], d[8]); else if (null !== (d = e.face_vertex_normal.exec(p))) h(c, d[1], d[3], d[5], d[7], void 0, void 0, void 0, void 0, d[2], d[4], d[6], d[8]); else { if (null === (d = e.face_vertex.exec(p))) return void s.error("Unexpected face line: '" + p + "'"); h(c, d[1], d[2], d[3], d[4]) } else if ("l" === l) { var _ = p.substring(1).trim().split(" "), v = [], y = []; if (-1 === p.indexOf("/")) v = _; else for (var T = 0, I = _.length; T < I; T++) { var E = _[T].split("/"); "" !== E[0] && v.push(E[0]), "" !== E[1] && y.push(E[1]) } var C = F = P = void 0, P = c, b = v, A = y; P.object.geometry.type = "Line"; for (var D = P.positions.length, R = P.uv.length, F = 0, w = b.length; F < w; F++) { var M = void 0, S = (M = P, i(b[F], D)), x = M.positions; (M = M.object.geometry.positions).push(x[S + 0]), M.push(x[S + 1]), M.push(x[S + 2]) } C = 0; for (var L = A.length; C < L; C++) { var O = void 0, N = (O = P, r(A[C], R)), B = O.uv; (O = O.object.geometry.uv).push(B[N + 0]), O.push(B[N + 1]) } } else if (null !== (d = e.object_pattern.exec(p))) t(c, G = d[0].substr(1).trim(), !0); else if (e.material_use_pattern.test(p)) { var G = p.substring(7).trim(); c.object.material.id = G } else if (e.material_library_pattern.test(p)) c.materialLibraries[p.substring(7).trim()] = !0; else if (null !== (d = e.smoothing_pattern.exec(p))) { var U = d[1].trim().toLowerCase(); c.object.material.smooth = "1" === U || "on" === U } else if ("\0" !== p) return void s.error("Unexpected line: '" + p + "'"); return c }; function t(e, t, i) { e.object && !1 === e.object.fromDeclaration ? (e.object.id = t, e.object.fromDeclaration = !1 !== i) : (e.object = { id: t || "", geometry: { positions: [], normals: [], uv: [] }, material: { id: "", smooth: !0 }, fromDeclaration: !1 !== i }, e.objects.push(e.object)) } function i(e, t) { return 3 * (0 <= (e = parseInt(e, 10)) ? e - 1 : e + t / 3) } function s(e, t) { return 3 * (0 <= (e = parseInt(e, 10)) ? e - 1 : e + t / 3) } function r(e, t) { return 2 * (0 <= (e = parseInt(e, 10)) ? e - 1 : e + t / 2) } function a(e, t, i, s) { var r = e.positions; (e = e.object.geometry.positions).push(r[t + 0]), e.push(r[t + 1]), e.push(r[t + 2]), e.push(r[i + 0]), e.push(r[i + 1]), e.push(r[i + 2]), e.push(r[s + 0]), e.push(r[s + 1]), e.push(r[s + 2]) } function o(e, t, i, s) { var r = e.normals; (e = e.object.geometry.normals).push(r[t + 0]), e.push(r[t + 1]), e.push(r[t + 2]), e.push(r[i + 0]), e.push(r[i + 1]), e.push(r[i + 2]), e.push(r[s + 0]), e.push(r[s + 1]), e.push(r[s + 2]) } function n(e, t, i, s) { var r = e.uv; (e = e.object.geometry.uv).push(r[t + 0]), e.push(r[t + 1]), e.push(r[i + 0]), e.push(r[i + 1]), e.push(r[s + 0]), e.push(r[s + 1]) } function h(e, t, h, l, c, u, p, d, m, f, g, _, v) { var y, T = e.positions.length; t = i(t, T), h = i(h, T), l = i(l, T); void 0 === c ? a(e, t, h, l) : (a(e, t, h, y = i(c, T)), a(e, h, l, y)), void 0 !== u && (t = r(u, T = e.uv.length), h = r(p, T), l = r(d, T), void 0 === c ? n(e, t, h, l) : (n(e, t, h, y = r(m, T)), n(e, h, l, y))), void 0 !== f && (t = s(f, u = e.normals.length), h = f === g ? t : s(g, u), l = f === _ ? t : s(_, u), void 0 === c ? o(e, t, h, l) : (o(e, t, h, y = s(v, u)), o(e, h, l, y))) } }(); function loadMTLs(e, t, i) { for (var s = t.basePath, r = Object.keys(t.materialLibraries), a = r.length, o = 0, n = a; o < n; o++)loadMTL(e, s, s + r[o], (function () { 0 == --a && i() })) } var loadMTL = function (e, t, i, s) { loadFile(i, (function (i) { parseMTL(e, i, t), s() }), (function (t) { e.error(t), s() })) }, parseMTL = function () { var e = /\s+/; return function (e, r, a) { var o, n, h, l, c, u = r.split("\n"), p = { id: "Default" }, d = !1; a = a || ""; for (var m = 0; m < u.length; m++)if (0 !== (o = u[m].trim()).length && "#" !== o.charAt(0)) switch (h = (h = 0 <= (n = o.indexOf(" ")) ? o.substring(0, n) : o).toLowerCase(), l = (l = 0 <= n ? o.substring(n + 1) : "").trim(), h.toLowerCase()) { case "newmtl": i(e, p), p = { id: l }, d = !0; break; case "ka": p.ambient = s(l); break; case "kd": p.diffuse = s(l); break; case "ks": p.specular = s(l); break; case "map_kd": p.diffuseMap || (p.diffuseMap = t(e, a, l, "sRGB")); break; case "map_ks": p.specularMap || (p.specularMap = t(e, a, l, "linear")); break; case "map_bump": case "bump": p.normalMap || (p.normalMap = t(e, a, l)); break; case "ns": p.shininess = parseFloat(l); break; case "d": (c = parseFloat(l)) < 1 && (p.alpha = c, p.alphaMode = "blend"); break; case "tr": 0 < (c = parseFloat(l)) && (p.alpha = 1 - c, p.alphaMode = "blend") }d && i(e, p) }; function t(e, t, i, s) { var r = {}, a = (i = i.split(/\s+/)).indexOf("-bm"); return 0 <= a && i.splice(a, 2), 0 <= (a = i.indexOf("-s")) && (r.scale = [parseFloat(i[a + 1]), parseFloat(i[a + 2])], i.splice(a, 4)), 0 <= (a = i.indexOf("-o")) && (r.translate = [parseFloat(i[a + 1]), parseFloat(i[a + 2])], i.splice(a, 4)), r.src = t + i.join(" ").trim(), r.flipY = !0, r.encoding = s || "linear", new Texture(e, r).id } function i(e, t) { new PhongMaterial(e, t) } function s(t) { return t = t.split(e, 3), [parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2])] } }(); function createMeshes(e, t) { for (var i = 0, s = t.objects.length; i < s; i++) { var r = t.objects[i]; if ((l = r.geometry).type, 0 !== l.positions.length) { (c = { primitive: "triangles", compressGeometry: !1 }).positions = l.positions, 0 < l.normals.length && (c.normals = l.normals), 0 < l.uv.length && (c.uv = l.uv); for (var a = new Array(c.positions.length / 3), o = 0; o < a.length; o++)a[o] = o; c.indices = a; var n, h = tempVec3a$4, l = (worldToRTCPositions(l.positions, l.positions, h), new ReadableGeometry(e, c)), c = ((c = r.material.id) && "" !== c ? (n = e.scene.components[c]) || e.error("Material not found: " + c) : n = new PhongMaterial(e, { diffuse: [.6, .6, .6], backfaces: !0 }), new Mesh(e, { id: e.id + "#" + r.id, origin: 0 !== h[0] || 0 !== h[1] || 0 !== h[2] ? h : null, isObject: !0, geometry: l, material: n, pickable: !0 })); e.addChild(c) } } } function loadFile(e, t, i) { var s = new XMLHttpRequest; s.open("GET", e, !0), s.addEventListener("load", (function (e) { var s = e.target.response; 200 === this.status ? t && t(s) : 0 === this.status ? (console.warn("loadFile: HTTP Status 0 received."), t && t(s)) : i && i(e) }), !1), s.addEventListener("error", (function (e) { i && i(e) }), !1), s.send(null) } class OBJLoaderPlugin extends Plugin { constructor(e, t) { super("OBJLoader", e, t), this._sceneGraphLoader = new OBJSceneGraphLoader } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); var t = new Node$1(this.viewer.scene, utils.apply(e, { isModel: !0 })); const i = t.id, s = e.src; if (s) { if (e.metaModelSrc) { const r = e.metaModelSrc; utils.loadJSON(r, (r => { this.viewer.metaScene.createMetaModel(i, r), this._sceneGraphLoader.load(t, s, e) }), (e => { this.error(`load(): Failed to load model modelMetadata for model '${i} from  '${r}' - ` + e) })) } else this._sceneGraphLoader.load(t, s, e); t.once("destroyed", (() => { this.viewer.metaScene.destroyMetaModel(i) })) } else this.error("load() param expected: src"); return t } destroy() { super.destroy() } } const zeroVec = new Float64Array([0, 0, 1]), quat = new Float64Array(4); class Control { constructor(e) { this.id = null, this._viewer = e.viewer, this._visible = !1, this._pos = math.vec3(), this._origin = math.vec3(), this._rtcPos = math.vec3(), this._baseDir = math.vec3(), this._rootNode = null, this._displayMeshes = null, this._affordanceMeshes = null, this._ignoreNextSectionPlaneDirUpdate = !1, this._createNodes(), this._bindEvents() } _setSectionPlane(e) { this._sectionPlane && (this._sectionPlane.off(this._onSectionPlanePos), this._sectionPlane.off(this._onSectionPlaneDir), this._onSectionPlanePos = null, this._onSectionPlaneDir = null, this._sectionPlane = null), e && (this.id = e.id, this._setPos(e.pos), this._setDir(e.dir), this._sectionPlane = e, this._onSectionPlanePos = e.on("pos", (() => { this._setPos(this._sectionPlane.pos) })), this._onSectionPlaneDir = e.on("dir", (() => { this._ignoreNextSectionPlaneDirUpdate ? this._ignoreNextSectionPlaneDirUpdate = !1 : this._setDir(this._sectionPlane.dir) }))) } get sectionPlane() { return this._sectionPlane } _setPos(e) { this._pos.set(e), worldToRTCPos(this._pos, this._origin, this._rtcPos), this._rootNode.origin = this._origin, this._rootNode.position = this._rtcPos } _setDir(e) { this._baseDir.set(e), this._rootNode.quaternion = math.vec3PairToQuaternion(zeroVec, e, quat) } _setSectionPlaneDir(e) { this._sectionPlane && (this._ignoreNextSectionPlaneDirUpdate = !0, this._sectionPlane.dir = e) } setVisible(e = !0) { if (this._visible !== e) { for (var t in this._visible = e, this._displayMeshes) this._displayMeshes.hasOwnProperty(t) && (this._displayMeshes[t].visible = e); if (!e) for (t in this._affordanceMeshes) this._affordanceMeshes.hasOwnProperty(t) && (this._affordanceMeshes[t].visible = e) } } getVisible() { return this._visible } setCulled(e) { for (var t in this._displayMeshes) this._displayMeshes.hasOwnProperty(t) && (this._displayMeshes[t].culled = e); if (!e) for (t in this._affordanceMeshes) this._affordanceMeshes.hasOwnProperty(t) && (this._affordanceMeshes[t].culled = e) } _createNodes() { var e = this._viewer.scene; this._rootNode = new Node$1(e, { position: [0, 0, 0], scale: [5, 5, 5] }); e = this._rootNode; var t, i, s, r = { arrowHead: new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .001, radiusBottom: .07, radialSegments: 32, heightSegments: 1, height: .2, openEnded: !1 })), arrowHeadBig: new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .001, radiusBottom: .09, radialSegments: 32, heightSegments: 1, height: .25, openEnded: !1 })), arrowHeadHandle: new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .09, radiusBottom: .09, radialSegments: 8, heightSegments: 1, height: .37, openEnded: !1 })), curve: new ReadableGeometry(e, buildTorusGeometry({ radius: .8, tube: .01, radialSegments: 64, tubeSegments: 14, arc: 2 * Math.PI / 4 })), curveHandle: new ReadableGeometry(e, buildTorusGeometry({ radius: .8, tube: .06, radialSegments: 64, tubeSegments: 14, arc: 2 * Math.PI / 4 })), hoop: new ReadableGeometry(e, buildTorusGeometry({ radius: .8, tube: .01, radialSegments: 64, tubeSegments: 8, arc: 2 * Math.PI })), axis: new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .01, radiusBottom: .01, radialSegments: 20, heightSegments: 1, height: 1, openEnded: !1 })), axisHandle: new ReadableGeometry(e, buildCylinderGeometry({ radiusTop: .08, radiusBottom: .08, radialSegments: 20, heightSegments: 1, height: 1, openEnded: !1 })) }, a = { pickable: new PhongMaterial(e, { diffuse: [1, 1, 0], alpha: 0, alphaMode: "blend" }), red: new PhongMaterial(e, { diffuse: [1, 0, 0], emissive: [1, 0, 0], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), highlightRed: new EmphasisMaterial(e, { edges: !1, fill: !0, fillColor: [1, 0, 0], fillAlpha: .6 }), green: new PhongMaterial(e, { diffuse: [0, 1, 0], emissive: [0, 1, 0], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), highlightGreen: new EmphasisMaterial(e, { edges: !1, fill: !0, fillColor: [0, 1, 0], fillAlpha: .6 }), blue: new PhongMaterial(e, { diffuse: [0, 0, 1], emissive: [0, 0, 1], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80, lineWidth: 2 }), highlightBlue: new EmphasisMaterial(e, { edges: !1, fill: !0, fillColor: [0, 0, 1], fillAlpha: .2 }), center: new PhongMaterial(e, { diffuse: [0, 0, 0], emissive: [0, 0, 0], ambient: [0, 0, 0], specular: [.6, .6, .3], shininess: 80 }), highlightBall: new EmphasisMaterial(e, { edges: !1, fill: !0, fillColor: [.5, .5, .5], fillAlpha: .5, vertices: !1 }), highlightPlane: new EmphasisMaterial(e, { edges: !0, edgeWidth: 3, fill: !1, fillColor: [.5, .5, .5], fillAlpha: .5, vertices: !1 }) }; this._displayMeshes = { plane: e.addChild(new Mesh(e, { geometry: new ReadableGeometry(e, { primitive: "triangles", positions: [.5, .5, 0, .5, -.5, 0, -.5, -.5, 0, -.5, .5, 0, .5, .5, -0, .5, -.5, -0, -.5, -.5, -0, -.5, .5, -0], indices: [0, 1, 2, 2, 3, 0] }), material: new PhongMaterial(e, { emissive: [0, 0, 0], diffuse: [0, 0, 0], backfaces: !0 }), opacity: .6, ghosted: !0, ghostMaterial: new EmphasisMaterial(e, { edges: !1, filled: !0, fillColor: [1, 1, 0], edgeColor: [0, 0, 0], fillAlpha: .1, backfaces: !0 }), pickable: !1, collidable: !0, clippable: !1, visible: !1, scale: [2.4, 2.4, 1] }), !1), planeFrame: e.addChild(new Mesh(e, { geometry: new ReadableGeometry(e, buildTorusGeometry({ center: [0, 0, 0], radius: 1.7, tube: .02, radialSegments: 4, tubeSegments: 4, arc: 2 * Math.PI })), material: new PhongMaterial(e, { emissive: [0, 0, 0], diffuse: [0, 0, 0], specular: [0, 0, 0], shininess: 0 }), highlightMaterial: new EmphasisMaterial(e, { edges: !1, edgeColor: [0, 0, 0], filled: !0, fillColor: [.8, .8, .8], fillAlpha: 1 }), pickable: !1, collidable: !1, clippable: !1, visible: !1, scale: [1, 1, .1], rotation: [0, 0, 45] }), !1), xCurve: e.addChild(new Mesh(e, { geometry: r.curve, material: a.red, matrix: (s = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4()), t = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(t, s, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, backfaces: !0, visible: !1 }), !1), xCurveHandle: e.addChild(new Mesh(e, { geometry: r.curveHandle, material: a.pickable, matrix: (t = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4()), s = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, backfaces: !0, visible: !1 }), !1), xCurveArrow1: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.red, matrix: (s = math.translateMat4c(0, -.07, -.8, math.identityMat4()), t = math.scaleMat4v([.6, .6, .6], math.identityMat4()), i = math.rotationMat4v(0 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(math.mulMat4(s, t, math.identityMat4()), i, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), xCurveArrow2: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.red, matrix: (s = math.translateMat4c(0, -.8, -.07, math.identityMat4()), t = math.scaleMat4v([.6, .6, .6], math.identityMat4()), i = math.rotationMat4v(90 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(math.mulMat4(s, t, math.identityMat4()), i, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), yCurve: e.addChild(new Mesh(e, { geometry: r.curve, material: a.green, rotation: [-90, 0, 0], pickable: !1, collidable: !0, clippable: !1, backfaces: !0, visible: !1 }), !1), yCurveHandle: e.addChild(new Mesh(e, { geometry: r.curveHandle, material: a.pickable, rotation: [-90, 0, 0], pickable: !0, collidable: !0, clippable: !1, backfaces: !0, visible: !1 }), !1), yCurveArrow1: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.green, matrix: (s = math.translateMat4c(.07, 0, -.8, math.identityMat4()), t = math.scaleMat4v([.6, .6, .6], math.identityMat4()), i = math.rotationMat4v(90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(math.mulMat4(s, t, math.identityMat4()), i, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), yCurveArrow2: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.green, matrix: (s = math.translateMat4c(.8, 0, -.07, math.identityMat4()), t = math.scaleMat4v([.6, .6, .6], math.identityMat4()), i = math.rotationMat4v(90 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(math.mulMat4(s, t, math.identityMat4()), i, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), zCurve: e.addChild(new Mesh(e, { geometry: r.curve, material: a.blue, matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), zCurveHandle: e.addChild(new Mesh(e, { geometry: r.curveHandle, material: a.pickable, matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), zCurveCurveArrow1: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.blue, matrix: (s = math.translateMat4c(.8, -.07, 0, math.identityMat4()), t = math.scaleMat4v([.6, .6, .6], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), zCurveArrow2: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.blue, matrix: (i = math.translateMat4c(.05, -.8, 0, math.identityMat4()), s = math.scaleMat4v([.6, .6, .6], math.identityMat4()), t = math.rotationMat4v(90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(math.mulMat4(i, s, math.identityMat4()), t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), center: e.addChild(new Mesh(e, { geometry: new ReadableGeometry(e, buildSphereGeometry({ radius: .05 })), material: a.center, pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), xAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.red, matrix: (i = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), xAxisArrowHandle: e.addChild(new Mesh(e, { geometry: r.arrowHeadHandle, material: a.pickable, matrix: (t = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), xAxis: e.addChild(new Mesh(e, { geometry: r.axis, material: a.red, matrix: (i = math.translateMat4c(0, .5, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), xAxisHandle: e.addChild(new Mesh(e, { geometry: r.axisHandle, material: a.pickable, matrix: (t = math.translateMat4c(0, .5, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), yAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.green, matrix: (i = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), yAxisArrowHandle: e.addChild(new Mesh(e, { geometry: r.arrowHeadHandle, material: a.pickable, matrix: (t = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1, opacity: .2 }), !1), yShaft: e.addChild(new Mesh(e, { geometry: r.axis, material: a.green, position: [0, -.5, 0], pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), yShaftHandle: e.addChild(new Mesh(e, { geometry: r.axisHandle, material: a.pickable, position: [0, -.5, 0], pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), zAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHead, material: a.blue, matrix: (i = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [.8, 0, 0], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), zAxisArrowHandle: e.addChild(new Mesh(e, { geometry: r.arrowHeadHandle, material: a.pickable, matrix: (t = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [.8, 0, 0], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !0, collidable: !0, clippable: !1, visible: !1 }), !1), zShaft: e.addChild(new Mesh(e, { geometry: r.axis, material: a.blue, matrix: (i = math.translateMat4c(0, .5, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), clippable: !1, pickable: !1, collidable: !0, visible: !1 }), !1), zAxisHandle: e.addChild(new Mesh(e, { geometry: r.axisHandle, material: a.pickable, matrix: (t = math.translateMat4c(0, .5, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), clippable: !1, pickable: !0, collidable: !0, visible: !1 }), !1) }, this._affordanceMeshes = { planeFrame: e.addChild(new Mesh(e, { geometry: new ReadableGeometry(e, buildTorusGeometry({ center: [0, 0, 0], radius: 2, tube: .01, radialSegments: 4, tubeSegments: 4, arc: 2 * Math.PI })), material: new PhongMaterial(e, { ambient: [1, 1, 1], diffuse: [0, 0, 0], emissive: [1, 1, 0] }), highlighted: !0, highlightMaterial: new EmphasisMaterial(e, { edges: !1, filled: !0, fillColor: [1, 1, 0], fillAlpha: 1 }), pickable: !1, collidable: !1, clippable: !1, visible: !1, scale: [1, 1, 1], rotation: [0, 0, 45] }), !1), xHoop: e.addChild(new Mesh(e, { geometry: r.hoop, material: a.red, highlighted: !0, highlightMaterial: a.highlightRed, matrix: (i = math.rotationMat4v(90 * math.DEGTORAD, [0, 1, 0], math.identityMat4()), s = math.rotationMat4v(270 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), yHoop: e.addChild(new Mesh(e, { geometry: r.hoop, material: a.green, highlighted: !0, highlightMaterial: a.highlightGreen, rotation: [-90, 0, 0], pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), zHoop: e.addChild(new Mesh(e, { geometry: r.hoop, material: a.blue, highlighted: !0, highlightMaterial: a.highlightBlue, matrix: math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), pickable: !1, collidable: !0, clippable: !1, backfaces: !0, visible: !1 }), !1), xAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHeadBig, material: a.red, matrix: (t = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [0, 0, 1], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), yAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHeadBig, material: a.green, matrix: (i = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(180 * math.DEGTORAD, [1, 0, 0], math.identityMat4()), math.mulMat4(s, i, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1), zAxisArrow: e.addChild(new Mesh(e, { geometry: r.arrowHeadBig, material: a.blue, matrix: (t = math.translateMat4c(0, 1.1, 0, math.identityMat4()), s = math.rotationMat4v(-90 * math.DEGTORAD, [.8, 0, 0], math.identityMat4()), math.mulMat4(s, t, math.identityMat4())), pickable: !1, collidable: !0, clippable: !1, visible: !1 }), !1) } } _bindEvents() { const e = this; var t = !1; const i = -1, s = 0, r = 1, a = 2, o = 3, n = 4, h = 5, l = this._rootNode; var c = null, u = null; const p = math.vec2(), d = math.vec3([1, 0, 0]), m = math.vec3([0, 1, 0]), f = math.vec3([0, 0, 1]), g = this._viewer.scene.canvas.canvas, _ = this._viewer.camera, v = this._viewer.scene; { const e = math.vec3([0, 0, 0]); let t = -1; this._onCameraViewMatrix = v.camera.on("viewMatrix", (() => { })), this._onCameraProjMatrix = v.camera.on("projMatrix", (() => { })), this._onSceneTick = v.on("tick", (() => { var i, s = Math.abs(math.lenVec3(math.subVec3(v.camera.eye, this._pos, e))); s !== t && "perspective" === _.projection && (i = Math.tan(_.perspective.fov * math.DEGTORAD) * s * .07, l.scale = [i, i, i], t = s), "ortho" === _.projection && (i = _.ortho.scale / 10, l.scale = [i, i, i], t = s) })) } const y = function () { const e = new Float64Array(2); return function (t) { if (t) { for (var i = t.target, s = 0, r = 0; i.offsetParent;)s += i.offsetLeft, r += i.offsetTop, i = i.offsetParent; e[0] = t.pageX - s, e[1] = t.pageY - r } else t = window.event, e[0] = t.x, e[1] = t.y; return e } }(), T = function () { const t = math.mat4(); return function (i, s) { return math.quaternionToMat4(e._rootNode.quaternion, t), math.transformVec3(t, i, s), math.normalizeVec3(s), s } }(); var I = function () { const e = math.vec3(); return function (t) { var i = Math.abs(t[0]); return i > Math.abs(t[1]) && i > Math.abs(t[2]) ? math.cross3Vec3(t, [0, 1, 0], e) : math.cross3Vec3(t, [1, 0, 0], e), math.cross3Vec3(e, t, e), math.normalizeVec3(e), e } }(); const E = function () { const t = math.vec3(), i = math.vec3(), s = math.vec4(); return function (r, a, o) { T(r, s), r = I(s, a, o), P(a, r, t), P(o, r, i), math.subVec3(i, t), a = math.dotVec3(i, s), e._pos[0] += s[0] * a, e._pos[1] += s[1] * a, e._pos[2] += s[2] * a, e._rootNode.position = e._pos, e._sectionPlane && (e._sectionPlane.pos = e._pos) } }(); var C = function () { const t = math.vec4(), i = math.vec4(), s = math.vec4(), r = math.vec4(); return function (a, o, n) { T(a, r), P(o, r, t) && P(n, r, i) || (h = I(r, o, n), P(o, h, t, 1), P(n, h, i, 1), h = math.dotVec3(t, r), t[0] -= h * r[0], t[1] -= h * r[1], t[2] -= h * r[2], h = math.dotVec3(i, r), i[0] -= h * r[0], i[1] -= h * r[1], i[2] -= h * r[2]), math.normalizeVec3(t), math.normalizeVec3(i); var h = math.dotVec3(t, i); h = math.clamp(h, -1, 1), o = Math.acos(h) * math.RADTODEG; math.cross3Vec3(t, i, s), math.dotVec3(s, r) < 0 && (o = -o), e._rootNode.rotate(a, o), b() } }(), P = function () { const t = math.vec4([0, 0, 0, 1]), i = math.mat4(); return function (s, r, a, o) { o = o || 0, t[0] = s[0] / g.width * 2 - 1, t[1] = -(s[1] / g.height * 2 - 1), t[2] = 0, t[3] = 1, math.mulMat4(_.projMatrix, _.viewMatrix, i), math.inverseMat4(i), math.transformVec4(i, t, t), math.mulVec4Scalar(t, 1 / t[3]); s = _.eye; var n = (math.subVec4(t, s, t), e._sectionPlane.pos), h = (o = -math.dotVec3(n, r) - o, math.dotVec3(r, t)); return .005 < Math.abs(h) && (r = -(math.dotVec3(r, s) + o) / h, math.mulVec3Scalar(t, r, a), math.addVec3(a, s), math.subVec3(a, n, a), !0) } }(); const b = function () { const t = math.vec3(), i = math.mat4(); return function () { e.sectionPlane && (math.quaternionToMat4(l.quaternion, i), math.transformVec3(i, [0, 0, 1], t), e._setSectionPlaneDir(t)) } }(); var A, D = !1; this._onCameraControlHover = this._viewer.cameraControl.on("hoverEnter", (e => { if (this._visible && !D) { var l; switch (t = !1, A && (A.visible = !1), e = e.entity.id) { case this._displayMeshes.xAxisArrowHandle.id: case this._displayMeshes.xAxisHandle.id: l = this._affordanceMeshes.xAxisArrow, c = s; break; case this._displayMeshes.yAxisArrowHandle.id: case this._displayMeshes.yShaftHandle.id: l = this._affordanceMeshes.yAxisArrow, c = r; break; case this._displayMeshes.zAxisArrowHandle.id: case this._displayMeshes.zAxisHandle.id: l = this._affordanceMeshes.zAxisArrow, c = a; break; case this._displayMeshes.xCurveHandle.id: l = this._affordanceMeshes.xHoop, c = o; break; case this._displayMeshes.yCurveHandle.id: l = this._affordanceMeshes.yHoop, c = n; break; case this._displayMeshes.zCurveHandle.id: l = this._affordanceMeshes.zHoop, c = h; break; default: return void (c = i) }l && (l.visible = !0), A = l, t = !0 } })), this._onCameraControlHoverLeave = this._viewer.cameraControl.on("hoverOut", (e => { this._visible && (A && (A.visible = !1), A = null, c = i) })), g.addEventListener("mousedown", this._canvasMouseDownListener = e => { e.preventDefault(), this._visible && t && (this._viewer.cameraControl.pointerEnabled = !1, 1 === e.which) && (D = !0, e = y(e), u = c, p[0] = e[0], p[1] = e[1]) }), g.addEventListener("mousemove", this._canvasMouseMoveListener = e => { if (this._visible && D) { var t = y(e), i = (e = t[0], t[1]); switch (u) { case s: E(d, p, t); break; case r: E(m, p, t); break; case a: E(f, p, t); break; case o: C(d, p, t); break; case n: C(m, p, t); break; case h: C(f, p, t) }p[0] = e, p[1] = i } }), g.addEventListener("mouseup", this._canvasMouseUpListener = e => { this._visible && (this._viewer.cameraControl.pointerEnabled = !0, D) && (e.which, t = D = !1) }), g.addEventListener("wheel", this._canvasWheelListener = e => { this._visible && Math.max(-1, Math.min(1, 40 * -e.deltaY)) }) } _destroy() { this._unbindEvents(), this._destroyNodes() } _unbindEvents() { var e = (s = this._viewer).scene, t = e.canvas.canvas, i = s.camera, s = s.cameraControl; e.off(this._onSceneTick), t.removeEventListener("mousedown", this._canvasMouseDownListener), t.removeEventListener("mousemove", this._canvasMouseMoveListener), t.removeEventListener("mouseup", this._canvasMouseUpListener), t.removeEventListener("wheel", this._canvasWheelListener), i.off(this._onCameraViewMatrix), i.off(this._onCameraProjMatrix), s.off(this._onCameraControlHover), s.off(this._onCameraControlHoverLeave) } _destroyNodes() { this._setSectionPlane(null), this._rootNode.destroy(), this._displayMeshes = {}, this._affordanceMeshes = {} } } class Plane { constructor(e, t, i) { this.id = i.id, this._sectionPlane = i, this._mesh = new Mesh(t, { id: i.id, geometry: new ReadableGeometry(t, buildBoxGeometry({ xSize: .5, ySize: .5, zSize: .001 })), material: new PhongMaterial(t, { emissive: [1, 1, 1], diffuse: [0, 0, 0], backfaces: !1 }), edgeMaterial: new EdgeMaterial(t, { edgeColor: [0, 0, 0], edgeAlpha: 1, edgeWidth: 1 }), highlightMaterial: new EmphasisMaterial(t, { fill: !0, fillColor: [.5, 1, .5], fillAlpha: .7, edges: !0, edgeColor: [0, 0, 0], edgeAlpha: 1, edgeWidth: 1 }), selectedMaterial: new EmphasisMaterial(t, { fill: !0, fillColor: [0, 0, 1], fillAlpha: .7, edges: !0, edgeColor: [1, 0, 0], edgeAlpha: 1, edgeWidth: 1 }), highlighted: !0, scale: [3, 3, 3], position: [0, 0, 0], rotation: [0, 0, 0], opacity: .3, edges: !0 }); { const e = math.vec3([0, 0, 0]), t = math.vec3(), s = math.vec3([0, 0, 1]), r = math.vec4(4), a = math.vec3(); this._onSectionPlanePos = this._sectionPlane.on("pos", i = () => { var i = this._sectionPlane.scene.center, o = [-this._sectionPlane.dir[0], -this._sectionPlane.dir[1], -this._sectionPlane.dir[2]]; math.subVec3(i, this._sectionPlane.pos, e), i = -math.dotVec3(o, e), math.normalizeVec3(o), math.mulVec3Scalar(o, i, t), o = math.vec3PairToQuaternion(s, this._sectionPlane.dir, r); a[0] = .1 * t[0], a[1] = .1 * t[1], a[2] = .1 * t[2], this._mesh.quaternion = o, this._mesh.position = a }), this._onSectionPlaneDir = this._sectionPlane.on("dir", i) } this._highlighted = !1, this._selected = !1 } setHighlighted(e) { this._highlighted = !!e, this._mesh.highlighted = this._highlighted, this._mesh.highlightMaterial.fillColor = e ? [0, .7, 0] : [0, 0, 0] } getHighlighted() { return this._highlighted } setSelected(e) { this._selected = !!e, this._mesh.edgeMaterial.edgeWidth = e ? 3 : 1, this._mesh.highlightMaterial.edgeWidth = e ? 3 : 1 } getSelected() { return this._selected } destroy() { this._sectionPlane.off(this._onSectionPlanePos), this._sectionPlane.off(this._onSectionPlaneDir), this._mesh.destroy() } } class Overview { constructor(e, t) { if (!(t.onHoverEnterPlane && t.onHoverLeavePlane && t.onClickedNothing && t.onClickedPlane)) throw "Missing config(s): onHoverEnterPlane, onHoverLeavePlane, onClickedNothing || onClickedPlane"; this.plugin = e, this._viewer = e.viewer, this._onHoverEnterPlane = t.onHoverEnterPlane, this._onHoverLeavePlane = t.onHoverLeavePlane, this._onClickedNothing = t.onClickedNothing, this._onClickedPlane = t.onClickedPlane, this._visible = !0, this._planes = {}, this._canvas = t.overviewCanvas, this._scene = new Scene(this._viewer, { canvasId: this._canvas.id, transparent: !0 }), this._scene.clearLights(), new DirLight(this._scene, { dir: [.4, -.4, .8], color: [.8, 1, 1], intensity: 1, space: "view" }), new DirLight(this._scene, { dir: [-.8, -.3, -.4], color: [.8, .8, .8], intensity: 1, space: "view" }), new DirLight(this._scene, { dir: [.8, -.6, -.8], color: [1, 1, 1], intensity: 1, space: "view" }), this._scene.camera, this._scene.camera.perspective.fov = 70, this._zUp = !1; { const e = this._scene.camera, t = math.rotationMat4c(-90 * math.DEGTORAD, 1, 0, 0), i = math.vec3(), s = math.vec3(), r = math.vec3(); this._synchCamera = () => { var a = this._viewer.camera.eye, o = this._viewer.camera.look, n = this._viewer.camera.up; math.mulVec3Scalar(math.normalizeVec3(math.subVec3(a, o, i)), 7), this._zUp ? (math.transformVec3(t, i, s), math.transformVec3(t, n, r), e.look = [0, 0, 0], e.eye = math.transformVec3(t, i, s), e.up = math.transformPoint3(t, n, r)) : (e.look = [0, 0, 0], e.eye = i, e.up = n) } } this._onViewerCameraMatrix = this._viewer.camera.on("matrix", this._synchCamera), this._onViewerCameraWorldAxis = this._viewer.camera.on("worldAxis", this._synchCamera), this._onViewerCameraFOV = this._viewer.camera.perspective.on("fov", (e => { this._scene.camera.perspective.fov = e })); var i = null; this._onInputMouseMove = this._scene.input.on("mousemove", (e => { (e = this._scene.pick({ canvasPos: e })) ? i && e.entity.id === i.id || (i && this._planes[i.id] && this._onHoverLeavePlane(i.id), i = e.entity, this._planes[i.id] && this._onHoverEnterPlane(i.id)) : i && (this._onHoverLeavePlane(i.id), i = null) })), this._scene.canvas.canvas.addEventListener("mouseup", this._onCanvasMouseUp = () => { i ? this._planes[i.id] && this._onClickedPlane(i.id) : this._onClickedNothing() }), this._scene.canvas.canvas.addEventListener("mouseout", this._onCanvasMouseOut = () => { i && (this._onHoverLeavePlane(i.id), i = null) }), this.setVisible(t.overviewVisible) } addSectionPlane(e) { this._planes[e.id] = new Plane(this, this._scene, e) } setPlaneHighlighted(e, t) { (e = this._planes[e]) && e.setHighlighted(t) } setPlaneSelected(e, t) { (e = this._planes[e]) && e.setSelected(t) } removeSectionPlane(e) { var t = this._planes[e.id]; t && (t.destroy(), delete this._planes[e.id]) } setVisible(e = !0) { this._visible = e, this._canvas.style.visibility = e ? "visible" : "hidden" } getVisible() { return this._visible } destroy() { this._viewer.camera.off(this._onViewerCameraMatrix), this._viewer.camera.off(this._onViewerCameraWorldAxis), this._viewer.camera.perspective.off(this._onViewerCameraFOV), this._scene.input.off(this._onInputMouseMove), this._scene.canvas.canvas.removeEventListener("mouseup", this._onCanvasMouseUp), this._scene.canvas.canvas.removeEventListener("mouseout", this._onCanvasMouseOut), this._scene.destroy() } } const tempAABB = math.AABB3(), tempVec3 = math.vec3(); class SectionPlanesPlugin extends Plugin { constructor(e, t = {}) { var i; super("SectionPlanes", e), this._freeControls = [], this._sectionPlanes = e.scene.sectionPlanes, this._controls = {}, (this._shownControlId = null) !== t.overviewCanvasId && void 0 !== t.overviewCanvasId && ((i = document.getElementById(t.overviewCanvasId)) ? this._overview = new Overview(this, { overviewCanvas: i, visible: t.overviewVisible, onHoverEnterPlane: e => { this._overview.setPlaneHighlighted(e, !0) }, onHoverLeavePlane: e => { this._overview.setPlaneHighlighted(e, !1) }, onClickedPlane: e => { this.getShownControl() === e ? this.hideControl() : (this.showControl(e), e = this.sectionPlanes[e].pos, tempAABB.set(this.viewer.scene.aabb), math.getAABB3Center(tempAABB, tempVec3), tempAABB[0] += e[0] - tempVec3[0], tempAABB[1] += e[1] - tempVec3[1], tempAABB[2] += e[2] - tempVec3[2], tempAABB[3] += e[0] - tempVec3[0], tempAABB[4] += e[1] - tempVec3[1], tempAABB[5] += e[2] - tempVec3[2], this.viewer.cameraFlight.flyTo({ aabb: tempAABB, fitFOV: 65 })) }, onClickedNothing: () => { this.hideControl() } }) : this.warn("Can't find overview canvas: '" + t.overviewCanvasId + "' - will create plugin without overview")), this._onSceneSectionPlaneCreated = e.scene.on("sectionPlaneCreated", (e => { this._sectionPlaneCreated(e) })) } setOverviewVisible(e) { this._overview && this._overview.setVisible(e) } getOverviewVisible() { if (this._overview) return this._overview.getVisible() } get sectionPlanes() { return this._sectionPlanes } createSectionPlane(e = {}) { return void 0 !== e.id && null !== e.id && this.viewer.scene.components[e.id] && (this.error("Viewer component with this ID already exists: " + e.id), delete e.id), new SectionPlane(this.viewer.scene, { id: e.id, pos: e.pos, dir: e.dir, active: !0 }) } _sectionPlaneCreated(e) { var t = 0 < this._freeControls.length ? this._freeControls.pop() : new Control(this); t._setSectionPlane(e), t.setVisible(!1), this._controls[e.id] = t, this._overview && this._overview.addSectionPlane(e), e.once("destroyed", (() => { this._sectionPlaneDestroyed(e) })) } flipSectionPlanes() { var e, t = this.viewer.scene.sectionPlanes; for (e in t) t[e].flipDir() } showControl(e) { var t = this._controls[e]; t ? (this.hideControl(), t.setVisible(!0), this._overview && this._overview.setPlaneSelected(e, !0), this._shownControlId = e) : this.error("Control not found: " + e) } getShownControl() { return this._shownControlId } hideControl() { for (var e in this._controls) this._controls.hasOwnProperty(e) && (this._controls[e].setVisible(!1), this._overview) && this._overview.setPlaneSelected(e, !1); this._shownControlId = null } destroySectionPlane(e) { var t = this.viewer.scene.sectionPlanes[e]; t ? (this._sectionPlaneDestroyed(t), t.destroy(), e === this._shownControlId && (this._shownControlId = null)) : this.error("SectionPlane not found: " + e) } _sectionPlaneDestroyed(e) { this._overview && this._overview.removeSectionPlane(e); var t = this._controls[e.id]; t && (t.setVisible(!1), t._setSectionPlane(null), delete this._controls[e.id], this._freeControls.push(t)) } clear() { for (var e = Object.keys(this._sectionPlanes), t = 0, i = e.length; t < i; t++)this.destroySectionPlane(e[t]) } send(e, t) { switch (e) { case "snapshotStarting": for (var i in this._controls) this._controls.hasOwnProperty(i) && this._controls[i].setCulled(!0); break; case "snapshotFinished": for (var s in this._controls) this._controls.hasOwnProperty(s) && this._controls[s].setCulled(!1); break; case "clearSectionPlanes": this.clear() } } destroy() { this.clear(), this._overview && this._overview.destroy(), this._destroyFreeControls(), super.destroy() } _destroyFreeControls() { for (var e = this._freeControls.pop(); e;)e._destroy(), e = this._freeControls.pop(); this.viewer.scene.off(this._onSceneSectionPlaneCreated) } } class SkyboxesPlugin extends Plugin { constructor(e) { super("skyboxes", e), this.skyboxes = {} } send(e, t) { "clear" === e && this.clear() } createSkybox(e, t) { return this.viewer.scene.components[e] ? (this.error("Component with this ID already exists: " + e), this) : (t = new Skybox(this.viewer.scene, { id: e, pos: t.pos, dir: t.dir, active: !0 }), this.skyboxes[e] = t) } destroySkybox(e) { var t = this.skyboxes[e]; t ? t.destroy() : this.error("Skybox not found: " + e) } clear() { for (var e = Object.keys(this.viewer.scene.skyboxes), t = 0, i = e.length; t < i; t++)this.destroySkybox(e[t]) } destroy() { this.clear(), super.clear() } } class STLDefaultDataSource { getSTL(e, t, i) { const s = new XMLHttpRequest; s.overrideMimeType("application/json"), s.open("GET", e, !0), s.responseType = "arraybuffer", s.onreadystatechange = function () { 4 === s.readyState && (200 === s.status ? t(s.response) : i(s.statusText)) }, s.send(null) } } const tempVec3a$3 = math.vec3(); class STLSceneGraphLoader { load(e, t, i, s, r, a) { s = s || {}; const o = e.viewer.scene.canvas.spinner; o.processes++, e.dataSource.getSTL(i, (function (i) { parse(e, t, i, s); try { var n = ensureBinary(i); isBinary(n) ? parseBinary(e, n, t, s) : parseASCII(e, ensureString(i), t, s), o.processes--, core.scheduleTask((function () { t.fire("loaded", !0, !1) })), r && r() } catch (i) { o.processes--, e.error(i), a && a(i), t.fire("error", i) } }), (function (i) { o.processes--, e.error(i), a && a(i), t.fire("error", i) })) } parse(e, t, i, s) { var r = e.viewer.scene.canvas.spinner; r.processes++; try { var a = ensureBinary(i); isBinary(a) ? parseBinary(e, a, t, s) : parseASCII(e, ensureString(i), t, s), r.processes--, core.scheduleTask((function () { t.fire("loaded", !0, !1) })) } catch (e) { r.processes--, t.fire("error", e) } } } function parse(e, t, i, s) { try { var r = ensureBinary(i); isBinary(r) ? parseBinary(e, r, t, s) : parseASCII(e, ensureString(i), t, s) } catch (e) { t.fire("error", e) } } function isBinary(e) { var t = new DataView(e); if (84 + 50 * t.getUint32(80, !0) === t.byteLength) return !0; for (var i = [115, 111, 108, 105, 100], s = 0; s < 5; s++)if (i[s] !== t.getUint8(s, !1)) return !0; return !1 } function parseBinary(e, t, i, s) { var r = new DataView(t), a = r.getUint32(80, !0); let o, n, h, l, c, u, p, d = !1, m = null, f = null, g = null, _ = !1; for (let e = 0; e < 70; e++)1129270351 === r.getUint32(e, !1) && 82 === r.getUint8(e + 4) && 61 === r.getUint8(e + 5) && (d = !0, l = [], c = r.getUint8(e + 6) / 255, u = r.getUint8(e + 7) / 255, p = r.getUint8(e + 8) / 255, r.getUint8(e + 9)); var v = new MetallicMaterial(i, { roughness: .5 }); let y = [], T = []; var I = s.splitMeshes; for (let e = 0; e < a; e++) { var E, C = 84 + 50 * e, P = r.getFloat32(C, !0), b = r.getFloat32(4 + C, !0), A = r.getFloat32(8 + C, !0); d && (h = 32768 & (E = r.getUint16(48 + C, !0)) ? (o = c, n = u, p) : (o = (31 & E) / 31, n = (E >> 5 & 31) / 31, (E >> 10 & 31) / 31), I && o !== m || n !== f || h !== g) && (null !== m && (_ = !0), m = o, f = n, g = h); for (let e = 1; e <= 3; e++) { var D = C + 12 * e; y.push(r.getFloat32(D, !0)), y.push(r.getFloat32(4 + D, !0)), y.push(r.getFloat32(8 + D, !0)), T.push(P, b, A), d && l.push(o, n, h, 1) } I && _ && (addMesh(i, y, T, l, v, s), y = [], T = [], l = l ? [] : null, _ = !1) } 0 < y.length && addMesh(i, y, T, l, v, s) } function parseASCII(e, t, i, s) { var r = /facet([\s\S]*?)endfacet/g; let a = 0; var o, n = /[\s]+([+-]?(?:\d+.\d+|\d+.|\d+|.\d+)(?:[eE][+-]?\d+)?)/.source, h = new RegExp("vertex" + n + n + n, "g"), l = new RegExp("normal" + n + n + n, "g"), c = [], u = []; let p, d, m, f, g, _; for (; null !== (f = r.exec(t));) { for (g = 0, _ = 0, o = f[0]; null !== (f = l.exec(o));)p = parseFloat(f[1]), d = parseFloat(f[2]), m = parseFloat(f[3]), _++; for (; null !== (f = h.exec(o));)c.push(parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3])), u.push(p, d, m), g++; 1 !== _ && e.error("Error in normal of face " + a), 3 !== g && e.error("Error in positions of face " + a), a++ } addMesh(i, c, u, null, new MetallicMaterial(i, { roughness: .5 }), s) } function addMesh(e, t, i, s, r, a) { var o = new Int32Array(t.length / 3); for (let e = 0, t = o.length; e < t; e++)o[e] = e; i = i && 0 < i.length ? i : null, s = s && 0 < s.length ? s : null, a.smoothNormals && math.faceToVertexNormals(t, i, a); var n = tempVec3a$3; worldToRTCPositions(t, t, n), t = new ReadableGeometry(e, { primitive: "triangles", positions: t, normals: i, colors: s, indices: o }), i = new Mesh(e, { origin: 0 !== n[0] || 0 !== n[1] || 0 !== n[2] ? n : null, geometry: t, material: r, edges: a.edges }); e.addChild(i) } function ensureString(e) { return "string" != typeof e ? decodeText(new Uint8Array(e)) : e } function ensureBinary(e) { if ("string" != typeof e) return e; var t = new Uint8Array(e.length); for (let i = 0; i < e.length; i++)t[i] = 255 & e.charCodeAt(i); return t.buffer || t } function decodeText(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let i = 0, s = e.length; i < s; i++)t += String.fromCharCode(e[i]); return decodeURIComponent(escape(t)) } class STLLoaderPlugin extends Plugin { constructor(e, t = {}) { super("STLLoader", e, t), this._sceneGraphLoader = new STLSceneGraphLoader, this.dataSource = t.dataSource } set dataSource(e) { this._dataSource = e || new STLDefaultDataSource } get dataSource() { return this._dataSource } load(e) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); var t = new Node$1(this.viewer.scene, utils.apply(e, { isModel: !0 })), i = e.src, s = e.stl; return i || s ? i ? this._sceneGraphLoader.load(this, t, i, e) : this._sceneGraphLoader.parse(this, t, s, e) : this.error("load() param expected: either 'src' or 'stl'"), t } } class Storey { constructor(e, t, i, s, r) { this.plugin = e, this.storeyId = s, this.modelId = i, this.aabb = t.slice(), this.numObjects = r } } const IFCStoreyPlanObjectStates = { IfcSlab: { visible: !0, edges: !1, colorize: [1, 1, 1, 1] }, IfcWall: { visible: !0, edges: !1, colorize: [.1, .1, .1, 1] }, IfcWallStandardCase: { visible: !0, edges: !1, colorize: [.1, .1, .1, 1] }, IfcDoor: { visible: !0, edges: !1, colorize: [.5, .5, .5, 1] }, IfcWindow: { visible: !0, edges: !1, colorize: [.5, .5, .5, 1] }, IfcColumn: { visible: !0, edges: !1, colorize: [.5, .5, .5, 1] }, IfcCurtainWall: { visible: !0, edges: !1, colorize: [.5, .5, .5, 1] }, IfcStair: { visible: !0, edges: !1, colorize: [.7, .7, .7, 1] }, IfcStairFlight: { visible: !0, edges: !1, colorize: [.7, .7, .7, 1] }, IfcRamp: { visible: !0, edges: !1, colorize: [.7, .7, .7, 1] }, IfcFurniture: { visible: !0, edges: !1, colorize: [.7, .7, .7, 1] }, IfcFooting: { visible: !0, edges: !1, colorize: [.7, .7, .7, 1] }, IfcFloor: { visible: !0, edges: !1, colorize: [1, 1, 1, 1] }, DEFAULT: { visible: !1 } }; class StoreyMap { constructor(e, t, i, s, r, a) { this.storeyId = e, this.imageData = t, this.format = i, this.width = s, this.height = r } } const tempVec3a$2 = math.vec3(), tempMat4 = math.mat4(), EMPTY_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="; class StoreyViewsPlugin extends Plugin { constructor(e, t = {}) { super("StoreyViews", e), this._objectsMemento = new ObjectsMemento, this._cameraMemento = new CameraMemento, this.storeys = {}, this.modelStoreys = {}, this.objectStates = t.objectStates, this._onModelLoaded = this.viewer.scene.on("modelLoaded", (e => { this._registerModelStoreys(e), this.fire("storeys", this.storeys) })) } _registerModelStoreys(e) { var t = (s = this.viewer).scene, i = s.metaScene, s = i.metaModels[e], r = t.models[e]; if (s && s.rootMetaObject) { var a = s.rootMetaObject.getObjectIDsInSubtreeByType(["IfcBuildingStorey"]); for (let s = 0, l = a.length; s < l; s++) { var o = a[s], n = i.metaObjects[o].getObjectIDsInSubtree(), h = t.getAABB(n); n = .5 < Math.random() ? n.length : 0; (h = new Storey(this, h, e, o, n))._onModelDestroyed = r.once("destroyed", (() => { this._deregisterModelStoreys(e), this.fire("storeys", this.storeys) })), this.storeys[o] = h, this.modelStoreys[e] || (this.modelStoreys[e] = {}), this.modelStoreys[e][o] = h } } } _deregisterModelStoreys(e) { var t = this.modelStoreys[e]; if (t) { var i, s, r, a = this.viewer.scene; for (i in t) t.hasOwnProperty(i) && (s = t[i], (r = a.models[s.modelId]) && r.off(s._onModelDestroyed), delete this.storeys[i]); delete this.modelStoreys[e] } } set objectStates(e) { this._objectStates = e || IFCStoreyPlanObjectStates } get objectStates() { return this._objectStates } gotoStoreyCamera(e, t = {}) { var i, s, r, a, o, n = this.storeys[e]; n ? (s = (i = this.viewer).scene.camera, (n = n.aabb)[3] < n[0] || n[4] < n[1] || n[5] < n[2] || n[3] === n[0] && n[4] === n[1] && n[5] === n[2] ? t.done && t.done() : (r = math.getAABB3Center(n), n = math.getAABB3Diag(n), o = Math.abs(n / Math.tan(45 * math.DEGTORAD)), n *= 1.3, (a = tempVec3a$2)[0] = r[0] + s.worldUp[0] * o, a[1] = r[1] + s.worldUp[1] * o, a[2] = r[2] + s.worldUp[2] * o, o = s.worldForward, t.done ? i.cameraFlight.flyTo(utils.apply(t, { eye: a, look: r, up: o, orthoScale: n }), (() => { t.done() })) : (i.cameraFlight.jumpTo(utils.apply(t, { eye: a, look: r, up: o, orthoScale: n })), i.camera.ortho.scale = n))) : (this.error("IfcBuildingStorey not found with this ID: " + e), t.done && t.done()) } showStoreyObjects(e, t = {}) { var i, s; this.storeys[e] ? (s = (i = this.viewer).scene, i.metaScene.metaObjects[e] && (t.hideOthers && s.setObjectsVisible(i.scene.visibleObjectIds, !1), this.withStoreyObjects(e, ((e, i) => { e && (t.useObjectStates ? (i = this._objectStates[i.type] || this._objectStates.DEFAULT) && (e.visible = i.visible, e.edges = i.edges, i.colorize && (e.colorize = i.colorize), null !== i.opacity) && void 0 !== i.opacity && (e.opacity = i.opacity) : e.visible = !0) })))) : this.error("IfcBuildingStorey not found with this ID: " + e) } withStoreyObjects(e, t) { var i = this.viewer, s = i.scene, r = i.metaScene; if (i = r.metaObjects[e]) for (var a = i.getObjectIDsInSubtree(), o = 0, n = a.length; o < n; o++) { var h = a[o], l = r.metaObjects[h]; (h = s.objects[h]) && t(h, l) } } createStoreyMap(e, t = {}) { var i = this.storeys[e]; if (!i) return this.error("IfcBuildingStorey not found with this ID: " + e), EMPTY_IMAGE; var s = this.viewer, r = s.scene, a = t.format || "png", o = ((o = i.aabb)[5] - o[2]) / (o[3] - o[0]), n = t.padding || 0; let h, l; return t.width && t.height ? (h = t.width, l = t.height) : t.height ? (l = t.height, h = l / o) : l = (h = t.width || 300) * o, this._objectsMemento.saveObjects(r), this._cameraMemento.saveCamera(r), s.beginSnapshot(), this.showStoreyObjects(e, utils.apply(t, { useObjectStates: !0, hideOthers: !0 })), this._arrangeStoreyMapCamera(i), o = s.getSnapshot({ width: h, height: l, format: a }), this._objectsMemento.restoreObjects(r), this._cameraMemento.restoreCamera(r), s.endSnapshot(), new StoreyMap(e, o, a, h, l, n) } _arrangeStoreyMapCamera(e) { var t = this.viewer, i = t.scene.camera, s = (e = e.aabb, math.getAABB3Center(e)), r = (i = ((r = tempVec3a$2)[0] = s[0] + .5 * i.worldUp[0], r[1] = s[1] + .5 * i.worldUp[1], r[2] = s[2] + .5 * i.worldUp[2], i.worldForward), t.cameraFlight.jumpTo({ eye: r, look: s, up: i }), (e[3] - e[0]) / 2), a = (s = (e[4] - e[1]) / 2, i = (e[5] - e[2]) / 2, e = -r, -s), o = -i; t.camera.customProjection.matrix = math.orthoMat4c(e, r, o, i, a, s, tempMat4), t.camera.projection = "customProjection" } pickStoreyMap(e, t, i = {}) { var s, r, a, o, n, h = e.storeyId; return (s = this.storeys[h]) ? (h = 1 - t[0] / e.width, t = 1 - t[1] / e.height, s = (e = s.aabb)[0], a = e[1], n = e[2], r = e[3] - s, o = e[4] - a, e = e[5] - n, s = math.vec3([s + r * h, a + .5 * o, n + e * t]), r = math.vec3([0, -1, 0]), h = math.addVec3(s, r, tempVec3a$2), a = this.viewer.camera.worldForward, o = math.lookAtMat4v(s, h, a, tempMat4), !(n = this.viewer.scene.pick({ pickSurface: i.pickSurface, pickInvisible: !0, matrix: o })) || (e = this.viewer.metaScene.metaObjects[n.entity.id], (t = this.objectStates[e.type]) && t.visible) ? n : null) : (this.error("IfcBuildingStorey not found with this ID: " + h), null) } getStoreyContainingWorldPos(e) { for (var t in this.storeys) { var i = this.storeys[t]; if (math.point3AABB3Intersect(i.aabb, e)) return t } return null } worldPosToStoreyMap(e, t, i) { var s, r, a, o, n, h, l, c, u = e.storeyId, p = this.storeys[u]; return p ? (s = (p = p.aabb)[0], r = p[1], a = p[2], o = p[3], n = p[4], p = p[5], h = !(l = (c = this.viewer.camera.worldUp)[0] > c[1] && c[0] > c[2]) && c[1] > c[0] && c[1] > c[2], !l && !h && c[2] > c[0] && (c[2], c[1]), l = e.width / (o - s), c = h ? e.height / (p - a) : e.height / (n - r), i[0] = Math.floor(e.width - (t[0] - s) * l), i[1] = Math.floor(e.height - (t[2] - a) * c), 0 <= i[0] && i[0] < e.width && 0 <= i[1] && i[1] <= e.height) : (this.error("IfcBuildingStorey not found with this ID: " + u), !1) } worldDirToStoreyMap(e, t, i) { var s = this.viewer.camera, r = s.eye, a = s.look, o = (a = math.subVec3(a, r, tempVec3a$2), !(s = (r = s.worldUp)[0] > r[1] && r[0] > r[2]) && r[1] > r[0] && r[1] > r[2]); !s && !o && r[2] > r[0] && (r[2], r[1]), s ? (i[0] = a[1], i[1] = a[2]) : o ? (i[0] = a[0], i[1] = a[2]) : (i[0] = a[0], i[1] = a[1]), math.normalizeVec2(i) } destroy() { this.viewer.scene.off(this._onModelLoaded), super.destroy() } } function validateMetaModelForTreeViewTypesHierarchy(e, t) { return !!e.rootMetaObject || (t.push("Can't build types hierarchy: model is empty"), !1) } function validateMetaModelForTreeViewStoreysHierarchy(e, t) { return (e = e.rootMetaObject) ? _validateMetaModelForStoreysHierarchy(e, t) : (t.push("Can't build storeys hierarchy: model is empty"), !1) } function validateMetaModelForTreeViewContainmentHierarchy(e, t) { return !!e.rootMetaObject || (t.push("Can't build containment hierarchy: model is empty"), !1) } function _validateMetaModelForStoreysHierarchy(e, t, i = 0, s, r) { s = s || { foundIFCBuildingStoreys: !1 }; var a = e.type, o = e.children; if ("IfcBuilding" === a) r = !0; else if ("IfcBuildingStorey" === a) { if (!r) return t.push("Can't build storeys hierarchy: IfcBuildingStorey found without parent IfcBuilding"), !1; s.foundIFCBuildingStoreys = !0 } if (o) for (let e = 0, a = o.length; e < a; e++)if (!_validateMetaModelForStoreysHierarchy(o[e], t, i + 1, s, r)) return !1; return 0 === i && s.foundIFCBuildingStoreys, !0 } const idMap = new Map$1; class ModelTreeView { constructor(e, t, i, s, r) { if (!r.containerElement) throw "Config expected: containerElement"; var a = s.rootMetaObject; a && (this.errors = [], this.valid = !0, this.metaModel = s, this._id = idMap.addItem(), this._baseId = "" + this._id, this._viewer = e, this._treeViewPlugin = t, this._rootMetaObject = a, this._containerElement = r.containerElement, this._rootElement = null, this._muteSceneEvents = !1, this._muteTreeEvents = !1, this._rootNodes = [], this._objectNodes = {}, this._rootName = r.rootName, this._sortNodes = r.sortNodes, this._pruneEmptyNodes = r.pruneEmptyNodes, this._showListItemElementId = null, this._containerElement.oncontextmenu = e => { e.preventDefault() }, this._onObjectVisibility = this._viewer.scene.on("objectVisibility", (e => { if (!this._muteSceneEvents) { var t = e.id; if (t = this._objectNodes[t]) { var i = e.visible; if (i !== t.checked) { this._muteTreeEvents = !0, (t.checked = i) ? t.numVisibleEntities++ : t.numVisibleEntities--, (e = document.getElementById(t.nodeId)) && (e.checked = i); let a = t.parent; for (; a;) { (a.checked = i) ? a.numVisibleEntities++ : a.numVisibleEntities--; var s, r = document.getElementById(a.nodeId); r && (s = 0 < a.numVisibleEntities) !== r.checked && (r.checked = s), a = a.parent } this._muteTreeEvents = !1 } } } })), this._onObjectXrayed = this._viewer.scene.on("objectXRayed", (e => { var t; this._muteSceneEvents || (t = e.id, (t = this._objectNodes[t]) && (this._muteTreeEvents = !0, (e = e.xrayed) !== t.xrayed) && (t.xrayed = e, t = "node-" + t.nodeId, null !== (t = document.getElementById(t)) && (e ? t.classList.add("xrayed-node") : t.classList.remove("xrayed-node")), this._muteTreeEvents = !1)) })), this.switchExpandHandler = e => { e.preventDefault(), e.stopPropagation(), e = e.target, this._expandSwitchElement(e) }, this.switchCollapseHandler = e => { e.preventDefault(), e.stopPropagation(), e = e.target, this._collapseSwitchElement(e) }, this._checkboxChangeHandler = e => { if (!this._muteTreeEvents) { this._muteSceneEvents = !0; const s = (e = e.target).checked, r = (e = e.id, e = this._nodeToObjectID(e), e = this._objectNodes[e], this._viewer.scene.objects); let a = 0, o = (this._withNodeTree(e, (e => { var t = e.objectId, i = e.nodeId, o = (t = r[t], 0 === e.children.length); e.numVisibleEntities = s ? e.numEntities : 0, o && s !== e.checked && a++, e.checked = s, (o = document.getElementById(i)) && (o.checked = s), t && (t.visible = s) })), e.parent); for (; o;) { o.checked = s; var t = document.getElementById(o.nodeId), i = (s ? o.numVisibleEntities += a : o.numVisibleEntities -= a, 0 < o.numVisibleEntities); i !== t.checked && (t.checked = i), o = o.parent } this._muteSceneEvents = !1 } }, this._hierarchy = r.hierarchy || "containment", this._autoExpandDepth = r.autoExpandDepth || 0, this._createNodes()) } _nodeToObjectID(e) { return e.substring(this._baseId.length) } _objectToNodeID(e) { return this._baseId + e } setAutoExpandDepth(e = 0) { this._autoExpandDepth = e } setHierarchy(e) { this._hierarchy !== e && (this._hierarchy = e, this._createNodes()) } _createNodes() { this._rootElement && (this._rootElement.parentNode.removeChild(this._rootElement), this._rootElement = null), this._rootNodes = [], this._objectNodes = {}, this._validate(), this.valid || "storeys" !== this._hierarchy ? this._createEnabledNodes() : this._createDisabledNodes() } _validate() { switch (this.errors = [], this._hierarchy) { case "storeys": this.valid = validateMetaModelForTreeViewStoreysHierarchy(this.metaModel, this.errors); break; case "types": this.valid = validateMetaModelForTreeViewTypesHierarchy(this.metaModel, this.errors); break; default: this.valid = validateMetaModelForTreeViewContainmentHierarchy(this.metaModel, this.errors) }return this.valid } _createEnabledNodes() { switch (this._pruneEmptyNodes && this._findEmptyNodes(), this._hierarchy) { case "storeys": this._createStoreysNodes(), 0 === this._rootNodes.length && this._treeViewPlugin.error("Failed to build storeys hierarchy for model '" + this.metaModel.id + "' - perhaps this model is not an IFC model?"); break; case "types": this._createTypesNodes(); break; default: this._createContainmentNodes() }this._sortNodes && this._doSortNodes(), this._synchNodesToEntities(), this._createTrees(), this.expandToDepth(this._autoExpandDepth) } _createDisabledNodes() { var e = (t = this._rootMetaObject).type, t = (t = t.name) && "" !== t && "Undefined" !== t && "Default" !== t ? t : e, i = (e = document.createElement("ul"), document.createElement("li")); e.appendChild(i), this._containerElement.appendChild(e), this._rootElement = e, (e = document.createElement("a")).href = "#", e.textContent = "!", e.classList.add("warn"), e.classList.add("warning"), i.appendChild(e), (e = document.createElement("span")).textContent = t, i.appendChild(e) } _findEmptyNodes(e = this._rootMetaObject, t) { var i = this._treeViewPlugin.viewer.scene, s = e.children, r = e.id; i = i.objects[r]; if (e._countEntities = 0, i && e._countEntities++, s) for (let t = 0, i = s.length; t < i; t++) { var a = s[t]; a._countEntities = this._findEmptyNodes(a), e._countEntities += a._countEntities } return e._countEntities } _createStoreysNodes(e = this._rootMetaObject, t, i, s) { if (!this._pruneEmptyNodes || 0 !== e._countEntities) { var r = e.type, a = e.name, o = e.children; e = e.id; if ("IfcBuilding" === r) t = { nodeId: this._objectToNodeID(e), objectId: e, title: this._rootName || (a && "" !== a && "Undefined" !== a && "Default" !== a ? a : r), type: r, parent: null, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, this._rootNodes.push(t), this._objectNodes[t.objectId] = t; else if ("IfcBuildingStorey" === r) { if (!t) return void this._treeViewPlugin.error("Failed to build storeys hierarchy for model '" + this.metaModel.id + "' - model does not have an IfcBuilding object, or is not an IFC model"); i = { nodeId: this._objectToNodeID(e), objectId: e, title: a && "" !== a && "Undefined" !== a && "Default" !== a ? a : r, type: r, parent: t, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, t.children.push(i), this._objectNodes[i.objectId] = i, s = {} } else if (i && this._viewer.scene.objects[e]) { let t = (s = s || {})[r]; t || (n = i.objectId + "." + r, t = { nodeId: h = this._objectToNodeID(n), objectId: n, title: r, type: r, parent: i, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, i.children.push(t), this._objectNodes[n] = t, s[r] = t); var n, h = { nodeId: this._objectToNodeID(e), objectId: e, title: a && "" !== a && "Undefined" !== a && "Default" !== a ? a : r, type: r, parent: t, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }; t.children.push(h), this._objectNodes[h.objectId] = h } if (o) for (let e = 0, r = o.length; e < r; e++) { var l = o[e]; this._createStoreysNodes(l, t, i, s) } } } _createTypesNodes(e = this._rootMetaObject, t, i) { if (!this._pruneEmptyNodes || 0 !== e._countEntities) { var s = e.type, r = e.name, a = e.children, o = e.id; if (e.id === this._rootMetaObject.id) t = { nodeId: this._objectToNodeID(o), objectId: o, title: this._rootName || (r && "" !== r && "Undefined" !== r && "Default" !== r ? r : s), type: s, parent: null, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, this._rootNodes.push(t), this._objectNodes[t.objectId] = t, i = {}; else if (t && this._viewer.scene.objects[o]) { let a = i[s]; a || (a = { nodeId: this._objectToNodeID(t.objectId + "." + s), objectId: t.objectId + "." + s, title: s, type: s, parent: t, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, t.children.push(a), this._objectNodes[a.objectId] = a, i[s] = a), e = { nodeId: this._objectToNodeID(o), objectId: o, title: r && "" !== r && "Default" !== r ? r : s, type: s, parent: a, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }, a.children.push(e), this._objectNodes[e.objectId] = e } if (a) for (let e = 0, s = a.length; e < s; e++) { var n = a[e]; this._createTypesNodes(n, t, i) } } } _createContainmentNodes(e = this._rootMetaObject, t) { if (!this._pruneEmptyNodes || 0 !== e._countEntities) { var i = e.type, s = e.name || i, r = e.children, a = (e = e.id, { nodeId: this._objectToNodeID(e), objectId: e, title: t ? s && "" !== s && "Undefined" !== s && "Default" !== s ? s : i : this._rootName || s, type: i, parent: t, numEntities: 0, numVisibleEntities: 0, checked: !1, xrayed: !1, children: [] }); if ((t ? t.children : this._rootNodes).push(a), this._objectNodes[a.objectId] = a, r) for (let e = 0, t = r.length; e < t; e++) { var o = r[e]; this._createContainmentNodes(o, a) } } } _doSortNodes() { for (let t = 0, i = this._rootNodes.length; t < i; t++) { var e = this._rootNodes[t]; this._sortChildren(e) } } _sortChildren(e) { var t = e.children; if (t && 0 !== t.length) { "storeys" === this._hierarchy && "IfcBuilding" === e.type ? t.sort(this._getSpatialSortFunc()) : t.sort(this._alphaSortFunc); for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; this._sortChildren(i) } } } _getSpatialSortFunc() { var e = this._treeViewPlugin.viewer; const t = e.scene, i = t.camera, s = e.metaScene; return this._spatialSortFunc || (this._spatialSortFunc = (e, r) => { e.aabb && r.aabb || (e.aabb || (e.aabb = t.getAABB(s.getObjectIDsInSubtree(e.objectId))), r.aabb) || (r.aabb = t.getAABB(s.getObjectIDsInSubtree(r.objectId))); var a = i.xUp ? 0 : i.yUp ? 1 : 2; return e.aabb[a] > r.aabb[a] ? -1 : e.aabb[a] < r.aabb[a] ? 1 : 0 }) } _alphaSortFunc(e, t) { return (e = e.title.toUpperCase()) < (t = t.title.toUpperCase()) ? -1 : t < e ? 1 : 0 } _synchNodesToEntities() { var e = this._rootMetaObject.getObjectIDsInSubtree(), t = this._viewer.metaScene.metaObjects, i = this._viewer.scene.objects; for (let o = 0, n = e.length; o < n; o++) { var s = e[o]; if (t[s]) { var r = this._objectNodes[s]; if (r && (s = i[s])) { var a = s.visible; r.numEntities = 1, r.xrayed = s.xrayed, a ? (r.numVisibleEntities = 1, r.checked = !0) : (r.numVisibleEntities = 0, r.checked = !1); let e = r.parent; for (; e;)e.numEntities++, a && (e.numVisibleEntities++, e.checked = !0), e = e.parent } } } } _withNodeTree(e, t) { t(e); var i = e.children; if (i) for (let e = 0, s = i.length; e < s; e++)this._withNodeTree(i[e], t) } _createTrees() { if (0 !== this._rootNodes.length) { var e = this._rootNodes.map((e => this._createNodeElement(e))); const t = document.createElement("ul"); e.forEach((e => { t.appendChild(e) })), this._containerElement.appendChild(t), this._rootElement = t } } _createNodeElement(e) { var t = document.createElement("li"), i = e.nodeId, s = (e.xrayed && t.classList.add("xrayed-node"), t.id = "node-" + i, 0 < e.children.length && (s = "switch-" + i, (r = document.createElement("a")).href = "#", r.id = s, r.textContent = "+", r.classList.add("plus"), r.addEventListener("click", this.switchExpandHandler), t.appendChild(r)), document.createElement("input")), r = (s.id = i, s.type = "checkbox", s.checked = e.checked, s.style["pointer-events"] = "all", s.addEventListener("change", this._checkboxChangeHandler), t.appendChild(s), document.createElement("span")); return r.textContent = e.title, t.appendChild(r), r.oncontextmenu = t => { this._treeViewPlugin.fire("contextmenu", { event: t, viewer: this._viewer, treeViewPlugin: this._treeViewPlugin, treeViewNode: e }), t.preventDefault() }, r.onclick = t => { this._treeViewPlugin.fire("nodeTitleClicked", { event: t, viewer: this._viewer, treeViewPlugin: this._treeViewPlugin, treeViewNode: e }), t.preventDefault() }, t } expandToDepth(e) { const t = (i, s) => { if (s !== e) { var r = i.nodeId; if (r = document.getElementById("switch-" + r)) { this._expandSwitchElement(r); for (var a = i.children, o = 0, n = a.length; o < n; o++) { var h = a[o]; t(h, s + 1) } } } }; for (let e = 0, s = this._rootNodes.length; e < s; e++) { var i = this._rootNodes[e]; t(i, 0) } } collapse() { for (let t = 0, i = this._rootNodes.length; t < i; t++) { var e = this._rootNodes[t].objectId; this._collapseNode(e) } } showNode(e) { this._showListItemElementId && this.unShowNode(); const t = this._objectNodes[e]; if (t) { var i = t.nodeId, s = document.getElementById("switch-" + i); if (s) this._expandSwitchElement(s), s.scrollIntoView(); else { var r = []; r.unshift(t); let a = t.parent; for (; a;)r.unshift(a), a = a.parent; for (let e = 0, t = r.length; e < t; e++) { const t = "switch-" + r[e].nodeId, i = document.getElementById(t); i && this._expandSwitchElement(i) } e = "node-" + i, (s = document.getElementById(e)).scrollIntoView({ block: "center" }), s.classList.add("highlighted-node"), this._showListItemElementId = e } } } unShowNode() { var e; this._showListItemElementId && ((e = document.getElementById(this._showListItemElementId)) && e.classList.remove("highlighted-node"), this._showListItemElementId = null) } _expandSwitchElement(e) { var t = e.parentElement, i = t.getElementsByTagName("li")[0]; if (!i) { i = t.id.replace("node-", ""), i = this._nodeToObjectID(i), i = this._objectNodes[i].children.map((e => this._createNodeElement(e))); const s = document.createElement("ul"); i.forEach((e => { s.appendChild(e) })), t.appendChild(s), e.classList.remove("plus"), e.classList.add("minus"), e.textContent = "-", e.removeEventListener("click", this.switchExpandHandler), e.addEventListener("click", this.switchCollapseHandler) } } _collapseNode(e) { e = this._objectToNodeID(e), e = document.getElementById("switch-" + e), this._collapseSwitchElement(e) } _collapseSwitchElement(e) { var t, i; e && (t = e.parentElement) && (i = t.querySelector("ul")) && (t.removeChild(i), e.classList.remove("minus"), e.classList.add("plus"), e.textContent = "+", e.removeEventListener("click", this.switchCollapseHandler), e.addEventListener("click", this.switchExpandHandler)) } destroy() { this._rootElement && !this._destroyed && (this._rootElement.parentNode.removeChild(this._rootElement), this._viewer.scene.off(this._onObjectVisibility), this._destroyed = !0, idMap.removeItem(this._id)) } } class TreeViewPlugin extends Plugin { constructor(e, t = {}) { if (super("TreeViewPlugin", e), t.containerElement) { if (this._containerElement = t.containerElement, this._modelTreeViews = {}, this._autoAddModels = !1 !== t.autoAddModels, this._autoExpandDepth = t.autoExpandDepth || 0, this._sortNodes = !1 !== t.sortNodes, this._pruneEmptyNodes = !1 !== t.pruneEmptyNodes, this._autoAddModels) { var i = Object.keys(this.viewer.metaScene.metaModels); for (let e = 0, t = i.length; e < t; e++) { var s = i[e]; this.addModel(s) } this.viewer.scene.on("modelLoaded", (e => { this.viewer.metaScene.metaModels[e] && this.addModel(e) })) } this.hierarchy = t.hierarchy } else this.error("Config expected: containerElement") } get modelTreeViews() { return this._modelTreeViews } set hierarchy(e) { for (var t in "containment" !== (e = e || "containment") && "storeys" !== e && "types" !== e && (this.error("Unsupported value for `hierarchy' - defaulting to 'containment'"), e = "containment"), this._hierarchy = e, this._modelTreeViews) this._modelTreeViews.hasOwnProperty(t) && this._modelTreeViews[t].setHierarchy(this._hierarchy) } get hierarchy() { return this._hierarchy } addModel(e, t = {}) { if (this._containerElement) { const s = this.viewer.scene.models[e]; if (!s) throw "Model not found: " + e; var i = this.viewer.metaScene.metaModels[e]; if (i) { if (!this._modelTreeViews[e]) return i = new ModelTreeView(this.viewer, this, s, i, { containerElement: this._containerElement, autoExpandDepth: this._autoExpandDepth, hierarchy: this._hierarchy, sortNodes: this._sortNodes, pruneEmptyNodes: this._pruneEmptyNodes, rootName: t.rootName }), this._modelTreeViews[e] = i, s.on("destroyed", (() => { this.removeModel(s.id) })), i; this.warn("Model already added: " + e) } else this.error("MetaModel not found: " + e) } } removeModel(e) { var t; this._containerElement && (t = this._modelTreeViews[e]) && (t.destroy(), delete this._modelTreeViews[e]) } collapse() { for (var e in this._modelTreeViews) this._modelTreeViews.hasOwnProperty(e) && this._modelTreeViews[e].collapse() } showNode(e) { this.unShowNode(); var t = this.viewer.metaScene.metaObjects[e]; t ? (t = t.metaModel.id, (t = this._modelTreeViews[t]) ? t.showNode(e) : this.error("Object not in this TreeView: " + e)) : this.error("MetaObject not found: " + e) } unShowNode() { for (var e in this._modelTreeViews) this._modelTreeViews.hasOwnProperty(e) && this._modelTreeViews[e].unShowNode() } expandToDepth(e) { for (var t in this._modelTreeViews) this._modelTreeViews.hasOwnProperty(t) && ((t = this._modelTreeViews[t]).collapse(), t.expandToDepth(e)) } withNodeTree(e, t) { t(e); var i = e.children; if (i) for (let e = 0, s = i.length; e < s; e++)this.withNodeTree(i[e], t) } destroy() { if (this._containerElement) { for (var e in this._modelTreeViews) this._modelTreeViews.hasOwnProperty(e) && this._modelTreeViews[e].destroy(); this._modelTreeViews = {}, super.destroy() } } } const tempVec3a$1 = math.vec3(), tempVec3b$1 = math.vec3(), tempMat4a = math.mat4(); class FrustumPlane { constructor() { this.normal = math.vec3(), this.offset = 0, this.testVertex = math.vec3() } set(e, t, i, s) { var r = 1 / Math.sqrt(e * e + t * t + i * i); this.normal[0] = e * r, this.normal[1] = t * r, this.normal[2] = i * r, this.offset = s * r, this.testVertex[0] = 0 <= this.normal[0] ? 1 : 0, this.testVertex[1] = 0 <= this.normal[1] ? 1 : 0, this.testVertex[2] = 0 <= this.normal[2] ? 1 : 0 } } class Frustum { constructor() { this.planes = [new FrustumPlane, new FrustumPlane, new FrustumPlane, new FrustumPlane, new FrustumPlane, new FrustumPlane] } } function setFrustum(e, t, i) { t = (i = math.mulMat4(i, t, tempMat4a))[0]; var s = i[1], r = i[2], a = i[3], o = i[4], n = i[5], h = i[6], l = i[7], c = i[8], u = i[9], p = i[10], d = i[11], m = i[12], f = i[13], g = i[14]; i = i[15]; e.planes[0].set(a - t, l - o, d - c, i - m), e.planes[1].set(a + t, l + o, d + c, i + m), e.planes[2].set(a - s, l - n, d - u, i - f), e.planes[3].set(a + s, l + n, d + u, i + f), e.planes[4].set(a - r, l - h, d - p, i - g), e.planes[5].set(a + r, l + h, d + p, i + g) } function frustumIntersectsAABB3(e, t) { let i = Frustum.INSIDE; var s = tempVec3a$1, r = tempVec3b$1, a = (s[0] = t[0], s[1] = t[1], s[2] = t[2], r[0] = t[3], r[1] = t[4], r[2] = t[5], [s, r]); for (let t = 0; t < 6; ++t) { var o = e.planes[t]; if (o.normal[0] * a[o.testVertex[0]][0] + o.normal[1] * a[o.testVertex[1]][1] + o.normal[2] * a[o.testVertex[2]][2] + o.offset < 0) return Frustum.OUTSIDE; o.normal[0] * a[1 - o.testVertex[0]][0] + o.normal[1] * a[1 - o.testVertex[1]][1] + o.normal[2] * a[1 - o.testVertex[2]][2] + o.offset < 0 && (i = Frustum.INTERSECT) } return i } Frustum.INSIDE = 0, Frustum.INTERSECT = 1, Frustum.OUTSIDE = 2; class ObjectCullStates { constructor(e) { this._scene = e, this._objects = [], this._objectsViewCulled = [], this._objectsDetailCulled = [], this._objectsChanged = [], this._objectsChangedList = [], this._modelInfos = {}, this._numObjects = 0, this._lenObjectsChangedList = 0, this._dirty = !0, this._onModelLoaded = e.on("modelLoaded", (t => { (t = e.models[t]) && this._addModel(t) })), this._onTick = e.on("tick", (() => { this._dirty && this._build(), this._applyChanges() })) } _addModel(e) { var t = { model: e, onDestroyed: e.on("destroyed", (() => { this._removeModel(e) })) }; this._modelInfos[e.id] = t, this._dirty = !0 } _removeModel(e) { var t = this._modelInfos[e.id]; t && (t.model.off(t.onDestroyed), delete this._modelInfos[e.id], this._dirty = !0) } _build() { if (this._dirty) { this._applyChanges(); var e, t = this._scene.objects; for (let e = 0; e < this._numObjects; e++)this._objects[e] = null; for (e in this._numObjects = 0, t) { var i = t[e]; this._objects[this._numObjects++] = i } this._lenObjectsChangedList = 0, this._dirty = !1 } } _applyChanges() { if (0 < this._lenObjectsChangedList) { for (let r = 0; r < this._lenObjectsChangedList; r++) { var e = this._objectsChangedList[r], t = this._objects[e], i = this._objectsViewCulled[e], s = this._objectsDetailCulled[e]; t.culled = i || s, this._objectsChanged[e] = !1 } this._lenObjectsChangedList = 0 } } get objects() { return this._dirty && this._build(), this._objects } get numObjects() { return this._dirty && this._build(), this._numObjects } setObjectViewCulled(e, t) { this._dirty && this._build(), this._objectsViewCulled[e] === t || (this._objectsViewCulled[e] = t, this._objectsChanged[e]) || (this._objectsChanged[e] = !0, this._objectsChangedList[this._lenObjectsChangedList++] = e) } setObjectDetailCulled(e, t) { this._dirty && this._build(), this._objectsDetailCulled[e] === t || (this._objectsDetailCulled[e] = t, this._objectsChanged[e]) || (this._objectsChanged[e] = !0, this._objectsChangedList[this._lenObjectsChangedList++] = e) } _destroy() { this._clear(), this._scene.off(this._onModelLoaded), this._scene.off(this._onTick) } _clear() { for (var e in this._modelInfos) (e = this._modelInfos[e]).model.off(e.onDestroyed); this._modelInfos = {}, this._dirty = !0 } } const sceneObjectCullStates = {}; function getObjectCullStates(e) { const t = e.id; let i = sceneObjectCullStates[t]; return i || (i = new ObjectCullStates(e), sceneObjectCullStates[t] = i, e.on("destroyed", (() => { delete sceneObjectCullStates[t], i._destroy() }))), i } const MAX_KD_TREE_DEPTH = 8, kdTreeDimLength = new Float32Array(3); class ViewCullPlugin extends Plugin { constructor(e, t = {}) { super("ViewCull", e), this._objectCullStates = getObjectCullStates(e.scene), this._maxTreeDepth = t.maxTreeDepth || 8, this._modelInfos = {}, this._frustum = new Frustum, this._kdRoot = null, this._frustumDirty = !1, this._kdTreeDirty = !1, this._onViewMatrix = e.scene.camera.on("viewMatrix", (() => { this._frustumDirty = !0 })), this._onProjMatrix = e.scene.camera.on("projMatMatrix", (() => { this._frustumDirty = !0 })), this._onModelLoaded = e.scene.on("modelLoaded", (e => { (e = this.viewer.scene.models[e]) && this._addModel(e) })), this._onSceneTick = e.scene.on("tick", (() => { this._doCull() })) } set enabled(e) { this._enabled = e } get enabled() { return this._enabled } _addModel(e) { var t = { model: e, onDestroyed: e.on("destroyed", (() => { this._removeModel(e) })) }; this._modelInfos[e.id] = t, this._kdTreeDirty = !0 } _removeModel(e) { var t = this._modelInfos[e.id]; t && (t.model.off(t.onDestroyed), delete this._modelInfos[e.id], this._kdTreeDirty = !0) } _doCull() { var e = this._frustumDirty || this._kdTreeDirty; this._frustumDirty && this._buildFrustum(), this._kdTreeDirty && this._buildKDTree(), (e = e && this._kdRoot) && this._visitKDNode(e) } _buildFrustum() { var e = this.viewer.scene.camera; setFrustum(this._frustum, e.viewMatrix, e.projMatrix), this._frustumDirty = !1 } _buildKDTree() { var e = this.viewer.scene; this._kdRoot, this._kdRoot = { aabb: e.getAABB(), intersection: Frustum.INTERSECT }; for (let e = 0, i = this._objectCullStates.numObjects; e < i; e++) { var t = this._objectCullStates.objects[e]; this._insertEntityIntoKDTree(this._kdRoot, t, e, 1) } this._kdTreeDirty = !1 } _insertEntityIntoKDTree(e, t, i, s) { var r = t.aabb; if (s >= this._maxTreeDepth) e.objects = e.objects || [], e.objects.push(i), math.expandAABB3(e.aabb, r); else if (e.left && math.containsAABB3(e.left.aabb, r)) this._insertEntityIntoKDTree(e.left, t, i, s + 1); else if (e.right && math.containsAABB3(e.right.aabb, r)) this._insertEntityIntoKDTree(e.right, t, i, s + 1); else { var a = e.aabb; kdTreeDimLength[0] = a[3] - a[0], kdTreeDimLength[1] = a[4] - a[1], kdTreeDimLength[2] = a[5] - a[2]; let n = 0; if (kdTreeDimLength[1] > kdTreeDimLength[n] && (n = 1), kdTreeDimLength[2] > kdTreeDimLength[n] && (n = 2), !e.left) { var o = a.slice(); if (o[n + 3] = (a[n] + a[n + 3]) / 2, e.left = { aabb: o, intersection: Frustum.INTERSECT }, math.containsAABB3(o, r)) return void this._insertEntityIntoKDTree(e.left, t, i, s + 1) } !e.right && ((o = a.slice())[n] = (a[n] + a[n + 3]) / 2, e.right = { aabb: o, intersection: Frustum.INTERSECT }, math.containsAABB3(o, r)) ? this._insertEntityIntoKDTree(e.right, t, i, s + 1) : (e.objects = e.objects || [], e.objects.push(i), math.expandAABB3(e.aabb, r)) } } _visitKDNode(e, t = Frustum.INTERSECT) { if (t === Frustum.INTERSECT || e.intersects !== t) { t === Frustum.INTERSECT && (t = frustumIntersectsAABB3(this._frustum, e.aabb), e.intersects = t); var i = t === Frustum.OUTSIDE, s = e.objects; if (s && 0 < s.length) for (let e = 0, t = s.length; e < t; e++) { var r = s[e]; this._objectCullStates.setObjectViewCulled(r, i) } e.left && this._visitKDNode(e.left, t), e.right && this._visitKDNode(e.right, t) } } send(e, t) { } destroy() { super.destroy(), this._clear(); var e = this.viewer.scene, t = e.camera; e.off(this._onModelLoaded), e.off(this._onSceneTick), t.off(this._onViewMatrix), t.off(this._onProjMatrix) } _clear() { for (var e in this._modelInfos) (e = this._modelInfos[e]).model.off(e.onDestroyed); this._modelInfos = {}, this._kdRoot = null, this._kdTreeDirty = !0 } } class XKTDefaultDataSource { constructor() { } getMetaModel(e, t, i) { utils.loadJSON(e, (e => { t(e) }), (function (e) { i(e) })) } getXKT(e, t, i) { var s = () => { }; if (t = t || s, i = i || s, s = e.match(/^data:(.*?)(;base64)?,(.*)$/)) { var r = !!s[2], a = s[3]; a = window.decodeURIComponent(a); r && (a = window.atob(a)); try { for (var o = new ArrayBuffer(a.length), n = new Uint8Array(o), h = 0; h < a.length; h++)n[h] = a.charCodeAt(h); t(o) } catch (e) { i(e) } } else { const s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onreadystatechange = function () { 4 === s.readyState && (200 === s.status ? t(s.response) : i("getXKT error : " + s.response)) }, s.send(null) } } } !function (e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(("undefined" != typeof globalThis ? globalThis : self).pako = {}) }((function (e) { function t(e) { let t = e.length; for (; 0 <= --t;)e[t] = 0 } const i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), s = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), a = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = new Array(576), n = (t(o), new Array(60)), h = (t(n), new Array(512)), l = (t(h), new Array(256)), c = (t(l), new Array(29)), u = (t(c), new Array(30)); function p(e, t, i, s, r) { this.static_tree = e, this.extra_bits = t, this.extra_base = i, this.elems = s, this.max_length = r, this.has_stree = e && e.length } let d, m, f; function g(e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t } t(u); const _ = e => e < 256 ? h[e] : h[256 + (e >>> 7)], v = (e, t) => { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255 }, y = (e, t, i) => { e.bi_valid > 16 - i ? (e.bi_buf |= t << e.bi_valid & 65535, v(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += i - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i) }, T = (e, t, i) => { y(e, i[2 * t], i[2 * t + 1]) }, I = (e, t) => { let i = 0; for (; i |= 1 & e, e >>>= 1, i <<= 1, 0 < --t;); return i >>> 1 }, E = (e, t, i) => { var s = new Array(16); let r, a, o = 0; for (r = 1; r <= 15; r++)s[r] = o = o + i[r - 1] << 1; for (a = 0; a <= t; a++) { var n = e[2 * a + 1]; 0 !== n && (e[2 * a] = I(s[n]++, n)) } }, C = e => { let t; for (t = 0; t < 286; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < 30; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < 19; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0 }, P = e => { 8 < e.bi_valid ? v(e, e.bi_buf) : 0 < e.bi_valid && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0 }, b = (e, t, i, s) => { var r = 2 * t, a = 2 * i; return e[r] < e[a] || e[r] === e[a] && s[t] <= s[i] }, A = (e, t, i) => { var s = e.heap[i]; let r = i << 1; for (; r <= e.heap_len && (r < e.heap_len && b(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !b(t, s, e.heap[r], e.depth));)e.heap[i] = e.heap[r], i = r, r <<= 1; e.heap[i] = s }, D = (e, t, r) => { var a, o, n, h; let p = 0; if (0 !== e.last_lit) for (; a = e.pending_buf[e.d_buf + 2 * p] << 8 | e.pending_buf[e.d_buf + 2 * p + 1], o = e.pending_buf[e.l_buf + p], p++, 0 == a ? T(e, o, t) : (n = l[o], T(e, n + 256 + 1, t), 0 !== (h = i[n]) && (o -= c[n], y(e, o, h)), a--, n = _(a), T(e, n, r), 0 !== (h = s[n]) && (a -= u[n], y(e, a, h))), p < e.last_lit;); T(e, 256, t) }, R = (e, t) => { var i = t.dyn_tree, s = t.stat_desc.static_tree, r = t.stat_desc.has_stree, a = t.stat_desc.elems; let o, n, h, l = -1; for (e.heap_len = 0, e.heap_max = 573, o = 0; o < a; o++)0 !== i[2 * o] ? (e.heap[++e.heap_len] = l = o, e.depth[o] = 0) : i[2 * o + 1] = 0; for (; e.heap_len < 2;)i[2 * (h = e.heap[++e.heap_len] = l < 2 ? ++l : 0)] = 1, e.depth[h] = 0, e.opt_len--, r && (e.static_len -= s[2 * h + 1]); for (t.max_code = l, o = e.heap_len >> 1; 1 <= o; o--)A(e, i, o); for (h = a; o = e.heap[1], e.heap[1] = e.heap[e.heap_len--], A(e, i, 1), n = e.heap[1], e.heap[--e.heap_max] = o, e.heap[--e.heap_max] = n, i[2 * h] = i[2 * o] + i[2 * n], e.depth[h] = (e.depth[o] >= e.depth[n] ? e.depth[o] : e.depth[n]) + 1, i[2 * o + 1] = i[2 * n + 1] = h, e.heap[1] = h++, A(e, i, 1), 2 <= e.heap_len;); e.heap[--e.heap_max] = e.heap[1]; { var c, u = e, p = t.dyn_tree, d = t.max_code, m = t.stat_desc.static_tree, f = t.stat_desc.has_stree, g = t.stat_desc.extra_bits, _ = t.stat_desc.extra_base, v = t.stat_desc.max_length; let i, s, r, a, o, n = 0; for (a = 0; a <= 15; a++)u.bl_count[a] = 0; for (p[2 * u.heap[u.heap_max] + 1] = 0, i = u.heap_max + 1; i < 573; i++)s = u.heap[i], (a = p[2 * p[2 * s + 1] + 1] + 1) > v && (a = v, n++), p[2 * s + 1] = a, s > d || (u.bl_count[a]++, o = 0, s >= _ && (o = g[s - _]), c = p[2 * s], u.opt_len += c * (a + o), f && (u.static_len += c * (m[2 * s + 1] + o))); if (0 !== n) { do { for (a = v - 1; 0 === u.bl_count[a];)a-- } while (u.bl_count[a]--, u.bl_count[a + 1] += 2, u.bl_count[v]--, 0 < (n -= 2)); for (a = v; 0 !== a; a--)for (s = u.bl_count[a]; 0 !== s;)d < (r = u.heap[--i]) || (p[2 * r + 1] !== a && (u.opt_len += (a - p[2 * r + 1]) * p[2 * r], p[2 * r + 1] = a), s--) } } E(i, l, e.bl_count) }, F = (e, t, i) => { let s, r = -1; var a; let o = t[1], n = 0, h = 7, l = 4; for (0 === o && (h = 138, l = 3), t[2 * (i + 1) + 1] = 65535, s = 0; s <= i; s++)a = o, o = t[2 * (s + 1) + 1], ++n < h && a === o || (n < l ? e.bl_tree[2 * a] += n : 0 !== a ? (a !== r && e.bl_tree[2 * a]++, e.bl_tree[32]++) : n <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, n = 0, r = a, l = 0 === o ? (h = 138, 3) : a === o ? (h = 6, 3) : (h = 7, 4)) }, w = (e, t, i) => { let s, r = -1; var a; let o = t[1], n = 0, h = 7, l = 4; for (0 === o && (h = 138, l = 3), s = 0; s <= i; s++)if (a = o, o = t[2 * (s + 1) + 1], !(++n < h && a === o)) { if (n < l) for (; T(e, a, e.bl_tree), 0 != --n;); else 0 !== a ? (a !== r && (T(e, a, e.bl_tree), n--), T(e, 16, e.bl_tree), y(e, n - 3, 2)) : n <= 10 ? (T(e, 17, e.bl_tree), y(e, n - 3, 3)) : (T(e, 18, e.bl_tree), y(e, n - 11, 7)); n = 0, r = a, l = 0 === o ? (h = 138, 3) : a === o ? (h = 6, 3) : (h = 7, 4) } }; let M = !1; const S = (e, t, i, s) => { y(e, 0 + (s ? 1 : 0), 3), s = e, e = t, t = i, i = !0, P(s), i && (v(s, t), v(s, ~t)), s.pending_buf.set(s.window.subarray(e, e + t), s.pending), s.pending += t }; var x = { _tr_init: e => { if (!M) { { let e, a, g, _, v; var t = new Array(16); for (g = 0, _ = 0; _ < 28; _++)for (c[_] = g, e = 0; e < 1 << i[_]; e++)l[g++] = _; for (l[g - 1] = _, v = 0, _ = 0; _ < 16; _++)for (u[_] = v, e = 0; e < 1 << s[_]; e++)h[v++] = _; for (v >>= 7; _ < 30; _++)for (u[_] = v << 7, e = 0; e < 1 << s[_] - 7; e++)h[256 + v++] = _; for (a = 0; a <= 15; a++)t[a] = 0; for (e = 0; e <= 143;)o[2 * e + 1] = 8, e++, t[8]++; for (; e <= 255;)o[2 * e + 1] = 9, e++, t[9]++; for (; e <= 279;)o[2 * e + 1] = 7, e++, t[7]++; for (; e <= 287;)o[2 * e + 1] = 8, e++, t[8]++; for (E(o, 287, t), e = 0; e < 30; e++)n[2 * e + 1] = 5, n[2 * e] = I(e, 5); d = new p(o, i, 257, 286, 15), m = new p(n, s, 0, 30, 15), f = new p(new Array(0), r, 0, 19, 7) } M = !0 } e.l_desc = new g(e.dyn_ltree, d), e.d_desc = new g(e.dyn_dtree, m), e.bl_desc = new g(e.bl_tree, f), e.bi_buf = 0, e.bi_valid = 0, C(e) }, _tr_stored_block: S, _tr_flush_block: (e, t, i, s) => { let r, h, l = 0; if (0 < e.level ? (2 === e.strm.data_type && (e.strm.data_type = (e => { let t, i = 4093624447; for (t = 0; t <= 31; t++, i >>>= 1)if (1 & i && 0 !== e.dyn_ltree[2 * t]) return 0; if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1; for (t = 32; t < 256; t++)if (0 !== e.dyn_ltree[2 * t]) return 1; return 0 })(e)), R(e, e.l_desc), R(e, e.d_desc), l = (e => { let t; for (F(e, e.dyn_ltree, e.l_desc.max_code), F(e, e.dyn_dtree, e.d_desc.max_code), R(e, e.bl_desc), t = 18; 3 <= t && 0 === e.bl_tree[2 * a[t] + 1]; t--); return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t })(e), r = e.opt_len + 3 + 7 >>> 3, (h = e.static_len + 3 + 7 >>> 3) <= r && (r = h)) : r = h = i + 5, i + 4 <= r && -1 !== t) S(e, t, i, s); else if (4 === e.strategy || h === r) y(e, 2 + (s ? 1 : 0), 3), D(e, o, n); else { y(e, 4 + (s ? 1 : 0), 3); { var c = e, u = (t = e.l_desc.max_code + 1, i = e.d_desc.max_code + 1, l + 1); let s; for (y(c, t - 257, 5), y(c, i - 1, 5), y(c, u - 4, 4), s = 0; s < u; s++)y(c, c.bl_tree[2 * a[s] + 1], 3); w(c, c.dyn_ltree, t - 1), w(c, c.dyn_dtree, i - 1) } D(e, e.dyn_ltree, e.dyn_dtree) } C(e), s && P(e) }, _tr_tally: (e, t, i) => (e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & i, e.last_lit++, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (l[i] + 256 + 1)]++, e.dyn_dtree[2 * _(t)]++), e.last_lit === e.lit_bufsize - 1), _tr_align: e => { y(e, 2, 3), T(e, 256, o), 16 === e.bi_valid ? (v(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : 8 <= e.bi_valid && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8) } }, L = (e, t, i, s) => { let r = 65535 & e, a = e >>> 16 & 65535, o = 0; for (; 0 !== i;) { for (i -= o = 2e3 < i ? 2e3 : i; r = r + t[s++] | 0, a = a + r | 0, --o;); r %= 65521, a %= 65521 } return r | a << 16 }; const O = new Uint32Array((() => { let e, t = []; for (var i = 0; i < 256; i++) { e = i; for (var s = 0; s < 8; s++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[i] = e } return t })()); var N = (e, t, i, s) => { var r = O, a = s + i; e ^= -1; for (let i = s; i < a; i++)e = e >>> 8 ^ r[255 & (e ^ t[i])]; return ~e }, B = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, G = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; const { _tr_init: U, _tr_stored_block: k, _tr_flush_block: V, _tr_tally: H, _tr_align: j } = x, { Z_NO_FLUSH: z, Z_PARTIAL_FLUSH: W, Z_FULL_FLUSH: Y, Z_FINISH: $, Z_BLOCK: X, Z_OK: K, Z_STREAM_END: J, Z_STREAM_ERROR: Q, Z_DATA_ERROR: Z, Z_BUF_ERROR: q, Z_DEFAULT_COMPRESSION: ee, Z_FILTERED: te, Z_HUFFMAN_ONLY: ie, Z_RLE: se, Z_FIXED: re, Z_UNKNOWN: ae, Z_DEFLATED: oe } = G, ne = 286, he = 30, le = 19, ce = 2 * ne + 1, ue = 15, pe = 258, de = 262, me = (e, t) => (e.msg = B[t], t), fe = e => (e << 1) - (4 < e ? 9 : 0), ge = e => { let t = e.length; for (; 0 <= --t;)e[t] = 0 }; let _e = (e, t, i) => (t << e.hash_shift ^ i) & e.hash_mask; const ve = e => { var t = e.state, i = t.pending; 0 !== (i = i > e.avail_out ? e.avail_out : i) && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + i), e.next_out), e.next_out += i, t.pending_out += i, e.total_out += i, e.avail_out -= i, t.pending -= i, 0 === t.pending) && (t.pending_out = 0) }, ye = (e, t) => { V(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, ve(e.strm) }, Te = (e, t) => { e.pending_buf[e.pending++] = t }, Ie = (e, t) => { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t }, Ee = (e, t) => { let i, s = e.max_chain_length, r = e.strstart; var a; let o = e.prev_length, n = e.nice_match; var h = e.strstart > e.w_size - de ? e.strstart - (e.w_size - de) : 0, l = e.window, c = e.w_mask, u = e.prev, p = e.strstart + pe; let d = l[r + o - 1], m = l[r + o]; e.prev_length >= e.good_match && (s >>= 2), n > e.lookahead && (n = e.lookahead); do { if (l[(i = t) + o] === m && l[i + o - 1] === d && l[i] === l[r] && l[++i] === l[r + 1]) { for (r += 2, i++; l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && r < p;); if (a = pe - (p - r), r = p - pe, a > o) { if (e.match_start = t, (o = a) >= n) break; d = l[r + o - 1], m = l[r + o] } } } while ((t = u[t & c]) > h && 0 != --s); return o <= e.lookahead ? o : e.lookahead }, Ce = e => { var t, i, s, r, a, o = e.w_size; let n, h, l, c, u; do { if (c = e.window_size - e.lookahead - e.strstart, e.strstart >= o + (o - de)) { for (e.window.set(e.window.subarray(o, o + o), 0), e.match_start -= o, e.strstart -= o, e.block_start -= o, h = e.hash_size, n = h; l = e.head[--n], e.head[n] = l >= o ? l - o : 0, --h;); for (h = o, n = h; l = e.prev[--n], e.prev[n] = l >= o ? l - o : 0, --h;); c += o } if (0 === e.strm.avail_in) break; if (t = e.strm, i = e.window, s = e.strstart + e.lookahead, h = 0 === (a = (r = c) < (a = t.avail_in) ? r : a) ? 0 : (t.avail_in -= a, i.set(t.input.subarray(t.next_in, t.next_in + a), s), 1 === t.state.wrap ? t.adler = L(t.adler, i, a, s) : 2 === t.state.wrap && (t.adler = N(t.adler, i, a, s)), t.next_in += a, t.total_in += a, a), e.lookahead += h, 3 <= e.lookahead + e.insert) for (u = e.strstart - e.insert, e.ins_h = e.window[u], e.ins_h = _e(e, e.ins_h, e.window[u + 1]); e.insert && (e.ins_h = _e(e, e.ins_h, e.window[u + 3 - 1]), e.prev[u & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = u, u++, e.insert--, !(e.lookahead + e.insert < 3));); } while (e.lookahead < de && 0 !== e.strm.avail_in) }; x = (e, t) => { let i, s; for (; ;) { if (e.lookahead < de) { if (Ce(e), e.lookahead < de && t === z) return 1; if (0 === e.lookahead) break } if (i = 0, 3 <= e.lookahead && (e.ins_h = _e(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - de && (e.match_length = Ee(e, i)), 3 <= e.match_length) if (s = H(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && 3 <= e.lookahead) { for (e.match_length--; e.strstart++, e.ins_h = _e(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, 0 != --e.match_length;); e.strstart++ } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = _e(e, e.ins_h, e.window[e.strstart + 1]); else s = H(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (s && (ye(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = e.strstart < 2 ? e.strstart : 2, t === $ ? (ye(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (ye(e, !1), 0 === e.strm.avail_out) ? 1 : 2 }; var Pe = (e, t) => { let i, s; for (var r; ;) { if (e.lookahead < de) { if (Ce(e), e.lookahead < de && t === z) return 1; if (0 === e.lookahead) break } if (i = 0, 3 <= e.lookahead && (e.ins_h = _e(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - de && (e.match_length = Ee(e, i), e.match_length <= 5) && (e.strategy === te || 3 === e.match_length && 4096 < e.strstart - e.match_start) && (e.match_length = 2), 3 <= e.prev_length && e.match_length <= e.prev_length) { for (r = e.strstart + e.lookahead - 3, s = H(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= r && (e.ins_h = _e(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 != --e.prev_length;); if (e.match_available = 0, e.match_length = 2, e.strstart++, s && (ye(e, !1), 0 === e.strm.avail_out)) return 1 } else if (e.match_available) { if ((s = H(e, 0, e.window[e.strstart - 1])) && ye(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1 } else e.match_available = 1, e.strstart++, e.lookahead-- } return e.match_available && (s = H(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === $ ? (ye(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (ye(e, !1), 0 === e.strm.avail_out) ? 1 : 2 }; function be(e, t, i, s, r) { this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = s, this.func = r } const Ae = [new be(0, 0, 0, 0, ((e, t) => { let i = 65535; for (i > e.pending_buf_size - 5 && (i = e.pending_buf_size - 5); ;) { if (e.lookahead <= 1) { if (Ce(e), 0 === e.lookahead && t === z) return 1; if (0 === e.lookahead) break } e.strstart += e.lookahead, e.lookahead = 0; var s = e.block_start + i; if ((0 === e.strstart || e.strstart >= s) && (e.lookahead = e.strstart - s, e.strstart = s, ye(e, !1), 0 === e.strm.avail_out)) return 1; if (e.strstart - e.block_start >= e.w_size - de && (ye(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, t === $ ? (ye(e, !0), 0 === e.strm.avail_out ? 3 : 4) : (e.strstart > e.block_start && (ye(e, !1), e.strm.avail_out), 1) })), new be(4, 4, 8, 4, x), new be(4, 5, 16, 8, x), new be(4, 6, 32, 32, x), new be(4, 4, 16, 16, Pe), new be(8, 16, 32, 32, Pe), new be(8, 16, 128, 128, Pe), new be(8, 32, 128, 256, Pe), new be(32, 128, 258, 1024, Pe), new be(32, 258, 258, 4096, Pe)]; function De() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = oe, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * ce), this.dyn_dtree = new Uint16Array(2 * (2 * he + 1)), this.bl_tree = new Uint16Array(2 * (2 * le + 1)), ge(this.dyn_ltree), ge(this.dyn_dtree), ge(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(ue + 1), this.heap = new Uint16Array(2 * ne + 1), ge(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * ne + 1), ge(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } const Re = e => { if (!e || !e.state) return me(e, Q); e.total_in = e.total_out = 0, e.data_type = ae; var t = e.state; return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? 42 : 113, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = z, U(t), K }, Fe = e => { var t = Re(e); return t === K && ((e = e.state).window_size = 2 * e.w_size, ge(e.head), e.max_lazy_match = Ae[e.level].max_lazy, e.good_match = Ae[e.level].good_length, e.nice_match = Ae[e.level].nice_length, e.max_chain_length = Ae[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0), t }; function we(e) { for (var t, i, s = Array.prototype.slice.call(arguments, 1); s.length;) { var r = s.shift(); if (r) { if ("object" != typeof r) throw new TypeError(r + "must be non-object"); for (const s in r) t = r, i = s, Object.prototype.hasOwnProperty.call(t, i) && (e[s] = r[s]) } } return e } var Me = e => { let t = 0; for (let i = 0, s = e.length; i < s; i++)t += e[i].length; var i = new Uint8Array(t); for (let t = 0, r = 0, a = e.length; t < a; t++) { var s = e[t]; i.set(s, r), r += s.length } return i }; let Se = !0; try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (e) { Se = !1 } const xe = new Uint8Array(256); for (let e = 0; e < 256; e++)xe[e] = 252 <= e ? 6 : 248 <= e ? 5 : 240 <= e ? 4 : 224 <= e ? 3 : 192 <= e ? 2 : 1; function Le() { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } xe[254] = xe[254] = 1; var Oe = e => { if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(e); let t, i, s, r, a, o = e.length, n = 0; for (r = 0; r < o; r++)55296 == (64512 & (i = e.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (s = e.charCodeAt(r + 1))) && (i = 65536 + (i - 55296 << 10) + (s - 56320), r++), n += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4; for (t = new Uint8Array(n), a = 0, r = 0; a < n; r++)55296 == (64512 & (i = e.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (s = e.charCodeAt(r + 1))) && (i = 65536 + (i - 55296 << 10) + (s - 56320), r++), i < 128 ? t[a++] = i : (i < 2048 ? t[a++] = 192 | i >>> 6 : (i < 65536 ? t[a++] = 224 | i >>> 12 : (t[a++] = 240 | i >>> 18, t[a++] = 128 | i >>> 12 & 63), t[a++] = 128 | i >>> 6 & 63), t[a++] = 128 | 63 & i); return t }; const Ne = Object.prototype.toString, { Z_NO_FLUSH: Be, Z_SYNC_FLUSH: Ge, Z_FULL_FLUSH: Ue, Z_FINISH: ke, Z_OK: Ve, Z_STREAM_END: He, Z_DEFAULT_COMPRESSION: je, Z_DEFAULT_STRATEGY: ze, Z_DEFLATED: We } = G; function Ye(e) { this.options = we({ level: je, method: We, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: ze }, e || {}), (e = this.options).raw && 0 < e.windowBits ? e.windowBits = -e.windowBits : e.gzip && 0 < e.windowBits && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Le, this.strm.avail_out = 0; var t, i, s = ((e, t, i, s, r, a) => { if (!e) return Q; let o = 1; if (t === ee && (t = 6), s < 0 ? (o = 0, s = -s) : 15 < s && (o = 2, s -= 16), r < 1 || 9 < r || i !== oe || s < 8 || 15 < s || t < 0 || 9 < t || a < 0 || a > re) return me(e, Q); 8 === s && (s = 9); var n = new De; return (e.state = n).strm = e, n.wrap = o, n.gzhead = null, n.w_bits = s, n.w_size = 1 << n.w_bits, n.w_mask = n.w_size - 1, n.hash_bits = r + 7, n.hash_size = 1 << n.hash_bits, n.hash_mask = n.hash_size - 1, n.hash_shift = ~~((n.hash_bits + 3 - 1) / 3), n.window = new Uint8Array(2 * n.w_size), n.head = new Uint16Array(n.hash_size), n.prev = new Uint16Array(n.w_size), n.lit_bufsize = 1 << r + 6, n.pending_buf_size = 4 * n.lit_bufsize, n.pending_buf = new Uint8Array(n.pending_buf_size), n.d_buf = +n.lit_bufsize, n.l_buf = 3 * n.lit_bufsize, n.level = t, n.strategy = a, n.method = i, Fe(e) })(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (s !== Ve) throw new Error(B[s]); if (e.header && (t = this.strm, i = e.header, t && t.state && 2 === t.state.wrap && (t.state.gzhead = i)), e.dictionary) { if (e = "string" == typeof e.dictionary ? Oe(e.dictionary) : "[object ArrayBuffer]" === Ne.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (s = ((e, t) => { let i = t.length; if (!e || !e.state) return Q; var s = e.state, r = s.wrap; if (2 === r || 1 === r && 42 !== s.status || s.lookahead) return Q; 1 === r && (e.adler = L(e.adler, t, i, 0)), s.wrap = 0, i >= s.w_size && (0 === r && (ge(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0), (a = new Uint8Array(s.w_size)).set(t.subarray(i - s.w_size, i), 0), t = a, i = s.w_size); var a = e.avail_in, o = e.next_in, n = e.input; for (e.avail_in = i, e.next_in = 0, e.input = t, Ce(s); 3 <= s.lookahead;) { let e = s.strstart, t = s.lookahead - 2; for (; s.ins_h = _e(s, s.ins_h, s.window[e + 3 - 1]), s.prev[e & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = e, e++, --t;); s.strstart = e, s.lookahead = 2, Ce(s) } return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = 2, s.match_available = 0, e.next_in = o, e.input = n, e.avail_in = a, s.wrap = r, K })(this.strm, e)) !== Ve) throw new Error(B[s]); this._dict_set = !0 } } function $e(e, t) { if ((t = new Ye(t)).push(e, !0), t.err) throw t.msg || B[t.err]; return t.result } Ye.prototype.push = function (e, t) { var i, s, r, a = this.strm, o = this.options.chunkSize; if (this.ended) return !1; for (i = t === ~~t ? t : !0 === t ? ke : Be, "string" == typeof e ? a.input = Oe(e) : "[object ArrayBuffer]" === Ne.call(e) ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ;)if (0 === a.avail_out && (a.output = new Uint8Array(o), a.next_out = 0, a.avail_out = o), (i === Ge || i === Ue) && a.avail_out <= 6) this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0; else { if (((e, t) => { let i, s; if (!e || !e.state || t > X || t < 0) return e ? me(e, Q) : Q; var r = e.state; if (!e.output || !e.input && 0 !== e.avail_in || 666 === r.status && t !== $) return me(e, 0 === e.avail_out ? q : Q); r.strm = e; var a = r.last_flush; if (r.last_flush = t, 42 === r.status) if (2 === r.wrap) e.adler = 0, Te(r, 31), Te(r, 139), Te(r, 8), r.gzhead ? (Te(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), Te(r, 255 & r.gzhead.time), Te(r, r.gzhead.time >> 8 & 255), Te(r, r.gzhead.time >> 16 & 255), Te(r, r.gzhead.time >> 24 & 255), Te(r, 9 === r.level ? 2 : r.strategy >= ie || r.level < 2 ? 4 : 0), Te(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (Te(r, 255 & r.gzhead.extra.length), Te(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = N(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69) : (Te(r, 0), Te(r, 0), Te(r, 0), Te(r, 0), Te(r, 0), Te(r, 9 === r.level ? 2 : r.strategy >= ie || r.level < 2 ? 4 : 0), Te(r, 3), r.status = 113); else { let t, i = oe + (r.w_bits - 8 << 4) << 8; t = r.strategy >= ie || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3, i |= t << 6, 0 !== r.strstart && (i |= 32), i += 31 - i % 31, r.status = 113, Ie(r, i), 0 !== r.strstart && (Ie(r, e.adler >>> 16), Ie(r, 65535 & e.adler)), e.adler = 1 } if (69 === r.status) if (r.gzhead.extra) { for (i = r.pending; r.gzindex < (65535 & r.gzhead.extra.length) && (r.pending !== r.pending_buf_size || (r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), ve(e), i = r.pending, r.pending !== r.pending_buf_size));)Te(r, 255 & r.gzhead.extra[r.gzindex]), r.gzindex++; r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex === r.gzhead.extra.length && (r.gzindex = 0, r.status = 73) } else r.status = 73; if (73 === r.status) if (r.gzhead.name) { i = r.pending; do { if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), ve(e), i = r.pending, r.pending === r.pending_buf_size)) { s = 1; break } } while (s = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, Te(r, s), 0 !== s); r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), 0 === s && (r.gzindex = 0, r.status = 91) } else r.status = 91; if (91 === r.status) if (r.gzhead.comment) { i = r.pending; do { if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), ve(e), i = r.pending, r.pending === r.pending_buf_size)) { s = 1; break } } while (s = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, Te(r, s), 0 !== s); r.gzhead.hcrc && r.pending > i && (e.adler = N(e.adler, r.pending_buf, r.pending - i, i)), 0 === s && (r.status = 103) } else r.status = 103; if (103 === r.status && (r.gzhead.hcrc ? (r.pending + 2 > r.pending_buf_size && ve(e), r.pending + 2 <= r.pending_buf_size && (Te(r, 255 & e.adler), Te(r, e.adler >> 8 & 255), e.adler = 0, r.status = 113)) : r.status = 113), 0 !== r.pending) { if (ve(e), 0 === e.avail_out) return r.last_flush = -1, K } else if (0 === e.avail_in && fe(t) <= fe(a) && t !== $) return me(e, q); if (666 === r.status && 0 !== e.avail_in) return me(e, q); if (0 !== e.avail_in || 0 !== r.lookahead || t !== z && 666 !== r.status) { if (3 !== (a = r.strategy === ie ? ((e, t) => { for (var i; ;) { if (0 === e.lookahead && (Ce(e), 0 === e.lookahead)) { if (t === z) return 1; break } if (e.match_length = 0, i = H(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (ye(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, t === $ ? (ye(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (ye(e, !1), 0 === e.strm.avail_out) ? 1 : 2 })(r, t) : r.strategy === se ? ((e, t) => { let i; var s; let r, a; for (var o = e.window; ;) { if (e.lookahead <= pe) { if (Ce(e), e.lookahead <= pe && t === z) return 1; if (0 === e.lookahead) break } if (e.match_length = 0, 3 <= e.lookahead && 0 < e.strstart && (s = o[r = e.strstart - 1]) === o[++r] && s === o[++r] && s === o[++r]) { for (a = e.strstart + pe; s === o[++r] && s === o[++r] && s === o[++r] && s === o[++r] && s === o[++r] && s === o[++r] && s === o[++r] && s === o[++r] && r < a;); e.match_length = pe - (a - r), e.match_length > e.lookahead && (e.match_length = e.lookahead) } if (3 <= e.match_length ? (i = H(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = H(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (ye(e, !1), 0 === e.strm.avail_out)) return 1 } return e.insert = 0, t === $ ? (ye(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (ye(e, !1), 0 === e.strm.avail_out) ? 1 : 2 })(r, t) : Ae[r.level].func(r, t)) && 4 !== a || (r.status = 666), 1 === a || 3 === a) return 0 === e.avail_out && (r.last_flush = -1), K; if (2 === a && (t === W ? j(r) : t !== X && (k(r, 0, 0, !1), t === Y) && (ge(r.head), 0 === r.lookahead) && (r.strstart = 0, r.block_start = 0, r.insert = 0), ve(e), 0 === e.avail_out)) return r.last_flush = -1, K } return t === $ && (r.wrap <= 0 || (2 === r.wrap ? (Te(r, 255 & e.adler), Te(r, e.adler >> 8 & 255), Te(r, e.adler >> 16 & 255), Te(r, e.adler >> 24 & 255), Te(r, 255 & e.total_in), Te(r, e.total_in >> 8 & 255), Te(r, e.total_in >> 16 & 255), Te(r, e.total_in >> 24 & 255)) : (Ie(r, e.adler >>> 16), Ie(r, 65535 & e.adler)), ve(e), 0 < r.wrap && (r.wrap = -r.wrap), 0 === r.pending)) ? J : K })(a, i) === He) return 0 < a.next_out && this.onData(a.output.subarray(0, a.next_out)), r = void 0, r = (s = this.strm) && s.state ? 42 !== (r = s.state.status) && 69 !== r && 73 !== r && 91 !== r && 103 !== r && 113 !== r && 666 !== r ? me(s, Q) : (s.state = null, 113 === r ? me(s, Z) : K) : Q, this.onEnd(r), this.ended = !0, r === Ve; if (0 === a.avail_out) this.onData(a.output); else if (0 < i && 0 < a.next_out) this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0; else if (0 === a.avail_in) break } return !0 }, Ye.prototype.onData = function (e) { this.chunks.push(e) }, Ye.prototype.onEnd = function (e) { e === Ve && (this.result = Me(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg }, x = { Deflate: Ye, deflate: $e, deflateRaw: function (e, t) { return (t = t || {}).raw = !0, $e(e, t) }, gzip: function (e, t) { return (t = t || {}).gzip = !0, $e(e, t) }, constants: G }; const Xe = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), Ke = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), Je = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), Qe = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]); var Ze = (e, t, i, s, r, a, o, n) => { var h, l = n.bits; let c, u, p, d, m, f = 0, g = 0, _ = 0, v = 0, y = 0, T = 0, I = 0, E = 0, C = 0, P = 0, b = null, A = 0; var D = new Uint16Array(16), R = new Uint16Array(16); let F, w, M, S = null, x = 0; for (f = 0; f <= 15; f++)D[f] = 0; for (g = 0; g < s; g++)D[t[i + g]]++; for (y = l, v = 15; 1 <= v && 0 === D[v]; v--); if (y > v && (y = v), 0 === v) r[a++] = 20971520, r[a++] = 20971520, n.bits = 1; else { for (_ = 1; _ < v && 0 === D[_]; _++); for (y < _ && (y = _), E = 1, f = 1; f <= 15; f++)if ((E = (E <<= 1) - D[f]) < 0) return -1; if (0 < E && (0 === e || 1 !== v)) return -1; for (R[1] = 0, f = 1; f < 15; f++)R[f + 1] = R[f] + D[f]; for (g = 0; g < s; g++)0 !== t[i + g] && (o[R[t[i + g]]++] = g); if (m = 0 === e ? (b = S = o, 19) : 1 === e ? (b = Xe, A -= 257, S = Ke, x -= 257, 256) : (b = Je, S = Qe, -1), P = 0, g = 0, f = _, d = a, T = y, I = 0, p = -1, h = (C = 1 << y) - 1, 1 === e && 852 < C || 2 === e && 592 < C) return 1; for (; ;) { for (F = f - I, M = o[g] < m ? (w = 0, o[g]) : o[g] > m ? (w = S[x + o[g]], b[A + o[g]]) : (w = 96, 0), c = 1 << f - I, u = 1 << T, _ = u; u -= c, r[d + (P >> I) + u] = F << 24 | w << 16 | M, 0 !== u;); for (c = 1 << f - 1; P & c;)c >>= 1; if (P = 0 !== c ? (P &= c - 1) + c : 0, g++, 0 == --D[f]) { if (f === v) break; f = t[i + o[g]] } if (f > y && (P & h) !== p) { for (0 === I && (I = y), d += _, T = f - I, E = 1 << T; T + I < v && !((E -= D[T + I]) <= 0);)T++, E <<= 1; if (C += 1 << T, 1 === e && 852 < C || 2 === e && 592 < C) return 1; r[p = P & h] = y << 24 | T << 16 | d - a } } 0 !== P && (r[d + P] = f - I << 24 | 64 << 16), n.bits = y } return 0 }; const { Z_FINISH: qe, Z_BLOCK: et, Z_TREES: tt, Z_OK: it, Z_STREAM_END: st, Z_NEED_DICT: rt, Z_STREAM_ERROR: at, Z_DATA_ERROR: ot, Z_MEM_ERROR: nt, Z_BUF_ERROR: ht, Z_DEFLATED: lt } = G, ct = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24); function ut() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } const pt = e => { var t; return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, it) : at }, dt = e => { var t; return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, pt(e)) : at }, mt = (e, t) => { let i; var s; return !e || !e.state || (s = e.state, t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t)) ? at : (null !== s.window && s.wbits !== t && (s.window = null), s.wrap = i, s.wbits = t, dt(e)) }; let ft, gt, _t = !0; const vt = (e, t, i, s) => { let r; return null === (e = e.state).window && (e.wsize = 1 << e.wbits, e.wnext = 0, e.whave = 0, e.window = new Uint8Array(e.wsize)), s >= e.wsize ? (e.window.set(t.subarray(i - e.wsize, i), 0), e.wnext = 0, e.whave = e.wsize) : ((r = e.wsize - e.wnext) > s && (r = s), e.window.set(t.subarray(i - s, i - s + r), e.wnext), (s -= r) ? (e.window.set(t.subarray(i - s, i), 0), e.wnext = s, e.whave = e.wsize) : (e.wnext += r, e.wnext === e.wsize && (e.wnext = 0), e.whave < e.wsize && (e.whave += r))), 0 }; function yt() { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } var Tt = dt, It = (e, t) => { var i; let s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I, E, C, P = 0; var b = new Uint8Array(4); let A, D; var R = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return at; 12 === (i = e.state).mode && (i.mode = 13), o = e.next_out, r = e.output, h = e.avail_out, a = e.next_in, s = e.input, n = e.avail_in, l = i.hold, c = i.bits, u = n, p = h, C = it; e: for (; ;)switch (i.mode) { case 1: if (0 === i.wrap) i.mode = 13; else { for (; c < 16;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (2 & i.wrap && 35615 === l) b[i.check = 0] = 255 & l, b[1] = l >>> 8 & 255, i.check = N(i.check, b, 2, 0), l = 0, c = 0, i.mode = 2; else if (i.flags = 0, i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) e.msg = "incorrect header check", i.mode = 30; else if ((15 & l) !== lt) e.msg = "unknown compression method", i.mode = 30; else { if (l >>>= 4, c -= 4, E = 8 + (15 & l), 0 === i.wbits) i.wbits = E; else if (E > i.wbits) { e.msg = "invalid window size", i.mode = 30; break } i.dmax = 1 << i.wbits, e.adler = i.check = 1, i.mode = 512 & l ? 10 : 12, l = 0, c = 0 } } break; case 2: for (; c < 16;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (i.flags = l, (255 & i.flags) !== lt) { e.msg = "unknown compression method", i.mode = 30; break } if (57344 & i.flags) { e.msg = "unknown header flags set", i.mode = 30; break } i.head && (i.head.text = l >> 8 & 1), 512 & i.flags && (b[0] = 255 & l, b[1] = l >>> 8 & 255, i.check = N(i.check, b, 2, 0)), l = 0, c = 0, i.mode = 3; case 3: for (; c < 32;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.head && (i.head.time = l), 512 & i.flags && (b[0] = 255 & l, b[1] = l >>> 8 & 255, b[2] = l >>> 16 & 255, b[3] = l >>> 24 & 255, i.check = N(i.check, b, 4, 0)), l = 0, c = 0, i.mode = 4; case 4: for (; c < 16;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.head && (i.head.xflags = 255 & l, i.head.os = l >> 8), 512 & i.flags && (b[0] = 255 & l, b[1] = l >>> 8 & 255, i.check = N(i.check, b, 2, 0)), l = 0, c = 0, i.mode = 5; case 5: if (1024 & i.flags) { for (; c < 16;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.length = l, i.head && (i.head.extra_len = l), 512 & i.flags && (b[0] = 255 & l, b[1] = l >>> 8 & 255, i.check = N(i.check, b, 2, 0)), l = 0, c = 0 } else i.head && (i.head.extra = null); i.mode = 6; case 6: if (1024 & i.flags && ((d = (d = i.length) > n ? n : d) && (i.head && (E = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(s.subarray(a, a + d), E)), 512 & i.flags && (i.check = N(i.check, s, d, a)), n -= d, a += d, i.length -= d), i.length)) break e; i.length = 0, i.mode = 7; case 7: if (2048 & i.flags) { if (0 === n) break e; for (d = 0; E = s[a + d++], i.head && E && i.length < 65536 && (i.head.name += String.fromCharCode(E)), E && d < n;); if (512 & i.flags && (i.check = N(i.check, s, d, a)), n -= d, a += d, E) break e } else i.head && (i.head.name = null); i.length = 0, i.mode = 8; case 8: if (4096 & i.flags) { if (0 === n) break e; for (d = 0; E = s[a + d++], i.head && E && i.length < 65536 && (i.head.comment += String.fromCharCode(E)), E && d < n;); if (512 & i.flags && (i.check = N(i.check, s, d, a)), n -= d, a += d, E) break e } else i.head && (i.head.comment = null); i.mode = 9; case 9: if (512 & i.flags) { for (; c < 16;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (l !== (65535 & i.check)) { e.msg = "header crc mismatch", i.mode = 30; break } l = 0, c = 0 } i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = 12; break; case 10: for (; c < 32;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } e.adler = i.check = ct(l), l = 0, c = 0, i.mode = 11; case 11: if (0 === i.havedict) return e.next_out = o, e.avail_out = h, e.next_in = a, e.avail_in = n, i.hold = l, i.bits = c, rt; e.adler = i.check = 1, i.mode = 12; case 12: if (t === et || t === tt) break e; case 13: if (i.last) l >>>= 7 & c, c -= 7 & c, i.mode = 27; else { for (; c < 3;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } switch (i.last = 1 & l, l >>>= 1, --c, 3 & l) { case 0: i.mode = 14; break; case 1: var F = i; if (_t) { ft = new Int32Array(512), gt = new Int32Array(32); let e = 0; for (; e < 144;)F.lens[e++] = 8; for (; e < 256;)F.lens[e++] = 9; for (; e < 280;)F.lens[e++] = 7; for (; e < 288;)F.lens[e++] = 8; for (Ze(1, F.lens, 0, 288, ft, 0, F.work, { bits: 9 }), e = 0; e < 32;)F.lens[e++] = 5; Ze(2, F.lens, 0, 32, gt, 0, F.work, { bits: 5 }), _t = !1 } if (F.lencode = ft, F.lenbits = 9, F.distcode = gt, F.distbits = 5, i.mode = 20, t !== tt) break; l >>>= 2, c -= 2; break e; case 2: i.mode = 17; break; case 3: e.msg = "invalid block type", i.mode = 30 }l >>>= 2, c -= 2 } break; case 14: for (l >>>= 7 & c, c -= 7 & c; c < 32;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if ((65535 & l) != (l >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", i.mode = 30; break } if (i.length = 65535 & l, l = 0, c = 0, i.mode = 15, t === tt) break e; case 15: i.mode = 16; case 16: if (d = i.length) { if (0 === (d = (d = d > n ? n : d) > h ? h : d)) break e; r.set(s.subarray(a, a + d), o), n -= d, a += d, h -= d, o += d, i.length -= d } else i.mode = 12; break; case 17: for (; c < 14;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (i.nlen = 257 + (31 & l), l >>>= 5, c -= 5, i.ndist = 1 + (31 & l), l >>>= 5, c -= 5, i.ncode = 4 + (15 & l), l >>>= 4, c -= 4, 286 < i.nlen || 30 < i.ndist) { e.msg = "too many length or distance symbols", i.mode = 30; break } i.have = 0, i.mode = 18; case 18: for (; i.have < i.ncode;) { for (; c < 3;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.lens[R[i.have++]] = 7 & l, l >>>= 3, c -= 3 } for (; i.have < 19;)i.lens[R[i.have++]] = 0; if (i.lencode = i.lendyn, i.lenbits = 7, A = { bits: i.lenbits }, C = Ze(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, C) { e.msg = "invalid code lengths set", i.mode = 30; break } i.have = 0, i.mode = 19; case 19: for (; i.have < i.nlen + i.ndist;) { for (; P = i.lencode[l & (1 << i.lenbits) - 1], g = P >>> 24, _ = P >>> 16 & 255, v = 65535 & P, !(g <= c);) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (v < 16) l >>>= g, c -= g, i.lens[i.have++] = v; else { if (16 === v) { for (D = g + 2; c < D;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (l >>>= g, c -= g, 0 === i.have) { e.msg = "invalid bit length repeat", i.mode = 30; break } E = i.lens[i.have - 1], d = 3 + (3 & l), l >>>= 2, c -= 2 } else if (17 === v) { for (D = g + 3; c < D;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } l >>>= g, c -= g, E = 0, d = 3 + (7 & l), l >>>= 3, c -= 3 } else { for (D = g + 7; c < D;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } l >>>= g, c -= g, E = 0, d = 11 + (127 & l), l >>>= 7, c -= 7 } if (i.have + d > i.nlen + i.ndist) { e.msg = "invalid bit length repeat", i.mode = 30; break } for (; d--;)i.lens[i.have++] = E } } if (30 === i.mode) break; if (0 === i.lens[256]) { e.msg = "invalid code -- missing end-of-block", i.mode = 30; break } if (i.lenbits = 9, A = { bits: i.lenbits }, C = Ze(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, C) { e.msg = "invalid literal/lengths set", i.mode = 30; break } if (i.distbits = 6, i.distcode = i.distdyn, A = { bits: i.distbits }, C = Ze(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, C) { e.msg = "invalid distances set", i.mode = 30; break } if (i.mode = 20, t === tt) break e; case 20: i.mode = 21; case 21: if (6 <= n && 258 <= h) { e.next_out = o, e.avail_out = h, e.next_in = a, e.avail_in = n, i.hold = l, i.bits = c; { var w, M, S, x, O, B, G, U, k, V, H, j, z, W, Y = void 0, $ = void 0, X = e, K = p; let t, i, s, r, a, o, n, h, l; $ = X.state, t = X.next_in, W = X.input, w = t + (X.avail_in - 5), i = X.next_out, Y = X.output, M = i - (K - X.avail_out), S = i + (X.avail_out - 257), x = $.dmax, O = $.wsize, B = $.whave, G = $.wnext, U = $.window, s = $.hold, r = $.bits, k = $.lencode, V = $.distcode, H = (1 << $.lenbits) - 1, j = (1 << $.distbits) - 1; t: do { for (r < 15 && (s += W[t++] << r, r += 8, s += W[t++] << r, r += 8), a = k[s & H]; ;) { if (o = a >>> 24, s >>>= o, r -= o, 0 == (o = a >>> 16 & 255)) Y[i++] = 65535 & a; else { if (!(16 & o)) { if (!(64 & o)) { a = k[(65535 & a) + (s & (1 << o) - 1)]; continue } if (32 & o) { $.mode = 12; break t } X.msg = "invalid literal/length code", $.mode = 30; break t } for (n = 65535 & a, (o &= 15) && (r < o && (s += W[t++] << r, r += 8), n += s & (1 << o) - 1, s >>>= o, r -= o), r < 15 && (s += W[t++] << r, r += 8, s += W[t++] << r, r += 8), a = V[s & j]; ;) { if (o = a >>> 24, s >>>= o, r -= o, !(16 & (o = a >>> 16 & 255))) { if (!(64 & o)) { a = V[(65535 & a) + (s & (1 << o) - 1)]; continue } X.msg = "invalid distance code", $.mode = 30; break t } if (z = 65535 & a, o &= 15, r < o && (s += W[t++] << r, (r += 8) < o) && (s += W[t++] << r, r += 8), x < (z += s & (1 << o) - 1)) { X.msg = "invalid distance too far back", $.mode = 30; break t } if (s >>>= o, r -= o, z > (o = i - M)) { if ((o = z - o) > B && $.sane) { X.msg = "invalid distance too far back", $.mode = 30; break t } if (h = 0, l = U, 0 === G) { if (h += O - o, o < n) { for (n -= o; Y[i++] = U[h++], --o;); h = i - z, l = Y } } else if (G < o) { if (h += O + G - o, (o -= G) < n) { for (n -= o; Y[i++] = U[h++], --o;); if (h = 0, G < n) { for (o = G, n -= o; Y[i++] = U[h++], --o;); h = i - z, l = Y } } } else if (h += G - o, o < n) { for (n -= o; Y[i++] = U[h++], --o;); h = i - z, l = Y } for (; 2 < n;)Y[i++] = l[h++], Y[i++] = l[h++], Y[i++] = l[h++], n -= 3; n && (Y[i++] = l[h++], 1 < n) && (Y[i++] = l[h++]) } else { for (h = i - z; Y[i++] = Y[h++], Y[i++] = Y[h++], Y[i++] = Y[h++], 2 < (n -= 3);); n && (Y[i++] = Y[h++], 1 < n) && (Y[i++] = Y[h++]) } break } } break } } while (t < w && i < S); n = r >> 3, t -= n, r -= n << 3, s &= (1 << r) - 1, X.next_in = t, X.next_out = i, X.avail_in = t < w ? w - t + 5 : 5 - (t - w), X.avail_out = i < S ? S - i + 257 : 257 - (i - S), $.hold = s, $.bits = r } o = e.next_out, r = e.output, h = e.avail_out, a = e.next_in, s = e.input, n = e.avail_in, l = i.hold, c = i.bits, 12 === i.mode && (i.back = -1); break } for (i.back = 0; P = i.lencode[l & (1 << i.lenbits) - 1], g = P >>> 24, _ = P >>> 16 & 255, v = 65535 & P, !(g <= c);) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (_ && !(240 & _)) { for (y = g, T = _, I = v; P = i.lencode[I + ((l & (1 << y + T) - 1) >> y)], g = P >>> 24, _ = P >>> 16 & 255, v = 65535 & P, !(y + g <= c);) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } l >>>= y, c -= y, i.back += y } if (l >>>= g, c -= g, i.back += g, i.length = v, 0 === _) { i.mode = 26; break } if (32 & _) { i.back = -1, i.mode = 12; break } if (64 & _) { e.msg = "invalid literal/length code", i.mode = 30; break } i.extra = 15 & _, i.mode = 22; case 22: if (i.extra) { for (D = i.extra; c < D;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.length += l & (1 << i.extra) - 1, l >>>= i.extra, c -= i.extra, i.back += i.extra } i.was = i.length, i.mode = 23; case 23: for (; P = i.distcode[l & (1 << i.distbits) - 1], g = P >>> 24, _ = P >>> 16 & 255, v = 65535 & P, !(g <= c);) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (!(240 & _)) { for (y = g, T = _, I = v; P = i.distcode[I + ((l & (1 << y + T) - 1) >> y)], g = P >>> 24, _ = P >>> 16 & 255, v = 65535 & P, !(y + g <= c);) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } l >>>= y, c -= y, i.back += y } if (l >>>= g, c -= g, i.back += g, 64 & _) { e.msg = "invalid distance code", i.mode = 30; break } i.offset = v, i.extra = 15 & _, i.mode = 24; case 24: if (i.extra) { for (D = i.extra; c < D;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } i.offset += l & (1 << i.extra) - 1, l >>>= i.extra, c -= i.extra, i.back += i.extra } if (i.offset > i.dmax) { e.msg = "invalid distance too far back", i.mode = 30; break } i.mode = 25; case 25: if (0 === h) break e; if (d = p - h, i.offset > d) { if ((d = i.offset - d) > i.whave && i.sane) { e.msg = "invalid distance too far back", i.mode = 30; break } m = d > i.wnext ? (d -= i.wnext, i.wsize - d) : i.wnext - d, d > i.length && (d = i.length), f = i.window } else f = r, m = o - i.offset, d = i.length; for (d > h && (d = h), h -= d, i.length -= d; r[o++] = f[m++], --d;); 0 === i.length && (i.mode = 21); break; case 26: if (0 === h) break e; r[o++] = i.length, h--, i.mode = 21; break; case 27: if (i.wrap) { for (; c < 32;) { if (0 === n) break e; n--, l |= s[a++] << c, c += 8 } if (p -= h, e.total_out += p, i.total += p, p && (e.adler = i.check = (i.flags ? N : L)(i.check, r, p, o - p)), p = h, (i.flags ? l : ct(l)) !== i.check) { e.msg = "incorrect data check", i.mode = 30; break } l = 0, c = 0 } i.mode = 28; case 28: if (i.wrap && i.flags) { for (; c < 32;) { if (0 === n) break e; n--, l += s[a++] << c, c += 8 } if (l !== (4294967295 & i.total)) { e.msg = "incorrect length check", i.mode = 30; break } l = 0, c = 0 } i.mode = 29; case 29: C = st; break e; case 30: C = ot; break e; case 31: return nt; default: return at }return e.next_out = o, e.avail_out = h, e.next_in = a, e.avail_in = n, i.hold = l, i.bits = c, (i.wsize || p !== e.avail_out && i.mode < 30 && (i.mode < 27 || t !== qe)) && vt(e, e.output, e.next_out, p - e.avail_out), u -= e.avail_in, p -= e.avail_out, e.total_in += u, e.total_out += p, i.total += p, i.wrap && p && (e.adler = i.check = (i.flags ? N : L)(i.check, r, p, e.next_out - p)), e.data_type = i.bits + (i.last ? 64 : 0) + (12 === i.mode ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 == u && 0 === p || t === qe) && C === it ? ht : C }, Et = (e, t) => { var i, s = t.length; return !e || !e.state || 0 !== (i = e.state).wrap && 11 !== i.mode ? at : 11 === i.mode && L(1, t, s, 0) !== i.check ? ot : vt(e, t, s, s) ? (i.mode = 31, nt) : (i.havedict = 1, it) }; const Ct = Object.prototype.toString, { Z_NO_FLUSH: Pt, Z_FINISH: bt, Z_OK: At, Z_STREAM_END: Dt, Z_NEED_DICT: Rt, Z_STREAM_ERROR: Ft, Z_DATA_ERROR: wt, Z_MEM_ERROR: Mt } = G; function St(e) { this.options = we({ chunkSize: 65536, windowBits: 15, to: "" }, e || {}); var t, i, s, r = this.options; if (r.raw && 0 <= r.windowBits && r.windowBits < 16 && (r.windowBits = -r.windowBits, 0 === r.windowBits) && (r.windowBits = -15), !(0 <= r.windowBits && r.windowBits < 16) || e && e.windowBits || (r.windowBits += 32), 15 < r.windowBits && r.windowBits < 48 && !(15 & r.windowBits) && (r.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Le, this.strm.avail_out = 0, t = this.strm, i = r.windowBits, (e = t ? (s = new ut, (t.state = s).window = null, (s = mt(t, i)) !== it && (t.state = null), s) : at) !== At) throw new Error(B[e]); if (this.header = new yt, i = this.strm, t = this.header, i && i.state && 2 & (i = i.state).wrap && ((i.head = t).done = !1), r.dictionary && ("string" == typeof r.dictionary ? r.dictionary = Oe(r.dictionary) : "[object ArrayBuffer]" === Ct.call(r.dictionary) && (r.dictionary = new Uint8Array(r.dictionary)), r.raw) && (e = Et(this.strm, r.dictionary)) !== At) throw new Error(B[e]) } function xt(e, t) { if ((t = new St(t)).push(e), t.err) throw t.msg || B[t.err]; return t.result } St.prototype.push = function (e, t) { var i, s, r, a = this.strm, o = this.options.chunkSize, n = this.options.dictionary; let h, l, c; if (this.ended) return !1; for (l = t === ~~t ? t : !0 === t ? bt : Pt, "[object ArrayBuffer]" === Ct.call(e) ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ;) { for (0 === a.avail_out && (a.output = new Uint8Array(o), a.next_out = 0, a.avail_out = o), (h = It(a, l)) === Rt && n && ((h = Et(a, n)) === At ? h = It(a, l) : h === wt && (h = Rt)); 0 < a.avail_in && h === Dt && 0 < a.state.wrap && 0 !== e[a.next_in];)Tt(a), h = It(a, l); switch (h) { case Ft: case wt: case Rt: case Mt: return this.onEnd(h), !(this.ended = !0) }if (c = a.avail_out, !a.next_out || 0 !== a.avail_out && h !== Dt || ("string" === this.options.to ? (s = ((e, t) => { let i = (t = (t = a.next_out || e.length) > e.length ? e.length : t) - 1; for (; 0 <= i && 128 == (192 & e[i]);)i--; return !(i < 0) && 0 !== i && i + xe[e[i]] > t ? i : t })(a.output), r = a.next_out - s, i = ((e, t) => { var i = t || e.length; if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(e.subarray(0, t)); let s, r; var a = new Array(2 * i); for (r = 0, s = 0; s < i;) { let t = e[s++]; if (t < 128) a[r++] = t; else { let o = xe[t]; if (4 < o) a[r++] = 65533, s += o - 1; else { for (t &= 2 === o ? 31 : 3 === o ? 15 : 7; 1 < o && s < i;)t = t << 6 | 63 & e[s++], o--; 1 < o ? a[r++] = 65533 : t < 65536 ? a[r++] = t : (t -= 65536, a[r++] = 55296 | t >> 10 & 1023, a[r++] = 56320 | 1023 & t) } } } { var o = a, n = r; if (n < 65534 && o.subarray && Se) return String.fromCharCode.apply(null, o.length === n ? o : o.subarray(0, n)); let e = ""; for (let t = 0; t < n; t++)e += String.fromCharCode(o[t]); return e } })(a.output, s), a.next_out = r, a.avail_out = o - r, r && a.output.set(a.output.subarray(s, s + r), 0), this.onData(i)) : this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out))), h !== At || 0 !== c) { if (h === Dt) return r = void 0, h = (s = this.strm) && s.state ? ((r = s.state).window && (r.window = null), s.state = null, it) : at, this.onEnd(h), this.ended = !0; if (0 === a.avail_in) break } } return !0 }, St.prototype.onData = function (e) { this.chunks.push(e) }, St.prototype.onEnd = function (e) { e === At && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Me(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg }; var { Deflate: Pe, deflate: x, deflateRaw: Lt, gzip: Ot } = x, { Inflate: Nt, inflate: Bt, inflateRaw: Gt, ungzip: Ut } = { Inflate: St, inflate: xt, inflateRaw: function (e, t) { return (t = t || {}).raw = !0, xt(e, t) }, ungzip: xt }, kt = { Deflate: Pe, deflate: x, deflateRaw: Lt, gzip: Ot, Inflate: Nt, inflate: Bt, inflateRaw: Gt, ungzip: Ut, constants: G }; e.Deflate = Pe, e.Inflate = Nt, e.constants = G, e.default = kt, e.deflate = x, e.deflateRaw = Lt, e.gzip = Ot, e.inflate = Bt, e.inflateRaw = Gt, e.ungzip = Ut, Object.defineProperty(e, "__esModule", { value: !0 }) })); var p = Object.freeze({ __proto__: null }); let pako$9 = window.pako || p; pako$9.inflate || (pako$9 = pako$9.default); const decompressColor$9 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function extract$9(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], meshPositions: e[4], meshIndices: e[5], meshEdgesIndices: e[6], meshColors: e[7], entityIDs: e[8], entityMeshes: e[9], entityIsObjects: e[10], positionsDecodeMatrix: e[11] } } function inflate$9(e) { return { positions: new Uint16Array(pako$9.inflate(e.positions).buffer), normals: new Int8Array(pako$9.inflate(e.normals).buffer), indices: new Uint32Array(pako$9.inflate(e.indices).buffer), edgeIndices: new Uint32Array(pako$9.inflate(e.edgeIndices).buffer), meshPositions: new Uint32Array(pako$9.inflate(e.meshPositions).buffer), meshIndices: new Uint32Array(pako$9.inflate(e.meshIndices).buffer), meshEdgesIndices: new Uint32Array(pako$9.inflate(e.meshEdgesIndices).buffer), meshColors: new Uint8Array(pako$9.inflate(e.meshColors).buffer), entityIDs: pako$9.inflate(e.entityIDs, { to: "string" }), entityMeshes: new Uint32Array(pako$9.inflate(e.entityMeshes).buffer), entityIsObjects: new Uint8Array(pako$9.inflate(e.entityIsObjects).buffer), positionsDecodeMatrix: new Float32Array(pako$9.inflate(e.positionsDecodeMatrix).buffer) } } function load$9(e, t, i, s) { s.positionsCompression = "precompressed", s.normalsCompression = "precompressed"; var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.meshPositions, l = i.meshIndices, c = i.meshEdgesIndices, u = i.meshColors, p = JSON.parse(i.entityIDs), d = i.entityMeshes, m = i.entityIsObjects, f = h.length, g = d.length; for (let A = 0; A < g; A++) { var _ = p[A], v = t.globalizeObjectIds ? math.globalizeObjectId(s.id, _) : _, y = {}, T = {}; if (_ = e.metaScene.metaObjects[v]) { if (t.excludeTypesMap && _.type && t.excludeTypesMap[_.type]) continue; if (t.includeTypesMap && _.type && !t.includeTypesMap[_.type]) continue; (_ = t.objectDefaults ? t.objectDefaults[_.type] || t.objectDefaults.DEFAULT : null) && (!1 === _.visible && (y.visible = !1), !1 === _.pickable && (y.pickable = !1), _.colorize && (T.color = _.colorize), void 0 !== _.opacity) && null !== _.opacity && (T.opacity = _.opacity) } else if (t.excludeUnclassifiedObjects) continue; _ = A === g - 1; var I = []; for (let e = d[A], t = _ ? d.length : d[A + 1]; e < t; e++) { var E = e === f - 1, C = v + ".mesh." + e, P = decompressColor$9(u.subarray(4 * e, 4 * e + 3)), b = u[4 * e + 3] / 255; s.createMesh(utils.apply(T, { id: C, primitive: "triangles", positionsCompressed: r.subarray(h[e], E ? r.length : h[e + 1]), normalsCompressed: a.subarray(h[e], E ? r.length : h[e + 1]), indices: o.subarray(l[e], E ? o.length : l[e + 1]), edgeIndices: n.subarray(c[e], E ? n.length : c[e + 1]), positionsDecodeMatrix: i.positionsDecodeMatrix, color: P, opacity: b })), I.push(C) } s.createEntity(utils.apply(y, { id: v, isObject: 1 === m[A], meshIds: I })) } } const ParserV1 = { version: 1, parse: function (e, t, i, s) { load$9(e, t, inflate$9(extract$9(i)), s) } }; let pako$8 = window.pako || p; function extract$8(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], meshPositions: e[4], meshIndices: e[5], meshEdgesIndices: e[6], meshColors: e[7], entityIDs: e[8], entityMeshes: e[9], entityIsObjects: e[10], positionsDecodeMatrix: e[11], entityMeshIds: e[12], entityMatrices: e[13], entityUsesInstancing: e[14] } } function inflate$8(e) { return { positions: new Uint16Array(pako$8.inflate(e.positions).buffer), normals: new Int8Array(pako$8.inflate(e.normals).buffer), indices: new Uint32Array(pako$8.inflate(e.indices).buffer), edgeIndices: new Uint32Array(pako$8.inflate(e.edgeIndices).buffer), meshPositions: new Uint32Array(pako$8.inflate(e.meshPositions).buffer), meshIndices: new Uint32Array(pako$8.inflate(e.meshIndices).buffer), meshEdgesIndices: new Uint32Array(pako$8.inflate(e.meshEdgesIndices).buffer), meshColors: new Uint8Array(pako$8.inflate(e.meshColors).buffer), entityIDs: pako$8.inflate(e.entityIDs, { to: "string" }), entityMeshes: new Uint32Array(pako$8.inflate(e.entityMeshes).buffer), entityIsObjects: new Uint8Array(pako$8.inflate(e.entityIsObjects).buffer), positionsDecodeMatrix: new Float32Array(pako$8.inflate(e.positionsDecodeMatrix).buffer), entityMeshIds: new Uint32Array(pako$8.inflate(e.entityMeshIds).buffer), entityMatrices: new Float32Array(pako$8.inflate(e.entityMatrices).buffer), entityUsesInstancing: new Uint8Array(pako$8.inflate(e.entityUsesInstancing).buffer) } } pako$8.inflate || (pako$8 = pako$8.default); const decompressColor$8 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$8(e, t, i, s) { s.positionsCompression = "precompressed", s.normalsCompression = "precompressed"; var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.meshPositions, l = i.meshIndices, c = i.meshEdgesIndices, u = i.meshColors, p = JSON.parse(i.entityIDs), d = i.entityMeshes, m = i.entityIsObjects, f = i.entityMeshIds, g = i.entityMatrices, _ = i.entityUsesInstancing, v = h.length, y = d.length, T = {}; for (let O = 0; O < y; O++) { var I = p[O], E = t.globalizeObjectIds ? math.globalizeObjectId(s.id, I) : I, C = (I = e.metaScene.metaObjects[E], {}), P = {}, b = g.subarray(16 * O, 16 * O + 16); if (I) { if (t.excludeTypesMap && I.type && t.excludeTypesMap[I.type]) continue; if (t.includeTypesMap && I.type && !t.includeTypesMap[I.type]) continue; (I = t.objectDefaults ? t.objectDefaults[I.type] || t.objectDefaults.DEFAULT : null) && (!1 === I.visible && (C.visible = !1), !1 === I.pickable && (C.pickable = !1), I.colorize && (P.color = I.colorize), void 0 !== I.opacity) && null !== I.opacity && (P.opacity = I.opacity) } else if (t.excludeUnclassifiedObjects) continue; I = O === y - 1; var A = []; for (let e = d[O], t = I ? f.length : d[O + 1]; e < t; e++) { var D = f[e], R = D === v - 1, F = E + ".mesh." + D, w = decompressColor$8(u.subarray(4 * D, 4 * D + 3)), M = u[4 * D + 3] / 255, S = r.subarray(h[D], R ? r.length : h[D + 1]), x = a.subarray(h[D], R ? r.length : h[D + 1]), L = o.subarray(l[D], R ? o.length : l[D + 1]); R = n.subarray(c[D], R ? n.length : c[D + 1]); 1 === _[O] ? ((D = "geometry." + D) in T || (s.createGeometry({ id: D, positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R, primitive: "triangles", positionsDecodeMatrix: i.positionsDecodeMatrix }), T[D] = !0), s.createMesh(utils.apply(P, { id: F, color: w, opacity: M, matrix: b, geometryId: D }))) : s.createMesh(utils.apply(P, { id: F, primitive: "triangles", positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R, positionsDecodeMatrix: i.positionsDecodeMatrix, color: w, opacity: M })), A.push(F) } A.length && s.createEntity(utils.apply(C, { id: E, isObject: 1 === m[O], meshIds: A })) } } const ParserV2 = { version: 2, parse: function (e, t, i, s) { load$8(e, t, inflate$8(extract$8(i)), s) } }; let pako$7 = window.pako || p; function extract$7(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], meshPositions: e[4], meshIndices: e[5], meshEdgesIndices: e[6], meshColors: e[7], entityIDs: e[8], entityMeshes: e[9], entityIsObjects: e[10], instancedPositionsDecodeMatrix: e[11], batchedPositionsDecodeMatrix: e[12], entityMeshIds: e[13], entityMatrices: e[14], entityUsesInstancing: e[15] } } function inflate$7(e) { return { positions: new Uint16Array(pako$7.inflate(e.positions).buffer), normals: new Int8Array(pako$7.inflate(e.normals).buffer), indices: new Uint32Array(pako$7.inflate(e.indices).buffer), edgeIndices: new Uint32Array(pako$7.inflate(e.edgeIndices).buffer), meshPositions: new Uint32Array(pako$7.inflate(e.meshPositions).buffer), meshIndices: new Uint32Array(pako$7.inflate(e.meshIndices).buffer), meshEdgesIndices: new Uint32Array(pako$7.inflate(e.meshEdgesIndices).buffer), meshColors: new Uint8Array(pako$7.inflate(e.meshColors).buffer), entityIDs: pako$7.inflate(e.entityIDs, { to: "string" }), entityMeshes: new Uint32Array(pako$7.inflate(e.entityMeshes).buffer), entityIsObjects: new Uint8Array(pako$7.inflate(e.entityIsObjects).buffer), instancedPositionsDecodeMatrix: new Float32Array(pako$7.inflate(e.instancedPositionsDecodeMatrix).buffer), batchedPositionsDecodeMatrix: new Float32Array(pako$7.inflate(e.batchedPositionsDecodeMatrix).buffer), entityMeshIds: new Uint32Array(pako$7.inflate(e.entityMeshIds).buffer), entityMatrices: new Float32Array(pako$7.inflate(e.entityMatrices).buffer), entityUsesInstancing: new Uint8Array(pako$7.inflate(e.entityUsesInstancing).buffer) } } pako$7.inflate || (pako$7 = pako$7.default); const decompressColor$7 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$7(e, t, i, s) { s.positionsCompression = "precompressed", s.normalsCompression = "precompressed"; var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.meshPositions, l = i.meshIndices, c = i.meshEdgesIndices, u = i.meshColors, p = JSON.parse(i.entityIDs), d = i.entityMeshes, m = i.entityIsObjects, f = i.entityMeshIds, g = i.entityMatrices, _ = i.entityUsesInstancing, v = h.length, y = d.length, T = {}; for (let O = 0; O < y; O++) { var I = p[O], E = t.globalizeObjectIds ? math.globalizeObjectId(s.id, I) : I, C = (I = e.metaScene.metaObjects[E], {}), P = {}, b = g.subarray(16 * O, 16 * O + 16); if (I) { if (t.excludeTypesMap && I.type && t.excludeTypesMap[I.type]) continue; if (t.includeTypesMap && I.type && !t.includeTypesMap[I.type]) continue; (I = t.objectDefaults ? t.objectDefaults[I.type] || t.objectDefaults.DEFAULT : null) && (!1 === I.visible && (C.visible = !1), !1 === I.pickable && (C.pickable = !1), I.colorize && (P.color = I.colorize), void 0 !== I.opacity) && null !== I.opacity && (P.opacity = I.opacity) } else if (t.excludeUnclassifiedObjects) continue; I = O === y - 1; var A = []; for (let e = d[O], t = I ? f.length : d[O + 1]; e < t; e++) { var D = f[e], R = D === v - 1, F = E + ".mesh." + D, w = decompressColor$7(u.subarray(4 * D, 4 * D + 3)), M = u[4 * D + 3] / 255, S = r.subarray(h[D], R ? r.length : h[D + 1]), x = a.subarray(h[D], R ? r.length : h[D + 1]), L = o.subarray(l[D], R ? o.length : l[D + 1]); R = n.subarray(c[D], R ? n.length : c[D + 1]); 1 === _[O] ? ((D = "geometry." + D) in T || (s.createGeometry({ id: D, positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R, primitive: "triangles", positionsDecodeMatrix: i.instancedPositionsDecodeMatrix }), T[D] = !0), s.createMesh(utils.apply(P, { id: F, color: w, opacity: M, matrix: b, geometryId: D }))) : s.createMesh(utils.apply(P, { id: F, primitive: "triangles", positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R, positionsDecodeMatrix: i.batchedPositionsDecodeMatrix, color: w, opacity: M })), A.push(F) } A.length && s.createEntity(utils.apply(C, { id: E, isObject: 1 === m[O], meshIds: A })) } } const ParserV3 = { version: 3, parse: function (e, t, i, s) { load$7(e, t, inflate$7(extract$7(i)), s) } }; let pako$6 = window.pako || p; function extract$6(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], decodeMatrices: e[4], matrices: e[5], eachPrimitivePositionsAndNormalsPortion: e[6], eachPrimitiveIndicesPortion: e[7], eachPrimitiveEdgeIndicesPortion: e[8], eachPrimitiveDecodeMatricesPortion: e[9], eachPrimitiveColor: e[10], primitiveInstances: e[11], eachEntityId: e[12], eachEntityPrimitiveInstancesPortion: e[13], eachEntityMatricesPortion: e[14], eachEntityMatrix: e[15] } } function inflate$6(e) { return { positions: new Uint16Array(pako$6.inflate(e.positions).buffer), normals: new Int8Array(pako$6.inflate(e.normals).buffer), indices: new Uint32Array(pako$6.inflate(e.indices).buffer), edgeIndices: new Uint32Array(pako$6.inflate(e.edgeIndices).buffer), decodeMatrices: new Float32Array(pako$6.inflate(e.decodeMatrices).buffer), matrices: new Float32Array(pako$6.inflate(e.matrices).buffer), eachPrimitivePositionsAndNormalsPortion: new Uint32Array(pako$6.inflate(e.eachPrimitivePositionsAndNormalsPortion).buffer), eachPrimitiveIndicesPortion: new Uint32Array(pako$6.inflate(e.eachPrimitiveIndicesPortion).buffer), eachPrimitiveEdgeIndicesPortion: new Uint32Array(pako$6.inflate(e.eachPrimitiveEdgeIndicesPortion).buffer), eachPrimitiveDecodeMatricesPortion: new Uint32Array(pako$6.inflate(e.eachPrimitiveDecodeMatricesPortion).buffer), eachPrimitiveColor: new Uint8Array(pako$6.inflate(e.eachPrimitiveColor).buffer), primitiveInstances: new Uint32Array(pako$6.inflate(e.primitiveInstances).buffer), eachEntityId: pako$6.inflate(e.eachEntityId, { to: "string" }), eachEntityPrimitiveInstancesPortion: new Uint32Array(pako$6.inflate(e.eachEntityPrimitiveInstancesPortion).buffer), eachEntityMatricesPortion: new Uint32Array(pako$6.inflate(e.eachEntityMatricesPortion).buffer) } } pako$6.inflate || (pako$6 = pako$6.default); const decompressColor$6 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$6(e, t, i, s) { s.positionsCompression = "precompressed", s.normalsCompression = "precompressed"; var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.decodeMatrices, l = i.matrices, c = i.eachPrimitivePositionsAndNormalsPortion, u = i.eachPrimitiveIndicesPortion, p = i.eachPrimitiveEdgeIndicesPortion; const d = i.eachPrimitiveDecodeMatricesPortion; var m = i.eachPrimitiveColor, f = i.primitiveInstances, g = JSON.parse(i.eachEntityId), _ = i.eachEntityPrimitiveInstancesPortion, v = i.eachEntityMatricesPortion, y = c.length, T = f.length, I = new Uint8Array(y), E = new Uint32Array(y), C = g.length; for (let e = 0; e < y; e++)E[e] = e; E.sort(((e, t) => d[e] < d[t] ? -1 : d[e] > d[t] ? 1 : 0)); for (let e = 0; e < T; e++)I[f[e]]++; var P = {}; for (let e = 0; e < C; e++) { var b = C - 1, A = e === b, D = _[e], R = A ? _[b] : _[e + 1]; for (let t = D; t < R; t++) { var F = f[t]; 1 < I[F] || (P[F] = e) } } for (let e = 0; e < y; e++) { var w = E[e], M = w === y - 1, S = 1 < I[w], x = decompressColor$6(m.subarray(4 * w, 4 * w + 3)), L = m[4 * w + 3] / 255, O = r.subarray(c[w], M ? r.length : c[w + 1]), N = a.subarray(c[w], M ? a.length : c[w + 1]), B = o.subarray(u[w], M ? o.length : u[w + 1]), G = (M = n.subarray(p[w], M ? n.length : p[w + 1]), h.subarray(d[w], d[w] + 16)); S ? s.createGeometry({ id: "geometry" + w, primitive: "triangles", positionsCompressed: O, normalsCompressed: N, indices: B, edgeIndices: M, positionsDecodeMatrix: G }) : (g[P[S = w]], w = {}, s.createMesh(utils.apply(w, { id: S, primitive: "triangles", positionsCompressed: O, normalsCompressed: N, indices: B, edgeIndices: M, positionsDecodeMatrix: G, color: x, opacity: L }))) } let U = 0; for (let e = 0; e < C; e++) { var k = C - 1, V = e === k, H = g[e], j = _[e], z = V ? _[k] : _[e + 1], W = []; for (let t = j; t < z; t++) { var Y = f[t]; if (1 < I[Y]) { var $ = "instance." + U++; const t = "geometry" + Y; var X = 16 * v[e]; X = l.subarray(X, 16 + X); s.createMesh(utils.apply({}, { id: $, geometryId: t, matrix: X })), W.push($) } else W.push(Y) } 0 < W.length && (V = {}, s.createEntity(utils.apply(V, { id: H, isObject: !0, meshIds: W }))) } } const ParserV4 = { version: 4, parse: function (e, t, i, s) { load$6(e, t, inflate$6(extract$6(i)), s) } }; let pako$5 = window.pako || p; function extract$5(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], matrices: e[4], eachPrimitivePositionsAndNormalsPortion: e[5], eachPrimitiveIndicesPortion: e[6], eachPrimitiveEdgeIndicesPortion: e[7], eachPrimitiveColor: e[8], primitiveInstances: e[9], eachEntityId: e[10], eachEntityPrimitiveInstancesPortion: e[11], eachEntityMatricesPortion: e[12] } } function inflate$5(e) { return { positions: new Float32Array(pako$5.inflate(e.positions).buffer), normals: new Int8Array(pako$5.inflate(e.normals).buffer), indices: new Uint32Array(pako$5.inflate(e.indices).buffer), edgeIndices: new Uint32Array(pako$5.inflate(e.edgeIndices).buffer), matrices: new Float32Array(pako$5.inflate(e.matrices).buffer), eachPrimitivePositionsAndNormalsPortion: new Uint32Array(pako$5.inflate(e.eachPrimitivePositionsAndNormalsPortion).buffer), eachPrimitiveIndicesPortion: new Uint32Array(pako$5.inflate(e.eachPrimitiveIndicesPortion).buffer), eachPrimitiveEdgeIndicesPortion: new Uint32Array(pako$5.inflate(e.eachPrimitiveEdgeIndicesPortion).buffer), eachPrimitiveColor: new Uint8Array(pako$5.inflate(e.eachPrimitiveColor).buffer), primitiveInstances: new Uint32Array(pako$5.inflate(e.primitiveInstances).buffer), eachEntityId: pako$5.inflate(e.eachEntityId, { to: "string" }), eachEntityPrimitiveInstancesPortion: new Uint32Array(pako$5.inflate(e.eachEntityPrimitiveInstancesPortion).buffer), eachEntityMatricesPortion: new Uint32Array(pako$5.inflate(e.eachEntityMatricesPortion).buffer) } } pako$5.inflate || (pako$5 = pako$5.default); const decompressColor$5 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$5(e, t, i, s) { s.positionsCompression = "disabled", s.normalsCompression = "precompressed"; var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.matrices, l = i.eachPrimitivePositionsAndNormalsPortion, c = i.eachPrimitiveIndicesPortion, u = i.eachPrimitiveEdgeIndicesPortion, p = i.eachPrimitiveColor, d = i.primitiveInstances, m = JSON.parse(i.eachEntityId), f = i.eachEntityPrimitiveInstancesPortion, g = i.eachEntityMatricesPortion, _ = l.length, v = d.length, y = new Uint8Array(_), T = m.length; for (let e = 0; e < v; e++)y[d[e]]++; var I = {}; for (let e = 0; e < T; e++) { var E = T - 1, C = e === E, P = f[e], b = C ? f[E] : f[e + 1]; for (let t = P; t < b; t++) { var A = d[t]; 1 < y[A] || (I[A] = e) } } for (let e = 0; e < _; e++) { var D, R = e === _ - 1, F = 1 < y[e], w = decompressColor$5(p.subarray(4 * e, 4 * e + 3)), M = p[4 * e + 3] / 255, S = r.subarray(l[e], R ? r.length : l[e + 1]), x = a.subarray(l[e], R ? a.length : l[e + 1]), L = o.subarray(c[e], R ? o.length : c[e + 1]); R = n.subarray(u[e], R ? n.length : u[e + 1]); F ? (D = "geometry" + e, s.createGeometry({ id: D, primitive: "triangles", positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R })) : (m[I[F = e]], D = {}, s.createMesh(utils.apply(D, { id: F, primitive: "triangles", positionsCompressed: S, normalsCompressed: x, indices: L, edgeIndices: R, color: w, opacity: M }))) } let O = 0; for (let e = 0; e < T; e++) { var N = T - 1, B = e === N, G = m[e], U = f[e], k = B ? f[N] : f[e + 1], V = []; for (let t = U; t < k; t++) { var H = d[t]; if (1 < y[H]) { var j = "instance." + O++; const t = "geometry" + H; var z = 16 * g[e]; z = h.subarray(z, 16 + z); s.createMesh(utils.apply({}, { id: j, geometryId: t, matrix: z })), V.push(j) } else V.push(H) } 0 < V.length && (B = {}, s.createEntity(utils.apply(B, { id: G, isObject: !0, meshIds: V }))) } } const ParserV5 = { version: 5, parse: function (e, t, i, s) { load$5(e, t, inflate$5(extract$5(i)), s) } }; let pako$4 = window.pako || p; function extract$4(e) { return { positions: e[0], normals: e[1], indices: e[2], edgeIndices: e[3], matrices: e[4], reusedPrimitivesDecodeMatrix: e[5], eachPrimitivePositionsAndNormalsPortion: e[6], eachPrimitiveIndicesPortion: e[7], eachPrimitiveEdgeIndicesPortion: e[8], eachPrimitiveColorAndOpacity: e[9], primitiveInstances: e[10], eachEntityId: e[11], eachEntityPrimitiveInstancesPortion: e[12], eachEntityMatricesPortion: e[13], eachTileAABB: e[14], eachTileEntitiesPortion: e[15] } } function inflate$4(e) { function t(e, t) { return 0 === e.length ? [] : pako$4.inflate(e, t).buffer } return { positions: new Uint16Array(t(e.positions)), normals: new Int8Array(t(e.normals)), indices: new Uint32Array(t(e.indices)), edgeIndices: new Uint32Array(t(e.edgeIndices)), matrices: new Float32Array(t(e.matrices)), reusedPrimitivesDecodeMatrix: new Float32Array(t(e.reusedPrimitivesDecodeMatrix)), eachPrimitivePositionsAndNormalsPortion: new Uint32Array(t(e.eachPrimitivePositionsAndNormalsPortion)), eachPrimitiveIndicesPortion: new Uint32Array(t(e.eachPrimitiveIndicesPortion)), eachPrimitiveEdgeIndicesPortion: new Uint32Array(t(e.eachPrimitiveEdgeIndicesPortion)), eachPrimitiveColorAndOpacity: new Uint8Array(t(e.eachPrimitiveColorAndOpacity)), primitiveInstances: new Uint32Array(t(e.primitiveInstances)), eachEntityId: pako$4.inflate(e.eachEntityId, { to: "string" }), eachEntityPrimitiveInstancesPortion: new Uint32Array(t(e.eachEntityPrimitiveInstancesPortion)), eachEntityMatricesPortion: new Uint32Array(t(e.eachEntityMatricesPortion)), eachTileAABB: new Float64Array(t(e.eachTileAABB)), eachTileEntitiesPortion: new Uint32Array(t(e.eachTileEntitiesPortion)) } } pako$4.inflate || (pako$4 = pako$4.default); const decompressColor$4 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$4(e, t, i, s) { var r = i.positions, a = i.normals, o = i.indices, n = i.edgeIndices, h = i.matrices, l = i.reusedPrimitivesDecodeMatrix, c = i.eachPrimitivePositionsAndNormalsPortion, u = i.eachPrimitiveIndicesPortion, p = i.eachPrimitiveEdgeIndicesPortion, d = i.eachPrimitiveColorAndOpacity, m = i.primitiveInstances, f = JSON.parse(i.eachEntityId), g = i.eachEntityPrimitiveInstancesPortion, _ = i.eachEntityMatricesPortion, v = i.eachTileAABB, y = i.eachTileEntitiesPortion, T = c.length, I = m.length, E = f.length, C = y.length; let P = 0; var b = new Uint32Array(T); for (let e = 0; e < I; e++) { var A = m[e]; void 0 !== b[A] ? b[A]++ : b[A] = 1 } var D = math.vec3(), R = math.AABB3(); for (let i = 0; i < C; i++) { var F = i === C - 1, w = y[i], M = F ? E : y[i + 1], S = (F = 6 * i, F = v.subarray(F, 6 + F), math.getAABB3Center(F, D), R[0] = F[0] - D[0], R[1] = F[1] - D[1], R[2] = F[2] - D[2], R[3] = F[3] - D[0], R[4] = F[4] - D[1], R[5] = F[5] - D[2], geometryCompressionUtils.createPositionsDecodeMatrix(R)), x = {}; for (let v = w; v < M; v++) { var L = f[v], O = (L = t.globalizeObjectIds ? math.globalizeObjectId(s.id, L) : L, _[v]), N = h.slice(O, O + 16), B = (O = v === E - 1, g[v]), G = O ? m.length : g[v + 1], U = [], k = {}, V = {}; if (O = e.metaScene.metaObjects[L]) { if (t.excludeTypesMap && O.type && t.excludeTypesMap[O.type]) continue; if (t.includeTypesMap && O.type && !t.includeTypesMap[O.type]) continue; (O = t.objectDefaults ? t.objectDefaults[O.type] || t.objectDefaults.DEFAULT : null) && (!1 === O.visible && (k.visible = !1), !1 === O.pickable && (k.pickable = !1), O.colorize && (V.color = O.colorize), void 0 !== O.opacity) && null !== O.opacity && (V.opacity = O.opacity) } else if (t.excludeUnclassifiedObjects) continue; for (let e = B; e < G; e++) { var H = m[e], j = 1 < b[H], z = r.subarray(c[H], ($ = H === T - 1) ? r.length : c[H + 1]), W = a.subarray(c[H], $ ? a.length : c[H + 1]), Y = o.subarray(u[H], $ ? o.length : u[H + 1]), $ = n.subarray(p[H], $ ? n.length : p[H + 1]), X = decompressColor$4(d.subarray(4 * H, 4 * H + 3)), K = d[4 * H + 3] / 255, J = P++; j ? (x[j = "geometry." + i + "." + H] || (s.createGeometry({ id: j, primitive: "triangles", positionsCompressed: z, normalsCompressed: W, indices: Y, edgeIndices: $, positionsDecodeMatrix: l }), x[j] = !0), s.createMesh(utils.apply(V, { id: J, geometryId: j, origin: D, matrix: N, color: X, opacity: K }))) : s.createMesh(utils.apply(V, { id: J, origin: D, primitive: "triangles", positionsCompressed: z, normalsCompressed: W, indices: Y, edgeIndices: $, positionsDecodeMatrix: S, color: X, opacity: K })), U.push(J) } 0 < U.length && s.createEntity(utils.apply(k, { id: L, isObject: !0, meshIds: U })) } } } const ParserV6 = { version: 6, parse: function (e, t, i, s) { load$4(e, t, inflate$4(extract$4(i)), s) } }; let pako$3 = window.pako || p; function extract$3(e) { return { positions: e[0], normals: e[1], colors: e[2], indices: e[3], edgeIndices: e[4], matrices: e[5], reusedGeometriesDecodeMatrix: e[6], eachGeometryPrimitiveType: e[7], eachGeometryPositionsPortion: e[8], eachGeometryNormalsPortion: e[9], eachGeometryColorsPortion: e[10], eachGeometryIndicesPortion: e[11], eachGeometryEdgeIndicesPortion: e[12], eachMeshGeometriesPortion: e[13], eachMeshMatricesPortion: e[14], eachMeshMaterial: e[15], eachEntityId: e[16], eachEntityMeshesPortion: e[17], eachTileAABB: e[18], eachTileEntitiesPortion: e[19] } } function inflate$3(e) { function t(e, t) { return 0 === e.length ? [] : pako$3.inflate(e, t).buffer } return { positions: new Uint16Array(t(e.positions)), normals: new Int8Array(t(e.normals)), colors: new Uint8Array(t(e.colors)), indices: new Uint32Array(t(e.indices)), edgeIndices: new Uint32Array(t(e.edgeIndices)), matrices: new Float32Array(t(e.matrices)), reusedGeometriesDecodeMatrix: new Float32Array(t(e.reusedGeometriesDecodeMatrix)), eachGeometryPrimitiveType: new Uint8Array(t(e.eachGeometryPrimitiveType)), eachGeometryPositionsPortion: new Uint32Array(t(e.eachGeometryPositionsPortion)), eachGeometryNormalsPortion: new Uint32Array(t(e.eachGeometryNormalsPortion)), eachGeometryColorsPortion: new Uint32Array(t(e.eachGeometryColorsPortion)), eachGeometryIndicesPortion: new Uint32Array(t(e.eachGeometryIndicesPortion)), eachGeometryEdgeIndicesPortion: new Uint32Array(t(e.eachGeometryEdgeIndicesPortion)), eachMeshGeometriesPortion: new Uint32Array(t(e.eachMeshGeometriesPortion)), eachMeshMatricesPortion: new Uint32Array(t(e.eachMeshMatricesPortion)), eachMeshMaterial: new Uint8Array(t(e.eachMeshMaterial)), eachEntityId: pako$3.inflate(e.eachEntityId, { to: "string" }), eachEntityMeshesPortion: new Uint32Array(t(e.eachEntityMeshesPortion)), eachTileAABB: new Float64Array(t(e.eachTileAABB)), eachTileEntitiesPortion: new Uint32Array(t(e.eachTileEntitiesPortion)) } } pako$3.inflate || (pako$3 = pako$3.default); const decompressColor$3 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function convertColorsRGBToRGBA$1(e) { var t = []; for (let i = 0, s = e.length; i < s; i += 3)t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]), t.push(1); return t } function load$3(e, t, i, s) { var r = i.positions, a = i.normals, o = i.colors, n = i.indices, h = i.edgeIndices, l = i.matrices, c = i.reusedGeometriesDecodeMatrix, u = i.eachGeometryPrimitiveType, p = i.eachGeometryPositionsPortion, d = i.eachGeometryNormalsPortion, m = i.eachGeometryColorsPortion, f = i.eachGeometryIndicesPortion, g = i.eachGeometryEdgeIndicesPortion, _ = i.eachMeshGeometriesPortion, v = i.eachMeshMatricesPortion, y = i.eachMeshMaterial, T = JSON.parse(i.eachEntityId), I = i.eachEntityMeshesPortion, E = i.eachTileAABB, C = i.eachTileEntitiesPortion, P = p.length, b = _.length, A = T.length, D = C.length; let R = 0; var F = new Uint32Array(P); for (let e = 0; e < b; e++) { var w = _[e]; void 0 !== F[w] ? F[w]++ : F[w] = 1 } var M = math.vec3(), S = math.AABB3(); for (let i = 0; i < D; i++) { var x = i === D - 1, L = C[i], O = x ? A : C[i + 1], N = (x = 6 * i, x = E.subarray(x, 6 + x), math.getAABB3Center(x, M), S[0] = x[0] - M[0], S[1] = x[1] - M[1], S[2] = x[2] - M[2], S[3] = x[3] - M[0], S[4] = x[4] - M[1], S[5] = x[5] - M[2], geometryCompressionUtils.createPositionsDecodeMatrix(S)), B = {}; for (let E = L; E < O; E++) { var G = T[E], U = (G = t.globalizeObjectIds ? math.globalizeObjectId(s.id, G) : G, E === A - 1), k = I[E], V = U ? _.length : I[E + 1], H = [], j = {}, z = {}; if (U = e.metaScene.metaObjects[G]) { if (t.excludeTypesMap && U.type && t.excludeTypesMap[U.type]) continue; if (t.includeTypesMap && U.type && !t.includeTypesMap[U.type]) continue; (U = t.objectDefaults ? t.objectDefaults[U.type] || t.objectDefaults.DEFAULT : null) && (!1 === U.visible && (j.visible = !1), !1 === U.pickable && (j.pickable = !1), U.colorize && (z.color = U.colorize), void 0 !== U.opacity && null !== U.opacity && (z.opacity = U.opacity), void 0 !== U.metallic && null !== U.metallic && (z.metallic = U.metallic), void 0 !== U.roughness) && null !== U.roughness && (z.roughness = U.roughness) } else if (t.excludeUnclassifiedObjects) continue; for (let e = k; e < V; e++) { var W = _[e], Y = 1 < F[W], $ = W === P - 1, X = decompressColor$3(y.subarray(6 * e, 6 * e + 3)), K = y[6 * e + 3] / 255, J = y[6 * e + 4] / 255, Q = y[6 * e + 5] / 255, Z = R++; if (Y) { Y = v[e], Y = l.slice(Y, Y + 16); var q = "geometry." + i + "." + W; if (!B[q]) { let e, t, i, l, _, v; switch (u[W]) { case 0: e = "solid", t = r.subarray(p[W], $ ? r.length : p[W + 1]), i = a.subarray(d[W], $ ? a.length : d[W + 1]), _ = n.subarray(f[W], $ ? n.length : f[W + 1]), v = h.subarray(g[W], $ ? h.length : g[W + 1]); break; case 1: e = "surface", t = r.subarray(p[W], $ ? r.length : p[W + 1]), i = a.subarray(d[W], $ ? a.length : d[W + 1]), _ = n.subarray(f[W], $ ? n.length : f[W + 1]), v = h.subarray(g[W], $ ? h.length : g[W + 1]); break; case 2: e = "points", t = r.subarray(p[W], $ ? r.length : p[W + 1]), l = convertColorsRGBToRGBA$1(o.subarray(m[W], $ ? o.length : m[W + 1])); break; case 3: e = "lines", t = r.subarray(p[W], $ ? r.length : p[W + 1]), _ = n.subarray(f[W], $ ? n.length : f[W + 1]); break; default: continue }s.createGeometry({ id: q, primitive: e, positionsCompressed: t, normalsCompressed: i, colors: l, indices: _, edgeIndices: v, positionsDecodeMatrix: c }), B[q] = !0 } s.createMesh(utils.apply(z, { id: Z, geometryId: q, origin: M, matrix: Y, color: X, metallic: J, roughness: Q, opacity: K })) } else { let e, t, i, l, c, _; switch (u[W]) { case 0: e = "solid", t = r.subarray(p[W], $ ? r.length : p[W + 1]), i = a.subarray(d[W], $ ? a.length : d[W + 1]), c = n.subarray(f[W], $ ? n.length : f[W + 1]), _ = h.subarray(g[W], $ ? h.length : g[W + 1]); break; case 1: e = "surface", t = r.subarray(p[W], $ ? r.length : p[W + 1]), i = a.subarray(d[W], $ ? a.length : d[W + 1]), c = n.subarray(f[W], $ ? n.length : f[W + 1]), _ = h.subarray(g[W], $ ? h.length : g[W + 1]); break; case 2: e = "points", t = r.subarray(p[W], $ ? r.length : p[W + 1]), l = convertColorsRGBToRGBA$1(o.subarray(m[W], $ ? o.length : m[W + 1])); break; case 3: e = "lines", t = r.subarray(p[W], $ ? r.length : p[W + 1]), c = n.subarray(f[W], $ ? n.length : f[W + 1]); break; default: continue }s.createMesh(utils.apply(z, { id: Z, origin: M, primitive: e, positionsCompressed: t, normalsCompressed: i, colors: l, indices: c, edgeIndices: _, positionsDecodeMatrix: N, color: X, metallic: J, roughness: Q, opacity: K })) } H.push(Z) } 0 < H.length && s.createEntity(utils.apply(j, { id: G, isObject: !0, meshIds: H })) } } } const ParserV7 = { version: 7, parse: function (e, t, i, s) { load$3(e, t, inflate$3(extract$3(i)), s) } }; let pako$2 = window.pako || p; pako$2.inflate || (pako$2 = pako$2.default); const tempVec4a$2 = math.vec4(), tempVec4b$2 = math.vec4(); function extract$2(e) { return { types: e[0], eachMetaObjectId: e[1], eachMetaObjectType: e[2], eachMetaObjectName: e[3], eachMetaObjectParent: e[4], positions: e[5], normals: e[6], colors: e[7], indices: e[8], edgeIndices: e[9], matrices: e[10], reusedGeometriesDecodeMatrix: e[11], eachGeometryPrimitiveType: e[12], eachGeometryPositionsPortion: e[13], eachGeometryNormalsPortion: e[14], eachGeometryColorsPortion: e[15], eachGeometryIndicesPortion: e[16], eachGeometryEdgeIndicesPortion: e[17], eachMeshGeometriesPortion: e[18], eachMeshMatricesPortion: e[19], eachMeshMaterial: e[20], eachEntityMetaObject: e[21], eachEntityMeshesPortion: e[22], eachTileAABB: e[23], eachTileEntitiesPortion: e[24] } } function inflate$2(e) { function t(e, t) { return 0 === e.length ? [] : pako$2.inflate(e, t).buffer } return { types: pako$2.inflate(e.types, { to: "string" }), eachMetaObjectId: pako$2.inflate(e.eachMetaObjectId, { to: "string" }), eachMetaObjectType: new Uint32Array(t(e.eachMetaObjectType)), eachMetaObjectName: pako$2.inflate(e.eachMetaObjectName, { to: "string" }), eachMetaObjectParent: new Uint32Array(t(e.eachMetaObjectParent)), positions: new Uint16Array(t(e.positions)), normals: new Int8Array(t(e.normals)), colors: new Uint8Array(t(e.colors)), indices: new Uint32Array(t(e.indices)), edgeIndices: new Uint32Array(t(e.edgeIndices)), matrices: new Float32Array(t(e.matrices)), reusedGeometriesDecodeMatrix: new Float32Array(t(e.reusedGeometriesDecodeMatrix)), eachGeometryPrimitiveType: new Uint8Array(t(e.eachGeometryPrimitiveType)), eachGeometryPositionsPortion: new Uint32Array(t(e.eachGeometryPositionsPortion)), eachGeometryNormalsPortion: new Uint32Array(t(e.eachGeometryNormalsPortion)), eachGeometryColorsPortion: new Uint32Array(t(e.eachGeometryColorsPortion)), eachGeometryIndicesPortion: new Uint32Array(t(e.eachGeometryIndicesPortion)), eachGeometryEdgeIndicesPortion: new Uint32Array(t(e.eachGeometryEdgeIndicesPortion)), eachMeshGeometriesPortion: new Uint32Array(t(e.eachMeshGeometriesPortion)), eachMeshMatricesPortion: new Uint32Array(t(e.eachMeshMatricesPortion)), eachMeshMaterial: new Uint8Array(t(e.eachMeshMaterial)), eachEntityMetaObject: new Uint32Array(t(e.eachEntityMetaObject)), eachEntityMeshesPortion: new Uint32Array(t(e.eachEntityMeshesPortion)), eachTileAABB: new Float64Array(t(e.eachTileAABB)), eachTileEntitiesPortion: new Uint32Array(t(e.eachTileEntitiesPortion)) } } const decompressColor$2 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function convertColorsRGBToRGBA(e) { var t = []; for (let i = 0, s = e.length; i < s; i += 3)t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]), t.push(1); return t } function load$2(e, t, i, s) { var r = JSON.parse(i.types), a = JSON.parse(i.eachMetaObjectId), o = i.eachMetaObjectType, n = JSON.parse(i.eachMetaObjectName), h = i.eachMetaObjectParent; const l = i.positions; var c = i.normals, u = i.colors, p = i.indices, d = i.edgeIndices, m = i.matrices, f = i.reusedGeometriesDecodeMatrix, g = i.eachGeometryPrimitiveType, _ = i.eachGeometryPositionsPortion, v = i.eachGeometryNormalsPortion, y = i.eachGeometryColorsPortion, T = i.eachGeometryIndicesPortion, I = i.eachGeometryEdgeIndicesPortion, E = i.eachMeshGeometriesPortion, C = i.eachMeshMatricesPortion, P = i.eachMeshMaterial, b = i.eachEntityMetaObject, A = i.eachEntityMeshesPortion, D = i.eachTileAABB, R = i.eachTileEntitiesPortion, F = a.length, w = _.length, M = E.length, S = b.length, x = R.length; let L = 0; const O = s.id; if (!e.metaScene.metaModels[O]) { var N = { metaObjects: [] }; for (let e = 0; e < F; e++) { var B = a[e], G = r[o[e]] || "default", U = n[e], k = (k = h[e]) !== e ? a[k] : null; N.metaObjects.push({ id: B, type: G, name: U, parent: k }) } e.metaScene.createMetaModel(O, N, { includeTypes: t.includeTypes, excludeTypes: t.excludeTypes, globalizeObjectIds: t.globalizeObjectIds }), s.once("destroyed", (() => { e.metaScene.destroyMetaModel(O) })) } var V = new Uint32Array(w); for (let e = 0; e < M; e++) { var H = E[e]; void 0 !== V[H] ? V[H]++ : V[H] = 1 } var j = math.vec3(), z = math.AABB3(), W = {}; for (let i = 0; i < x; i++) { var Y = i === x - 1, $ = R[i], X = Y ? S : R[i + 1], K = (Y = 6 * i, Y = D.subarray(Y, 6 + Y), math.getAABB3Center(Y, j), z[0] = Y[0] - j[0], z[1] = Y[1] - j[1], z[2] = Y[2] - j[2], z[3] = Y[3] - j[0], z[4] = Y[4] - j[1], z[5] = Y[5] - j[2], geometryCompressionUtils.createPositionsDecodeMatrix(z)), J = {}; for (let r = $; r < X; r++) { var Q = a[b[r]], Z = (Q = t.globalizeObjectIds ? math.globalizeObjectId(s.id, Q) : Q, r === S - 1), q = A[r], ee = Z ? E.length : A[r + 1], te = [], ie = {}, se = {}; if (Z = e.metaScene.metaObjects[Q]) { if (t.excludeTypesMap && Z.type && t.excludeTypesMap[Z.type]) continue; if (t.includeTypesMap && Z.type && !t.includeTypesMap[Z.type]) continue; (Z = t.objectDefaults ? t.objectDefaults[Z.type] || t.objectDefaults.DEFAULT : null) && (!1 === Z.visible && (ie.visible = !1), !1 === Z.pickable && (ie.pickable = !1), Z.colorize && (se.color = Z.colorize), void 0 !== Z.opacity && null !== Z.opacity && (se.opacity = Z.opacity), void 0 !== Z.metallic && null !== Z.metallic && (se.metallic = Z.metallic), void 0 !== Z.roughness) && null !== Z.roughness && (se.roughness = Z.roughness) } else if (t.excludeUnclassifiedObjects) continue; for (let e = q; e < ee; e++) { var re = E[e], ae = 1 < V[re], oe = re === w - 1, ne = decompressColor$2(P.subarray(6 * e, 6 * e + 3)), he = P[6 * e + 3] / 255, le = P[6 * e + 4] / 255, ce = P[6 * e + 5] / 255, ue = L++; if (ae) { ae = C[e]; var pe = m.slice(ae, ae + 16); let r = W[ae = "geometry." + i + "." + re]; if (!r) { let e = !(r = { batchThisMesh: !t.reuseGeometries }); switch (g[re]) { case 0: r.primitiveName = "solid", r.geometryPositions = l.subarray(_[re], oe ? l.length : _[re + 1]), r.geometryNormals = c.subarray(v[re], oe ? c.length : v[re + 1]), r.geometryIndices = p.subarray(T[re], oe ? p.length : T[re + 1]), r.geometryEdgeIndices = d.subarray(I[re], oe ? d.length : I[re + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 1: r.primitiveName = "surface", r.geometryPositions = l.subarray(_[re], oe ? l.length : _[re + 1]), r.geometryNormals = c.subarray(v[re], oe ? c.length : v[re + 1]), r.geometryIndices = p.subarray(T[re], oe ? p.length : T[re + 1]), r.geometryEdgeIndices = d.subarray(I[re], oe ? d.length : I[re + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 2: r.primitiveName = "points", r.geometryPositions = l.subarray(_[re], oe ? l.length : _[re + 1]), r.geometryColors = convertColorsRGBToRGBA(u.subarray(y[re], oe ? u.length : y[re + 1])), e = 0 < r.geometryPositions.length; break; case 3: r.primitiveName = "lines", r.geometryPositions = l.subarray(_[re], oe ? l.length : _[re + 1]), r.geometryIndices = p.subarray(T[re], oe ? p.length : T[re + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; default: continue }if ((r = e ? r : null) && (r.geometryPositions.length, r.batchThisMesh)) { r.decompressedPositions = new Float32Array(r.geometryPositions.length); var de = r.geometryPositions, me = r.decompressedPositions; for (let e = 0, t = de.length; e < t; e += 3)me[e + 0] = de[e + 0] * f[0] + f[12], me[e + 1] = de[e + 1] * f[5] + f[13], me[e + 2] = de[e + 2] * f[10] + f[14]; r.geometryPositions = null, W[ae] = r } } if (r) { if (r.batchThisMesh) { var fe = r.decompressedPositions; const e = new Uint16Array(fe.length); for (let t = 0, i = fe.length; t < i; t += 3)tempVec4a$2[0] = fe[t + 0], tempVec4a$2[1] = fe[t + 1], tempVec4a$2[2] = fe[t + 2], tempVec4a$2[3] = 1, math.transformVec4(pe, tempVec4a$2, tempVec4b$2), geometryCompressionUtils.compressPosition(tempVec4b$2, z, tempVec4a$2), e[t + 0] = tempVec4a$2[0], e[t + 1] = tempVec4a$2[1], e[t + 2] = tempVec4a$2[2]; s.createMesh(utils.apply(se, { id: ue, origin: j, primitive: r.primitiveName, positionsCompressed: e, normalsCompressed: r.geometryNormals, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: K, color: ne, metallic: le, roughness: ce, opacity: he })) } else J[ae] || (s.createGeometry({ id: ae, primitive: r.primitiveName, positionsCompressed: r.geometryPositions, normalsCompressed: r.geometryNormals, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: f }), J[ae] = !0), s.createMesh(utils.apply(se, { id: ue, geometryId: ae, origin: j, matrix: pe, color: ne, metallic: le, roughness: ce, opacity: he })); te.push(ue) } } else { let e, t, i, r, a, o, n = !1; switch (g[re]) { case 0: e = "solid", t = l.subarray(_[re], oe ? l.length : _[re + 1]), i = c.subarray(v[re], oe ? c.length : v[re + 1]), a = p.subarray(T[re], oe ? p.length : T[re + 1]), o = d.subarray(I[re], oe ? d.length : I[re + 1]), n = 0 < t.length && 0 < a.length; break; case 1: e = "surface", t = l.subarray(_[re], oe ? l.length : _[re + 1]), i = c.subarray(v[re], oe ? c.length : v[re + 1]), a = p.subarray(T[re], oe ? p.length : T[re + 1]), o = d.subarray(I[re], oe ? d.length : I[re + 1]), n = 0 < t.length && 0 < a.length; break; case 2: e = "points", t = l.subarray(_[re], oe ? l.length : _[re + 1]), r = convertColorsRGBToRGBA(u.subarray(y[re], oe ? u.length : y[re + 1])), n = 0 < t.length; break; case 3: e = "lines", t = l.subarray(_[re], oe ? l.length : _[re + 1]), a = p.subarray(T[re], oe ? p.length : T[re + 1]), n = 0 < t.length && 0 < a.length; break; default: continue }n && (s.createMesh(utils.apply(se, { id: ue, origin: j, primitive: e, positionsCompressed: t, normalsCompressed: i, colorsCompressed: r, indices: a, edgeIndices: o, positionsDecodeMatrix: K, color: ne, metallic: le, roughness: ce, opacity: he })), te.push(ue)) } } 0 < te.length && s.createEntity(utils.apply(ie, { id: Q, isObject: !0, meshIds: te })) } } } const ParserV8 = { version: 8, parse: function (e, t, i, s) { load$2(e, t, inflate$2(extract$2(i)), s) } }; let pako$1 = window.pako || p; pako$1.inflate || (pako$1 = pako$1.default); const tempVec4a$1 = math.vec4(), tempVec4b$1 = math.vec4(); function extract$1(e) { return { metadata: e[0], positions: e[1], normals: e[2], colors: e[3], indices: e[4], edgeIndices: e[5], matrices: e[6], reusedGeometriesDecodeMatrix: e[7], eachGeometryPrimitiveType: e[8], eachGeometryPositionsPortion: e[9], eachGeometryNormalsPortion: e[10], eachGeometryColorsPortion: e[11], eachGeometryIndicesPortion: e[12], eachGeometryEdgeIndicesPortion: e[13], eachMeshGeometriesPortion: e[14], eachMeshMatricesPortion: e[15], eachMeshMaterial: e[16], eachEntityId: e[17], eachEntityMeshesPortion: e[18], eachTileAABB: e[19], eachTileEntitiesPortion: e[20] } } function inflate$1(e) { function t(e, t) { return 0 === e.length ? [] : pako$1.inflate(e, t).buffer } return { metadata: JSON.parse(pako$1.inflate(e.metadata, { to: "string" })), positions: new Uint16Array(t(e.positions)), normals: new Int8Array(t(e.normals)), colors: new Uint8Array(t(e.colors)), indices: new Uint32Array(t(e.indices)), edgeIndices: new Uint32Array(t(e.edgeIndices)), matrices: new Float32Array(t(e.matrices)), reusedGeometriesDecodeMatrix: new Float32Array(t(e.reusedGeometriesDecodeMatrix)), eachGeometryPrimitiveType: new Uint8Array(t(e.eachGeometryPrimitiveType)), eachGeometryPositionsPortion: new Uint32Array(t(e.eachGeometryPositionsPortion)), eachGeometryNormalsPortion: new Uint32Array(t(e.eachGeometryNormalsPortion)), eachGeometryColorsPortion: new Uint32Array(t(e.eachGeometryColorsPortion)), eachGeometryIndicesPortion: new Uint32Array(t(e.eachGeometryIndicesPortion)), eachGeometryEdgeIndicesPortion: new Uint32Array(t(e.eachGeometryEdgeIndicesPortion)), eachMeshGeometriesPortion: new Uint32Array(t(e.eachMeshGeometriesPortion)), eachMeshMatricesPortion: new Uint32Array(t(e.eachMeshMatricesPortion)), eachMeshMaterial: new Uint8Array(t(e.eachMeshMaterial)), eachEntityId: JSON.parse(pako$1.inflate(e.eachEntityId, { to: "string" })), eachEntityMeshesPortion: new Uint32Array(t(e.eachEntityMeshesPortion)), eachTileAABB: new Float64Array(t(e.eachTileAABB)), eachTileEntitiesPortion: new Uint32Array(t(e.eachTileEntitiesPortion)) } } const decompressColor$1 = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load$1(e, t, i, s) { var r = i.metadata, a = i.positions, o = i.normals, n = i.colors, h = i.indices, l = i.edgeIndices, c = i.matrices, u = i.reusedGeometriesDecodeMatrix, p = i.eachGeometryPrimitiveType, d = i.eachGeometryPositionsPortion, m = i.eachGeometryNormalsPortion, f = i.eachGeometryColorsPortion, g = i.eachGeometryIndicesPortion, _ = i.eachGeometryEdgeIndicesPortion, v = i.eachMeshGeometriesPortion, y = i.eachMeshMatricesPortion, T = i.eachMeshMaterial, I = i.eachEntityId, E = i.eachEntityMeshesPortion, C = i.eachTileAABB, P = i.eachTileEntitiesPortion, b = d.length, A = v.length, D = E.length, R = P.length; let F = 0; const w = s.id; e.metaScene.metaModels[w] || (e.metaScene.createMetaModel(w, r, { includeTypes: t.includeTypes, excludeTypes: t.excludeTypes, globalizeObjectIds: t.globalizeObjectIds }), s.once("destroyed", (() => { e.metaScene.destroyMetaModel(w) }))); var M = new Uint32Array(b); for (let e = 0; e < A; e++) { var S = v[e]; void 0 !== M[S] ? M[S]++ : M[S] = 1 } var x = math.vec3(), L = math.AABB3(), O = {}; for (let i = 0; i < R; i++) { var N = i === R - 1, B = P[i], G = N ? D - 1 : P[i + 1] - 1, U = (N = 6 * i, N = C.subarray(N, 6 + N), math.getAABB3Center(N, x), L[0] = N[0] - x[0], L[1] = N[1] - x[1], L[2] = N[2] - x[2], L[3] = N[3] - x[0], L[4] = N[4] - x[1], L[5] = N[5] - x[2], geometryCompressionUtils.createPositionsDecodeMatrix(L)), k = {}; for (let r = B; r <= G; r++) { var V = I[r], H = (V = t.globalizeObjectIds ? math.globalizeObjectId(s.id, V) : V, r === D - 1), j = E[r], z = H ? v.length - 1 : E[r + 1] - 1, W = [], Y = {}, $ = {}; if (H = e.metaScene.metaObjects[V]) { if (t.excludeTypesMap && H.type && t.excludeTypesMap[H.type]) continue; if (t.includeTypesMap && H.type && !t.includeTypesMap[H.type]) continue; (H = t.objectDefaults ? t.objectDefaults[H.type] || t.objectDefaults.DEFAULT : null) && (!1 === H.visible && (Y.visible = !1), !1 === H.pickable && (Y.pickable = !1), H.colorize && ($.color = H.colorize), void 0 !== H.opacity && null !== H.opacity && ($.opacity = H.opacity), void 0 !== H.metallic && null !== H.metallic && ($.metallic = H.metallic), void 0 !== H.roughness) && null !== H.roughness && ($.roughness = H.roughness) } else if (t.excludeUnclassifiedObjects) continue; for (let e = j; e <= z; e++) { var X = v[e], K = 1 < M[X], J = X === b - 1, Q = decompressColor$1(T.subarray(6 * e, 6 * e + 3)), Z = T[6 * e + 3] / 255, q = T[6 * e + 4] / 255, ee = T[6 * e + 5] / 255, te = F++; if (K) { K = y[e]; var ie = c.slice(K, K + 16); let r = O[K = "geometry." + i + "." + X]; if (!r) { let e = !(r = { batchThisMesh: !t.reuseGeometries }); switch (p[X]) { case 0: r.primitiveName = "solid", r.geometryPositions = a.subarray(d[X], J ? a.length : d[X + 1]), r.geometryNormals = o.subarray(m[X], J ? o.length : m[X + 1]), r.geometryIndices = h.subarray(g[X], J ? h.length : g[X + 1]), r.geometryEdgeIndices = l.subarray(_[X], J ? l.length : _[X + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 1: r.primitiveName = "surface", r.geometryPositions = a.subarray(d[X], J ? a.length : d[X + 1]), r.geometryNormals = o.subarray(m[X], J ? o.length : m[X + 1]), r.geometryIndices = h.subarray(g[X], J ? h.length : g[X + 1]), r.geometryEdgeIndices = l.subarray(_[X], J ? l.length : _[X + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 2: r.primitiveName = "points", r.geometryPositions = a.subarray(d[X], J ? a.length : d[X + 1]), r.geometryColors = n.subarray(f[X], J ? n.length : f[X + 1]), e = 0 < r.geometryPositions.length; break; case 3: r.primitiveName = "lines", r.geometryPositions = a.subarray(d[X], J ? a.length : d[X + 1]), r.geometryIndices = h.subarray(g[X], J ? h.length : g[X + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; default: continue }if ((r = e ? r : null) && (r.geometryPositions.length, r.batchThisMesh)) { r.decompressedPositions = new Float32Array(r.geometryPositions.length), r.transformedAndRecompressedPositions = new Uint16Array(r.geometryPositions.length); var se = r.geometryPositions, re = r.decompressedPositions; for (let e = 0, t = se.length; e < t; e += 3)re[e + 0] = se[e + 0] * u[0] + u[12], re[e + 1] = se[e + 1] * u[5] + u[13], re[e + 2] = se[e + 2] * u[10] + u[14]; r.geometryPositions = null, O[K] = r } } if (r) { if (r.batchThisMesh) { var ae = r.decompressedPositions, oe = r.transformedAndRecompressedPositions; for (let e = 0, t = ae.length; e < t; e += 3)tempVec4a$1[0] = ae[e + 0], tempVec4a$1[1] = ae[e + 1], tempVec4a$1[2] = ae[e + 2], tempVec4a$1[3] = 1, math.transformVec4(ie, tempVec4a$1, tempVec4b$1), geometryCompressionUtils.compressPosition(tempVec4b$1, L, tempVec4a$1), oe[e + 0] = tempVec4a$1[0], oe[e + 1] = tempVec4a$1[1], oe[e + 2] = tempVec4a$1[2]; s.createMesh(utils.apply($, { id: te, origin: x, primitive: r.primitiveName, positionsCompressed: oe, normalsCompressed: r.geometryNormals, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: U, color: Q, metallic: q, roughness: ee, opacity: Z })) } else k[K] || (s.createGeometry({ id: K, primitive: r.primitiveName, positionsCompressed: r.geometryPositions, normalsCompressed: r.geometryNormals, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: u }), k[K] = !0), s.createMesh(utils.apply($, { id: te, geometryId: K, origin: x, matrix: ie, color: Q, metallic: q, roughness: ee, opacity: Z })); W.push(te) } } else { let e, t, i, r, c, u, v = !1; switch (p[X]) { case 0: e = "solid", t = a.subarray(d[X], J ? a.length : d[X + 1]), i = o.subarray(m[X], J ? o.length : m[X + 1]), c = h.subarray(g[X], J ? h.length : g[X + 1]), u = l.subarray(_[X], J ? l.length : _[X + 1]), v = 0 < t.length && 0 < c.length; break; case 1: e = "surface", t = a.subarray(d[X], J ? a.length : d[X + 1]), i = o.subarray(m[X], J ? o.length : m[X + 1]), c = h.subarray(g[X], J ? h.length : g[X + 1]), u = l.subarray(_[X], J ? l.length : _[X + 1]), v = 0 < t.length && 0 < c.length; break; case 2: e = "points", t = a.subarray(d[X], J ? a.length : d[X + 1]), r = n.subarray(f[X], J ? n.length : f[X + 1]), v = 0 < t.length; break; case 3: e = "lines", t = a.subarray(d[X], J ? a.length : d[X + 1]), c = h.subarray(g[X], J ? h.length : g[X + 1]), v = 0 < t.length && 0 < c.length; break; default: continue }v && (s.createMesh(utils.apply($, { id: te, origin: x, primitive: e, positionsCompressed: t, normalsCompressed: i, colorsCompressed: r, indices: c, edgeIndices: u, positionsDecodeMatrix: U, color: Q, metallic: q, roughness: ee, opacity: Z })), W.push(te)) } } 0 < W.length && s.createEntity(utils.apply(Y, { id: V, isObject: !0, meshIds: W })) } } } const ParserV9 = { version: 9, parse: function (e, t, i, s) { load$1(e, t, inflate$1(extract$1(i)), s) } }; let pako = window.pako || p; pako.inflate || (pako = pako.default); const tempVec4a = math.vec4(), tempVec4b = math.vec4(), NUM_TEXTURE_ATTRIBUTES = 9; function extract(e) { var t = 0; return { metadata: e[t++], textureData: e[t++], eachTextureDataPortion: e[t++], eachTextureAttributes: e[t++], positions: e[t++], normals: e[t++], colors: e[t++], uvs: e[t++], indices: e[t++], edgeIndices: e[t++], eachTextureSetTextures: e[t++], matrices: e[t++], reusedGeometriesDecodeMatrix: e[t++], eachGeometryPrimitiveType: e[t++], eachGeometryPositionsPortion: e[t++], eachGeometryNormalsPortion: e[t++], eachGeometryColorsPortion: e[t++], eachGeometryUVsPortion: e[t++], eachGeometryIndicesPortion: e[t++], eachGeometryEdgeIndicesPortion: e[t++], eachMeshGeometriesPortion: e[t++], eachMeshMatricesPortion: e[t++], eachMeshTextureSet: e[22], eachMeshMaterialAttributes: e[23], eachEntityId: e[24], eachEntityMeshesPortion: e[25], eachTileAABB: e[26], eachTileEntitiesPortion: e[27] } } function inflate(e) { function t(e, t) { return 0 === e.length ? [] : pako.inflate(e, t).buffer } return { metadata: JSON.parse(pako.inflate(e.metadata, { to: "string" })), textureData: new Uint8Array(t(e.textureData)), eachTextureDataPortion: new Uint32Array(t(e.eachTextureDataPortion)), eachTextureAttributes: new Uint16Array(t(e.eachTextureAttributes)), positions: new Uint16Array(t(e.positions)), normals: new Int8Array(t(e.normals)), colors: new Uint8Array(t(e.colors)), uvs: new Float32Array(t(e.uvs)), indices: new Uint32Array(t(e.indices)), edgeIndices: new Uint32Array(t(e.edgeIndices)), eachTextureSetTextures: new Int32Array(t(e.eachTextureSetTextures)), matrices: new Float32Array(t(e.matrices)), reusedGeometriesDecodeMatrix: new Float32Array(t(e.reusedGeometriesDecodeMatrix)), eachGeometryPrimitiveType: new Uint8Array(t(e.eachGeometryPrimitiveType)), eachGeometryPositionsPortion: new Uint32Array(t(e.eachGeometryPositionsPortion)), eachGeometryNormalsPortion: new Uint32Array(t(e.eachGeometryNormalsPortion)), eachGeometryColorsPortion: new Uint32Array(t(e.eachGeometryColorsPortion)), eachGeometryUVsPortion: new Uint32Array(t(e.eachGeometryUVsPortion)), eachGeometryIndicesPortion: new Uint32Array(t(e.eachGeometryIndicesPortion)), eachGeometryEdgeIndicesPortion: new Uint32Array(t(e.eachGeometryEdgeIndicesPortion)), eachMeshGeometriesPortion: new Uint32Array(t(e.eachMeshGeometriesPortion)), eachMeshMatricesPortion: new Uint32Array(t(e.eachMeshMatricesPortion)), eachMeshTextureSet: new Int32Array(t(e.eachMeshTextureSet)), eachMeshMaterialAttributes: new Uint8Array(t(e.eachMeshMaterialAttributes)), eachEntityId: JSON.parse(pako.inflate(e.eachEntityId, { to: "string" })), eachEntityMeshesPortion: new Uint32Array(t(e.eachEntityMeshesPortion)), eachTileAABB: new Float64Array(t(e.eachTileAABB)), eachTileEntitiesPortion: new Uint32Array(t(e.eachTileEntitiesPortion)) } } const decompressColor = function () { const e = new Float32Array(3); return function (t) { return e[0] = t[0] / 255, e[1] = t[1] / 255, e[2] = t[2] / 255, e } }(); function load(e, t, i, s) { var r = i.metadata, a = i.textureData, o = i.eachTextureDataPortion, n = i.eachTextureAttributes, h = i.positions, l = i.normals, c = i.colors, u = i.uvs, p = i.indices, d = i.edgeIndices, m = i.eachTextureSetTextures, f = i.matrices, g = i.reusedGeometriesDecodeMatrix, _ = i.eachGeometryPrimitiveType, v = i.eachGeometryPositionsPortion, y = i.eachGeometryNormalsPortion, T = i.eachGeometryColorsPortion, I = i.eachGeometryUVsPortion, E = i.eachGeometryIndicesPortion, C = i.eachGeometryEdgeIndicesPortion, P = i.eachMeshGeometriesPortion, b = i.eachMeshMatricesPortion, A = i.eachMeshTextureSet, D = i.eachMeshMaterialAttributes, R = i.eachEntityId, F = i.eachEntityMeshesPortion, w = i.eachTileAABB, M = i.eachTileEntitiesPortion, S = o.length, x = m.length / 5, L = v.length, O = P.length, N = F.length, B = M.length; let G = 0; const U = s.id; e.metaScene.metaModels[U] || (e.metaScene.createMetaModel(U, r, { includeTypes: t.includeTypes, excludeTypes: t.excludeTypes, globalizeObjectIds: t.globalizeObjectIds }), s.once("destroyed", (() => { e.metaScene.destroyMetaModel(U) }))); for (let e = 0; e < S; e++) { var k = e === S - 1, V = o[e], H = 0 < (k = k ? a.length : o[e + 1]) - V, j = 1 === n[0 + (K = 9 * e)], z = n[1 + K], W = (n[2 + K], n[3 + K], n[4 + K]), Y = n[5 + K], $ = n[6 + K], X = n[7 + K], K = n[8 + K]; H && (H = new Uint8Array(a.subarray(V, k)).buffer, V = "texture-" + e, j ? s.createTexture({ id: V, buffers: [H], minFilter: W, magFilter: Y, wrapS: $, wrapT: X, wrapR: K }) : (k = 10001 === z ? "image/jpeg" : 10002 === z ? "image/png" : "image/gif", j = new Blob([H], { type: k }), z = (window.URL || window.webkitURL).createObjectURL(j), (H = document.createElement("img")).src = z, s.createTexture({ id: V, image: H, minFilter: W, magFilter: Y, wrapS: $, wrapT: X, wrapR: K }))) } for (let e = 0; e < x; e++) { var J = "textureSet-" + e, Q = m[0 + (te = 5 * e)], Z = m[1 + te], q = m[2 + te], ee = m[3 + te], te = m[4 + te]; s.createTextureSet({ id: J, colorTextureId: 0 <= Q ? "texture-" + Q : null, normalsTextureId: 0 <= q ? "texture-" + q : null, metallicRoughnessTextureId: 0 <= Z ? "texture-" + Z : null, emissiveTextureId: 0 <= ee ? "texture-" + ee : null, occlusionTextureId: 0 <= te ? "texture-" + te : null }) } var ie = new Uint32Array(L); for (let e = 0; e < O; e++) { var se = P[e]; void 0 !== ie[se] ? ie[se]++ : ie[se] = 1 } var re = math.vec3(), ae = math.AABB3(), oe = {}; for (let i = 0; i < B; i++) { var ne = i === B - 1, he = M[i], le = ne ? N - 1 : M[i + 1] - 1, ce = (ne = 6 * i, ne = w.subarray(ne, 6 + ne), math.getAABB3Center(ne, re), ae[0] = ne[0] - re[0], ae[1] = ne[1] - re[1], ae[2] = ne[2] - re[2], ae[3] = ne[3] - re[0], ae[4] = ne[4] - re[1], ae[5] = ne[5] - re[2], geometryCompressionUtils.createPositionsDecodeMatrix(ae)), ue = {}; for (let r = he; r <= le; r++) { var pe = R[r], de = (pe = t.globalizeObjectIds ? math.globalizeObjectId(s.id, pe) : pe, r === N - 1), me = F[r], fe = de ? P.length - 1 : F[r + 1] - 1, ge = [], _e = {}, ve = {}; if (de = e.metaScene.metaObjects[pe]) { if (t.excludeTypesMap && de.type && t.excludeTypesMap[de.type]) continue; if (t.includeTypesMap && de.type && !t.includeTypesMap[de.type]) continue; (de = t.objectDefaults ? t.objectDefaults[de.type] || t.objectDefaults.DEFAULT : null) && (!1 === de.visible && (_e.visible = !1), !1 === de.pickable && (_e.pickable = !1), de.colorize && (ve.color = de.colorize), void 0 !== de.opacity && null !== de.opacity && (ve.opacity = de.opacity), void 0 !== de.metallic && null !== de.metallic && (ve.metallic = de.metallic), void 0 !== de.roughness) && null !== de.roughness && (ve.roughness = de.roughness) } else if (t.excludeUnclassifiedObjects) continue; for (let e = me; e <= fe; e++) { var ye = P[e], Te = 1 < ie[ye], Ie = ye === L - 1, Ee = 0 <= (Ee = A[e]) ? "textureSet-" + Ee : null, Ce = decompressColor(D.subarray(6 * e, 6 * e + 3)), Pe = D[6 * e + 3] / 255, be = D[6 * e + 4] / 255, Ae = D[6 * e + 5] / 255, De = G++; if (Te) { Te = b[e]; var Re = f.slice(Te, Te + 16); let r = oe[Te = "geometry." + i + "." + ye]; if (!r) { let e = !(r = { batchThisMesh: !t.reuseGeometries }); switch (_[ye]) { case 0: r.primitiveName = "solid", r.geometryPositions = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), r.geometryNormals = l.subarray(y[ye], Ie ? l.length : y[ye + 1]), r.geometryUVs = u.subarray(I[ye], Ie ? u.length : I[ye + 1]), r.geometryIndices = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), r.geometryEdgeIndices = d.subarray(C[ye], Ie ? d.length : C[ye + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 1: r.primitiveName = "surface", r.geometryPositions = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), r.geometryNormals = l.subarray(y[ye], Ie ? l.length : y[ye + 1]), r.geometryUVs = u.subarray(I[ye], Ie ? u.length : I[ye + 1]), r.geometryIndices = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), r.geometryEdgeIndices = d.subarray(C[ye], Ie ? d.length : C[ye + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; case 2: r.primitiveName = "points", r.geometryPositions = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), r.geometryColors = c.subarray(T[ye], Ie ? c.length : T[ye + 1]), e = 0 < r.geometryPositions.length; break; case 3: r.primitiveName = "lines", r.geometryPositions = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), r.geometryIndices = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), e = 0 < r.geometryPositions.length && 0 < r.geometryIndices.length; break; default: continue }if ((r = e ? r : null) && (r.geometryPositions.length, r.batchThisMesh)) { r.decompressedPositions = new Float32Array(r.geometryPositions.length), r.transformedAndRecompressedPositions = new Uint16Array(r.geometryPositions.length); var Fe = r.geometryPositions, we = r.decompressedPositions; for (let e = 0, t = Fe.length; e < t; e += 3)we[e + 0] = Fe[e + 0] * g[0] + g[12], we[e + 1] = Fe[e + 1] * g[5] + g[13], we[e + 2] = Fe[e + 2] * g[10] + g[14]; r.geometryPositions = null, oe[Te] = r } } if (r) { if (r.batchThisMesh) { var Me = r.decompressedPositions, Se = r.transformedAndRecompressedPositions; for (let e = 0, t = Me.length; e < t; e += 3)tempVec4a[0] = Me[e + 0], tempVec4a[1] = Me[e + 1], tempVec4a[2] = Me[e + 2], tempVec4a[3] = 1, math.transformVec4(Re, tempVec4a, tempVec4b), geometryCompressionUtils.compressPosition(tempVec4b, ae, tempVec4a), Se[e + 0] = tempVec4a[0], Se[e + 1] = tempVec4a[1], Se[e + 2] = tempVec4a[2]; s.createMesh(utils.apply(ve, { id: De, textureSetId: Ee, origin: re, primitive: r.primitiveName, positionsCompressed: Se, normalsCompressed: r.geometryNormals, uv: r.geometryUVs, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: ce, color: Ce, metallic: be, roughness: Ae, opacity: Pe })) } else ue[Te] || (s.createGeometry({ id: Te, primitive: r.primitiveName, positionsCompressed: r.geometryPositions, normalsCompressed: r.geometryNormals, uv: r.geometryUVs, colorsCompressed: r.geometryColors, indices: r.geometryIndices, edgeIndices: r.geometryEdgeIndices, positionsDecodeMatrix: g }), ue[Te] = !0), s.createMesh(utils.apply(ve, { id: De, geometryId: Te, textureSetId: Ee, matrix: Re, color: Ce, metallic: be, roughness: Ae, opacity: Pe, origin: re })); ge.push(De) } } else { let e, t, i, r, a, o, n, m = !1; switch (_[ye]) { case 0: e = "solid", t = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), i = l.subarray(y[ye], Ie ? l.length : y[ye + 1]), r = u.subarray(I[ye], Ie ? u.length : I[ye + 1]), o = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), n = d.subarray(C[ye], Ie ? d.length : C[ye + 1]), m = 0 < t.length && 0 < o.length; break; case 1: e = "surface", t = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), i = l.subarray(y[ye], Ie ? l.length : y[ye + 1]), r = u.subarray(I[ye], Ie ? u.length : I[ye + 1]), o = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), n = d.subarray(C[ye], Ie ? d.length : C[ye + 1]), m = 0 < t.length && 0 < o.length; break; case 2: e = "points", t = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), a = c.subarray(T[ye], Ie ? c.length : T[ye + 1]), m = 0 < t.length; break; case 3: e = "lines", t = h.subarray(v[ye], Ie ? h.length : v[ye + 1]), o = p.subarray(E[ye], Ie ? p.length : E[ye + 1]), m = 0 < t.length && 0 < o.length; break; default: continue }m && (s.createMesh(utils.apply(ve, { id: De, textureSetId: Ee, origin: re, primitive: e, positionsCompressed: t, normalsCompressed: i, uv: r && 0 < r.length ? r : null, colorsCompressed: a, indices: o, edgeIndices: n, positionsDecodeMatrix: ce, color: Ce, metallic: be, roughness: Ae, opacity: Pe })), ge.push(De)) } } 0 < ge.length && s.createEntity(utils.apply(_e, { id: pe, isObject: !0, meshIds: ge })) } } } document.createElement("canvas").getContext("2d"); const ParserV10 = { version: 10, parse: function (e, t, i, s) { load(e, t, inflate(extract(i)), s) } }, parsers = {}; parsers[ParserV1.version] = ParserV1, parsers[ParserV2.version] = ParserV2, parsers[ParserV3.version] = ParserV3, parsers[ParserV4.version] = ParserV4, parsers[ParserV5.version] = ParserV5, parsers[ParserV6.version] = ParserV6, parsers[ParserV7.version] = ParserV7, parsers[ParserV8.version] = ParserV8, parsers[ParserV9.version] = ParserV9, parsers[ParserV10.version] = ParserV10; class XKTLoaderPlugin extends Plugin { constructor(e, t = {}) { super("XKTLoader", e, t), this._maxGeometryBatchSize = t.maxGeometryBatchSize, this.textureTranscoder = t.textureTranscoder, this.dataSource = t.dataSource, this.objectDefaults = t.objectDefaults, this.includeTypes = t.includeTypes, this.excludeTypes = t.excludeTypes, this.excludeUnclassifiedObjects = t.excludeUnclassifiedObjects, this.reuseGeometries = t.reuseGeometries } get supportedVersions() { return Object.keys(parsers) } get textureTranscoder() { return this._textureTranscoder } set textureTranscoder(e) { this._textureTranscoder = e } get dataSource() { return this._dataSource } set dataSource(e) { this._dataSource = e || new XKTDefaultDataSource } get objectDefaults() { return this._objectDefaults } set objectDefaults(e) { this._objectDefaults = e || IFCObjectDefaults } get includeTypes() { return this._includeTypes } set includeTypes(e) { this._includeTypes = e } get excludeTypes() { return this._excludeTypes } set excludeTypes(e) { this._excludeTypes = e } get excludeUnclassifiedObjects() { return this._excludeUnclassifiedObjects } set excludeUnclassifiedObjects(e) { this._excludeUnclassifiedObjects = !!e } get globalizeObjectIds() { return this._globalizeObjectIds } set globalizeObjectIds(e) { this._globalizeObjectIds = !!e } get reuseGeometries() { return this._reuseGeometries } set reuseGeometries(e) { this._reuseGeometries = !1 !== e } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); const t = new VBOSceneModel(this.viewer.scene, utils.apply(e, { isModel: !0, textureTranscoder: this._textureTranscoder, maxGeometryBatchSize: this._maxGeometryBatchSize, origin: e.origin })), i = t.id; if (e.src || e.xkt) { const r = {}, a = e.includeTypes || this._includeTypes, o = e.excludeTypes || this._excludeTypes; var s = e.objectDefaults || this._objectDefaults; if (r.reuseGeometries = null !== e.reuseGeometries && void 0 !== e.reuseGeometries ? e.reuseGeometries : !1 !== this._reuseGeometries, a) { r.includeTypesMap = {}; for (let e = 0, t = a.length; e < t; e++)r.includeTypesMap[a[e]] = !0 } if (o) { r.excludeTypesMap = {}; for (let e = 0, t = o.length; e < t; e++)r.excludeTypesMap[o[e]] = !0 } if (s && (r.objectDefaults = s), r.excludeUnclassifiedObjects = void 0 !== e.excludeUnclassifiedObjects ? !!e.excludeUnclassifiedObjects : this._excludeUnclassifiedObjects, r.globalizeObjectIds = void 0 !== e.globalizeObjectIds ? !!e.globalizeObjectIds : this._globalizeObjectIds, e.metaModelSrc || e.metaModelData) { const s = s => !!this.viewer.metaScene.createMetaModel(i, s, { includeTypes: a, excludeTypes: o, globalizeObjectIds: this.globalizeObjectIds }) && (e.src ? this._loadModel(e.src, e, r, t) : this._parseModel(e.xkt, e, r, t), t.once("destroyed", (() => { this.viewer.metaScene.destroyMetaModel(t.id) })), !0); if (e.metaModelSrc) { const r = e.metaModelSrc; this.viewer.scene.canvas.spinner.processes++, this._dataSource.getMetaModel(r, (e => { t.destroyed || (s(e) || (this.error(`load(): Failed to load model metadata for model '${i} from '${r}' - metadata not valid`), t.fire("error", "Metadata not valid")), this.viewer.scene.canvas.spinner.processes--) }), (e => { this.error(`load(): Failed to load model metadata for model '${i} from  '${r}' - ` + e), t.fire("error", `Failed to load model metadata from  '${r}' - ` + e), this.viewer.scene.canvas.spinner.processes-- })) } else e.metaModelData && !s(e.metaModelData) && (this.error(`load(): Failed to load model metadata for model '${i} from '${e.metaModelSrc}' - metadata not valid`), t.fire("error", "Metadata not valid")) } else e.src ? this._loadModel(e.src, e, r, t) : this._parseModel(e.xkt, e, r, t) } else this.error("load() param expected: src or xkt"); return t } _loadModel(e, t, i, s) { const r = this.viewer.scene.canvas.spinner; r.processes++, this._dataSource.getXKT(t.src, (e => { this._parseModel(e, t, i, s), r.processes-- }), (e => { r.processes--, this.error(e), s.fire("error", e) })) } _parseModel(e, t, i, s) { if (!s.destroyed) { var r = new DataView(e), a = new Uint8Array(e), o = (e = r.getUint32(0, !0), parsers[e]); if (o) { var n = r.getUint32(4, !0), h = []; let e = 4 * (n + 2); for (let t = 0; t < n; t++) { var l = r.getUint32(4 * (t + 2), !0); h.push(a.subarray(e, e + l)), e += l } o.parse(this.viewer, i, h, s), s.finalize(), this._createDefaultMetaModelIfNeeded(s, t, i), s.scene.once("tick", (() => { s.destroyed || (s.scene.fire("modelLoaded", s.id), s.fire("loaded", !0, !1)) })) } else this.error("Unsupported .XKT file version: " + e + " - this XKTLoaderPlugin supports versions " + Object.keys(parsers)) } } _createDefaultMetaModelIfNeeded(e, t, i) { const s = e.id; if (!this.viewer.metaScene.metaModels[s]) { var r = { metaObjects: [] }, a = (r.metaObjects.push({ id: s, type: "default", name: s, parent: null }), e.entityList); for (let e = 0, t = a.length; e < t; e++) { var o = a[e]; o.isObject && r.metaObjects.push({ id: o.id, type: "default", name: o.id, parent: s }) } const n = t.src; this.viewer.metaScene.createMetaModel(s, r, { includeTypes: i.includeTypes, excludeTypes: i.excludeTypes, globalizeObjectIds: i.globalizeObjectIds, getProperties: async e => this._dataSource.getProperties(n, e) }), e.once("destroyed", (() => { this.viewer.metaScene.destroyMetaModel(s) })) } } } var zipLib = {}; !function (e) { var t, i = "File format is not recognized.", s = "Error while reading zip file.", r = "Error while reading file data.", a = 524288, o = "text/plain"; try { t = 0 === new Blob([new DataView(new ArrayBuffer(0))]).size } catch (c) { } function n() { this.crc = -1 } function h() { } function l(e, t) { e = new ArrayBuffer(e); var i = new Uint8Array(e); return t && i.set(t, 0), { buffer: e, array: i, view: new DataView(e) } } function c() { } function u(e) { var t, i = this; i.size = 0, i.init = function (s, r) { var a = new Blob([e], { type: o }); (t = new d(a)).init((function () { i.size = t.size, s() }), r) }, i.readUint8Array = function (e, i, s, r) { t.readUint8Array(e, i, s, r) } } function p(t) { var i, s = this; s.size = 0, s.init = function (e) { for (var r = t.length; "=" == t.charAt(r - 1);)r--; i = t.indexOf(",") + 1, s.size = Math.floor(.75 * (r - i)), e() }, s.readUint8Array = function (s, r, a) { for (var o = l(r), n = 4 * Math.floor(s / 3), h = 4 * Math.ceil((s + r) / 3), c = e.atob(t.substring(n + i, h + i)), u = s - 3 * Math.floor(n / 4), p = u; p < u + r; p++)o.array[p - u] = c.charCodeAt(p); a(o.array) } } function d(e) { var t = this; t.size = 0, t.init = function (i) { t.size = e.size, i() }, t.readUint8Array = function (t, i, s, r) { var a = new FileReader; a.onload = function (e) { s(new Uint8Array(e.target.result)) }, a.onerror = r; try { a.readAsArrayBuffer(function (e, t, i) { if (t < 0 || i < 0 || t + i > e.size) throw new RangeError("offset:" + t + ", length:" + i + ", size:" + e.size); return e.slice ? e.slice(t, t + i) : e.webkitSlice ? e.webkitSlice(t, t + i) : e.mozSlice ? e.mozSlice(t, t + i) : e.msSlice ? e.msSlice(t, t + i) : void 0 }(e, t, i)) } catch (t) { r(t) } } } function m() { } function f(e) { var i; this.init = function (e) { i = new Blob([], { type: o }), e() }, this.writeUint8Array = function (e, s) { i = new Blob([i, t ? e : e.buffer], { type: o }), s() }, this.getData = function (t, s) { var r = new FileReader; r.onload = function (e) { t(e.target.result) }, r.onerror = s, r.readAsText(i, e) } } function g(t) { var i = "", s = ""; this.init = function (e) { i += "data:" + (t || "") + ";base64,", e() }, this.writeUint8Array = function (t, r) { var a, o = s.length, n = s; for (s = "", a = 0; a < 3 * Math.floor((o + t.length) / 3) - o; a++)n += String.fromCharCode(t[a]); for (; a < t.length; a++)s += String.fromCharCode(t[a]); 2 < n.length ? i += e.btoa(n) : s = n, r() }, this.getData = function (t) { t(i + e.btoa(s)) } } function _(e) { var i; this.init = function (t) { i = new Blob([], { type: e }), t() }, this.writeUint8Array = function (s, r) { i = new Blob([i, t ? s : s.buffer], { type: e }), r() }, this.getData = function (e) { e(i) } } function v(e, t, i, s, r, o, n, h, l, c) { var u, p, d, m = 0, f = t.sn; function g() { e.removeEventListener("message", _, !1), h(p, d) } function _(t) { var i = t.data, r = i.data; if (t = i.error) t.toString = function () { return "Error: " + this.message }, l(t); else if (i.sn === f) switch ("number" == typeof i.codecTime && (e.codecTime += i.codecTime), "number" == typeof i.crcTime && (e.crcTime += i.crcTime), i.type) { case "append": r ? (p += r.length, s.writeUint8Array(r, (function () { v() }), c)) : v(); break; case "flush": d = i.crc, r ? (p += r.length, s.writeUint8Array(r, (function () { g() }), c)) : g(); break; case "progress": n && n(u + i.loaded, o); break; case "importScripts": case "newTask": case "echo": break; default: console.warn("zip.js:launchWorkerProcess: unknown message: ", i) } } function v() { (u = m * a) <= o ? i.readUint8Array(r + u, Math.min(a, o - u), (function (i) { n && n(u, o); var s = 0 === u ? t : { sn: f }; s.type = "append", s.data = i; try { e.postMessage(s, [i.buffer]) } catch (i) { e.postMessage(s) } m++ }), l) : e.postMessage({ sn: f, type: "flush" }) } p = 0, e.addEventListener("message", _, !1), v() } function y(e, t, i, s, r, o, h, l, c, u) { var p, d = 0, m = 0, f = "input" === o, g = "output" === o, _ = new n; !function o() { var n; if ((p = d * a) < r) t.readUint8Array(s + p, Math.min(a, r - p), (function (t) { var s; try { s = e.append(t, (function (e) { h && h(p + e, r) })) } catch (t) { return void c(t) } s ? (m += s.length, i.writeUint8Array(s, (function () { d++, setTimeout(o, 1) }), u), g && _.append(s)) : (d++, setTimeout(o, 1)), f && _.append(t), h && h(p, r) }), c); else { try { n = e.flush() } catch (n) { return void c(n) } n ? (g && _.append(n), m += n.length, i.writeUint8Array(n, (function () { l(m, _.get()) }), u)) : l(m, _.get()) } }() } function T(t, i, s, r, a, o, n, l, c, u, p) { e.zip.useWebWorkers && n ? v(t, { sn: i, codecClass: "NOOP", crcType: "input" }, s, r, a, o, c, l, u, p) : y(new h, s, r, a, o, "input", c, l, u, p) } function I(e) { for (var t, i = "", s = ["Ç", "ü", "é", "â", "ä", "à", "å", "ç", "ê", "ë", "è", "ï", "î", "ì", "Ä", "Å", "É", "æ", "Æ", "ô", "ö", "ò", "û", "ù", "ÿ", "Ö", "Ü", "ø", "£", "Ø", "×", "ƒ", "á", "í", "ó", "ú", "ñ", "Ñ", "ª", "º", "¿", "®", "¬", "½", "¼", "¡", "«", "»", "_", "_", "_", "¦", "¦", "Á", "Â", "À", "©", "¦", "¦", "+", "+", "¢", "¥", "+", "+", "-", "-", "+", "-", "+", "ã", "Ã", "+", "+", "-", "-", "¦", "-", "+", "¤", "ð", "Ð", "Ê", "Ë", "È", "i", "Í", "Î", "Ï", "+", "+", "_", "_", "¦", "Ì", "_", "Ó", "ß", "Ô", "Ò", "õ", "Õ", "µ", "þ", "Þ", "Ú", "Û", "Ù", "ý", "Ý", "¯", "´", "­", "±", "_", "¾", "¶", "§", "÷", "¸", "°", "¨", "·", "¹", "³", "²", "_", " "], r = 0; r < e.length; r++)i += 127 < (t = 255 & e.charCodeAt(r)) ? s[t - 128] : String.fromCharCode(t); return i } function E(e) { return decodeURIComponent(escape(e)) } function C(e) { for (var t = "", i = 0; i < e.length; i++)t += String.fromCharCode(e[i]); return t } function P(e, t, i, s, r) { e.version = t.view.getUint16(i, !0), e.bitFlag = t.view.getUint16(i + 2, !0), e.compressionMethod = t.view.getUint16(i + 4, !0), e.lastModDateRaw = t.view.getUint32(i + 6, !0), e.lastModDate = function (e) { var t = (4294901760 & e) >> 16; e &= 65535; try { return new Date(1980 + ((65024 & t) >> 9), ((480 & t) >> 5) - 1, 31 & t, (63488 & e) >> 11, (2016 & e) >> 5, 2 * (31 & e), 0) } catch (e) { } }(e.lastModDateRaw), 1 & ~e.bitFlag ? (!s && !(8 & ~e.bitFlag) || (e.crc32 = t.view.getUint32(i + 10, !0), e.compressedSize = t.view.getUint32(i + 14, !0), e.uncompressedSize = t.view.getUint32(i + 18, !0)), 4294967295 === e.compressedSize || 4294967295 === e.uncompressedSize ? r("File is using Zip64 (4gb+ file size).") : (e.filenameLength = t.view.getUint16(i + 22, !0), e.extraFieldLength = t.view.getUint16(i + 24, !0))) : r("File contains encrypted entry.") } function b(e) { return unescape(encodeURIComponent(e)) } function A(e) { for (var t = [], i = 0; i < e.length; i++)t.push(e.charCodeAt(i)); return t } n.prototype.append = function (e) { for (var t = 0 | this.crc, i = this.table, s = 0, r = 0 | e.length; s < r; s++)t = t >>> 8 ^ i[255 & (t ^ e[s])]; this.crc = t }, n.prototype.get = function () { return ~this.crc }, n.prototype.table = function () { for (var e, t, i = [], s = 0; s < 256; s++) { for (t = s, e = 0; e < 8; e++)1 & t ? t = t >>> 1 ^ 3988292384 : t >>>= 1; i[s] = t } return i }(), h.prototype.append = function (e, t) { return e }, h.prototype.flush = function () { }, (u.prototype = new c).constructor = u, (p.prototype = new c).constructor = p, (d.prototype = new c).constructor = d, m.prototype.getData = function (e) { e(this.data) }, (f.prototype = new m).constructor = f, (g.prototype = new m).constructor = g, _.prototype = new m; var D = { deflater: ["z-worker.js", "deflate.js"], inflater: ["z-worker.js", "inflate.js"] }; function R(t, i, s) { if (null !== e.zip.workerScripts && null !== e.zip.workerScriptsPath) s(new Error("Either zip.workerScripts or zip.workerScriptsPath may be set, not both.")); else { var r, a, o; if (e.zip.workerScripts) { if (r = e.zip.workerScripts[t], !Array.isArray(r)) return s(new Error("zip.workerScripts." + t + " is not an array!")); a = r, o = document.createElement("a"), r = a.map((function (e) { return o.href = e, o.href })) } else (r = D[t].slice(0))[0] = (e.zip.workerScriptsPath || "") + r[0]; var n = new Worker(r[0]); n.codecTime = n.crcTime = 0, n.postMessage({ type: "importScripts", scripts: r.slice(1) }), n.addEventListener("message", (function e(t) { (t = t.data).error ? (n.terminate(), s(t.error)) : "importScripts" === t.type && (n.removeEventListener("message", e), n.removeEventListener("error", h), i(n)) })), n.addEventListener("error", h) } function h(e) { n.terminate(), s(e) } } function F(e) { console.error(e) } e.zip = { Reader: c, Writer: m, BlobReader: d, Data64URIReader: p, TextReader: u, BlobWriter: _.prototype.constructor = _, Data64URIWriter: g, TextWriter: f, createReader: function (t, a, o) { o = o || F, t.init((function () { function n() { } var h, c = t, u = a, p = o, d = 0; n.prototype.getData = function (t, s, a, o) { var n = this; function h(e, i) { var r; o && ((r = l(4)).view.setUint32(0, i), n.crc32 != r.view.getUint32(0)) ? p("CRC failed.") : t.getData((function (e) { s(e) })) } function u(e) { p(e || r) } function m(e) { p(e || "Error while writing file data.") } c.readUint8Array(n.offset, 30, (function (s) { var r; 1347093252 != (s = l(s.length, s)).view.getUint32(0) ? p(i) : (P(n, s, 4, !1, p), r = n.offset + 30 + n.filenameLength + n.extraFieldLength, t.init((function () { var i, s, l, p, f, g, _, I, E, C, P; 0 === n.compressionMethod ? T(n._worker, d++, c, t, r, n.compressedSize, o, h, a, u, m) : (i = n._worker, s = d++, l = c, p = t, f = r, g = n.compressedSize, I = h, E = a, C = u, P = m, _ = o ? "output" : "none", e.zip.useWebWorkers ? v(i, { sn: s, codecClass: "Inflater", crcType: _ }, l, p, f, g, E, I, C, P) : y(new e.zip.Inflater, l, p, f, g, _, E, I, C, P)) }), m)) }), u) }, h = { getEntries: function (e) { var t, r = this._worker; function a(e, i) { c.readUint8Array(c.size - e, e, (function (e) { for (var s = e.length - 22; 0 <= s; s--)if (80 === e[s] && 75 === e[s + 1] && 5 === e[s + 2] && 6 === e[s + 3]) return void t(new DataView(e.buffer, s, 22)); i() }), (function () { p(s) })) } t = function (t) { var a = t.getUint32(16, !0), o = t.getUint16(8, !0); a < 0 || a >= c.size ? p(i) : c.readUint8Array(a, c.size - a, (function (t) { for (var s, a, h = 0, c = [], u = l(t.length, t), d = 0; d < o; d++) { if ((s = new n)._worker = r, 1347092738 != u.view.getUint32(h)) return void p(i); P(s, u, h + 6, !0, p), s.commentLength = u.view.getUint16(h + 32, !0), s.directory = !(16 & ~u.view.getUint8(h + 38)), s.offset = u.view.getUint32(h + 42, !0), a = C(u.array.subarray(h + 46, h + 46 + s.filenameLength)), s.filename = (2048 & ~s.bitFlag ? I : E)(a), s.directory || "/" != s.filename.charAt(s.filename.length - 1) || (s.directory = !0), a = C(u.array.subarray(h + 46 + s.filenameLength + s.extraFieldLength, h + 46 + s.filenameLength + s.extraFieldLength + s.commentLength)), s.comment = (2048 & ~s.bitFlag ? I : E)(a), c.push(s), h += 46 + s.filenameLength + s.extraFieldLength + s.commentLength } e(c) }), (function () { p(s) })) }, c.size < 22 ? p(i) : a(22, (function () { a(Math.min(65558, c.size), (function () { p(i) })) })) }, close: function (e) { this._worker && (this._worker.terminate(), this._worker = null), e && e() }, _worker: null }, e.zip.useWebWorkers ? R("inflater", (function (e) { h._worker = e, u(h) }), (function (e) { p(e) })) : u(h) }), o) }, createWriter: function (t, i, s, a) { s = s || F, a = !!a, t.init((function () { function o(e) { p(e || "Error while writing zip file.") } function n(e) { p(e || r) } var h, c = t, u = i, p = s, d = a, m = {}, f = [], g = h = 0, _ = { add: function (t, i, s, r, a) { var u, _, I, E = this._worker; function C(e, t) { var r = l(16); h += e || 0, r.view.setUint32(0, 1347094280), void 0 !== t && (u.view.setUint32(10, t, !0), r.view.setUint32(4, t, !0)), i && (r.view.setUint32(8, e, !0), u.view.setUint32(14, e, !0), r.view.setUint32(12, i.size, !0), u.view.setUint32(18, i.size, !0)), c.writeUint8Array(r.array, (function () { h += 16, s() }), o) } function P() { var s, P; a = a || {}, t = t.trim(), a.directory && "/" != t.charAt(t.length - 1) && (t += "/"), m.hasOwnProperty(t) ? p("File already exists.") : (_ = A(b(t)), f.push(t), s = function () { var t, s, h, l, u, p, m, f; i ? d || 0 === a.level ? T(E, g++, i, c, 0, i.size, !0, C, r, n, o) : (t = g++, s = i, h = c, l = a.level, u = C, p = r, m = n, f = o, e.zip.useWebWorkers ? v(E, { sn: t, options: { level: l }, codecClass: "Deflater", crcType: "input" }, s, h, 0, s.size, p, u, m, f) : y(new e.zip.Deflater, s, h, 0, s.size, "input", p, u, m, f)) : C() }, I = a.lastModDate || new Date, u = l(26), m[t] = { headerArray: u.array, directory: a.directory, filename: _, offset: h, comment: A(b(a.comment || "")) }, u.view.setUint32(0, 335546376), a.version && u.view.setUint8(0, a.version), d || 0 === a.level || a.directory || u.view.setUint16(4, 2048), u.view.setUint16(6, (I.getHours() << 6 | I.getMinutes()) << 5 | I.getSeconds() / 2, !0), u.view.setUint16(8, (I.getFullYear() - 1980 << 4 | I.getMonth() + 1) << 5 | I.getDate(), !0), u.view.setUint16(22, _.length, !0), (P = l(30 + _.length)).view.setUint32(0, 1347093252), P.array.set(u.array, 4), P.array.set(_, 30), h += P.array.length, c.writeUint8Array(P.array, s, o)) } i ? i.init(P, n) : P() }, close: function (e) { this._worker && (this._worker.terminate(), this._worker = null); for (var t, i, s = 0, r = 0, a = 0; a < f.length; a++)s += 46 + (i = m[f[a]]).filename.length + i.comment.length; for (t = l(s + 22), a = 0; a < f.length; a++)i = m[f[a]], t.view.setUint32(r, 1347092738), t.view.setUint16(r + 4, 5120), t.array.set(i.headerArray, r + 6), t.view.setUint16(r + 32, i.comment.length, !0), i.directory && t.view.setUint8(r + 38, 16), t.view.setUint32(r + 42, i.offset, !0), t.array.set(i.filename, r + 46), t.array.set(i.comment, r + 46 + i.filename.length), r += 46 + i.filename.length + i.comment.length; t.view.setUint32(r, 1347093766), t.view.setUint16(r + 8, f.length, !0), t.view.setUint16(r + 10, f.length, !0), t.view.setUint32(r + 12, s, !0), t.view.setUint32(r + 16, h, !0), c.writeUint8Array(t.array, (function () { c.getData(e) }), o) }, _worker: null }; e.zip.useWebWorkers ? R("deflater", (function (e) { _._worker = e, u(_) }), (function (e) { p(e) })) : u(_) }), s) }, useWebWorkers: !0, workerScriptsPath: null, workerScripts: null } }(zipLib); const zipExt = function (e) { var t, i, s = e.Reader, r = e.Writer; try { i = 0 === new Blob([new DataView(new ArrayBuffer(0))]).size } catch (s) { } function a(e) { var t = this; function i(i, s) { var r; t.data ? i() : ((r = new XMLHttpRequest).addEventListener("load", (function () { t.size || (t.size = Number(r.getResponseHeader("Content-Length")) || Number(r.response.byteLength)), t.data = new Uint8Array(r.response), i() }), !1), r.addEventListener("error", s, !1), r.open("GET", e), r.responseType = "arraybuffer", r.send()) } t.size = 0, t.init = function (s, r) { var a, o, n = e; (a = document.createElement("a")).href = n, "http:" !== a.protocol && "https:" !== a.protocol ? i(s, r) : ((o = new XMLHttpRequest).addEventListener("load", (function () { t.size = Number(o.getResponseHeader("Content-Length")), t.size ? s() : i(s, r) }), !1), o.addEventListener("error", r, !1), o.open("HEAD", e), o.send()) }, t.readUint8Array = function (e, s, r, a) { i((function () { r(new Uint8Array(t.data.subarray(e, e + s))) }), a) } } function o(e) { var t = this; t.size = 0, t.init = function (i, s) { var r = new XMLHttpRequest; r.addEventListener("load", (function () { t.size = Number(r.getResponseHeader("Content-Length")), "bytes" == r.getResponseHeader("Accept-Ranges") ? i() : s("HTTP Range not supported.") }), !1), r.addEventListener("error", s, !1), r.open("HEAD", e), r.send() }, t.readUint8Array = function (t, i, s, r) { var a; (a = new XMLHttpRequest).open("GET", e), a.responseType = "arraybuffer", a.setRequestHeader("Range", "bytes=" + t + "-" + (t + i - 1)), a.addEventListener("load", (function () { var e = a.response; s(new Uint8Array(e)) }), !1), a.addEventListener("error", r, !1), a.send() } } function n(e) { var t = this; t.size = 0, t.init = function (i, s) { t.size = e.byteLength, i() }, t.readUint8Array = function (t, i, s, r) { s(new Uint8Array(e.slice(t, t + i))) } } function h() { var e; this.init = function (t, i) { e = new Uint8Array, t() }, this.writeUint8Array = function (t, i, s) { var r = new Uint8Array(e.length + t.length); r.set(e), r.set(t, e.length), e = r, i() }, this.getData = function (t) { t(e.buffer) } } function l(e, t) { var s; this.init = function (t, i) { e.createWriter((function (e) { s = e, t() }), i) }, this.writeUint8Array = function (e, r, a) { e = new Blob([i ? e : e.buffer], { type: t }), s.onwrite = function () { s.onwrite = null, r() }, s.onerror = a, s.write(e) }, this.getData = function (t) { e.file(t) } } (a.prototype = new s).constructor = a, (o.prototype = new s).constructor = o, (n.prototype = new s).constructor = n, (h.prototype = new r).constructor = h, l.prototype = new r, e.FileWriter = l.prototype.constructor = l, e.HttpReader = a, e.HttpRangeReader = o, e.ArrayBufferReader = n, e.ArrayBufferWriter = h, e.fs && ((t = e.fs.ZipDirectoryEntry).prototype.addHttpContent = function (i, s, r) { if (s = { data: s, Reader: r ? o : a }, r = void 0, this.directory) return new (r ? t : e.fs.ZipFileEntry)(this.fs, i, s, this); throw "Parent entry is not a directory." }, t.prototype.importHttpContent = function (e, t, i, s) { this.importZip(new (t ? o : a)(e), i, s) }, e.fs.FS.prototype.importHttpContent = function (e, i, s, r) { this.entries = [], this.root = new t(this), this.root.importHttpContent(e, i, s, r) }) }, zip = zipLib.zip, supportedSchemas = (zipExt(zip), ["4.2"]); class XML3DSceneGraphLoader { constructor(e, t = {}) { this.supportedSchemas = supportedSchemas, this._xrayOpacity = .7, this._src = null, this._options = t, this.viewpoint = null, t.workerScriptsPath ? (zip.workerScriptsPath = t.workerScriptsPath, this.src = t.src, this.xrayOpacity = .7, this.displayEffect = t.displayEffect, this.createMetaModel = t.createMetaModel) : e.error("Config expected: workerScriptsPath") } load(e, t, i, s, r, a) { switch (s.materialType) { case "MetallicMaterial": t._defaultMaterial = new MetallicMaterial(t, { baseColor: [1, 1, 1], metallic: .6, roughness: .6 }); break; case "SpecularMaterial": t._defaultMaterial = new SpecularMaterial(t, { diffuse: [1, 1, 1], specular: math.vec3([1, 1, 1]), glossiness: .5 }); break; default: t._defaultMaterial = new PhongMaterial(t, { reflectivity: .75, shiness: 100, diffuse: [1, 1, 1] }) }t._wireframeMaterial = new LambertMaterial(t, { color: [0, 0, 0], lineWidth: 2 }); var o = t.scene.canvas.spinner; o.processes++, load3DXML(e, t, i, s, (function () { o.processes--, r && r(), t.fire("loaded", !0, !1) }), (function (e) { o.processes--, t.error(e), a && a(e), t.fire("error", e) }), (function (e) { console.log("Error, Will Robinson: " + e) })) } } var load3DXML = function (e, t, i, s, r, a) { loadZIP(i, (function (i) { parse3DXML(e, i, s, t, r, a) }), a) }, parse3DXML = function () { return function (i, s, r, a, o) { var n, h, l = { plugin: i, zip: s, edgeThreshold: 30, materialType: r.materialType, scene: a.scene, modelNode: a, info: { references: {} }, materials: {} }; r.createMetaModel && (l.metaModelData = { modelId: a.id, metaObjects: [{ name: a.id, type: "Default", id: a.id }] }), a.scene.loading++, h = function () { l.metaModelData && i.viewer.metaScene.createMetaModel(a.id, l.metaModelData), a.scene.loading--, o() }, (n = l).zip.getFile("Manifest.xml", (function (i, s) { for (var r = s.children, a = 0, o = r.length; a < o; a++) { var l = r[a]; "Manifest" === l.type && function (i, s) { for (var r = l.children, a = 0, o = r.length; a < o; a++) { var n = r[a]; "Root" === n.type && (n = n.children[0], i.zip.getFile(n, (function (r, a) { for (var o = i, n = s, h = a.children, l = 0, c = h.length; l < c; l++) { var u = h[l]; if ("Model_3dxml" === u.type) { P = D = b = v = I = y = f = void 0; for (var p = o, d = n, m = u.children, f = 0, g = m.length; f < g; f++) { var _ = m[f]; switch (_.type) { case "Header": for (var v = I = void 0, y = p, T = _.children, I = {}, E = (v = 0, T.length); v < E; v++) { var C = T[v]; switch (C.type) { case "SchemaVersion": I.schemaVersion = C.children[0], function (e) { for (var t = 0, i = supportedSchemas.length; t < i; t++)if (e === supportedSchemas[t]) return 1 }(I.schemaVersion) || y.plugin.error("Schema version not supported: " + I.schemaVersion + " - supported versions are: " + supportedSchemas.join(",")); break; case "Title": I.title = C.children[0]; break; case "Author": I.author = C.children[0]; break; case "Created": I.created = C.children[0] } } y.modelNode.meta = I; break; case "ProductStructure": !function (i, s, r) { for (var a, o, n = i, h = {}, l = s.children, c = 0, u = 0, p = l.length; u < p; u++)"ReferenceRep" === (a = l[u]).type && c++; for (u = 0, p = l.length; u < p; u++)"ReferenceRep" === (a = l[u]).type && a.associatedFile && (o = stripURN(a.associatedFile), function () { var l = a.id; n.zip.getFile(o, (function (a, o) { a = a.getElementsByTagName("MaterialId"), loadCATMaterialRefDocuments(n, a, (function () { for (var a = { id: l }, u = n, p = a, d = o.children, m = 0, f = d.length; m < f; m++) { var g = d[m]; if ("XMLRepresentation" === g.type) { C = T = void 0; for (var _ = u, v = p, y = g.children, T = 0, I = y.length; T < I; T++) { var E = y[T]; if ("Root" === E.type) { var C = void 0, P = _, b = v; E["xsi:type"]; C = 0; for (var A, D = (A = E.children).length; C < D; C++) { var R = A[C]; "Rep" === R.type && function i(s, r, a) { r["xsi:type"]; for (var o = { edgeThreshold: s.edgeThreshold || 30, compressGeometry: !0 }, n = r.children, h = 0, l = n.length; h < l; h++) { var c = n[h]; switch (c.type) { case "Rep": i(s, c, a); break; case "Edges": break; case "Faces": o.primitive = "triangles", v = P = C = E = T = _ = m = void 0; for (var u = s, p = o, d = c.children, m = 0, f = d.length; m < f; m++) { var g = d[m]; if ("Face" === g.type) { var _, v = P = C = E = _ = T = void 0, y = u, T = p; if (_ = g.strips) { var I = function () { for (var e = _.split(","), t = [], i = 0, s = e.length; i < s; i++) { var r = e[i].trim(); if (0 < r.length) { for (var a = r.trim().split(" "), o = new Int16Array(a.length), n = 0, h = 0, l = a.length; h < l; h++)"" !== a[h] && (o[n++] = parseInt(a[h])); t.push(o) } } return t }(); if (0 < I.length) { T.primitive = "triangles"; for (var E = [], C = 0, P = I.length; C < P; C++)for (var b = function (e) { for (var t = [], i = 0, s = e.length; i < s - 2; i++)1 & i ? (t.push(e[i]), t.push(e[i + 2]), t.push(e[i + 1])) : (t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2])); return t }(I[C]), A = (v = 0, b.length); v < A; v++)E.push(b[v]); T.indices = E } } else (_ = g.triangles) && (T.primitive = "triangles", T.indices = function (e) { e = e.trim().split(" "); for (var t = new Int32Array(e.length), i = 0, s = e.length; i < s; i++) { var r = e[i]; t[i] = parseInt(r) } return t }(_)); var D = g.children; for (C = 0, P = D.length; C < P; C++) { var R = D[C]; "SurfaceAttributes" === R.type && t(y, R, T) } } } break; case "VertexBuffer": for (var F = w = void 0, w = o, M = c.children, S = (F = 0, M.length); F < S; F++) { var x = M[F]; switch (x.type) { case "Positions": w.positions = e(x.children[0], 3); break; case "Normals": w.normals = e(x.children[0], 3); break; case "TextureCoordinates": w.uv = e(x.children[0], 2) } } break; case "SurfaceAttributes": t(s, c, o) } } o.positions && (a[(r = new ReadableGeometry(s.modelNode, o)).id] = { geometry: r, color: o.color || [1, 1, 1, 1], materialId: o.materialId }) }(P, R, b) } } } } } if (h[l] = a, 0 == --c) { for (var F, w = h, M = s.children, S = {}, x = {}, L = {}, O = 0, N = M.length; O < N; O++) { var B = M[O]; switch (B.type) { case "Reference3D": S[B.id] = { type: "Reference3D", id: B.id, name: B.name, instance3Ds: {}, instanceReps: {} }; break; case "InstanceRep": for (var G = 0, U = B.children.length; G < U; G++)switch ((j = B.children[G]).type) { case "IsAggregatedBy": k = j.children[0]; break; case "IsInstanceOf": V = j.children[0] }x[B.id] = { type: "InstanceRep", id: B.id, name: B.name, isAggregatedBy: k, isInstanceOf: V, referenceReps: {} }; break; case "Instance3D": var k, V, H, j; for (G = 0, U = B.children.length; G < U; G++)switch ((j = B.children[G]).type) { case "IsAggregatedBy": k = j.children[0]; break; case "IsInstanceOf": V = j.children[0]; break; case "RelativeMatrix": H = j.children[0] }L[B.id] = { type: "Instance3D", id: B.id, name: B.name, isAggregatedBy: k, isInstanceOf: V, relativeMatrix: H, reference3Ds: {} } } } for (F in L) (W = S[(z = L[F]).isAggregatedBy]) ? W.instance3Ds[z.id] = z : alert("foo"); for (F in L) { var z, W = S[(z = L[F]).isInstanceOf]; (z.reference3Ds[W.id] = W).instance3D = z } for (F in x) { var Y, $ = w[(Y = x[F]).isInstanceOf]; $ && (Y.referenceReps[$.id] = $) } for (F in x) (W = S[(Y = x[F]).isAggregatedBy]) && (W.instanceReps[Y.id] = Y); for (F in S) if (!(W = S[F]).instance3D) return function t(i, s, r) { for (var a in s.instance3Ds) { var o, n, h = n = o = u = l = void 0, l = i, c = s.instance3Ds[a], u = r; for (h in (c.relativeMatrix ? (n = [(o = e(c.relativeMatrix, 12))[9], o[10], o[11]], o = o.slice(0, 9), o = math.mat3ToMat4(o, math.identityMat4()), n = new Node$1(l.modelNode, { position: n }), l.metaModelData && l.metaModelData.metaObjects.push({ id: n.id, type: "Default", name: c.name, parent: (u || l.modelNode).id }), (u || l.modelNode).addChild(n, !0), u = n, n = new Node$1(l.modelNode, { matrix: o }), l.metaModelData && l.metaModelData.metaObjects.push({ id: n.id, type: "Default", name: c.name, parent: (u || l.modelNode).id }), u) : (n = new Node$1(l.modelNode, {}), l.metaModelData && l.metaModelData.metaObjects.push({ id: n.id, type: "Default", name: c.name, parent: (u || l.modelNode).id }), u || l.modelNode)).addChild(n, !0), u = n, c.reference3Ds) t(l, c.reference3Ds[h], u) } for (var a in s.instanceReps) { var p = _ = g = d = void 0, d = i, m = s.instanceReps[a], f = r; if (m.referenceReps) for (var g in m.referenceReps) { var _, v, y, T = m.referenceReps[g]; for (_ in T) "id" !== _ && (v = "lines" === (p = T[_]).geometry.primitive ? d.modelNode._wireframeMaterial : p.materialId ? d.materials[p.materialId] : null, y = p.color, p = new Mesh(d.modelNode, { isObject: !0, geometry: p.geometry, material: v || d.modelNode._defaultMaterial, colorize: y, backfaces: !1 }), d.metaModelData && d.metaModelData.metaObjects.push({ id: p.id, type: "Default", name: m.name, parent: (f || d.modelNode).id }), (f || d.modelNode).addChild(p, !0), p.colorize = y) } } }(i, W, null), void r(); alert("No root Reference3D element found in this modelNode - can't load."), r() } })) }), (function (e) { })) }()) }(p, _, d); break; case "DefaultView": for (var P = D = void 0, b = p, A = _.children, D = 0, R = A.length; D < R; D++) { var F = A[D]; if ("Viewpoint" === F.type) { var w = F.children; b.modelNode.viewpoint = {}; P = 0; for (var M = w.length; P < M; P++) { var S = w[D]; switch (S.type) { case "Position": b.modelNode.viewpoint.eye = e(S.children[0], 3); break; case "Sight": b.modelNode.viewpoint.look = e(S.children[0], 3); break; case "Up": b.modelNode.viewpoint.up = e(S.children[0], 3) } } } } } } } } }))) } }(n, h) } })) }; function e(e, t) { e = e.split(","); for (var i = new Float32Array(e.length * t), s = 0, r = 0, a = e.length; r < a; r++)for (var o = e[r], n = 0, h = (o = o.split(" ")).length; n < h; n++)"" !== o[n] && (i[s++] = parseFloat(o[n])); return i } function t(e, t, i) { i.color = [1, 1, 1, 1]; for (var s = t.children, r = 0, a = s.length; r < a; r++) { var o = s[r]; switch (o.type) { case "Color": i.color[0] = o.red, i.color[1] = o.green, i.color[2] = o.blue, i.color[3] = o.alpha; break; case "MaterialApplication": for (var n = o.children, h = 0, l = n.length; h < l; h++) { var c = n[h]; "MaterialId" === c.type && (c = getIDFromURI(c.id), e.materials[c] || e.plugin.error("material  not found: " + c), i.materialId = c) } } } } }(); function loadCATMaterialRefDocuments(e, t, i) { var s = {}; !function r(a) { var o, n; a >= t.length ? i() : (0 < (n = (o = 0 < (n = (o = t[a].id).lastIndexOf(":")) ? o.substring(n + 1) : o).lastIndexOf("#")) && (o = o.substring(0, n)), s[o] ? r(a + 1) : loadCATMaterialRefDocument(e, o, (function () { s[o] = !0, r(a + 1) }))) }(0) } function loadCATMaterialRefDocument(e, t, i) { e.zip.getFile(t, (function (t, s) { parseCATMaterialRefDocument(e, s, i) })) } function parseCATMaterialRefDocument(e, t, i) { for (var s, r = t.children, a = 0, o = r.length; a < o; a++)"Model_3dxml" === (s = r[a]).type && parseModel_3dxml(e, s, i) } function parseModel_3dxml(e, t, i) { for (var s, r = t.children, a = 0, o = r.length; a < o; a++)"CATMaterialRef" === (s = r[a]).type && parseCATMaterialRef(e, s, i) } function parseCATMaterialRef(e, t, i) { for (var s = {}, r = t.children, a = 0, o = 0, n = r.length; o < n; o++) { var h = r[o]; if ("MaterialDomainInstance" === h.type) { for (var l, c, u = 0, p = h.children.length; u < p; u++) { var d = h.children[u]; switch (d.type) { case "IsAggregatedBy": l = d.children[0]; break; case "IsInstanceOf": c = d.children[0] } } s[c] = l } } for (o = 0, n = r.length; o < n; o++)"MaterialDomain" === (h = r[o]).type && a++; for (o = 0, n = r.length; o < n; o++)"MaterialDomain" === (h = r[o]).type && h.associatedFile && function () { var t = h.id, r = stripURN(h.associatedFile); e.zip.getFile(r, (function (r, o) { e.materials[s[t]] = parseMaterialDefDocument(e, o), 0 == --a && i() }), (function (e) { })) }() } function parseMaterialDefDocument(e, t) { for (var i = t.children, s = 0, r = i.length; s < r; s++) { var a = i[s]; if ("Osm" === a.type) return parseMaterialDefDocumentOsm(e, a) } } function parseMaterialDefDocumentOsm(e, t) { for (var i = t.children, s = 0, r = i.length; s < r; s++) { var a = i[s]; switch (a.type) { case "RenderingRootFeature": break; case "Feature": if ("RenderingFeature" !== a.Alias) break; for (var o, n, h = {}, l = {}, c = a.children, u = 0, p = c.length; u < p; u++)switch ((o = c[u]).Name) { case "AmbientCoef": h.ambient = parseFloat(o.Value); break; case "DiffuseCoef": h.diffuse = parseFloat(o.Value); break; case "EmissiveCoef": h.emissive = parseFloat(o.Value); break; case "SpecularExponent": h.specular = parseFloat(o.Value) }for (u = 0, p = c.length; u < p; u++)switch ((o = c[u]).Name) { case "AmbientColor": l.ambient = parseRGB(o.Value, h.ambient); break; case "DiffuseColor": l.diffuse = parseRGB(o.Value, h.diffuse); break; case "EmissiveColor": l.emissive = parseRGB(o.Value, h.emissive); break; case "SpecularColor": l.specular = parseRGB(o.Value, h.specular); break; case "Transparency": var d = 1 - parseFloat(o.Value); d < 1 && (l.alpha = d, l.alphaMode = "blend") }switch (e.materialType) { case "MetallicMaterial": n = new MetallicMaterial(e.modelNode, { baseColor: l.diffuse, metallic: .7, roughness: .5, emissive: l.emissive, alpha: l.alpha, alphaMode: l.alphaMode }); break; case "SpecularMaterial": n = new SpecularMaterial(e.modelNode, { diffuse: l.diffuse, specular: l.specular, glossiness: .5, emissive: l.emissive, alpha: l.alpha, alphaMode: l.alphaMode }); break; default: n = new PhongMaterial(e.modelNode, { reflectivity: .5, ambient: l.ambient, diffuse: l.diffuse, specular: l.specular, emissive: l.emissive, alphaMode: l.alphaMode, alpha: t.alpha }) }return n } } } function parseRGB(e, t) { t = void 0 !== t ? t : .5; for (var i = e.indexOf("["), s = e.indexOf("]"), r = (e = (e = e.substring(i + 1, s - i)).split(","), new Float32Array(e.length)), a = 0, o = 0, n = e.length; o < n; o++)for (var h = e[o], l = 0, c = (h = h.trim().split(" ")).length; l < c; l++)"" !== h[l] && (r[a++] = parseFloat(h[l]) * t); return r } var ZIP = function () { var e = {}; this.load = function (t, i, s) { zip.createReader(new zip.HttpReader(t), (function (t) { t.getEntries((function (t) { if (0 < t.length) for (var s = 0, r = t.length; s < r; s++) { var a = t[s]; e[a.filename] = a } i() })) }), s) }, this.getFile = function (t, i, s) { var r = e[t]; r ? r.getData(new zip.TextWriter, (function (e) { var t = function e(t, i) { if (t.nodeType === t.TEXT_NODE) { var s = t.nodeValue; if (null === s.match(/^\s+$/)) return s } else if (t.nodeType === t.ELEMENT_NODE || t.nodeType === t.DOCUMENT_NODE) { var r = { type: t.nodeName, children: [] }; if (t.nodeType === t.ELEMENT_NODE) for (var a = 0; a < t.attributes.length; a++) { var o = t.attributes[a]; r[i[o.nodeName] || o.nodeName] = o.nodeValue } for (var n = 0; n < t.childNodes.length; n++)(a = e(t.childNodes[n], i)) && r.children.push(a); return r } }(e = (new DOMParser).parseFromString(e, "text/xml"), {}); i(e, t) })) : (r = "ZIP entry not found: " + t, console.error(r), s && s(r)) }, this.destroy = function () { (void 0).close((function () { })) } }; function loadZIP(e, t, i) { var s = new ZIP; s.load(e, (function () { t(s) }), (function (e) { i("Error loading ZIP archive: " + e) })) } function stripURN(e) { var t = "urn:3DXML:"; return 0 === e.indexOf(t) ? e.substring(10) : e } function getIDFromURI(e) { var t = e.lastIndexOf("#"); return -1 !== t ? e.substring(t + 1) : e } class XML3DLoaderPlugin extends Plugin { constructor(e, t = {}) { super("XML3DLoader", e, t), t.workerScriptsPath ? (this._workerScriptsPath = t.workerScriptsPath, this._loader = new XML3DSceneGraphLoader(this, t), this.supportedSchemas = this._loader.supportedSchemas) : this.error("Config expected: workerScriptsPath") } load(e = {}) { e.workerScriptsPath = this._workerScriptsPath, e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); var t = new Node$1(this.viewer.scene, utils.apply(e, { isModel: !0 })), i = e.src; return i ? this._loader.load(this, t, i, e) : this.error("load() param expected: src"), t } } var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (e, t, i) => t in e ? __defProp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, __spreadValues = (e, t) => { for (var i in t = t || {}) __hasOwnProp.call(t, i) && __defNormalProp(e, i, t[i]); if (__getOwnPropSymbols) for (var i of __getOwnPropSymbols(t)) __propIsEnum.call(t, i) && __defNormalProp(e, i, t[i]); return e }, __require = e => { if ("undefined" != typeof require) return require(e); throw new Error('Dynamic require of "' + e + '" is not supported') }, __commonJS = (e, t) => function () { return t || (0, e[Object.keys(e)[0]])((t = { exports: {} }).exports, t), t.exports }, __async = (e, t, i) => new Promise(((s, r) => { var a = e => { try { n(i.next(e)) } catch (e) { r(e) } }, o = e => { try { n(i.throw(e)) } catch (e) { r(e) } }, n = e => e.done ? s(e.value) : Promise.resolve(e.value).then(a, o); n((i = i.apply(e, t)).next()) })), require_crypto = __commonJS({ "(disabled):crypto"() { } }), require_web_ifc_mt = __commonJS({ "dist/web-ifc-mt.js"(e, t) { function i(e) { function t() { return M.buffer != j && ae(M.buffer), z } function i() { return M.buffer != j && ae(M.buffer), W } function r() { return M.buffer != j && ae(M.buffer), Y } function a() { return M.buffer != j && ae(M.buffer), $ } function o() { return M.buffer != j && ae(M.buffer), X } function n() { return M.buffer != j && ae(M.buffer), K } function h() { return M.buffer != j && ae(M.buffer), Q } var l, c, u, p = e = e || {}, d = (p.ready = new Promise((function (e, t) { l = e, c = t })), {}); for (u in p) p.hasOwnProperty(u) && (d[u] = p[u]); var m, f, g = "./this.program", _ = function (e, t) { throw t }, v = "object" == typeof window, y = "function" == typeof importScripts, T = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, I = p.ENVIRONMENT_IS_PTHREAD || !1, E = ""; function C(e) { return p.locateFile ? p.locateFile(e, E) : E + e } if (T) { E = y ? __require("path").dirname(E) + "/" : __dirname + "/"; var P = function (e, t) { return m = m || __require("fs"), e = (f = f || __require("path")).normalize(e), m.readFileSync(e, t ? null : "utf8") }, b = function (e) { return O((e = (e = P(e, !0)).buffer ? e : new Uint8Array(e)).buffer), e }, A = function (e, t, i) { m = m || __require("fs"), e = (f = f || __require("path")).normalize(e), m.readFile(e, (function (e, s) { e ? i(e) : t(s.buffer) })) }; 1 < process.argv.length && (g = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", (function (e) { if (!(e instanceof Wi)) throw e })), process.on("unhandledRejection", Ee), _ = function (e, t) { if (de()) throw process.exitCode = e, t; process.exit(e) }, p.inspect = function () { return "[Emscripten Module object]" }; try { ne = __require("worker_threads") } catch (e) { throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e } global.Worker = ne.Worker } else (v || y) && (y ? E = self.location.href : "undefined" != typeof document && document.currentScript && (E = document.currentScript.src), E = 0 !== (E = s || E).indexOf("blob:") ? E.substr(0, E.lastIndexOf("/") + 1) : "", A = T ? (P = function (e, t) { return m = m || __require("fs"), e = (f = f || __require("path")).normalize(e), m.readFileSync(e, t ? null : "utf8") }, b = function (e) { return O((e = (e = P(e, !0)).buffer ? e : new Uint8Array(e)).buffer), e }, function (e, t, i) { m = m || __require("fs"), e = (f = f || __require("path")).normalize(e), m.readFile(e, (function (e, s) { e ? i(e) : t(s.buffer) })) }) : (P = function (e) { var t = new XMLHttpRequest; return t.open("GET", e, !1), t.send(null), t.responseText }, y && (b = function (e) { var t = new XMLHttpRequest; return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response) }), function (e, t, i) { var s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onload = function () { 200 == s.status || 0 == s.status && s.response ? t(s.response) : i() }, s.onerror = i, s.send(null) })); T && "undefined" == typeof performance && (global.performance = __require("perf_hooks").performance); var D, R = p.print || console.log.bind(console), F = p.printErr || console.warn.bind(console); for (u in d) d.hasOwnProperty(u) && (p[u] = d[u]); function w(e) { w.shown || (w.shown = {}), w.shown[e] || (w.shown[e] = 1, F(e)) } d = null, p.arguments, p.thisProgram && (g = p.thisProgram), p.quit && (_ = p.quit), p.wasmBinary && (D = p.wasmBinary); var M, S, x = p.noExitRuntime || !0, L = ("object" != typeof WebAssembly && Ee("no native wasm support detected"), !1); function O(e, t) { e || Ee("Assertion failed: " + t) } function N(e) { var t = new TextDecoder(e); this.decode = function (e) { return e.buffer instanceof SharedArrayBuffer && (e = new Uint8Array(e)), t.decode.call(t, e) } } var B = "undefined" != typeof TextDecoder ? new N("utf8") : void 0; function G(e, t, i) { for (var s = (t >>>= 0) + i, r = t; e[r >>> 0] && !(s <= r);)++r; if (16 < r - t && e.subarray && B) return B.decode(e.subarray(t >>> 0, r >>> 0)); for (var a = ""; t < r;) { var o, n, h = e[t++ >>> 0]; 128 & h ? (n = 63 & e[t++ >>> 0], 192 == (224 & h) ? a += String.fromCharCode((31 & h) << 6 | n) : (o = 63 & e[t++ >>> 0], (h = 224 == (240 & h) ? (15 & h) << 12 | n << 6 | o : (7 & h) << 18 | n << 12 | o << 6 | 63 & e[t++ >>> 0]) < 65536 ? a += String.fromCharCode(h) : (n = h - 65536, a += String.fromCharCode(55296 | n >> 10, 56320 | 1023 & n)))) : a += String.fromCharCode(h) } return a } function U(e, t) { return (e >>>= 0) ? G(i(), e, t) : "" } function k(e, t, i, s) { if (!(0 < s)) return 0; for (var r = i >>>= 0, a = i + s - 1, o = 0; o < e.length; ++o) { var n = e.charCodeAt(o); if ((n = 55296 <= n && n <= 57343 ? 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++o) : n) <= 127) { if (a <= i) break; t[i++ >>> 0] = n } else { if (n <= 2047) { if (a <= i + 1) break; t[i++ >>> 0] = 192 | n >> 6 } else { if (n <= 65535) { if (a <= i + 2) break; t[i++ >>> 0] = 224 | n >> 12 } else { if (a <= i + 3) break; t[i++ >>> 0] = 240 | n >> 18, t[i++ >>> 0] = 128 | n >> 12 & 63 } t[i++ >>> 0] = 128 | n >> 6 & 63 } t[i++ >>> 0] = 128 | 63 & n } } return t[i >>> 0] = 0, i - r } function V(e, t, s) { k(e, i(), t, s) } function H(e) { for (var t = 0, i = 0; i < e.length; ++i) { var s = e.charCodeAt(i); (s = 55296 <= s && s <= 57343 ? 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++i) : s) <= 127 ? ++t : t += s <= 2047 ? 2 : s <= 65535 ? 3 : 4 } return t } var j, z, W, Y, $, X, K, J, Q, Z = "undefined" != typeof TextDecoder ? new N("utf-16le") : void 0; function q(e, t) { for (var s, o = e >> 1, n = o + t / 2; !(n <= o) && a()[o >>> 0];)++o; if (32 < (s = o << 1) - e && Z) return Z.decode(i().subarray(e >>> 0, s >>> 0)); for (var h = "", l = 0; !(t / 2 <= l); ++l) { var c = r()[e + 2 * l >>> 1]; if (0 == c) break; h += String.fromCharCode(c) } return h } function ee(e, t, i) { if ((i = void 0 === i ? 2147483647 : i) < 2) return 0; for (var s = t, a = (i -= 2) < 2 * e.length ? i / 2 : e.length, o = 0; o < a; ++o) { var n = e.charCodeAt(o); r()[t >>> 1] = n, t += 2 } return r()[t >>> 1] = 0, t - s } function te(e) { return 2 * e.length } function ie(e, t) { for (var i = 0, s = ""; !(t / 4 <= i);) { var r, a = o()[e + 4 * i >>> 2]; if (0 == a) break; ++i, 65536 <= a ? (r = a - 65536, s += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : s += String.fromCharCode(a) } return s } function se(e, t, i) { if ((i = void 0 === i ? 2147483647 : i) < 4) return 0; for (var s = t >>>= 0, r = s + i - 4, a = 0; a < e.length; ++a) { var n = e.charCodeAt(a); if (55296 <= n && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++a)), o()[t >>> 2] = n, r < (t += 4) + 4) break } return o()[t >>> 2] = 0, t - s } function re(e) { for (var t = 0, i = 0; i < e.length; ++i) { var s = e.charCodeAt(i); 55296 <= s && s <= 57343 && ++i, t += 4 } return t } function ae(e) { j = e, p.HEAP8 = z = new Int8Array(e), p.HEAP16 = Y = new Int16Array(e), p.HEAP32 = X = new Int32Array(e), p.HEAPU8 = W = new Uint8Array(e), p.HEAPU16 = $ = new Uint16Array(e), p.HEAPU32 = K = new Uint32Array(e), p.HEAPF32 = J = new Float32Array(e), p.HEAPF64 = Q = new Float64Array(e) } I && (j = p.buffer); var oe, ne = p.INITIAL_MEMORY || 16777216; if (I) M = p.wasmMemory, j = p.buffer; else if (p.wasmMemory) M = p.wasmMemory; else if (!((M = new WebAssembly.Memory({ initial: ne / 65536, maximum: 65536, shared: !0 })).buffer instanceof SharedArrayBuffer)) throw F("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), T && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory"); (j = M ? M.buffer : j).byteLength, ae(j); var he = [], le = [], ce = [], ue = [], pe = 0; function de() { return x || 0 < pe } function me() { I || (p.noFSInit || Be.init.initialized || Be.init(), Be.ignorePermissions = !1, De(le)) } var fe, ge, _e, ve = 0, ye = null; function Te(e) { ve++, p.monitorRunDependencies && p.monitorRunDependencies(ve) } function Ie(e) { var t; ve--, p.monitorRunDependencies && p.monitorRunDependencies(ve), 0 == ve && ye && (t = ye, ye = null, t()) } function Ee(e) { throw p.onAbort && p.onAbort(e), I && console.error("Pthread aborting at " + (new Error).stack), F(e += ""), L = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", e = new WebAssembly.RuntimeError(e), c(e), e } function Ce(e) { return e.startsWith("data:application/octet-stream;base64,") } function Pe(e) { return e.startsWith("file://") } function be(e) { try { if (e == fe && D) return new Uint8Array(D); if (b) return b(e); throw "both async and sync fetching of the wasm failed" } catch (e) { Ee(e) } } p.preloadedImages = {}, p.preloadedAudios = {}, Ce(fe = "web-ifc-mt.wasm") || (fe = C(fe)); var Ae = { 44848: function () { throw "Canceled!" }, 44866: function (e, t) { setTimeout((function () { Ri(e, t) }), 0) } }; function De(e) { for (; 0 < e.length;) { var t, i = e.shift(); "function" == typeof i ? i(p) : "number" == typeof (t = i.func) ? void 0 === i.arg ? oe.get(t)() : oe.get(t)(i.arg) : t(void 0 === i.arg ? null : i.arg) } } function Re(e, i) { if (e <= 0 || e > t().length || !0 & e || i < 0) return -28; if (0 == i) return 0; 2147483647 <= i && (i = 1 / 0); var s = Atomics.load(o(), zi >> 2), r = 0; if (s == e) { var a = Atomics.compareExchange(o(), zi >> 2, s, 0); if (a == s && (r = 1, --i <= 0)) return 1 } if (0 <= (a = Atomics.notify(o(), e >> 2, i))) return a + r; throw "Atomics.notify returned an unexpected value " + a } p._emscripten_futex_wake = Re; var Fe = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], initMainThreadBlock: function () { for (var e = navigator.hardwareConcurrency, t = 0; t < e; ++t)Fe.allocateUnusedWorker() }, initRuntime: function () { for (var e = Pi(228), t = 0; t < 57; ++t)n()[e / 4 + t >>> 0] = 0; var i = (o()[e + 12 >>> 2] = e) + 152, s = (o()[i >>> 2] = i, Pi(512)); for (t = 0; t < 128; ++t)n()[s / 4 + t >>> 0] = 0; Atomics.store(n(), e + 100 >> 2, s), Atomics.store(n(), e + 40 >> 2, e), xi(e, !y, 1), Di(e) }, initWorker: function () { }, pthreads: {}, threadExitHandlers: [], runExitHandlers: function () { for (; 0 < Fe.threadExitHandlers.length;)Fe.threadExitHandlers.pop()(); Bi() }, runExitHandlersAndDeinitThread: function (e, t) { Atomics.store(n(), e + 56 >> 2, 1), Atomics.store(n(), e + 60 >> 2, 0), Fe.runExitHandlers(), Atomics.store(n(), e + 4 >> 2, t), Atomics.store(n(), e + 0 >> 2, 1), Re(e + 0, 2147483647), xi(0, 0, 0) }, setExitStatus: function (e) { }, threadExit: function (e) { var t = Ni(); t && (Fe.runExitHandlersAndDeinitThread(t, e), I) && postMessage({ cmd: "exit" }) }, threadCancel: function () { Fe.runExitHandlersAndDeinitThread(Ni(), -1), postMessage({ cmd: "cancelDone" }) }, terminateAllThreads: function () { for (var e in Fe.pthreads) (s = Fe.pthreads[e]) && s.worker && Fe.returnWorkerToPool(s.worker); Fe.pthreads = {}; for (var t = 0; t < Fe.unusedWorkers.length; ++t)(i = Fe.unusedWorkers[t]).terminate(); for (Fe.unusedWorkers = [], t = 0; t < Fe.runningWorkers.length; ++t) { var i, s = (i = Fe.runningWorkers[t]).pthread; Fe.freeThreadData(s), i.terminate() } Fe.runningWorkers = [] }, freeThreadData: function (e) { var t; e && (e.threadInfoStruct && (t = o()[e.threadInfoStruct + 100 >>> 2], o()[e.threadInfoStruct + 100 >>> 2] = 0, bi(t), bi(e.threadInfoStruct)), e.threadInfoStruct = 0, e.allocatedOwnStack && e.stackBase && bi(e.stackBase), e.stackBase = 0, e.worker) && (e.worker.pthread = null) }, returnWorkerToPool: function (e) { Fe.runWithoutMainThreadQueuedCalls((function () { delete Fe.pthreads[e.pthread.threadInfoStruct], Fe.unusedWorkers.push(e), Fe.runningWorkers.splice(Fe.runningWorkers.indexOf(e), 1), Fe.freeThreadData(e.pthread), e.pthread = void 0 })) }, runWithoutMainThreadQueuedCalls: function (e) { o()[ji >>> 2] = 0; try { e() } finally { o()[ji >>> 2] = 1 } }, receiveObjectTransfer: function (e) { }, threadInit: function () { for (var e in Fe.tlsInitFunctions) Fe.tlsInitFunctions[e]() }, loadWasmModuleToWorker: function (e, t) { e.onmessage = function (i) { var s = i.data, r = s.cmd; if (e.pthread && (Fe.currentProxiedOperationCallerThread = e.pthread.threadInfoStruct), s.targetThread && s.targetThread != Ni()) (a = Fe.pthreads[s.targetThread]) ? a.worker.postMessage(i.data, s.transferList) : console.error('Internal error! Worker sent a message "' + r + '" to target pthread ' + s.targetThread + ", but that thread no longer exists!"); else if ("processQueuedMainThreadWork" === r) wi(); else if ("spawnThread" === r) ci(i.data); else if ("cleanupThread" === r) { var a = s.thread; if (I) throw "Internal Error! cleanupThread() can only ever be called from main application thread!"; if (!a) throw "Internal Error! Null pthread_ptr in cleanupThread!"; var h = Fe.pthreads[a]; h && (o()[a + 12 >>> 2] = 0, a = h.worker, Fe.returnWorkerToPool(a)) } else if ("killThread" === r) { if (h = s.thread, I) throw "Internal Error! killThread() can only ever be called from main application thread!"; if (!h) throw "Internal Error! Null pthread_ptr in killThread!"; o()[h + 12 >>> 2] = 0, (h = Fe.pthreads[h]).worker.terminate(), Fe.freeThreadData(h), Fe.runningWorkers.splice(Fe.runningWorkers.indexOf(h.worker), 1), h.worker.pthread = void 0 } else if ("cancelThread" === r) { if (a = s.thread, I) throw "Internal Error! cancelThread() can only ever be called from main application thread!"; if (!a) throw "Internal Error! Null pthread_ptr in cancelThread!"; Fe.pthreads[a].worker.postMessage({ cmd: "cancel" }) } else if ("loaded" === r) e.loaded = !0, t && t(e), e.runPthread && (e.runPthread(), delete e.runPthread); else if ("print" === r) R("Thread " + s.threadId + ": " + s.text); else if ("printErr" === r) F("Thread " + s.threadId + ": " + s.text); else if ("alert" === r) alert("Thread " + s.threadId + ": " + s.text); else if ("exit" === r) e.pthread && Atomics.load(n(), e.pthread.threadInfoStruct + 64 >> 2) && Fe.returnWorkerToPool(e); else if ("exitProcess" === r) try { $i(s.returnCode) } catch (i) { if (i instanceof Wi) return; throw i } else "cancelDone" === r ? Fe.returnWorkerToPool(e) : "objectTransfer" === r ? Fe.receiveObjectTransfer(i.data) : "setimmediate" === i.data.target ? e.postMessage(i.data) : F("worker sent an unknown command " + r); Fe.currentProxiedOperationCallerThread = void 0 }, e.onerror = function (e) { F("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message) }, T && (e.on("message", (function (t) { e.onmessage({ data: t }) })), e.on("error", (function (t) { e.onerror(t) })), e.on("exit", (function (e) { }))), e.postMessage({ cmd: "load", urlOrBlob: p.mainScriptUrlOrBlob || s, wasmMemory: M, wasmModule: S }) }, allocateUnusedWorker: function () { var e = C("web-ifc-mt.worker.js"); Fe.unusedWorkers.push(new Worker(e)) }, getNewWorker: function () { return 0 == Fe.unusedWorkers.length && (Fe.allocateUnusedWorker(), Fe.loadWasmModuleToWorker(Fe.unusedWorkers[0])), Fe.unusedWorkers.pop() }, busySpinWait: function (e) { for (var t = performance.now() + e; performance.now() < t;); } }, we = (p.establishStackSpace = function (e, t) { Vi(e, t), Ui(e) }, p.invokeEntryPoint = function (e, t) { return oe.get(e)(t) }, T ? function () { var e = process.hrtime(); return 1e3 * e[0] + e[1] / 1e6 } : I ? function () { return performance.now() - p.__performance_now_clock_drift } : function () { return performance.now() }); function Me(e) { o()[Oi() >>> 2] = e } function Se(e) { this.excPtr = e, this.ptr = e - 16, this.set_type = function (e) { o()[this.ptr + 4 >>> 2] = e }, this.get_type = function () { return o()[this.ptr + 4 >>> 2] }, this.set_destructor = function (e) { o()[this.ptr + 8 >>> 2] = e }, this.get_destructor = function () { return o()[this.ptr + 8 >>> 2] }, this.set_refcount = function (e) { o()[this.ptr >>> 2] = e }, this.set_caught = function (e) { e = e ? 1 : 0, t()[this.ptr + 12 >>> 0] = e }, this.get_caught = function () { return 0 != t()[this.ptr + 12 >>> 0] }, this.set_rethrown = function (e) { e = e ? 1 : 0, t()[this.ptr + 13 >>> 0] = e }, this.get_rethrown = function () { return 0 != t()[this.ptr + 13 >>> 0] }, this.init = function (e, t) { this.set_type(e), this.set_destructor(t), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1) }, this.add_ref = function () { Atomics.add(o(), this.ptr + 0 >> 2, 1) }, this.release_ref = function () { return 1 === Atomics.sub(o(), this.ptr + 0 >> 2, 1) } } var xe = { splitPath: function (e) { return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1) }, normalizeArray: function (e, t) { for (var i = 0, s = e.length - 1; 0 <= s; s--) { var r = e[s]; "." === r ? e.splice(s, 1) : ".." === r ? (e.splice(s, 1), i++) : i && (e.splice(s, 1), i--) } if (t) for (; i; i--)e.unshift(".."); return e }, normalize: function (e) { var t = "/" === e.charAt(0), i = "/" === e.substr(-1); return (e = (e = xe.normalizeArray(e.split("/").filter((function (e) { return !!e })), !t).join("/")) || t ? e : ".") && i && (e += "/"), (t ? "/" : "") + e }, dirname: function (e) { var t = (e = xe.splitPath(e))[0]; e = e[1]; return t || e ? t + (e && e.substr(0, e.length - 1)) : "." }, basename: function (e) { var t; return "/" === e ? "/" : -1 === (t = (e = (e = xe.normalize(e)).replace(/\/$/, "")).lastIndexOf("/")) ? e : e.substr(t + 1) }, extname: function (e) { return xe.splitPath(e)[3] }, join: function () { var e = Array.prototype.slice.call(arguments, 0); return xe.normalize(e.join("/")) }, join2: function (e, t) { return xe.normalize(e + "/" + t) } }, Le = { resolve: function () { for (var e = "", t = !1, i = arguments.length - 1; -1 <= i && !t; i--) { var s = 0 <= i ? arguments[i] : Be.cwd(); if ("string" != typeof s) throw new TypeError("Arguments to path.resolve must be strings"); if (!s) return ""; e = s + "/" + e, t = "/" === s.charAt(0) } return (t ? "/" : "") + xe.normalizeArray(e.split("/").filter((function (e) { return !!e })), !t).join("/") || "." }, relative: function (e, t) { function i(e) { for (var t = 0; t < e.length && "" === e[t]; t++); for (var i = e.length - 1; 0 <= i && "" === e[i]; i--); return i < t ? [] : e.slice(t, i - t + 1) } e = Le.resolve(e).substr(1), t = Le.resolve(t).substr(1); for (var s = i(e.split("/")), r = i(t.split("/")), a = Math.min(s.length, r.length), o = a, n = 0; n < a; n++)if (s[n] !== r[n]) { o = n; break } var h = []; for (n = o; n < s.length; n++)h.push(".."); return (h = h.concat(r.slice(o))).join("/") } }, Oe = { ttys: [], init: function () { }, shutdown: function () { }, register: function (e, t) { Oe.ttys[e] = { input: [], output: [], ops: t }, Be.registerDevice(e, Oe.stream_ops) }, stream_ops: { open: function (e) { var t = Oe.ttys[e.node.rdev]; if (!t) throw new Be.ErrnoError(43); e.tty = t, e.seekable = !1 }, close: function (e) { e.tty.ops.flush(e.tty) }, flush: function (e) { e.tty.ops.flush(e.tty) }, read: function (e, t, i, s, r) { if (!e.tty || !e.tty.ops.get_char) throw new Be.ErrnoError(60); for (var a, o = 0, n = 0; n < s; n++) { try { a = e.tty.ops.get_char(e.tty) } catch (e) { throw new Be.ErrnoError(29) } if (void 0 === a && 0 === o) throw new Be.ErrnoError(6); if (null == a) break; o++, t[i + n] = a } return o && (e.node.timestamp = Date.now()), o }, write: function (e, t, i, s, r) { if (!e.tty || !e.tty.ops.put_char) throw new Be.ErrnoError(60); try { for (var a = 0; a < s; a++)e.tty.ops.put_char(e.tty, t[i + a]) } catch (e) { throw new Be.ErrnoError(29) } return s && (e.node.timestamp = Date.now()), a } }, default_tty_ops: { get_char: function (e) { if (!e.input.length) { var t = null; if (T) { var i = Buffer.alloc(256), s = 0; try { s = m.readSync(process.stdin.fd, i, 0, 256, null) } catch (e) { if (!e.toString().includes("EOF")) throw e; s = 0 } t = 0 < s ? i.slice(0, s).toString("utf-8") : null } else "undefined" != typeof window && "function" == typeof window.prompt ? null !== (t = window.prompt("Input: ")) && (t += "\n") : "function" == typeof readline && null !== (t = readline()) && (t += "\n"); if (!t) return null; e.input = Ii(t, !0) } return e.input.shift() }, put_char: function (e, t) { null === t || 10 === t ? (R(G(e.output, 0)), e.output = []) : 0 != t && e.output.push(t) }, flush: function (e) { e.output && 0 < e.output.length && (R(G(e.output, 0)), e.output = []) } }, default_tty1_ops: { put_char: function (e, t) { null === t || 10 === t ? (F(G(e.output, 0)), e.output = []) : 0 != t && e.output.push(t) }, flush: function (e) { e.output && 0 < e.output.length && (F(G(e.output, 0)), e.output = []) } } }, Ne = { ops_table: null, mount: function (e) { return Ne.createNode(null, "/", 16895, 0) }, createNode: function (e, t, i, s) { if (Be.isBlkdev(i) || Be.isFIFO(i)) throw new Be.ErrnoError(63); return Ne.ops_table || (Ne.ops_table = { dir: { node: { getattr: Ne.node_ops.getattr, setattr: Ne.node_ops.setattr, lookup: Ne.node_ops.lookup, mknod: Ne.node_ops.mknod, rename: Ne.node_ops.rename, unlink: Ne.node_ops.unlink, rmdir: Ne.node_ops.rmdir, readdir: Ne.node_ops.readdir, symlink: Ne.node_ops.symlink }, stream: { llseek: Ne.stream_ops.llseek } }, file: { node: { getattr: Ne.node_ops.getattr, setattr: Ne.node_ops.setattr }, stream: { llseek: Ne.stream_ops.llseek, read: Ne.stream_ops.read, write: Ne.stream_ops.write, allocate: Ne.stream_ops.allocate, mmap: Ne.stream_ops.mmap, msync: Ne.stream_ops.msync } }, link: { node: { getattr: Ne.node_ops.getattr, setattr: Ne.node_ops.setattr, readlink: Ne.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: Ne.node_ops.getattr, setattr: Ne.node_ops.setattr }, stream: Be.chrdev_stream_ops } }), i = Be.createNode(e, t, i, s), Be.isDir(i.mode) ? (i.node_ops = Ne.ops_table.dir.node, i.stream_ops = Ne.ops_table.dir.stream, i.contents = {}) : Be.isFile(i.mode) ? (i.node_ops = Ne.ops_table.file.node, i.stream_ops = Ne.ops_table.file.stream, i.usedBytes = 0, i.contents = null) : Be.isLink(i.mode) ? (i.node_ops = Ne.ops_table.link.node, i.stream_ops = Ne.ops_table.link.stream) : Be.isChrdev(i.mode) && (i.node_ops = Ne.ops_table.chrdev.node, i.stream_ops = Ne.ops_table.chrdev.stream), i.timestamp = Date.now(), e && (e.contents[t] = i, e.timestamp = i.timestamp), i }, getFileDataAsTypedArray: function (e) { return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0) }, expandFileStorage: function (e, t) { var i = e.contents ? e.contents.length : 0; (t >>>= 0) <= i || (t = Math.max(t, i * (i < 1048576 ? 2 : 1.125) >>> 0), 0 != i && (t = Math.max(t, 256)), i = e.contents, e.contents = new Uint8Array(t), 0 < e.usedBytes && e.contents.set(i.subarray(0, e.usedBytes), 0)) }, resizeFileStorage: function (e, t) { var i; e.usedBytes != (t >>>= 0) && (0 == t ? (e.contents = null, e.usedBytes = 0) : (i = e.contents, e.contents = new Uint8Array(t), i && e.contents.set(i.subarray(0, Math.min(t, e.usedBytes))), e.usedBytes = t)) }, node_ops: { getattr: function (e) { var t = {}; return t.dev = Be.isChrdev(e.mode) ? e.id : 1, t.ino = e.id, t.mode = e.mode, t.nlink = 1, t.uid = 0, t.gid = 0, t.rdev = e.rdev, Be.isDir(e.mode) ? t.size = 4096 : Be.isFile(e.mode) ? t.size = e.usedBytes : Be.isLink(e.mode) ? t.size = e.link.length : t.size = 0, t.atime = new Date(e.timestamp), t.mtime = new Date(e.timestamp), t.ctime = new Date(e.timestamp), t.blksize = 4096, t.blocks = Math.ceil(t.size / t.blksize), t }, setattr: function (e, t) { void 0 !== t.mode && (e.mode = t.mode), void 0 !== t.timestamp && (e.timestamp = t.timestamp), void 0 !== t.size && Ne.resizeFileStorage(e, t.size) }, lookup: function (e, t) { throw Be.genericErrors[44] }, mknod: function (e, t, i, s) { return Ne.createNode(e, t, i, s) }, rename: function (e, t, i) { if (Be.isDir(e.mode)) { var s; try { s = Be.lookupNode(t, i) } catch (e) { } if (s) for (var r in s.contents) throw new Be.ErrnoError(55) } delete e.parent.contents[e.name], e.parent.timestamp = Date.now(), e.name = i, t.contents[i] = e, t.timestamp = e.parent.timestamp, e.parent = t }, unlink: function (e, t) { delete e.contents[t], e.timestamp = Date.now() }, rmdir: function (e, t) { for (var i in Be.lookupNode(e, t).contents) throw new Be.ErrnoError(55); delete e.contents[t], e.timestamp = Date.now() }, readdir: function (e) { var t, i = [".", ".."]; for (t in e.contents) e.contents.hasOwnProperty(t) && i.push(t); return i }, symlink: function (e, t, i) { return (e = Ne.createNode(e, t, 41471, 0)).link = i, e }, readlink: function (e) { if (Be.isLink(e.mode)) return e.link; throw new Be.ErrnoError(28) } }, stream_ops: { read: function (e, t, i, s, r) { var a = e.node.contents; if (r >= e.node.usedBytes) return 0; var o = Math.min(e.node.usedBytes - r, s); if (8 < o && a.subarray) t.set(a.subarray(r, r + o), i); else for (var n = 0; n < o; n++)t[i + n] = a[r + n]; return o }, write: function (e, i, s, r, a, o) { if (i.buffer === t().buffer && (o = !1), !r) return 0; var n = e.node; if (n.timestamp = Date.now(), i.subarray && (!n.contents || n.contents.subarray)) { if (o) return n.contents = i.subarray(s, s + r), n.usedBytes = r; if (0 === n.usedBytes && 0 === a) return n.contents = i.slice(s, s + r), n.usedBytes = r; if (a + r <= n.usedBytes) return n.contents.set(i.subarray(s, s + r), a), r } if (Ne.expandFileStorage(n, a + r), n.contents.subarray && i.subarray) n.contents.set(i.subarray(s, s + r), a); else for (var h = 0; h < r; h++)n.contents[a + h] = i[s + h]; return n.usedBytes = Math.max(n.usedBytes, a + r), r }, llseek: function (e, t, i) { if (1 === i ? t += e.position : 2 === i && Be.isFile(e.node.mode) && (t += e.node.usedBytes), t < 0) throw new Be.ErrnoError(28); return t }, allocate: function (e, t, i) { Ne.expandFileStorage(e.node, t + i), e.node.usedBytes = Math.max(e.node.usedBytes, t + i) }, mmap: function (e, s, r, a, o, n) { if (0 !== s) throw new Be.ErrnoError(28); if (!Be.isFile(e.node.mode)) throw new Be.ErrnoError(43); var h, l; s = e.node.contents; if (2 & n || s.buffer !== j) { if ((0 < a || a + r < s.length) && (s = s.subarray ? s.subarray(a, a + r) : Array.prototype.slice.call(s, a, a + r)), l = !0, n = e = r, e = 65536 * Math.ceil(n / 65536), !(h = (n = Hi(65536, e)) ? (a = n, i().fill(0, a, a + e), n) : 0)) throw new Be.ErrnoError(48); h >>>= 0, t().set(s, h >>> 0) } else l = !1, h = s.byteOffset; return { ptr: h, allocated: l } }, msync: function (e, t, i, s, r) { if (Be.isFile(e.node.mode)) return 2 & r || Ne.stream_ops.write(e, t, 0, s, i, !1), 0; throw new Be.ErrnoError(43) } } }, Be = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function (e, t) { if (t = t || {}, !(e = Le.resolve(Be.cwd(), e))) return { path: "", node: null }; var i, s = { follow_mount: !0, recurse_count: 0 }; for (i in s) void 0 === t[i] && (t[i] = s[i]); if (8 < t.recurse_count) throw new Be.ErrnoError(32); for (var r = xe.normalizeArray(e.split("/").filter((function (e) { return !!e })), !1), a = Be.root, o = "/", n = 0; n < r.length; n++) { var h = n === r.length - 1; if (h && t.parent) break; if (a = Be.lookupNode(a, r[n]), o = xe.join2(o, r[n]), !Be.isMountpoint(a) || h && !t.follow_mount || (a = a.mounted.root), !h || t.follow) for (var l = 0; Be.isLink(a.mode);) { var c = Be.readlink(o); o = Le.resolve(xe.dirname(o), c), a = Be.lookupPath(o, { recurse_count: t.recurse_count }).node; if (40 < l++) throw new Be.ErrnoError(32) } } return { path: o, node: a } }, getPath: function (e) { for (var t, i; ;) { if (Be.isRoot(e)) return i = e.mount.mountpoint, t ? "/" !== i[i.length - 1] ? i + "/" + t : i + t : i; t = t ? e.name + "/" + t : e.name, e = e.parent } }, hashName: function (e, t) { for (var i = 0, s = 0; s < t.length; s++)i = (i << 5) - i + t.charCodeAt(s) | 0; return (e + i >>> 0) % Be.nameTable.length }, hashAddNode: function (e) { var t = Be.hashName(e.parent.id, e.name); e.name_next = Be.nameTable[t], Be.nameTable[t] = e }, hashRemoveNode: function (e) { var t = Be.hashName(e.parent.id, e.name); if (Be.nameTable[t] === e) Be.nameTable[t] = e.name_next; else for (var i = Be.nameTable[t]; i;) { if (i.name_next === e) { i.name_next = e.name_next; break } i = i.name_next } }, lookupNode: function (e, t) { if (i = Be.mayLookup(e)) throw new Be.ErrnoError(i, e); for (var i = Be.hashName(e.id, t), s = Be.nameTable[i]; s; s = s.name_next) { var r = s.name; if (s.parent.id === e.id && r === t) return s } return Be.lookup(e, t) }, createNode: function (e, t, i, s) { return e = new Be.FSNode(e, t, i, s), Be.hashAddNode(e), e }, destroyNode: function (e) { Be.hashRemoveNode(e) }, isRoot: function (e) { return e === e.parent }, isMountpoint: function (e) { return !!e.mounted }, isFile: function (e) { return 32768 == (61440 & e) }, isDir: function (e) { return 16384 == (61440 & e) }, isLink: function (e) { return 40960 == (61440 & e) }, isChrdev: function (e) { return 8192 == (61440 & e) }, isBlkdev: function (e) { return 24576 == (61440 & e) }, isFIFO: function (e) { return 4096 == (61440 & e) }, isSocket: function (e) { return !(49152 & ~e) }, flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, modeStringToFlags: function (e) { var t = Be.flagModes[e]; if (void 0 === t) throw new Error("Unknown file open mode: " + e); return t }, flagsToPermissionString: function (e) { var t = ["r", "w", "rw"][3 & e]; return 512 & e && (t += "w"), t }, nodePermissions: function (e, t) { return Be.ignorePermissions || (!t.includes("r") || 292 & e.mode) && (!t.includes("w") || 146 & e.mode) && (!t.includes("x") || 73 & e.mode) ? 0 : 2 }, mayLookup: function (e) { return Be.nodePermissions(e, "x") || (e.node_ops.lookup ? 0 : 2) }, mayCreate: function (e, t) { try { return Be.lookupNode(e, t), 20 } catch (e) { } return Be.nodePermissions(e, "wx") }, mayDelete: function (e, t, i) { var s; try { s = Be.lookupNode(e, t) } catch (e) { return e.errno } if (t = Be.nodePermissions(e, "wx")) return t; if (i) { if (!Be.isDir(s.mode)) return 54; if (Be.isRoot(s) || Be.getPath(s) === Be.cwd()) return 10 } else if (Be.isDir(s.mode)) return 31; return 0 }, mayOpen: function (e, t) { return e ? Be.isLink(e.mode) ? 32 : Be.isDir(e.mode) && ("r" !== Be.flagsToPermissionString(t) || 512 & t) ? 31 : Be.nodePermissions(e, Be.flagsToPermissionString(t)) : 44 }, MAX_OPEN_FDS: 4096, nextfd: function (e, t) { t = t || Be.MAX_OPEN_FDS; for (var i = e = e || 0; i <= t; i++)if (!Be.streams[i]) return i; throw new Be.ErrnoError(33) }, getStream: function (e) { return Be.streams[e] }, createStream: function (e, t, i) { Be.FSStream || (Be.FSStream = function () { }, Be.FSStream.prototype = { object: { get: function () { return this.node }, set: function (e) { this.node = e } }, isRead: { get: function () { return 1 != (2097155 & this.flags) } }, isWrite: { get: function () { return !!(2097155 & this.flags) } }, isAppend: { get: function () { return 1024 & this.flags } } }); var s, r = new Be.FSStream; for (s in e) r[s] = e[s]; return e = r, t = Be.nextfd(t, i), e.fd = t, Be.streams[t] = e }, closeStream: function (e) { Be.streams[e] = null }, chrdev_stream_ops: { open: function (e) { var t = Be.getDevice(e.node.rdev); e.stream_ops = t.stream_ops, e.stream_ops.open && e.stream_ops.open(e) }, llseek: function () { throw new Be.ErrnoError(70) } }, major: function (e) { return e >> 8 }, minor: function (e) { return 255 & e }, makedev: function (e, t) { return e << 8 | t }, registerDevice: function (e, t) { Be.devices[e] = { stream_ops: t } }, getDevice: function (e) { return Be.devices[e] }, getMounts: function (e) { for (var t = [], i = [e]; i.length;) { var s = i.pop(); t.push(s), i.push.apply(i, s.mounts) } return t }, syncfs: function (e, t) { "function" == typeof e && (t = e, e = !1), Be.syncFSRequests++, 1 < Be.syncFSRequests && F("warning: " + Be.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work"); var i = Be.getMounts(Be.root.mount), s = 0; function r(e) { return Be.syncFSRequests--, t(e) } function a(e) { if (e) return a.errored ? void 0 : (a.errored = !0, r(e)); ++s >= i.length && r(null) } i.forEach((function (t) { if (!t.type.syncfs) return a(null); t.type.syncfs(t, e, a) })) }, mount: function (e, t, i) { var s, r = "/" === i, a = !i; if (r && Be.root) throw new Be.ErrnoError(10); if (!r && !a) { if (i = (a = Be.lookupPath(i, { follow_mount: !1 })).path, s = a.node, Be.isMountpoint(s)) throw new Be.ErrnoError(10); if (!Be.isDir(s.mode)) throw new Be.ErrnoError(54) } return ((t = e.mount(a = { type: e, opts: t, mountpoint: i, mounts: [] })).mount = a).root = t, r ? Be.root = t : s && (s.mounted = a, s.mount) && s.mount.mounts.push(a), t }, unmount: function (e) { if (e = Be.lookupPath(e, { follow_mount: !1 }), !Be.isMountpoint(e.node)) throw new Be.ErrnoError(28); var t = (e = e.node).mounted, i = Be.getMounts(t); Object.keys(Be.nameTable).forEach((function (e) { for (var t = Be.nameTable[e]; t;) { var s = t.name_next; i.includes(t.mount) && Be.destroyNode(t), t = s } })), e.mounted = null, t = e.mount.mounts.indexOf(t); e.mount.mounts.splice(t, 1) }, lookup: function (e, t) { return e.node_ops.lookup(e, t) }, mknod: function (e, t, i) { var s = Be.lookupPath(e, { parent: !0 }).node; if (!(e = xe.basename(e)) || "." === e || ".." === e) throw new Be.ErrnoError(28); var r = Be.mayCreate(s, e); if (r) throw new Be.ErrnoError(r); if (s.node_ops.mknod) return s.node_ops.mknod(s, e, t, i); throw new Be.ErrnoError(63) }, create: function (e, t) { return Be.mknod(e, t = 4095 & (void 0 !== t ? t : 438) | 32768, 0) }, mkdir: function (e, t) { return Be.mknod(e, t = 1023 & (void 0 !== t ? t : 511) | 16384, 0) }, mkdirTree: function (e, t) { for (var i = e.split("/"), s = "", r = 0; r < i.length; ++r)if (i[r]) { s += "/" + i[r]; try { Be.mkdir(s, t) } catch (e) { if (20 != e.errno) throw e } } }, mkdev: function (e, t, i) { return void 0 === i && (i = t, t = 438), Be.mknod(e, t |= 8192, i) }, symlink: function (e, t) { if (!Le.resolve(e)) throw new Be.ErrnoError(44); var i = Be.lookupPath(t, { parent: !0 }).node; if (!i) throw new Be.ErrnoError(44); t = xe.basename(t); var s = Be.mayCreate(i, t); if (s) throw new Be.ErrnoError(s); if (i.node_ops.symlink) return i.node_ops.symlink(i, t, e); throw new Be.ErrnoError(63) }, rename: function (e, t) { var i = xe.dirname(e), s = xe.dirname(t), r = xe.basename(e), a = xe.basename(t), o = (o = Be.lookupPath(e, { parent: !0 })).node, n = Be.lookupPath(t, { parent: !0 }).node; if (!o || !n) throw new Be.ErrnoError(44); if (o.mount !== n.mount) throw new Be.ErrnoError(75); var h, l = Be.lookupNode(o, r); if ("." !== (s = Le.relative(e, s)).charAt(0)) throw new Be.ErrnoError(28); if ("." !== (s = Le.relative(t, i)).charAt(0)) throw new Be.ErrnoError(55); try { h = Be.lookupNode(n, a) } catch (i) { } if (l !== h) { if (i = Be.isDir(l.mode), s = Be.mayDelete(o, r, i)) throw new Be.ErrnoError(s); if (s = h ? Be.mayDelete(n, a, i) : Be.mayCreate(n, a)) throw new Be.ErrnoError(s); if (!o.node_ops.rename) throw new Be.ErrnoError(63); if (Be.isMountpoint(l) || h && Be.isMountpoint(h)) throw new Be.ErrnoError(10); if (n !== o && (s = Be.nodePermissions(o, "w"))) throw new Be.ErrnoError(s); try { Be.trackingDelegate.willMovePath && Be.trackingDelegate.willMovePath(e, t) } catch (i) { F("FS.trackingDelegate['willMovePath']('" + e + "', '" + t + "') threw an exception: " + i.message) } Be.hashRemoveNode(l); try { o.node_ops.rename(l, n, a) } catch (i) { throw i } finally { Be.hashAddNode(l) } try { Be.trackingDelegate.onMovePath && Be.trackingDelegate.onMovePath(e, t) } catch (i) { F("FS.trackingDelegate['onMovePath']('" + e + "', '" + t + "') threw an exception: " + i.message) } } }, rmdir: function (e) { var t = Be.lookupPath(e, { parent: !0 }).node, i = xe.basename(e), s = Be.lookupNode(t, i), r = Be.mayDelete(t, i, !0); if (r) throw new Be.ErrnoError(r); if (!t.node_ops.rmdir) throw new Be.ErrnoError(63); if (Be.isMountpoint(s)) throw new Be.ErrnoError(10); try { Be.trackingDelegate.willDeletePath && Be.trackingDelegate.willDeletePath(e) } catch (t) { F("FS.trackingDelegate['willDeletePath']('" + e + "') threw an exception: " + t.message) } t.node_ops.rmdir(t, i), Be.destroyNode(s); try { Be.trackingDelegate.onDeletePath && Be.trackingDelegate.onDeletePath(e) } catch (t) { F("FS.trackingDelegate['onDeletePath']('" + e + "') threw an exception: " + t.message) } }, readdir: function (e) { if ((e = Be.lookupPath(e, { follow: !0 }).node).node_ops.readdir) return e.node_ops.readdir(e); throw new Be.ErrnoError(54) }, unlink: function (e) { var t = Be.lookupPath(e, { parent: !0 }).node, i = xe.basename(e), s = Be.lookupNode(t, i), r = Be.mayDelete(t, i, !1); if (r) throw new Be.ErrnoError(r); if (!t.node_ops.unlink) throw new Be.ErrnoError(63); if (Be.isMountpoint(s)) throw new Be.ErrnoError(10); try { Be.trackingDelegate.willDeletePath && Be.trackingDelegate.willDeletePath(e) } catch (t) { F("FS.trackingDelegate['willDeletePath']('" + e + "') threw an exception: " + t.message) } t.node_ops.unlink(t, i), Be.destroyNode(s); try { Be.trackingDelegate.onDeletePath && Be.trackingDelegate.onDeletePath(e) } catch (t) { F("FS.trackingDelegate['onDeletePath']('" + e + "') threw an exception: " + t.message) } }, readlink: function (e) { if (!(e = Be.lookupPath(e).node)) throw new Be.ErrnoError(44); if (e.node_ops.readlink) return Le.resolve(Be.getPath(e.parent), e.node_ops.readlink(e)); throw new Be.ErrnoError(28) }, stat: function (e, t) { if (!(e = Be.lookupPath(e, { follow: !t }).node)) throw new Be.ErrnoError(44); if (e.node_ops.getattr) return e.node_ops.getattr(e); throw new Be.ErrnoError(63) }, lstat: function (e) { return Be.stat(e, !0) }, chmod: function (e, t, i) { if (!(i = "string" == typeof e ? Be.lookupPath(e, { follow: !i }).node : e).node_ops.setattr) throw new Be.ErrnoError(63); i.node_ops.setattr(i, { mode: 4095 & t | -4096 & i.mode, timestamp: Date.now() }) }, lchmod: function (e, t) { Be.chmod(e, t, !0) }, fchmod: function (e, t) { if (!(e = Be.getStream(e))) throw new Be.ErrnoError(8); Be.chmod(e.node, t) }, chown: function (e, t, i, s) { if (!(s = "string" == typeof e ? Be.lookupPath(e, { follow: !s }).node : e).node_ops.setattr) throw new Be.ErrnoError(63); s.node_ops.setattr(s, { timestamp: Date.now() }) }, lchown: function (e, t, i) { Be.chown(e, t, i, !0) }, fchown: function (e, t, i) { if (!(e = Be.getStream(e))) throw new Be.ErrnoError(8); Be.chown(e.node, t, i) }, truncate: function (e, t) { if (t < 0) throw new Be.ErrnoError(28); if (!(e = "string" == typeof e ? Be.lookupPath(e, { follow: !0 }).node : e).node_ops.setattr) throw new Be.ErrnoError(63); if (Be.isDir(e.mode)) throw new Be.ErrnoError(31); if (!Be.isFile(e.mode)) throw new Be.ErrnoError(28); var i = Be.nodePermissions(e, "w"); if (i) throw new Be.ErrnoError(i); e.node_ops.setattr(e, { size: t, timestamp: Date.now() }) }, ftruncate: function (e, t) { if (!(e = Be.getStream(e))) throw new Be.ErrnoError(8); if (!(2097155 & e.flags)) throw new Be.ErrnoError(28); Be.truncate(e.node, t) }, utime: function (e, t, i) { (e = Be.lookupPath(e, { follow: !0 }).node).node_ops.setattr(e, { timestamp: Math.max(t, i) }) }, open: function (e, t, i, s, r) { if ("" === e) throw new Be.ErrnoError(44); if (i = void 0 === i ? 438 : i, i = 64 & (t = "string" == typeof t ? Be.modeStringToFlags(t) : t) ? 4095 & i | 32768 : 0, "object" == typeof e) a = e; else { e = xe.normalize(e); try { var a = Be.lookupPath(e, { follow: !(131072 & t) }).node } catch (t) { } } var o, n = !1; if (64 & t) if (a) { if (128 & t) throw new Be.ErrnoError(20) } else a = Be.mknod(e, i, 0), n = !0; if (!a) throw new Be.ErrnoError(44); if (Be.isChrdev(a.mode) && (t &= -513), 65536 & t && !Be.isDir(a.mode)) throw new Be.ErrnoError(54); if (!n && (i = Be.mayOpen(a, t))) throw new Be.ErrnoError(i); 512 & t && Be.truncate(a, 0), t &= -131713, (n = Be.createStream({ node: a, path: Be.getPath(a), flags: t, seekable: !0, position: 0, stream_ops: a.stream_ops, ungotten: [], error: !1 }, s, r)).stream_ops.open && n.stream_ops.open(n), !p.logReadFiles || 1 & t || (Be.readFiles || (Be.readFiles = {}), e in Be.readFiles) || (Be.readFiles[e] = 1, F("FS.trackingDelegate error on read file: " + e)); try { Be.trackingDelegate.onOpenFile && (o = 0, 1 != (2097155 & t) && (o |= Be.tracking.openFlags.READ), !!(2097155 & t) && (o |= Be.tracking.openFlags.WRITE), Be.trackingDelegate.onOpenFile(e, o)) } catch (t) { F("FS.trackingDelegate['onOpenFile']('" + e + "', flags) threw an exception: " + t.message) } return n }, close: function (e) { if (Be.isClosed(e)) throw new Be.ErrnoError(8); e.getdents && (e.getdents = null); try { e.stream_ops.close && e.stream_ops.close(e) } catch (e) { throw e } finally { Be.closeStream(e.fd) } e.fd = null }, isClosed: function (e) { return null === e.fd }, llseek: function (e, t, i) { if (Be.isClosed(e)) throw new Be.ErrnoError(8); if (!e.seekable || !e.stream_ops.llseek) throw new Be.ErrnoError(70); if (0 != i && 1 != i && 2 != i) throw new Be.ErrnoError(28); return e.position = e.stream_ops.llseek(e, t, i), e.ungotten = [], e.position }, read: function (e, t, i, s, r) { if (i >>>= 0, s < 0 || r < 0) throw new Be.ErrnoError(28); if (Be.isClosed(e)) throw new Be.ErrnoError(8); if (1 == (2097155 & e.flags)) throw new Be.ErrnoError(8); if (Be.isDir(e.node.mode)) throw new Be.ErrnoError(31); if (!e.stream_ops.read) throw new Be.ErrnoError(28); var a = void 0 !== r; if (a) { if (!e.seekable) throw new Be.ErrnoError(70) } else r = e.position; return t = e.stream_ops.read(e, t, i, s, r), a || (e.position += t), t }, write: function (e, t, i, s, r, a) { if (i >>>= 0, s < 0 || r < 0) throw new Be.ErrnoError(28); if (Be.isClosed(e)) throw new Be.ErrnoError(8); if (!(2097155 & e.flags)) throw new Be.ErrnoError(8); if (Be.isDir(e.node.mode)) throw new Be.ErrnoError(31); if (!e.stream_ops.write) throw new Be.ErrnoError(28); e.seekable && 1024 & e.flags && Be.llseek(e, 0, 2); var o = void 0 !== r; if (o) { if (!e.seekable) throw new Be.ErrnoError(70) } else r = e.position; t = e.stream_ops.write(e, t, i, s, r, a), o || (e.position += t); try { e.path && Be.trackingDelegate.onWriteToFile && Be.trackingDelegate.onWriteToFile(e.path) } catch (t) { F("FS.trackingDelegate['onWriteToFile']('" + e.path + "') threw an exception: " + t.message) } return t }, allocate: function (e, t, i) { if (Be.isClosed(e)) throw new Be.ErrnoError(8); if (t < 0 || i <= 0) throw new Be.ErrnoError(28); if (!(2097155 & e.flags)) throw new Be.ErrnoError(8); if (!Be.isFile(e.node.mode) && !Be.isDir(e.node.mode)) throw new Be.ErrnoError(43); if (!e.stream_ops.allocate) throw new Be.ErrnoError(138); e.stream_ops.allocate(e, t, i) }, mmap: function (e, t, i, s, r, a) { if (t >>>= 0, 2 & r && !(2 & a) && 2 != (2097155 & e.flags)) throw new Be.ErrnoError(2); if (1 == (2097155 & e.flags)) throw new Be.ErrnoError(2); if (e.stream_ops.mmap) return e.stream_ops.mmap(e, t, i, s, r, a); throw new Be.ErrnoError(43) }, msync: function (e, t, i, s, r) { return i >>>= 0, e && e.stream_ops.msync ? e.stream_ops.msync(e, t, i, s, r) : 0 }, munmap: function (e) { return 0 }, ioctl: function (e, t, i) { if (e.stream_ops.ioctl) return e.stream_ops.ioctl(e, t, i); throw new Be.ErrnoError(59) }, readFile: function (e, t) { if ((t = t || {}).flags = t.flags || 0, t.encoding = t.encoding || "binary", "utf8" !== t.encoding && "binary" !== t.encoding) throw new Error('Invalid encoding type "' + t.encoding + '"'); var i, s = Be.open(e, t.flags), r = (e = Be.stat(e).size, new Uint8Array(e)); return Be.read(s, r, 0, e, 0), "utf8" === t.encoding ? i = G(r, 0) : "binary" === t.encoding && (i = r), Be.close(s), i }, writeFile: function (e, t, i) { if ((i = i || {}).flags = i.flags || 577, e = Be.open(e, i.flags, i.mode), "string" == typeof t) { var s = new Uint8Array(H(t) + 1), r = k(t, s, 0, s.length); Be.write(e, s, 0, r, void 0, i.canOwn) } else { if (!ArrayBuffer.isView(t)) throw new Error("Unsupported data type"); Be.write(e, t, 0, t.byteLength, void 0, i.canOwn) } Be.close(e) }, cwd: function () { return Be.currentPath }, chdir: function (e) { if (null === (e = Be.lookupPath(e, { follow: !0 })).node) throw new Be.ErrnoError(44); if (!Be.isDir(e.node.mode)) throw new Be.ErrnoError(54); var t = Be.nodePermissions(e.node, "x"); if (t) throw new Be.ErrnoError(t); Be.currentPath = e.path }, createDefaultDirectories: function () { Be.mkdir("/tmp"), Be.mkdir("/home"), Be.mkdir("/home/web_user") }, createDefaultDevices: function () { Be.mkdir("/dev"), Be.registerDevice(Be.makedev(1, 3), { read: function () { return 0 }, write: function (e, t, i, s, r) { return s } }), Be.mkdev("/dev/null", Be.makedev(1, 3)), Oe.register(Be.makedev(5, 0), Oe.default_tty_ops), Oe.register(Be.makedev(6, 0), Oe.default_tty1_ops), Be.mkdev("/dev/tty", Be.makedev(5, 0)), Be.mkdev("/dev/tty1", Be.makedev(6, 0)); var e = function () { var e; if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) return e = new Uint8Array(1), function () { return crypto.getRandomValues(e), e[0] }; if (T) try { var t = require_crypto(); return function () { return t.randomBytes(1)[0] } } catch (e) { } return function () { Ee("randomDevice") } }(); Be.createDevice("/dev", "random", e), Be.createDevice("/dev", "urandom", e), Be.mkdir("/dev/shm"), Be.mkdir("/dev/shm/tmp") }, createSpecialDirectories: function () { Be.mkdir("/proc"); var e = Be.mkdir("/proc/self"); Be.mkdir("/proc/self/fd"), Be.mount({ mount: function () { var t = Be.createNode(e, "fd", 16895, 73); return t.node_ops = { lookup: function (e, t) { var i = Be.getStream(+t); if (i) return (t = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function () { return i.path } } }).parent = t; throw new Be.ErrnoError(8) } }, t } }, {}, "/proc/self/fd") }, createStandardStreams: function () { p.stdin ? Be.createDevice("/dev", "stdin", p.stdin) : Be.symlink("/dev/tty", "/dev/stdin"), p.stdout ? Be.createDevice("/dev", "stdout", null, p.stdout) : Be.symlink("/dev/tty", "/dev/stdout"), p.stderr ? Be.createDevice("/dev", "stderr", null, p.stderr) : Be.symlink("/dev/tty1", "/dev/stderr"), Be.open("/dev/stdin", 0), Be.open("/dev/stdout", 1), Be.open("/dev/stderr", 1) }, ensureErrnoError: function () { Be.ErrnoError || (Be.ErrnoError = function (e, t) { this.node = t, this.setErrno = function (e) { this.errno = e }, this.setErrno(e), this.message = "FS error" }, Be.ErrnoError.prototype = new Error, Be.ErrnoError.prototype.constructor = Be.ErrnoError, [44].forEach((function (e) { Be.genericErrors[e] = new Be.ErrnoError(e), Be.genericErrors[e].stack = "<generic error, no stack>" }))) }, staticInit: function () { Be.ensureErrnoError(), Be.nameTable = new Array(4096), Be.mount(Ne, {}, "/"), Be.createDefaultDirectories(), Be.createDefaultDevices(), Be.createSpecialDirectories(), Be.filesystems = { MEMFS: Ne } }, init: function (e, t, i) { Be.init.initialized = !0, Be.ensureErrnoError(), p.stdin = e || p.stdin, p.stdout = t || p.stdout, p.stderr = i || p.stderr, Be.createStandardStreams() }, quit: function () { Be.init.initialized = !1; var e = p._fflush; e && e(0); for (var t = 0; t < Be.streams.length; t++) { var i = Be.streams[t]; i && Be.close(i) } }, getMode: function (e, t) { var i = 0; return e && (i |= 365), t && (i |= 146), i }, findObject: function (e, t) { return (e = Be.analyzePath(e, t)).exists ? e.object : null }, analyzePath: function (e, t) { try { e = (s = Be.lookupPath(e, { follow: !t })).path } catch (e) { } var i = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null }; try { var s = Be.lookupPath(e, { parent: !0 }); i.parentExists = !0, i.parentPath = s.path, i.parentObject = s.node, i.name = xe.basename(e), s = Be.lookupPath(e, { follow: !t }), i.exists = !0, i.path = s.path, i.object = s.node, i.name = s.node.name, i.isRoot = "/" === s.path } catch (e) { i.error = e.errno } return i }, createPath: function (e, t, i, s) { e = "string" == typeof e ? e : Be.getPath(e); for (var r = t.split("/").reverse(); r.length;) { var a = r.pop(); if (a) { var o = xe.join2(e, a); try { Be.mkdir(o) } catch (e) { } e = o } } return o }, createFile: function (e, t, i, s, r) { return e = xe.join2("string" == typeof e ? e : Be.getPath(e), t), t = Be.getMode(s, r), Be.create(e, t) }, createDataFile: function (e, t, i, s, r, a) { if (t = t ? xe.join2("string" == typeof e ? e : Be.getPath(e), t) : e, e = Be.getMode(s, r), s = Be.create(t, e), i) { if ("string" == typeof i) { for (var o = new Array(i.length), n = 0, h = i.length; n < h; ++n)o[n] = i.charCodeAt(n); i = o } Be.chmod(s, 146 | e), r = Be.open(s, 577), Be.write(r, i, 0, i.length, 0, a), Be.close(r), Be.chmod(s, e) } return s }, createDevice: function (e, t, i, s) { e = xe.join2("string" == typeof e ? e : Be.getPath(e), t), t = Be.getMode(!!i, !!s); var r = (Be.createDevice.major || (Be.createDevice.major = 64), Be.makedev(Be.createDevice.major++, 0)); return Be.registerDevice(r, { open: function (e) { e.seekable = !1 }, close: function (e) { s && s.buffer && s.buffer.length && s(10) }, read: function (e, t, s, r, a) { for (var o, n = 0, h = 0; h < r; h++) { try { o = i() } catch (e) { throw new Be.ErrnoError(29) } if (void 0 === o && 0 === n) throw new Be.ErrnoError(6); if (null == o) break; n++, t[s + h] = o } return n && (e.node.timestamp = Date.now()), n }, write: function (e, t, i, r, a) { for (var o = 0; o < r; o++)try { s(t[i + o]) } catch (e) { throw new Be.ErrnoError(29) } return r && (e.node.timestamp = Date.now()), o } }), Be.mkdev(e, t, r) }, forceLoadFile: function (e) { if (e.isDevice || e.isFolder || e.link || e.contents) return !0; if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."); if (!P) throw new Error("Cannot load without read() or XMLHttpRequest."); try { e.contents = Ii(P(e.url), !0), e.usedBytes = e.contents.length } catch (e) { throw new Be.ErrnoError(29) } }, createLazyFile: function (e, t, i, s, r) { function a() { this.lengthKnown = !1, this.chunks = [] } if (a.prototype.get = function (e) { var t; if (!(e > this.length - 1 || e < 0)) return t = e % this.chunkSize, e = e / this.chunkSize | 0, this.getter(e)[t] }, a.prototype.setDataGetter = function (e) { this.getter = e }, a.prototype.cacheLength = function () { if ((r = new XMLHttpRequest).open("HEAD", i, !1), r.send(null), !(200 <= r.status && r.status < 300 || 304 === r.status)) throw new Error("Couldn't load " + i + ". Status: " + r.status); var e, t = Number(r.getResponseHeader("Content-length")), s = (e = r.getResponseHeader("Accept-Ranges")) && "bytes" === e, r = (e = r.getResponseHeader("Content-Encoding")) && "gzip" === e, a = 1048576, o = (s || (a = t), this); o.setDataGetter((function (e) { var s = e * a, r = (e + 1) * a - 1; r = Math.min(r, t - 1); if (void 0 === o.chunks[e] && (o.chunks[e] = function (e, s) { if (s < e) throw new Error("invalid range (" + e + ", " + s + ") or no bytes requested!"); if (t - 1 < s) throw new Error("only " + t + " bytes available! programmer error!"); var r = new XMLHttpRequest; if (r.open("GET", i, !1), t !== a && r.setRequestHeader("Range", "bytes=" + e + "-" + s), "undefined" != typeof Uint8Array && (r.responseType = "arraybuffer"), r.overrideMimeType && r.overrideMimeType("text/plain; charset=x-user-defined"), r.send(null), 200 <= r.status && r.status < 300 || 304 === r.status) return void 0 !== r.response ? new Uint8Array(r.response || []) : Ii(r.responseText || "", !0); throw new Error("Couldn't load " + i + ". Status: " + r.status) }(s, r)), void 0 === o.chunks[e]) throw new Error("doXHR failed!"); return o.chunks[e] })), !r && t || (a = t = 1, t = this.getter(0).length, a = t, R("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = t, this._chunkSize = a, this.lengthKnown = !0 }, "undefined" != typeof XMLHttpRequest) { if (!y) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var o = new a; o = (Object.defineProperties(o, { length: { get: function () { return this.lengthKnown || this.cacheLength(), this._length } }, chunkSize: { get: function () { return this.lengthKnown || this.cacheLength(), this._chunkSize } } }), { isDevice: !1, contents: o }) } else o = { isDevice: !1, url: i }; var n = Be.createFile(e, t, o, s, r), h = (o.contents ? n.contents = o.contents : o.url && (n.contents = null, n.url = o.url), Object.defineProperties(n, { usedBytes: { get: function () { return this.contents.length } } }), {}); return Object.keys(n.stream_ops).forEach((function (e) { var t = n.stream_ops[e]; h[e] = function () { return Be.forceLoadFile(n), t.apply(null, arguments) } })), h.read = function (e, t, i, s, r) { Be.forceLoadFile(n); var a = e.node.contents; if (r >= a.length) return 0; var o = Math.min(a.length - r, s); if (a.slice) for (var h = 0; h < o; h++)t[i + h] = a[r + h]; else for (h = 0; h < o; h++)t[i + h] = a.get(r + h); return o }, n.stream_ops = h, n }, createPreloadedFile: function (e, t, i, s, r, a, o, n, h, l) { Browser.init(); var c, u, d, m, f = t ? Le.resolve(xe.join2(e, t)) : e; function g(i) { function c(i) { l && l(), n || Be.createDataFile(e, t, i, s, r, h), a && a(), Ie() } var u = !1; p.preloadPlugins.forEach((function (e) { u || e.canHandle(f) && (e.handle(i, f, c, (function () { o && o(), Ie() })), u = !0) })), u || c(i) } Te(), "string" == typeof i ? (u = function (e) { g(e) }, d = o, m = "al " + (c = i), A(c, (function (e) { O(e, 'Loading data file "' + c + '" failed (no arrayBuffer).'), u(new Uint8Array(e)), m && Ie() }), (function (e) { if (!d) throw 'Loading data file "' + c + '" failed.'; d() })), m && Te()) : g(i) }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return "EM_FS_" + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (e, t, i) { t = t || function () { }, i = i || function () { }; var s = Be.indexedDB(); try { var r = s.open(Be.DB_NAME(), Be.DB_VERSION) } catch (s) { return i(s) } r.onupgradeneeded = function () { R("creating db"), r.result.createObjectStore(Be.DB_STORE_NAME) }, r.onsuccess = function () { var s = r.result.transaction([Be.DB_STORE_NAME], "readwrite"), a = s.objectStore(Be.DB_STORE_NAME), o = 0, n = 0, h = e.length; function l() { (0 == n ? t : i)() } e.forEach((function (e) { (e = a.put(Be.analyzePath(e).object.contents, e)).onsuccess = function () { ++o + n == h && l() }, e.onerror = function () { o + ++n == h && l() } })), s.onerror = i }, r.onerror = i }, loadFilesFromDB: function (e, t, i) { t = t || function () { }, i = i || function () { }; var s = Be.indexedDB(); try { var r = s.open(Be.DB_NAME(), Be.DB_VERSION) } catch (s) { return i(s) } r.onupgradeneeded = i, r.onsuccess = function () { var s = r.result; try { var a = s.transaction([Be.DB_STORE_NAME], "readonly") } catch (s) { return void i(s) } var o = a.objectStore(Be.DB_STORE_NAME), n = 0, h = 0, l = e.length; function c() { (0 == h ? t : i)() } e.forEach((function (e) { var t = o.get(e); t.onsuccess = function () { Be.analyzePath(e).exists && Be.unlink(e), Be.createDataFile(xe.dirname(e), xe.basename(e), t.result, !0, !0, !0), ++n + h == l && c() }, t.onerror = function () { n + ++h == l && c() } })), a.onerror = i }, r.onerror = i } }, Ge = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function (e, t, i) { if ("/" === t[0]) return t; var s; if (-100 === e) s = Be.cwd(); else { if (!(e = Be.getStream(e))) throw new Be.ErrnoError(8); s = e.path } if (0 != t.length) return xe.join2(s, t); if (i) return s; throw new Be.ErrnoError(44) }, doStat: function (e, t, i) { try { var s = e(t) } catch (e) { if (e && e.node && xe.normalize(t) !== xe.normalize(Be.getPath(e.node))) return -54; throw e } return o()[i >>> 2] = s.dev, o()[i + 4 >>> 2] = 0, o()[i + 8 >>> 2] = s.ino, o()[i + 12 >>> 2] = s.mode, o()[i + 16 >>> 2] = s.nlink, o()[i + 20 >>> 2] = s.uid, o()[i + 24 >>> 2] = s.gid, o()[i + 28 >>> 2] = s.rdev, o()[i + 32 >>> 2] = 0, _e = [s.size >>> 0, (ge = s.size, 1 <= +Math.abs(ge) ? 0 < ge ? (0 | Math.min(+Math.floor(ge / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ge - (~~ge >>> 0)) / 4294967296) >>> 0 : 0)], o()[i + 40 >>> 2] = _e[0], o()[i + 44 >>> 2] = _e[1], o()[i + 48 >>> 2] = 4096, o()[i + 52 >>> 2] = s.blocks, o()[i + 56 >>> 2] = s.atime.getTime() / 1e3 | 0, o()[i + 60 >>> 2] = 0, o()[i + 64 >>> 2] = s.mtime.getTime() / 1e3 | 0, o()[i + 68 >>> 2] = 0, o()[i + 72 >>> 2] = s.ctime.getTime() / 1e3 | 0, o()[i + 76 >>> 2] = 0, _e = [s.ino >>> 0, (ge = s.ino, 1 <= +Math.abs(ge) ? 0 < ge ? (0 | Math.min(+Math.floor(ge / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ge - (~~ge >>> 0)) / 4294967296) >>> 0 : 0)], o()[i + 80 >>> 2] = _e[0], o()[i + 84 >>> 2] = _e[1], 0 }, doMsync: function (e, t, s, r, a) { e = i().slice(e, e + s), Be.msync(t, e, a, s, r) }, doMkdir: function (e, t) { return "/" === (e = xe.normalize(e))[e.length - 1] && (e = e.substr(0, e.length - 1)), Be.mkdir(e, t, 0), 0 }, doMknod: function (e, t, i) { switch (61440 & t) { case 32768: case 8192: case 24576: case 4096: case 49152: break; default: return -28 }return Be.mknod(e, t, i), 0 }, doReadlink: function (e, i, s) { var r, a; return s <= 0 ? -28 : (e = Be.readlink(e), r = Math.min(s, H(e)), a = t()[i + r >>> 0], V(e, i, s + 1), t()[i + r >>> 0] = a, r) }, doAccess: function (e, t) { var i; return -8 & t ? -28 : (e = Be.lookupPath(e, { follow: !0 }).node) ? (i = "", 4 & t && (i += "r"), 2 & t && (i += "w"), 1 & t && (i += "x"), i && Be.nodePermissions(e, i) ? -2 : 0) : -44 }, doDup: function (e, t, i) { var s = Be.getStream(i); return s && Be.close(s), Be.open(e, t, 0, i, i).fd }, doReadv: function (e, i, s, r) { for (var a = 0, n = 0; n < s; n++) { var h = o()[i + 8 * n >>> 2], l = o()[i + (8 * n + 4) >>> 2]; if ((h = Be.read(e, t(), h, l, r)) < 0) return -1; if (a += h, h < l) break } return a }, doWritev: function (e, i, s, r) { for (var a = 0, n = 0; n < s; n++) { var h = o()[i + 8 * n >>> 2], l = o()[i + (8 * n + 4) >>> 2]; if ((h = Be.write(e, t(), h, l, r)) < 0) return -1; a += h } return a }, varargs: void 0, get: function () { return Ge.varargs += 4, o()[Ge.varargs - 4 >>> 2] }, getStr: function (e) { return U(e) }, getStreamFromFD: function (e) { if (e = Be.getStream(e)) return e; throw new Be.ErrnoError(8) }, get64: function (e, t) { return e } }; function Ue(e, t, i) { if (I) return $t(2, 1, e, t, i); Ge.varargs = i; try { var s = Ge.getStreamFromFD(e); switch (t) { case 0: return (a = Ge.get()) < 0 ? -28 : Be.open(s.path, s.flags, 0, a).fd; case 1: case 2: case 13: case 14: return 0; case 3: return s.flags; case 4: var a = Ge.get(); return s.flags |= a, 0; case 12: return a = Ge.get(), r()[a + 0 >>> 1] = 2, 0; case 16: case 8: default: return -28; case 9: return Me(28), -1 } } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), -e.errno } } function ke(e, t, i) { if (I) return $t(3, 1, e, t, i); Ge.varargs = i; try { var s = Ge.getStreamFromFD(e); switch (t) { case 21509: case 21505: case 21510: case 21511: case 21512: case 21506: case 21507: case 21508: case 21523: case 21524: return s.tty ? 0 : -59; case 21519: return s.tty ? (r = Ge.get(), o()[r >>> 2] = 0) : -59; case 21520: return s.tty ? -28 : -59; case 21531: var r = Ge.get(); return Be.ioctl(s, t, r); default: Ee("bad ioctl syscall " + t) } } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), -e.errno } } function Ve(e, t, i) { if (I) return $t(4, 1, e, t, i); Ge.varargs = i; try { var s = Ge.getStr(e), r = i ? Ge.get() : 0; return Be.open(s, t, r).fd } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), -e.errno } } var He = {}; function je(e) { for (; e.length;) { var t = e.pop(); e.pop()(t) } } function ze(e) { return this.fromWireType(n()[e >>> 2]) } var We = {}, Ye = {}, $e = {}, Xe = 48, Ke = 57; function Je(e) { var t; return void 0 === e ? "_unknown" : (t = (e = e.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0), Xe <= t && t <= Ke ? "_" + e : e) } function Qe(e, t) { return e = Je(e), new Function("body", "return function " + e + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(t) } function Ze(e, t) { var i = Qe(t, (function (e) { this.name = t, this.message = e, void 0 !== (e = new Error(e).stack) && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, "")) })); return i.prototype = Object.create(e.prototype), (i.prototype.constructor = i).prototype.toString = function () { return void 0 === this.message ? this.name : this.name + ": " + this.message }, i } var qe = void 0; function et(e) { throw new qe(e) } function tt(e, t, i) { function s(t) { var s = i(t); s.length !== e.length && et("Mismatched type converter count"); for (var r = 0; r < e.length; ++r)ht(e[r], s[r]) } e.forEach((function (e) { $e[e] = t })); var r = new Array(t.length), a = [], o = 0; t.forEach((function (e, t) { Ye.hasOwnProperty(e) ? r[t] = Ye[e] : (a.push(e), We.hasOwnProperty(e) || (We[e] = []), We[e].push((function () { r[t] = Ye[e], ++o === a.length && s(r) }))) })), 0 === a.length && s(r) } var it = {}; function st(e) { switch (e) { case 1: return 0; case 2: return 1; case 4: return 2; case 8: return 3; default: throw new TypeError("Unknown type size: " + e) } } var rt = void 0; function at(e) { for (var t = "", s = e; i()[s >>> 0];)t += rt[i()[s++ >>> 0]]; return t } var ot = void 0; function nt(e) { throw new ot(e) } function ht(e, t, i) { if (i = i || {}, !("argPackAdvance" in t)) throw new TypeError("registerType registeredInstance requires argPackAdvance"); var s = t.name; if (e || nt('type "' + s + '" must have a positive integer typeid pointer'), Ye.hasOwnProperty(e)) { if (i.ignoreDuplicateRegistrations) return; nt("Cannot register type '" + s + "' twice") } Ye[e] = t, delete $e[e], We.hasOwnProperty(e) && (i = We[e], delete We[e], i.forEach((function (e) { e() }))) } function lt(e) { nt(e.$$.ptrType.registeredClass.name + " instance already deleted") } var ct = !1; function ut(e) { } function pt(e) { --e.count.value, 0 === e.count.value && (e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr)) } function dt(e) { return "undefined" == typeof FinalizationGroup ? (dt = function (e) { return e }, e) : (ct = new FinalizationGroup((function (e) { for (var t = e.next(); !t.done; t = e.next()) { var i = t.value; i.ptr ? pt(i) : console.warn("object already deleted: " + i.ptr) } })), ut = function (e) { ct.unregister(e.$$) }, (dt = function (e) { return ct.register(e, e.$$, e.$$), e })(e)) } var mt = void 0, ft = []; function gt() { for (; ft.length;) { var e = ft.pop(); e.$$.deleteScheduled = !1, e.delete() } } function _t() { } var vt = {}; function yt(e, t, i) { var s; void 0 === e[t].overloadTable && (s = e[t], e[t] = function () { return e[t].overloadTable.hasOwnProperty(arguments.length) || nt("Function '" + i + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + e[t].overloadTable + ")!"), e[t].overloadTable[arguments.length].apply(this, arguments) }, e[t].overloadTable = [], e[t].overloadTable[s.argCount] = s) } function Tt(e, t, i) { p.hasOwnProperty(e) ? ((void 0 === i || void 0 !== p[e].overloadTable && void 0 !== p[e].overloadTable[i]) && nt("Cannot register public name '" + e + "' twice"), yt(p, e, e), p.hasOwnProperty(i) && nt("Cannot register multiple overloads of a function with the same number of arguments (" + i + ")!"), p[e].overloadTable[i] = t) : (p[e] = t, void 0 !== i && (p[e].numArguments = i)) } function It(e, t, i, s, r, a, o, n) { this.name = e, this.constructor = t, this.instancePrototype = i, this.rawDestructor = s, this.baseClass = r, this.getActualType = a, this.upcast = o, this.downcast = n, this.pureVirtualFunctions = [] } function Et(e, t, i) { for (; t !== i;)t.upcast || nt("Expected null or instance of " + i.name + ", got an instance of " + t.name), e = t.upcast(e), t = t.baseClass; return e } function Ct(e, t) { if (null === t) return this.isReference && nt("null is not a valid " + this.name), 0; t.$$ || nt('Cannot pass "' + Vt(t) + '" as a ' + this.name), t.$$.ptr || nt("Cannot pass deleted object as a pointer of type " + this.name); var i = t.$$.ptrType.registeredClass; return Et(t.$$.ptr, i, this.registeredClass) } function Pt(e, t) { if (null === t) return this.isReference && nt("null is not a valid " + this.name), this.isSmartPointer ? (r = this.rawConstructor(), null !== e && e.push(this.rawDestructor, r), r) : 0; t.$$ || nt('Cannot pass "' + Vt(t) + '" as a ' + this.name), t.$$.ptr || nt("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && t.$$.ptrType.isConst && nt("Cannot convert argument of type " + (t.$$.smartPtrType || t.$$.ptrType).name + " to parameter type " + this.name); var i, s = t.$$.ptrType.registeredClass, r = Et(t.$$.ptr, s, this.registeredClass); if (this.isSmartPointer) switch (void 0 === t.$$.smartPtr && nt("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) { case 0: t.$$.smartPtrType === this ? r = t.$$.smartPtr : nt("Cannot convert argument of type " + (t.$$.smartPtrType || t.$$.ptrType).name + " to parameter type " + this.name); break; case 1: r = t.$$.smartPtr; break; case 2: t.$$.smartPtrType === this ? r = t.$$.smartPtr : (i = t.clone(), r = this.rawShare(r, Ut((function () { i.delete() }))), null !== e && e.push(this.rawDestructor, r)); break; default: nt("Unsupporting sharing policy") }return r } function bt(e, t) { if (null === t) return this.isReference && nt("null is not a valid " + this.name), 0; t.$$ || nt('Cannot pass "' + Vt(t) + '" as a ' + this.name), t.$$.ptr || nt("Cannot pass deleted object as a pointer of type " + this.name), t.$$.ptrType.isConst && nt("Cannot convert argument of type " + t.$$.ptrType.name + " to parameter type " + this.name); var i = t.$$.ptrType.registeredClass; return Et(t.$$.ptr, i, this.registeredClass) } var At = {}; function Dt(e, t) { return t.ptrType && t.ptr || et("makeClassHandle requires ptr and ptrType"), !!t.smartPtrType != !!t.smartPtr && et("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, dt(Object.create(e, { $$: { value: t } })) } function Rt(e, t, i, s, r, a, o, n, h, l, c) { this.name = e, this.registeredClass = t, this.isReference = i, this.isConst = s, this.isSmartPointer = r, this.pointeeType = a, this.sharingPolicy = o, this.rawGetPointee = n, this.rawConstructor = h, this.rawShare = l, this.rawDestructor = c, r || void 0 !== t.baseClass ? this.toWireType = Pt : (this.toWireType = s ? Ct : bt, this.destructorFunction = null) } function Ft(e, t, i) { p.hasOwnProperty(e) || et("Replacing nonexistant public symbol"), void 0 !== p[e].overloadTable && void 0 !== i ? p[e].overloadTable[i] = t : (p[e] = t, p[e].argCount = i) } function wt(e, t) { var i, s, r, a = (e = at(e)).includes("j") ? (i = e, s = t, r = [], function () { r.length = arguments.length; for (var e, t, a, o, n = 0; n < arguments.length; n++)r[n] = arguments[n]; return t = s, a = r, (e = i).includes("j") ? (o = t, e = p["dynCall_" + e], a && a.length ? e.apply(null, [o].concat(a)) : e.call(null, o)) : oe.get(t).apply(null, a) }) : oe.get(t); return "function" != typeof a && nt("unknown function pointer with signature " + e + ": " + t), a } var Mt = void 0; function St(e) { var t = at(e = Ai(e)); return bi(e), t } function xt(e, t) { var i = [], s = {}; throw t.forEach((function e(t) { s[t] || Ye[t] || ($e[t] ? $e[t].forEach(e) : (i.push(t), s[t] = !0)) })), new Mt(e + ": " + i.map(St).join([", "])) } function Lt(e, t) { for (var i = [], s = 0; s < e; s++)i.push(o()[(t >> 2) + s >>> 0]); return i } function Ot(e, t, i, s, r) { for (var a = t.length, o = (i = (a < 2 && nt("argTypes array size mismatch! Must at least get return value and 'this' types!"), null !== t[1] && null !== i), !1), n = 1; n < t.length; ++n)if (null !== t[n] && void 0 === t[n].destructorFunction) { o = !0; break } var h = "void" !== t[0].name, l = "", c = ""; for (n = 0; n < a - 2; ++n)l += (0 !== n ? ", " : "") + "arg" + n, c += (0 !== n ? ", " : "") + "arg" + n + "Wired"; var u = "return function " + Je(e) + "(" + l + ") {\nif (arguments.length !== " + (a - 2) + ") {\nthrowBindingError('function " + e + " called with ' + arguments.length + ' arguments, expected " + (a - 2) + " args!');\n}\n", p = (o && (u += "var destructors = [];\n"), o ? "destructors" : "null"), d = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"], m = [nt, s, r, je, t[0], t[1]]; for (i && (u += "var thisWired = classParam.toWireType(" + p + ", this);\n"), n = 0; n < a - 2; ++n)u += "var arg" + n + "Wired = argType" + n + ".toWireType(" + p + ", arg" + n + "); // " + t[n + 2].name + "\n", d.push("argType" + n), m.push(t[n + 2]); if (u += (h ? "var rv = " : "") + "invoker(fn" + (0 < (c = i ? "thisWired" + (0 < c.length ? ", " : "") + c : c).length ? ", " : "") + c + ");\n", o) u += "runDestructors(destructors);\n"; else for (n = i ? 1 : 2; n < t.length; ++n) { var f = 1 === n ? "thisWired" : "arg" + (n - 2) + "Wired"; null !== t[n].destructorFunction && (u += f + "_dtor(" + f + "); // " + t[n].name + "\n", d.push(f + "_dtor"), m.push(t[n].destructorFunction)) } return h && (u += "var ret = retType.fromWireType(rv);\nreturn ret;\n"), d.push(u += "}\n"), function (e, t) { var i; if (e instanceof Function) return (i = Qe(e.name || "unknownFunctionName", (function () { }))).prototype = e.prototype, i = new i, (t = e.apply(i, t)) instanceof Object ? t : i; throw new TypeError("new_ called with constructor type " + typeof e + " which is not a function") }(Function, d).apply(null, m) } var Nt = [], Bt = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }]; function Gt(e) { 4 < e && 0 == --Bt[e].refcount && (Bt[e] = void 0, Nt.push(e)) } function Ut(e) { switch (e) { case void 0: return 1; case null: return 2; case !0: return 3; case !1: return 4; default: var t = Nt.length ? Nt.pop() : Bt.length; return Bt[t] = { refcount: 1, value: e }, t } } function kt(e, t) { var i = Ye[e]; return void 0 === i && nt(t + " has unknown type " + St(e)), i } function Vt(e) { var t; return null === e ? "null" : "object" == (t = typeof e) || "array" == t || "function" == t ? e.toString() : "" + e } function Ht(e) { return e || nt("Cannot use deleted val. handle = " + e), Bt[e].value } var jt = {}; function zt(e) { var t = jt[e]; return void 0 === t ? at(e) : t } function Wt() { return "object" == typeof globalThis ? globalThis : Function("return this")() } var Yt = []; function $t(e, t) { for (var i = arguments.length - 2, s = Gi(), r = i, a = ki(8 * r), o = a >> 3, n = 0; n < i; n++) { var l = arguments[2 + n]; h()[o + n >>> 0] = l } return r = Mi(e, r, a, t), Ui(s), r } var Xt = [], Kt = { inEventHandler: 0, removeAllEventListeners: function () { for (var e = Kt.eventHandlers.length - 1; 0 <= e; --e)Kt._removeHandler(e); Kt.eventHandlers = [], Kt.deferredCalls = [] }, registerRemoveEventListeners: function () { Kt.removeEventListenersRegistered || (Kt.removeEventListenersRegistered = !0) }, deferredCalls: [], deferCall: function (e, t, i) { for (var s in Kt.deferredCalls) if ((s = Kt.deferredCalls[s]).targetFunction == e && function (e, t) { if (e.length == t.length) { for (var i in e) if (e[i] != t[i]) return; return 1 } }(s.argsList, i)) return; Kt.deferredCalls.push({ targetFunction: e, precedence: t, argsList: i }), Kt.deferredCalls.sort((function (e, t) { return e.precedence < t.precedence })) }, removeDeferredCalls: function (e) { for (var t = 0; t < Kt.deferredCalls.length; ++t)Kt.deferredCalls[t].targetFunction == e && (Kt.deferredCalls.splice(t, 1), --t) }, canPerformEventHandlerRequests: function () { return Kt.inEventHandler && Kt.currentEventHandler.allowsDeferredCalls }, runDeferredCalls: function () { if (Kt.canPerformEventHandlerRequests()) for (var e = 0; e < Kt.deferredCalls.length; ++e) { var t = Kt.deferredCalls[e]; Kt.deferredCalls.splice(e, 1), --e, t.targetFunction.apply(null, t.argsList) } }, eventHandlers: [], removeAllHandlersOnTarget: function (e, t) { for (var i = 0; i < Kt.eventHandlers.length; ++i)Kt.eventHandlers[i].target != e || t && t != Kt.eventHandlers[i].eventTypeString || Kt._removeHandler(i--) }, _removeHandler: function (e) { var t = Kt.eventHandlers[e]; t.target.removeEventListener(t.eventTypeString, t.eventListenerFunc, t.useCapture), Kt.eventHandlers.splice(e, 1) }, registerOrRemoveHandler: function (e) { function t(t) { ++Kt.inEventHandler, Kt.currentEventHandler = e, Kt.runDeferredCalls(), e.handlerFunc(t), Kt.runDeferredCalls(), --Kt.inEventHandler } if (e.callbackfunc) e.eventListenerFunc = t, e.target.addEventListener(e.eventTypeString, t, e.useCapture), Kt.eventHandlers.push(e), Kt.registerRemoveEventListeners(); else for (var i = 0; i < Kt.eventHandlers.length; ++i)Kt.eventHandlers[i].target == e.target && Kt.eventHandlers[i].eventTypeString == e.eventTypeString && Kt._removeHandler(i--) }, queueEventHandlerOnThread_iiii: function (e, t, i, s, r) { var a = Gi(), n = ki(12); o()[n >>> 2] = i, o()[n + 4 >>> 2] = s, o()[n + 8 >>> 2] = r, Si(0, e, 637534208, t, s, n), Ui(a) }, getTargetThreadForEventCallback: function (e) { switch (e) { case 1: return 0; case 2: return Fe.currentProxiedOperationCallerThread; default: return e } }, getNodeNameForTarget: function (e) { return e ? e == window ? "#window" : e == screen ? "#screen" : e && e.nodeName ? e.nodeName : "" : "" }, fullscreenEnabled: function () { return document.fullscreenEnabled || document.webkitFullscreenEnabled } }, Jt = [0, "undefined" != typeof document ? document : 0, "undefined" != typeof window ? window : 0]; function Qt(e) { return e = 2 < (t = e) ? U(t) : t, Jt[e] || ("undefined" != typeof document ? document.querySelector(e) : void 0); var t } function Zt(e, t, i) { var s, r, a, n, h, l, c, u, p, d = Qt(e); return d ? (d.canvasSharedPtr && (o()[d.canvasSharedPtr >>> 2] = t, o()[d.canvasSharedPtr + 4 >>> 2] = i), !d.offscreenCanvas && d.controlTransferredOffscreen ? d.canvasSharedPtr ? (n = t, h = i, r = s = o()[d.canvasSharedPtr + 8 >>> 2], a = s = (s = e) ? U(s) : "", c = Gi(), u = ki(12), p = 0, a && (l = H(a) + 1, V(a, a = Pi(l), l), p = a), o()[u >>> 2] = p, o()[u + 4 >>> 2] = n, o()[u + 8 >>> 2] = h, Si(0, r, 657457152, 0, p, u), Ui(c), 1) : -4 : (e = !1, (d = d.offscreenCanvas || d).GLctxObject && d.GLctxObject.GLctx && (e = 0 === (s = d.GLctxObject.GLctx.getParameter(2978))[0] && 0 === s[1] && s[2] === d.width && s[3] === d.height), d.width = t, d.height = i, e && d.GLctxObject.GLctx.viewport(0, 0, t, i), 0)) : -4 } function qt(e, t, i) { return I ? $t(5, 1, e, t, i) : Zt(e, t, i) } var ei = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function (e) { ei.lastError || (ei.lastError = e) }, getNewId: function (e) { for (var t = ei.counter++, i = e.length; i < t; i++)e[i] = null; return t }, getSource: function (e, t, i, s) { for (var r = "", a = 0; a < t; ++a) { var n = s ? o()[s + 4 * a >>> 2] : -1; r += U(o()[i + 4 * a >>> 2], n < 0 ? void 0 : n) } return r }, createContext: function (e, t) { e.getContextSafariWebGL2Fixed || (e.getContextSafariWebGL2Fixed = e.getContext, e.getContext = function (t, i) { return "webgl" == t == (i = e.getContextSafariWebGL2Fixed(t, i)) instanceof WebGLRenderingContext ? i : null }); var i = e.getContext("webgl", t); return i ? ei.registerContext(i, t) : 0 }, registerContext: function (e, t) { var i = Pi(8), s = (o()[i + 4 >>> 2] = Ni(), { handle: i, attributes: t, version: t.majorVersion, GLctx: e }); return e.canvas && (e.canvas.GLctxObject = s), ei.contexts[i] = s, void 0 !== t.enableExtensionsByDefault && !t.enableExtensionsByDefault || ei.initExtensions(s), i }, makeContextCurrent: function (e) { return ei.currentContext = ei.contexts[e], p.ctx = di = ei.currentContext && ei.currentContext.GLctx, !(e && !di) }, getContext: function (e) { return ei.contexts[e] }, deleteContext: function (e) { ei.currentContext === ei.contexts[e] && (ei.currentContext = null), "object" == typeof Kt && Kt.removeAllHandlersOnTarget(ei.contexts[e].GLctx.canvas), ei.contexts[e] && ei.contexts[e].GLctx.canvas && (ei.contexts[e].GLctx.canvas.GLctxObject = void 0), bi(ei.contexts[e].handle), ei.contexts[e] = null }, initExtensions: function (e) { var t, i, s, r; (e = e || ei.currentContext).initExtensionsDone || (e.initExtensionsDone = !0, t = e.GLctx, (i = (e = t).getExtension("ANGLE_instanced_arrays")) && (e.vertexAttribDivisor = function (e, t) { i.vertexAttribDivisorANGLE(e, t) }, e.drawArraysInstanced = function (e, t, s, r) { i.drawArraysInstancedANGLE(e, t, s, r) }, e.drawElementsInstanced = function (e, t, s, r, a) { i.drawElementsInstancedANGLE(e, t, s, r, a) }), (s = (e = t).getExtension("OES_vertex_array_object")) && (e.createVertexArray = function () { return s.createVertexArrayOES() }, e.deleteVertexArray = function (e) { s.deleteVertexArrayOES(e) }, e.bindVertexArray = function (e) { s.bindVertexArrayOES(e) }, e.isVertexArray = function (e) { return s.isVertexArrayOES(e) }), (r = (e = t).getExtension("WEBGL_draw_buffers")) && (e.drawBuffers = function (e, t) { r.drawBuffersWEBGL(e, t) }), t.disjointTimerQueryExt = t.getExtension("EXT_disjoint_timer_query"), t.multiDrawWebgl = t.getExtension("WEBGL_multi_draw"), (t.getSupportedExtensions() || []).forEach((function (e) { e.includes("lose_context") || e.includes("debug") || t.getExtension(e) }))) } }, ti = ["default", "low-power", "high-performance"], ii = {}; function si() { if (!si.strings) { var e = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: g || "./this.program" }; for (t in ii) void 0 === ii[t] ? delete e[t] : e[t] = ii[t]; var t, i = []; for (t in e) i.push(t + "=" + e[t]); si.strings = i } return si.strings } function ri(e, i) { if (I) return $t(6, 1, e, i); try { var s = 0; return si().forEach((function (r, a) { for (var n = i + s, h = r, l = o()[e + 4 * a >>> 2] = n, c = (a = void 0, 0); c < h.length; ++c)t()[l++ >>> 0] = h.charCodeAt(c); a || (t()[l >>> 0] = 0), s += r.length + 1 })), 0 } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function ai(e, t) { if (I) return $t(7, 1, e, t); try { var i = si(), s = (o()[e >>> 2] = i.length, 0); return i.forEach((function (e) { s += e.length + 1 })), o()[t >>> 2] = s, 0 } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function oi(e) { if (I) return $t(8, 1, e); try { var t = Ge.getStreamFromFD(e); return Be.close(t), 0 } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function ni(e, t, i, s) { if (I) return $t(9, 1, e, t, i, s); try { var r = Ge.getStreamFromFD(e), a = Ge.doReadv(r, t, i); return o()[s >>> 2] = a, 0 } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function hi(e, t, i, s, r) { if (I) return $t(10, 1, e, t, i, s, r); try { var a = Ge.getStreamFromFD(e), n = 4294967296 * i + (t >>> 0), h = 9007199254740992; return n <= -h || h <= n ? -61 : (Be.llseek(a, n, s), _e = [a.position >>> 0, (ge = a.position, 1 <= +Math.abs(ge) ? 0 < ge ? (0 | Math.min(+Math.floor(ge / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ge - (~~ge >>> 0)) / 4294967296) >>> 0 : 0)], o()[r >>> 2] = _e[0], o()[r + 4 >>> 2] = _e[1], a.getdents && 0 == n && 0 === s && (a.getdents = null), 0) } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function li(e, t, i, s) { if (I) return $t(11, 1, e, t, i, s); try { var r = Ge.getStreamFromFD(e), a = Ge.doWritev(r, t, i); return o()[s >>> 2] = a, 0 } catch (e) { return void 0 !== Be && e instanceof Be.ErrnoError || Ee(e), e.errno } } function ci(e) { if (I) throw "Internal Error! spawnThread() can only ever be called from main application thread!"; var t = Fe.getNewWorker(); if (!t) return 6; if (void 0 !== t.pthread) throw "Internal error!"; if (!e.pthread_ptr) throw "Internal error, no pthread ptr!"; Fe.runningWorkers.push(t); for (var i = Pi(512), s = 0; s < 128; ++s)o()[i + 4 * s >>> 2] = 0; var r = e.stackBase + e.stackSize, a = Fe.pthreads[e.pthread_ptr] = { worker: t, stackBase: e.stackBase, stackSize: e.stackSize, allocatedOwnStack: e.allocatedOwnStack, threadInfoStruct: e.pthread_ptr }, h = a.threadInfoStruct >> 2, l = (r = (Atomics.store(n(), 16 + h, e.detached), Atomics.store(n(), 25 + h, i), Atomics.store(n(), 10 + h, a.threadInfoStruct), Atomics.store(n(), 20 + h, e.stackSize), Atomics.store(n(), 19 + h, r), Atomics.store(n(), 26 + h, e.stackSize), Atomics.store(n(), 28 + h, r), Atomics.store(n(), 29 + h, e.detached), Li() + 40), Atomics.store(n(), 43 + h, r), t.pthread = a, { cmd: "run", start_routine: e.startRoutine, arg: e.arg, threadInfoStruct: e.pthread_ptr, stackBase: e.stackBase, stackSize: e.stackSize }); return t.runPthread = function () { l.time = performance.now(), t.postMessage(l, e.transferList) }, t.loaded && (t.runPthread(), delete t.runPthread), 0 } function ui(e) { return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0) } function pi(e, t) { for (var i = 0, s = 0; s <= t; i += e[s++]); return i } var di, mi = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], fi = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function gi(e, t) { for (var i = new Date(e.getTime()); 0 < t;) { var s = ui(i.getFullYear()), r = i.getMonth(); if (!(t > (s = (s ? mi : fi)[r]) - i.getDate())) return i.setDate(i.getDate() + t), i; t -= s - i.getDate() + 1, i.setDate(1), r < 11 ? i.setMonth(r + 1) : (i.setMonth(0), i.setFullYear(i.getFullYear() + 1)) } return i } function _i(e, t, i, s) { this.parent = e = e || this, this.mount = e.mount, this.mounted = null, this.id = Be.nextInode++, this.name = t, this.mode = i, this.node_ops = {}, this.stream_ops = {}, this.rdev = s } I || Fe.initMainThreadBlock(), Object.defineProperties(_i.prototype, { read: { get: function () { return !(365 & ~this.mode) }, set: function (e) { e ? this.mode |= 365 : this.mode &= -366 } }, write: { get: function () { return !(146 & ~this.mode) }, set: function (e) { e ? this.mode |= 146 : this.mode &= -147 } }, isFolder: { get: function () { return Be.isDir(this.mode) } }, isDevice: { get: function () { return Be.isChrdev(this.mode) } } }), Be.FSNode = _i, Be.staticInit(), p.FS_createPath = Be.createPath, p.FS_createDataFile = Be.createDataFile, p.FS_createPreloadedFile = Be.createPreloadedFile, p.FS_createLazyFile = Be.createLazyFile, p.FS_createDevice = Be.createDevice, p.FS_unlink = Be.unlink; qe = p.InternalError = Ze(Error, "InternalError"); for (var vi = new Array(256), yi = 0; yi < 256; ++yi)vi[yi] = String.fromCharCode(yi); rt = vi, ot = p.BindingError = Ze(Error, "BindingError"), _t.prototype.isAliasOf = function (e) { if (!(this instanceof _t)) return !1; if (!(e instanceof _t)) return !1; for (var t = this.$$.ptrType.registeredClass, i = this.$$.ptr, s = e.$$.ptrType.registeredClass, r = e.$$.ptr; t.baseClass;)i = t.upcast(i), t = t.baseClass; for (; s.baseClass;)r = s.upcast(r), s = s.baseClass; return t === s && i === r }, _t.prototype.clone = function () { var e; return this.$$.ptr || lt(this), this.$$.preservePointerOnDelete ? (this.$$.count.value += 1, this) : ((e = dt(Object.create(Object.getPrototypeOf(this), { $$: { value: { count: (e = this.$$).count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType } } }))).$$.count.value += 1, e.$$.deleteScheduled = !1, e) }, _t.prototype.delete = function () { this.$$.ptr || lt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && nt("Object already scheduled for deletion"), ut(this), pt(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0) }, _t.prototype.isDeleted = function () { return !this.$$.ptr }, _t.prototype.deleteLater = function () { return this.$$.ptr || lt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && nt("Object already scheduled for deletion"), ft.push(this), 1 === ft.length && mt && mt(gt), this.$$.deleteScheduled = !0, this }, Rt.prototype.getPointee = function (e) { return this.rawGetPointee ? this.rawGetPointee(e) : e }, Rt.prototype.destructor = function (e) { this.rawDestructor && this.rawDestructor(e) }, Rt.prototype.argPackAdvance = 8, Rt.prototype.readValueFromPointer = ze, Rt.prototype.deleteObject = function (e) { null !== e && e.delete() }, Rt.prototype.fromWireType = function (e) { var t, i, s = this.getPointee(e); return s ? void 0 !== (i = function (e, t) { for (void 0 === t && nt("ptr should not be undefined"); e.baseClass;)t = e.upcast(t), e = e.baseClass; return t }(i = this.registeredClass, i = s), i = At[i]) ? 0 === i.$$.count.value ? (i.$$.ptr = s, i.$$.smartPtr = e, i.clone()) : (i = i.clone(), this.destructor(e), i) : (i = this.registeredClass.getActualType(s), (i = vt[i]) && (i = this.isConst ? i.constPointerType : i.pointerType, null !== (t = function e(t, i, s) { return i === s ? t : void 0 === s.baseClass || null === (t = e(t, i, s.baseClass)) ? null : s.downcast(t) }(s, this.registeredClass, i.registeredClass))) ? this.isSmartPointer ? Dt(i.registeredClass.instancePrototype, { ptrType: i, ptr: t, smartPtrType: this, smartPtr: e }) : Dt(i.registeredClass.instancePrototype, { ptrType: i, ptr: t }) : function () { return this.isSmartPointer ? Dt(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: s, smartPtrType: this, smartPtr: e }) : Dt(this.registeredClass.instancePrototype, { ptrType: this, ptr: e }) }.call(this)) : (this.destructor(e), null) }, p.getInheritedInstanceCount = function () { return Object.keys(At).length }, p.getLiveInheritedInstances = function () { var e, t = []; for (e in At) At.hasOwnProperty(e) && t.push(At[e]); return t }, p.flushPendingDeletes = gt, p.setDelayFunction = function (e) { mt = e, ft.length && mt && mt(gt) }, Mt = p.UnboundTypeError = Ze(Error, "UnboundTypeError"), p.count_emval_handles = function () { for (var e = 0, t = 5; t < Bt.length; ++t)void 0 !== Bt[t] && ++e; return e }, p.get_first_emval = function () { for (var e = 5; e < Bt.length; ++e)if (void 0 !== Bt[e]) return Bt[e]; return null }; var Ti = [null, function (e, t) { if (I) return $t(1, 1, e, t) }, Ue, ke, Ve, qt, ri, ai, oi, ni, hi, li]; function Ii(e, t, i) { return i = 0 < i ? i : H(e) + 1, e = k(e, i = new Array(i), 0, i.length), t && (i.length = e), i } var Ei, Ci = { l: function (e, t, i, s) { Ee("Assertion failed: " + U(e) + ", at: " + [t ? U(t) : "unknown filename", i, s ? U(s) : "unknown function"]) }, B: function (e) { return Pi(e + 16) + 16 }, ka: function (e, t) { Fe.threadExitHandlers.push((function () { oe.get(e)(t) })) }, A: function (e, t, i) { throw new Se(e).init(t, i), e }, D: Ue, V: ke, W: Ve, ma: function (e) { var t = He[e], i = (delete He[e], t.elements), s = i.length, r = i.map((function (e) { return e.getterReturnType })).concat(i.map((function (e) { return e.setterArgumentType }))), a = t.rawConstructor, o = t.rawDestructor; tt([e], r, (function (e) { return i.forEach((function (t, i) { var r = e[i], a = t.getter, o = t.getterContext, n = e[i + s], h = t.setter, l = t.setterContext; t.read = function (e) { return r.fromWireType(a(o, e)) }, t.write = function (e, t) { var i = []; h(l, e, n.toWireType(i, t)), je(i) } })), [{ name: t.name, fromWireType: function (e) { for (var t = new Array(s), r = 0; r < s; ++r)t[r] = i[r].read(e); return o(e), t }, toWireType: function (e, r) { if (s !== r.length) throw new TypeError("Incorrect number of tuple elements for " + t.name + ": expected=" + s + ", actual=" + r.length); for (var n = a(), h = 0; h < s; ++h)i[h].write(n, r[h]); return null !== e && e.push(o, n), n }, argPackAdvance: 8, readValueFromPointer: ze, destructorFunction: o }] })) }, s: function (e) { var t = it[e], i = (delete it[e], t.rawConstructor), s = t.rawDestructor, r = t.fields; tt([e], r.map((function (e) { return e.getterReturnType })).concat(r.map((function (e) { return e.setterArgumentType }))), (function (e) { var a = {}; return r.forEach((function (t, i) { var s = t.fieldName, o = e[i], n = t.getter, h = t.getterContext, l = e[i + r.length], c = t.setter, u = t.setterContext; a[s] = { read: function (e) { return o.fromWireType(n(h, e)) }, write: function (e, t) { var i = []; c(u, e, l.toWireType(i, t)), je(i) } } })), [{ name: t.name, fromWireType: function (e) { var t, i = {}; for (t in a) i[t] = a[t].read(e); return s(e), i }, toWireType: function (e, t) { for (var r in a) if (!(r in t)) throw new TypeError('Missing field:  "' + r + '"'); var o = i(); for (r in a) a[r].write(o, t[r]); return null !== e && e.push(s, o), o }, argPackAdvance: 8, readValueFromPointer: ze, destructorFunction: s }] })) }, O: function (e, t, i, s, r) { }, ia: function (e, i, s, a, n) { var h = st(s); ht(e, { name: i = at(i), fromWireType: function (e) { return !!e }, toWireType: function (e, t) { return t ? a : n }, argPackAdvance: 8, readValueFromPointer: function (e) { var a; if (1 === s) a = t(); else if (2 === s) a = r(); else { if (4 !== s) throw new TypeError("Unknown boolean type size: " + i); a = o() } return this.fromWireType(a[e >>> h]) }, destructorFunction: null }) }, v: function (e, t, i, s, r, a, o, n, h, l, c, u, p) { c = at(c), a = wt(r, a), n = n && wt(o, n), l = l && wt(h, l), p = wt(u, p); var d = Je(c); Tt(d, (function () { xt("Cannot construct " + c + " due to unbound types", [s]) })), tt([e, t, i], s ? [s] : [], (function (t) { t = t[0], t = s ? (h = t.registeredClass).instancePrototype : _t.prototype; var i = Qe(d, (function () { if (Object.getPrototypeOf(this) !== r) throw new ot("Use 'new' to construct " + c); if (void 0 === o.constructor_body) throw new ot(c + " has no accessible constructor"); var e = o.constructor_body[arguments.length]; if (void 0 === e) throw new ot("Tried to invoke ctor of " + c + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(o.constructor_body).toString() + ") parameters instead!"); return e.apply(this, arguments) })), r = Object.create(t, { constructor: { value: i } }), o = (i.prototype = r, new It(c, i, r, p, h, a, n, l)), h = (t = new Rt(c, o, !0, !1, !1), new Rt(c + "*", o, !1, !1, !1)), u = new Rt(c + " const*", o, !1, !0, !1); return vt[e] = { pointerType: h, constPointerType: u }, Ft(d, i), [t, h, u] })) }, u: function (e, t, i, s, r, a) { O(0 < t); var o = Lt(t, i), n = (r = wt(s, r), [a]), h = []; tt([], [e], (function (e) { var i = "constructor " + (e = e[0]).name; if (void 0 === e.registeredClass.constructor_body && (e.registeredClass.constructor_body = []), void 0 !== e.registeredClass.constructor_body[t - 1]) throw new ot("Cannot register multiple constructors with identical number of parameters (" + (t - 1) + ") for class '" + e.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!"); return e.registeredClass.constructor_body[t - 1] = function () { xt("Cannot construct " + e.name + " due to unbound types", o) }, tt([], o, (function (s) { return e.registeredClass.constructor_body[t - 1] = function () { arguments.length !== t - 1 && nt(i + " called with " + arguments.length + " arguments, expected " + (t - 1)), h.length = 0, n.length = t; for (var e = 1; e < t; ++e)n[e] = s[e].toWireType(h, arguments[e - 1]); var a = r.apply(null, n); return je(h), s[0].fromWireType(a) }, [] })), [] })) }, c: function (e, t, i, s, r, a, o, n) { var h = Lt(i, s); t = at(t), a = wt(r, a), tt([], [e], (function (e) { var s = (e = e[0]).name + "." + t; function r() { xt("Cannot call " + s + " due to unbound types", h) } t.startsWith("@@") && (t = Symbol[t.substring(2)]), n && e.registeredClass.pureVirtualFunctions.push(t); var l = e.registeredClass.instancePrototype, c = l[t]; return void 0 === c || void 0 === c.overloadTable && c.className !== e.name && c.argCount === i - 2 ? (r.argCount = i - 2, r.className = e.name, l[t] = r) : (yt(l, t, s), l[t].overloadTable[i - 2] = r), tt([], h, (function (r) { return r = Ot(s, r, e, a, o), void 0 === l[t].overloadTable ? (r.argCount = i - 2, l[t] = r) : l[t].overloadTable[i - 2] = r, [] })), [] })) }, ha: function (e, t) { ht(e, { name: t = at(t), fromWireType: function (e) { var t = Bt[e].value; return Gt(e), t }, toWireType: function (e, t) { return Ut(t) }, argPackAdvance: 8, readValueFromPointer: ze, destructorFunction: null }) }, la: function (e, s, h, l) { function c() { } h = st(h), s = at(s), c.values = {}, ht(e, { name: s, constructor: c, fromWireType: function (e) { return this.constructor.values[e] }, toWireType: function (e, t) { return t.value }, argPackAdvance: 8, readValueFromPointer: function (e, s) { switch (h) { case 0: return function (e) { var r = (s ? t : i)(); return this.fromWireType(r[e >>> 0]) }; case 1: return function (e) { var t = (s ? r : a)(); return this.fromWireType(t[e >>> 1]) }; case 2: return function (e) { var t = (s ? o : n)(); return this.fromWireType(t[e >>> 2]) }; default: throw new TypeError("Unknown integer type: " + e) } }(s, l), destructorFunction: null }), Tt(s, c) }, y: function (e, t, i) { e = kt(e, "enum"); var s = (t = at(t), e.constructor); e = Object.create(e.constructor.prototype, { value: { value: i }, constructor: { value: Qe(e.name + "_" + t, (function () { })) } }); s.values[i] = e, s[t] = e }, J: function (e, t, i) { i = st(i), ht(e, { name: t = at(t), fromWireType: function (e) { return e }, toWireType: function (e, t) { if ("number" != typeof t && "boolean" != typeof t) throw new TypeError('Cannot convert "' + Vt(t) + '" to ' + this.name); return t }, argPackAdvance: 8, readValueFromPointer: function (e) { switch (i) { case 2: return function (e) { return this.fromWireType((M.buffer != j && ae(M.buffer), J)[e >>> 2]) }; case 3: return function (e) { return this.fromWireType(h()[e >>> 3]) }; default: throw new TypeError("Unknown float type: " + e) } }(t), destructorFunction: null }) }, f: function (e, t, i, s, r, a) { var o = Lt(t, i); e = at(e), r = wt(s, r), Tt(e, (function () { xt("Cannot call " + e + " due to unbound types", o) }), t - 1), tt([], o, (function (i) { return i = [i[0], null].concat(i.slice(1)), Ft(e, Ot(e, i, null, r, a), t - 1), [] })) }, p: function (e, s, h, l, c) { s = at(s), -1 === c && (c = 4294967295); var u, p = st(h), d = function (e) { return e }, m = (0 === l && (u = 32 - 8 * h, d = function (e) { return e << u >>> u }), s.includes("unsigned")); ht(e, { name: s, fromWireType: d, toWireType: function (e, t) { if ("number" != typeof t && "boolean" != typeof t) throw new TypeError('Cannot convert "' + Vt(t) + '" to ' + this.name); if (t < l || c < t) throw new TypeError('Passing a number "' + Vt(t) + '" from JS side to C/C++ side to an argument of type "' + s + '", which is outside the valid range [' + l + ", " + c + "]!"); return m ? t >>> 0 : 0 | t }, argPackAdvance: 8, readValueFromPointer: function (e, s) { switch (p) { case 0: return s ? function (e) { return t()[e >>> 0] } : function (e) { return i()[e >>> 0] }; case 1: return s ? function (e) { return r()[e >>> 1] } : function (e) { return a()[e >>> 1] }; case 2: return s ? function (e) { return o()[e >>> 2] } : function (e) { return n()[e >>> 2] }; default: throw new TypeError("Unknown integer type: " + e) } }(s, 0 !== l), destructorFunction: null }) }, k: function (e, t, i) { var s = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][t]; function r(e) { e >>= 2; var t = (i = n())[e >>> 0], i = i[e + 1 >>> 0]; return new s(j, i, t) } ht(e, { name: i = at(i), fromWireType: r, argPackAdvance: 8, readValueFromPointer: r }, { ignoreDuplicateRegistrations: !0 }) }, K: function (e, t) { var s = "std::string" === (t = at(t)); ht(e, { name: t, fromWireType: function (e) { var t = n()[e >>> 2]; if (s) for (var r = e + 4, a = 0; a <= t; ++a) { var o, h, l = e + 4 + a; a != t && 0 != i()[l >>> 0] || (o = U(r, l - r), h = void 0 === h ? o : h + String.fromCharCode(0) + o, r = l + 1) } else { var c = new Array(t); for (a = 0; a < t; ++a)c[a] = String.fromCharCode(i()[e + 4 + a >>> 0]); h = c.join("") } return bi(e), h }, toWireType: function (e, t) { var r = "string" == typeof (t = t instanceof ArrayBuffer ? new Uint8Array(t) : t), a = (r || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int8Array || nt("Cannot pass non-string to std::string"), (s && r ? function () { return H(t) } : function () { return t.length })()), o = Pi(4 + a + 1); if (o >>>= 0, n()[o >>> 2] = a, s && r) V(t, 4 + o, a + 1); else if (r) for (var h = 0; h < a; ++h) { var l = t.charCodeAt(h); 255 < l && (bi(o), nt("String has UTF-16 code units that do not fit in 8 bits")), i()[4 + o + h >>> 0] = l } else for (h = 0; h < a; ++h)i()[4 + o + h >>> 0] = t[h]; return null !== e && e.push(bi, o), o }, argPackAdvance: 8, readValueFromPointer: ze, destructorFunction: function (e) { bi(e) } }) }, z: function (e, t, i) { var s, r, o, h, l; i = at(i), 2 === t ? (s = q, r = ee, h = te, o = a, l = 1) : 4 === t && (s = ie, r = se, h = re, o = n, l = 2), ht(e, { name: i, fromWireType: function (e) { for (var i = n()[e >>> 2], r = o(), a = e + 4, h = 0; h <= i; ++h) { var c, u, p = e + 4 + h * t; h != i && 0 != r[p >>> l] || (c = s(a, p - a), u = void 0 === u ? c : u + String.fromCharCode(0) + c, a = p + t) } return bi(e), u }, toWireType: function (e, s) { "string" != typeof s && nt("Cannot pass non-string to C++ string type " + i); var a = h(s), o = Pi(4 + a + t); return o >>>= 0, n()[o >>> 2] = a >> l, r(s, 4 + o, a + t), null !== e && e.push(bi, o), o }, argPackAdvance: 8, readValueFromPointer: ze, destructorFunction: function (e) { bi(e) } }) }, na: function (e, t, i, s, r, a) { He[e] = { name: at(t), rawConstructor: wt(i, s), rawDestructor: wt(r, a), elements: [] } }, h: function (e, t, i, s, r, a, o, n, h) { He[e].elements.push({ getterReturnType: t, getter: wt(i, s), getterContext: r, setterArgumentType: a, setter: wt(o, n), setterContext: h }) }, t: function (e, t, i, s, r, a) { it[e] = { name: at(t), rawConstructor: wt(i, s), rawDestructor: wt(r, a), fields: [] } }, e: function (e, t, i, s, r, a, o, n, h, l) { it[e].fields.push({ fieldName: at(t), getterReturnType: i, getter: wt(s, r), getterContext: a, setterArgumentType: o, setter: wt(n, h), setterContext: l }) }, ja: function (e, t) { ht(e, { isVoid: !0, name: t = at(t), argPackAdvance: 0, fromWireType: function () { }, toWireType: function (e, t) { } }) }, ea: function (e, t) { if (e == t) postMessage({ cmd: "processQueuedMainThreadWork" }); else if (I) postMessage({ targetThread: e, cmd: "processThreadQueue" }); else { if (!(e = (t = Fe.pthreads[e]) && t.worker)) return; e.postMessage({ cmd: "processThreadQueue" }) } return 1 }, n: function (e, t, i) { e = Ht(e), t = kt(t, "emval::as"); var s = [], r = Ut(s); return o()[i >>> 2] = r, t.toWireType(s, e) }, L: function (e, t, i, s) { e = Ht(e); for (var r = function (e, t) { for (var i = new Array(e), s = 0; s < e; ++s)i[s] = kt(o()[(t >> 2) + s >>> 0], "parameter " + s); return i }(t, i), a = new Array(t), n = 0; n < t; ++n) { var h = r[n]; a[n] = h.readValueFromPointer(s), s += h.argPackAdvance } return Ut(e.apply(void 0, a)) }, b: Gt, U: function (e) { return 0 === e ? Ut(Wt()) : (e = zt(e), Ut(Wt()[e])) }, o: function (e, t) { return Ut((e = Ht(e))[t = Ht(t)]) }, j: function (e) { 4 < e && (Bt[e].refcount += 1) }, ca: function (e, t) { return (e = Ht(e)) instanceof Ht(t) }, M: function (e) { return "number" == typeof Ht(e) }, C: function () { return Ut([]) }, g: function (e) { return Ut(zt(e)) }, w: function () { return Ut({}) }, m: function (e) { je(Bt[e].value), Gt(e) }, i: function (e, t, i) { e = Ht(e), t = Ht(t), i = Ht(i), e[t] = i }, d: function (e, t) { return Ut((e = kt(e, "_emval_take_value")).readValueFromPointer(t)) }, I: function () { Ee() }, T: function (e, t) { var i; if (0 === e) i = Date.now(); else { if (1 !== e && 4 !== e) return Me(28), -1; i = we() } return o()[t >>> 2] = i / 1e3 | 0, o()[t + 4 >>> 2] = i % 1e3 * 1e3 * 1e3 | 0, 0 }, G: function (e, t, s) { return t = function (e, t) { for (Yt.length = 0, t >>= 2; s = i()[e++ >>> 0];) { var s = s < 105; s && 1 & t && t++, Yt.push(s ? h()[t++ >>> 1] : o()[t >>> 0]), ++t } return Yt }(t, s), Ae[e].apply(null, t) }, _: function () { T || y || w("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread") }, F: function (e, t) { }, r: function (e, i, s) { if (e <= 0 || e > t().length || !0 & e) return -28; if (v) { if (Atomics.load(o(), e >> 2) != i) return -6; var r = performance.now() + s; for (Atomics.exchange(o(), zi >> 2, e); ;) { if (r < performance.now()) return Atomics.exchange(o(), zi >> 2, 0), -73; if (0 == Atomics.exchange(o(), zi >> 2, 0)) break; if (wi(), Atomics.load(o(), e >> 2) != i) return -6; Atomics.exchange(o(), zi >> 2, e) } return 0 } if ("timed-out" === (s = Atomics.wait(o(), e >> 2, i, s))) return -73; if ("not-equal" === s) return -6; if ("ok" === s) return 0; throw "Atomics.wait returned an unexpected value " + s }, q: Re, x: we, R: function (e, t, s) { i().copyWithin(e >>> 0, t >>> 0, t + s >>> 0) }, $: function (e, t, i) { Xt.length = t; for (var s = i >> 3, r = 0; r < t; r++)Xt[r] = h()[s + r >>> 0]; return (e < 0 ? Ae[-e - 1] : Ti[e]).apply(null, Xt) }, S: function (e) { var t = i().length; if (!((e >>>= 0) <= t || 4294901760 < e)) for (var s = 1; s <= 4; s *= 2) { var r = t * (1 + .2 / s); r = Math.min(r, e + 100663296); if (function (e) { try { return M.grow(e - j.byteLength + 65535 >>> 16), ae(M.buffer), 1 } catch (e) { } }(Math.min(4294901760, (0 < (r = Math.max(e, r)) % 65536 && (r += 65536 - r % 65536), r)))) return !0 } return !1 }, aa: function (e, t, i) { return (Qt(e) ? Zt : qt)(e, t, i) }, E: function (e) { }, ba: function (e, t) { return t >>= 2, i = o()[6 + t >>> 0], i = { alpha: !!o()[t >>> 0], depth: !!o()[1 + t >>> 0], stencil: !!o()[2 + t >>> 0], antialias: !!o()[3 + t >>> 0], premultipliedAlpha: !!o()[4 + t >>> 0], preserveDrawingBuffer: !!o()[5 + t >>> 0], powerPreference: ti[i], failIfMajorPerformanceCaveat: !!o()[7 + t >>> 0], majorVersion: o()[8 + t >>> 0], minorVersion: o()[9 + t >>> 0], enableExtensionsByDefault: o()[10 + t >>> 0], explicitSwapControl: o()[11 + t >>> 0], proxyContextToMainThread: o()[12 + t >>> 0], renderViaOffscreenBackBuffer: o()[13 + t >>> 0] }, !(t = Qt(e)) || i.explicitSwapControl ? 0 : ei.createContext(t, i); var i }, Y: ri, Z: ai, H: oi, ga: ni, N: hi, fa: li, Q: function () { Fe.initRuntime() }, a: M || p.wasmMemory, da: function (e, t, i, s) { if ("undefined" == typeof SharedArrayBuffer) return F("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6; if (!e) return F("pthread_create called with a null thread pointer!"), 28; var r = []; if (I && 0 === r.length) return Fi(687865856, e, t, i, s); var a = 0, h = 0, l = 0; t && -1 != t ? (a = o()[t >>> 2], a += 81920, h = o()[t + 8 >>> 2], l = 0 !== o()[t + 12 >>> 2]) : a = 2097152, (t = 0 == h) ? h = Hi(16, a) : O(0 < (h -= a)); for (var c = Pi(228), u = 0; u < 57; ++u)n()[(c >> 2) + u >>> 0] = 0; return o()[e >>> 2] = c, e = (o()[c + 12 >>> 2] = c) + 152, o()[e >>> 2] = e, e = { stackBase: h, stackSize: a, allocatedOwnStack: t, detached: l, startRoutine: i, pthread_ptr: c, arg: s, transferList: r }, I ? (e.cmd = "spawnThread", postMessage(e, r), 0) : ci(e) }, P: function (e) { }, X: function (e, i, s, r) { var a = o()[r + 40 >>> 2], n = { tm_sec: o()[r >>> 2], tm_min: o()[r + 4 >>> 2], tm_hour: o()[r + 8 >>> 2], tm_mday: o()[r + 12 >>> 2], tm_mon: o()[r + 16 >>> 2], tm_year: o()[r + 20 >>> 2], tm_wday: o()[r + 24 >>> 2], tm_yday: o()[r + 28 >>> 2], tm_isdst: o()[r + 32 >>> 2], tm_gmtoff: o()[r + 36 >>> 2], tm_zone: a ? U(a) : "" }, h = U(s), l = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }; for (_ in l) h = h.replace(new RegExp(_, "g"), l[_]); var c = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], u = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function p(e, t, i) { for (var s = "number" == typeof e ? e.toString() : e || ""; s.length < t;)s = i[0] + s; return s } function d(e, t) { return p(e, t, "0") } function m(e, t) { function i(e) { return e < 0 ? -1 : 0 < e ? 1 : 0 } var s; return 0 === (s = i(e.getFullYear() - t.getFullYear())) && 0 === (s = i(e.getMonth() - t.getMonth())) ? i(e.getDate() - t.getDate()) : s } function f(e) { switch (e.getDay()) { case 0: return new Date(e.getFullYear() - 1, 11, 29); case 1: return e; case 2: return new Date(e.getFullYear(), 0, 3); case 3: return new Date(e.getFullYear(), 0, 2); case 4: return new Date(e.getFullYear(), 0, 1); case 5: return new Date(e.getFullYear() - 1, 11, 31); case 6: return new Date(e.getFullYear() - 1, 11, 30) } } function g(e) { e = gi(new Date(e.tm_year + 1900, 0, 1), e.tm_yday); var t = new Date(e.getFullYear(), 0, 4), i = new Date(e.getFullYear() + 1, 0, 4); t = f(t), i = f(i); return m(t, e) <= 0 ? m(i, e) <= 0 ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1 } var _, v = { "%a": function (e) { return c[e.tm_wday].substring(0, 3) }, "%A": function (e) { return c[e.tm_wday] }, "%b": function (e) { return u[e.tm_mon].substring(0, 3) }, "%B": function (e) { return u[e.tm_mon] }, "%C": function (e) { return d((e.tm_year + 1900) / 100 | 0, 2) }, "%d": function (e) { return d(e.tm_mday, 2) }, "%e": function (e) { return p(e.tm_mday, 2, " ") }, "%g": function (e) { return g(e).toString().substring(2) }, "%G": g, "%H": function (e) { return d(e.tm_hour, 2) }, "%I": function (e) { return 0 == (e = e.tm_hour) ? e = 12 : 12 < e && (e -= 12), d(e, 2) }, "%j": function (e) { return d(e.tm_mday + pi(ui(e.tm_year + 1900) ? mi : fi, e.tm_mon - 1), 3) }, "%m": function (e) { return d(e.tm_mon + 1, 2) }, "%M": function (e) { return d(e.tm_min, 2) }, "%n": function () { return "\n" }, "%p": function (e) { return 0 <= e.tm_hour && e.tm_hour < 12 ? "AM" : "PM" }, "%S": function (e) { return d(e.tm_sec, 2) }, "%t": function () { return "\t" }, "%u": function (e) { return e.tm_wday || 7 }, "%U": function (e) { var t, i = new Date(e.tm_year + 1900, 0, 1), s = 0 === i.getDay() ? i : gi(i, 7 - i.getDay()); return m(s, e = new Date(e.tm_year + 1900, e.tm_mon, e.tm_mday)) < 0 ? (t = pi(ui(e.getFullYear()) ? mi : fi, e.getMonth() - 1) - 31, t = 31 - s.getDate() + t + e.getDate(), d(Math.ceil(t / 7), 2)) : 0 === m(s, i) ? "01" : "00" }, "%V": function (e) { var t = new Date(e.tm_year + 1900, 0, 4), i = new Date(e.tm_year + 1901, 0, 4), s = (t = f(t), i = f(i), gi(new Date(e.tm_year + 1900, 0, 1), e.tm_yday)); return m(s, t) < 0 ? "53" : m(i, s) <= 0 ? "01" : (i = t.getFullYear() < e.tm_year + 1900 ? e.tm_yday + 32 - t.getDate() : e.tm_yday + 1 - t.getDate(), d(Math.ceil(i / 7), 2)) }, "%w": function (e) { return e.tm_wday }, "%W": function (e) { var t, i = new Date(e.tm_year, 0, 1), s = 1 === i.getDay() ? i : gi(i, 0 === i.getDay() ? 1 : 7 - i.getDay() + 1); return m(s, e = new Date(e.tm_year + 1900, e.tm_mon, e.tm_mday)) < 0 ? (t = pi(ui(e.getFullYear()) ? mi : fi, e.getMonth() - 1) - 31, t = 31 - s.getDate() + t + e.getDate(), d(Math.ceil(t / 7), 2)) : 0 === m(s, i) ? "01" : "00" }, "%y": function (e) { return (e.tm_year + 1900).toString().substring(2) }, "%Y": function (e) { return e.tm_year + 1900 }, "%z": function (e) { var t = 0 <= (e = e.tm_gmtoff); e = Math.abs(e) / 60; return (t ? "+" : "-") + String("0000" + (e / 60 * 100 + e % 60)).slice(-4) }, "%Z": function (e) { return e.tm_zone }, "%%": function () { return "%" } }; for (_ in v) h.includes(_) && (h = h.replace(new RegExp(_, "g"), v[_](n))); return (r = Ii(h, !1)).length > i ? 0 : (a = r, s = e, t().set(a, s >>> 0), r.length - 1) } }, Pi = (function () { var e = { a: Ci }; function t(e, t) { var i; e = e.exports; p.asm = e, oe = p.asm.ta, e = p.asm.oa, le.unshift(e), Fe.tlsInitFunctions.push(p.asm.sa), S = t, I || (i = Fe.unusedWorkers.length, Fe.unusedWorkers.forEach((function (e) { Fe.loadWasmModuleToWorker(e, (function () { --i || Ie() })) }))) } function i(e) { t(e.instance, e.module) } function s(t) { return function () { if (!D && (v || y)) { if ("function" == typeof fetch && !Pe(fe)) return fetch(fe, { credentials: "same-origin" }).then((function (e) { if (e.ok) return e.arrayBuffer(); throw "failed to load wasm binary file at '" + fe + "'" })).catch((function () { return be(fe) })); if (A) return new Promise((function (e, t) { A(fe, (function (t) { e(new Uint8Array(t)) }), t) })) } return Promise.resolve().then((function () { return be(fe) })) }().then((function (t) { return WebAssembly.instantiate(t, e) })).then(t, (function (e) { F("failed to asynchronously prepare wasm: " + e), Ee(e) })) } if (I || Te(), p.instantiateWasm) try { return p.instantiateWasm(e, t) } catch (e) { return F("Module.instantiateWasm callback failed with error: " + e) } (D || "function" != typeof WebAssembly.instantiateStreaming || Ce(fe) || Pe(fe) || "function" != typeof fetch ? s(i) : fetch(fe, { credentials: "same-origin" }).then((function (t) { return WebAssembly.instantiateStreaming(t, e).then(i, (function (e) { return F("wasm streaming compile failed: " + e), F("falling back to ArrayBuffer instantiation"), s(i) })) }))).catch(c) }(), p.___wasm_call_ctors = function () { return (p.___wasm_call_ctors = p.asm.oa).apply(null, arguments) }, p._main = function () { return (p._main = p.asm.pa).apply(null, arguments) }, p._malloc = function () { return (Pi = p._malloc = p.asm.qa).apply(null, arguments) }), bi = p._free = function () { return (bi = p._free = p.asm.ra).apply(null, arguments) }, Ai = (p._emscripten_tls_init = function () { return (p._emscripten_tls_init = p.asm.sa).apply(null, arguments) }, p.___getTypeName = function () { return (Ai = p.___getTypeName = p.asm.ua).apply(null, arguments) }), Di = (p.___embind_register_native_and_builtin_types = function () { return (p.___embind_register_native_and_builtin_types = p.asm.va).apply(null, arguments) }, p._emscripten_current_thread_process_queued_calls = function () { return (p._emscripten_current_thread_process_queued_calls = p.asm.wa).apply(null, arguments) }, p._emscripten_register_main_browser_thread_id = function () { return (Di = p._emscripten_register_main_browser_thread_id = p.asm.xa).apply(null, arguments) }), Ri = p.__emscripten_do_dispatch_to_thread = function () { return (Ri = p.__emscripten_do_dispatch_to_thread = p.asm.ya).apply(null, arguments) }, Fi = p._emscripten_sync_run_in_main_thread_4 = function () { return (Fi = p._emscripten_sync_run_in_main_thread_4 = p.asm.za).apply(null, arguments) }, wi = p._emscripten_main_thread_process_queued_calls = function () { return (wi = p._emscripten_main_thread_process_queued_calls = p.asm.Aa).apply(null, arguments) }, Mi = p._emscripten_run_in_main_runtime_thread_js = function () { return (Mi = p._emscripten_run_in_main_runtime_thread_js = p.asm.Ba).apply(null, arguments) }, Si = p.__emscripten_call_on_thread = function () { return (Si = p.__emscripten_call_on_thread = p.asm.Ca).apply(null, arguments) }, xi = p.__emscripten_thread_init = function () { return (xi = p.__emscripten_thread_init = p.asm.Da).apply(null, arguments) }, Li = p._emscripten_get_global_libc = function () { return (Li = p._emscripten_get_global_libc = p.asm.Ea).apply(null, arguments) }, Oi = p.___errno_location = function () { return (Oi = p.___errno_location = p.asm.Fa).apply(null, arguments) }, Ni = p._pthread_self = function () { return (Ni = p._pthread_self = p.asm.Ga).apply(null, arguments) }, Bi = p.___pthread_tsd_run_dtors = function () { return (Bi = p.___pthread_tsd_run_dtors = p.asm.Ha).apply(null, arguments) }, Gi = p.stackSave = function () { return (Gi = p.stackSave = p.asm.Ia).apply(null, arguments) }, Ui = p.stackRestore = function () { return (Ui = p.stackRestore = p.asm.Ja).apply(null, arguments) }, ki = p.stackAlloc = function () { return (ki = p.stackAlloc = p.asm.Ka).apply(null, arguments) }, Vi = p._emscripten_stack_set_limits = function () { return (Vi = p._emscripten_stack_set_limits = p.asm.La).apply(null, arguments) }, Hi = p._memalign = function () { return (Hi = p._memalign = p.asm.Ma).apply(null, arguments) }, ji = (p.dynCall_jiji = function () { return (p.dynCall_jiji = p.asm.Na).apply(null, arguments) }, p.dynCall_viijii = function () { return (p.dynCall_viijii = p.asm.Oa).apply(null, arguments) }, p.dynCall_iiiiij = function () { return (p.dynCall_iiiiij = p.asm.Pa).apply(null, arguments) }, p.dynCall_iiiiijj = function () { return (p.dynCall_iiiiijj = p.asm.Qa).apply(null, arguments) }, p.dynCall_iiiiiijj = function () { return (p.dynCall_iiiiiijj = p.asm.Ra).apply(null, arguments) }, p.__emscripten_allow_main_runtime_queued_calls = 44840), zi = p.__emscripten_main_thread_futex = 48292; function Wi(e) { this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e } function Yi(e) { function t() { if (!Ei && (Ei = !0, p.calledRun = !0, !L)) { if (me(), I || De(ce), l(p), p.onRuntimeInitialized && p.onRuntimeInitialized(), Xi) { var e = p._main; try { $i(e(0, 0), !0) } catch (t) { t instanceof Wi || "unwind" == t || ((e = t) && "object" == typeof t && t.stack && (e = [t, t.stack]), F("exception thrown: " + e), _(1, t)) } } if (!I) { if (p.postRun) for ("function" == typeof p.postRun && (p.postRun = [p.postRun]); p.postRun.length;)t = p.postRun.shift(), ue.unshift(t); var t; De(ue) } } } if (!(0 < ve)) if (I) l(p), me(), postMessage({ cmd: "loaded" }); else { if (!I) { if (p.preRun) for ("function" == typeof p.preRun && (p.preRun = [p.preRun]); p.preRun.length;)i = p.preRun.shift(), he.unshift(i); var i; De(he) } 0 < ve || (p.setStatus ? (p.setStatus("Running..."), setTimeout((function () { setTimeout((function () { p.setStatus("") }), 1), t() }), 1)) : t()) } } function $i(e, t) { if (!t && I) throw postMessage({ cmd: "exitProcess", returnCode: e }), new Wi(e); de() || (Fe.terminateAllThreads(), p.onExit && p.onExit(e), L = !0), _(e, new Wi(e)) } if (p.addRunDependency = Te, p.removeRunDependency = Ie, p.FS_createPath = Be.createPath, p.FS_createDataFile = Be.createDataFile, p.FS_createPreloadedFile = Be.createPreloadedFile, p.FS_createLazyFile = Be.createLazyFile, p.FS_createDevice = Be.createDevice, p.FS_unlink = Be.unlink, p.keepRuntimeAlive = de, p.FS = Be, p.PThread = Fe, p.PThread = Fe, p.wasmMemory = M, p.ExitStatus = Wi, ye = function e() { Ei || Yi(), Ei || (ye = e) }, p.run = Yi, p.preInit) for ("function" == typeof p.preInit && (p.preInit = [p.preInit]); 0 < p.preInit.length;)p.preInit.pop()(); var Xi = !0; return p.noInitialRun && (Xi = !1), I && (x = !1, Fe.initWorker()), Yi(), e.ready } var s = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0; "undefined" != typeof __filename && (s = s || __filename), "object" == typeof e && "object" == typeof t ? t.exports = i : "function" == typeof define && define.amd ? define([], (function () { return i })) : "object" == typeof e && (e.WebIFCWasm = i) } }), require_web_ifc = __commonJS({ "dist/web-ifc.js"(e, t) { function i(e) { var t, i, r, a = e = e || {}, o = (a.ready = new Promise((function (e, s) { t = e, i = s })), {}); for (r in a) a.hasOwnProperty(r) && (o[r] = a[r]); var n, h, l, c, u, p = "./this.program", d = function (e, t) { throw t }, m = "object" == typeof window, f = "function" == typeof importScripts, g = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, _ = ""; g ? (_ = f ? __require("path").dirname(_) + "/" : __dirname + "/", n = function (e, t) { return c = c || __require("fs"), e = (u = u || __require("path")).normalize(e), c.readFileSync(e, t ? null : "utf8") }, l = function (e) { return P((e = (e = n(e, !0)).buffer ? e : new Uint8Array(e)).buffer), e }, h = function (e, t, i) { c = c || __require("fs"), e = (u = u || __require("path")).normalize(e), c.readFile(e, (function (e, s) { e ? i(e) : t(s.buffer) })) }, 1 < process.argv.length && (p = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", (function (e) { if (!(e instanceof zt)) throw e })), process.on("unhandledRejection", le), d = function (e, t) { if (ee()) throw process.exitCode = e, t; process.exit(e) }, a.inspect = function () { return "[Emscripten Module object]" }) : (m || f) && (f ? _ = self.location.href : "undefined" != typeof document && document.currentScript && (_ = document.currentScript.src), _ = 0 !== (_ = s || _).indexOf("blob:") ? _.substr(0, _.lastIndexOf("/") + 1) : "", n = function (e) { var t = new XMLHttpRequest; return t.open("GET", e, !1), t.send(null), t.responseText }, f && (l = function (e) { var t = new XMLHttpRequest; return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response) }), h = function (e, t, i) { var s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onload = function () { 200 == s.status || 0 == s.status && s.response ? t(s.response) : i() }, s.onerror = i, s.send(null) }); var v, y = a.print || console.log.bind(console), T = a.printErr || console.warn.bind(console); for (r in o) o.hasOwnProperty(r) && (a[r] = o[r]); o = null, a.arguments, a.thisProgram && (p = a.thisProgram), a.quit && (d = a.quit), a.wasmBinary && (v = a.wasmBinary); var I, E = a.noExitRuntime || !0, C = ("object" != typeof WebAssembly && le("no native wasm support detected"), !1); function P(e, t) { e || le("Assertion failed: " + t) } var b = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0; function A(e, t, i) { for (var s = (t >>>= 0) + i, r = t; e[r >>> 0] && !(s <= r);)++r; if (16 < r - t && e.subarray && b) return b.decode(e.subarray(t >>> 0, r >>> 0)); for (var a = ""; t < r;) { var o, n, h = e[t++ >>> 0]; 128 & h ? (n = 63 & e[t++ >>> 0], 192 == (224 & h) ? a += String.fromCharCode((31 & h) << 6 | n) : (o = 63 & e[t++ >>> 0], (h = 224 == (240 & h) ? (15 & h) << 12 | n << 6 | o : (7 & h) << 18 | n << 12 | o << 6 | 63 & e[t++ >>> 0]) < 65536 ? a += String.fromCharCode(h) : (n = h - 65536, a += String.fromCharCode(55296 | n >> 10, 56320 | 1023 & n)))) : a += String.fromCharCode(h) } return a } function D(e, t) { return (e >>>= 0) ? A(x, e, t) : "" } function R(e, t, i, s) { if (!(0 < s)) return 0; for (var r = i >>>= 0, a = i + s - 1, o = 0; o < e.length; ++o) { var n = e.charCodeAt(o); if ((n = 55296 <= n && n <= 57343 ? 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++o) : n) <= 127) { if (a <= i) break; t[i++ >>> 0] = n } else { if (n <= 2047) { if (a <= i + 1) break; t[i++ >>> 0] = 192 | n >> 6 } else { if (n <= 65535) { if (a <= i + 2) break; t[i++ >>> 0] = 224 | n >> 12 } else { if (a <= i + 3) break; t[i++ >>> 0] = 240 | n >> 18, t[i++ >>> 0] = 128 | n >> 12 & 63 } t[i++ >>> 0] = 128 | n >> 6 & 63 } t[i++ >>> 0] = 128 | 63 & n } } return t[i >>> 0] = 0, i - r } function F(e, t, i) { R(e, x, t, i) } function w(e) { for (var t = 0, i = 0; i < e.length; ++i) { var s = e.charCodeAt(i); (s = 55296 <= s && s <= 57343 ? 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++i) : s) <= 127 ? ++t : t += s <= 2047 ? 2 : s <= 65535 ? 3 : 4 } return t } var M, S, x, L, O, N, B, G, U, k, V = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0; function H(e, t) { for (var i, s = e >> 1, r = s + t / 2; !(r <= s) && O[s >>> 0];)++s; if (32 < (i = s << 1) - e && V) return V.decode(x.subarray(e >>> 0, i >>> 0)); for (var a = "", o = 0; !(t / 2 <= o); ++o) { var n = L[e + 2 * o >>> 1]; if (0 == n) break; a += String.fromCharCode(n) } return a } function j(e, t, i) { if ((i = void 0 === i ? 2147483647 : i) < 2) return 0; for (var s = t, r = (i -= 2) < 2 * e.length ? i / 2 : e.length, a = 0; a < r; ++a) { var o = e.charCodeAt(a); L[t >>> 1] = o, t += 2 } return L[t >>> 1] = 0, t - s } function z(e) { return 2 * e.length } function W(e, t) { for (var i = 0, s = ""; !(t / 4 <= i);) { var r, a = N[e + 4 * i >>> 2]; if (0 == a) break; ++i, 65536 <= a ? (r = a - 65536, s += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : s += String.fromCharCode(a) } return s } function Y(e, t, i) { if ((i = void 0 === i ? 2147483647 : i) < 4) return 0; for (var s = t >>>= 0, r = s + i - 4, a = 0; a < e.length; ++a) { var o = e.charCodeAt(a); if (55296 <= o && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e.charCodeAt(++a)), N[t >>> 2] = o, r < (t += 4) + 4) break } return N[t >>> 2] = 0, t - s } function $(e) { for (var t = 0, i = 0; i < e.length; ++i) { var s = e.charCodeAt(i); 55296 <= s && s <= 57343 && ++i, t += 4 } return t } function X(e) { M = e, a.HEAP8 = S = new Int8Array(e), a.HEAP16 = L = new Int16Array(e), a.HEAP32 = N = new Int32Array(e), a.HEAPU8 = x = new Uint8Array(e), a.HEAPU16 = O = new Uint16Array(e), a.HEAPU32 = B = new Uint32Array(e), a.HEAPF32 = G = new Float32Array(e), a.HEAPF64 = U = new Float64Array(e) } a.INITIAL_MEMORY; var K = [], J = [], Q = [], Z = [], q = 0; function ee() { return E || 0 < q } var te, ie, se, re, ae = 0, oe = null; function ne(e) { ae++, a.monitorRunDependencies && a.monitorRunDependencies(ae) } function he(e) { var t; ae--, a.monitorRunDependencies && a.monitorRunDependencies(ae), 0 == ae && oe && (t = oe, oe = null, t()) } function le(e) { throw a.onAbort && a.onAbort(e), T(e += ""), C = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", e = new WebAssembly.RuntimeError(e), i(e), e } function ce(e) { return e.startsWith("data:application/octet-stream;base64,") } function ue(e) { return e.startsWith("file://") } function pe(e) { try { if (e == te && v) return new Uint8Array(v); if (l) return l(e); throw "both async and sync fetching of the wasm failed" } catch (e) { le(e) } } function de(e) { for (; 0 < e.length;) { var t, i = e.shift(); "function" == typeof i ? i(a) : "number" == typeof (t = i.func) ? void 0 === i.arg ? k.get(t)() : k.get(t)(i.arg) : t(void 0 === i.arg ? null : i.arg) } } function me(e) { this.excPtr = e, this.ptr = e - 16, this.set_type = function (e) { N[this.ptr + 4 >>> 2] = e }, this.get_type = function () { return N[this.ptr + 4 >>> 2] }, this.set_destructor = function (e) { N[this.ptr + 8 >>> 2] = e }, this.get_destructor = function () { return N[this.ptr + 8 >>> 2] }, this.set_refcount = function (e) { N[this.ptr >>> 2] = e }, this.set_caught = function (e) { S[this.ptr + 12 >>> 0] = e = e ? 1 : 0 }, this.get_caught = function () { return 0 != S[this.ptr + 12 >>> 0] }, this.set_rethrown = function (e) { S[this.ptr + 13 >>> 0] = e = e ? 1 : 0 }, this.get_rethrown = function () { return 0 != S[this.ptr + 13 >>> 0] }, this.init = function (e, t) { this.set_type(e), this.set_destructor(t), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1) }, this.add_ref = function () { var e = N[this.ptr >>> 2]; N[this.ptr >>> 2] = e + 1 }, this.release_ref = function () { var e = N[this.ptr >>> 2]; return N[this.ptr >>> 2] = e - 1, 1 === e } } function fe(e) { N[jt() >>> 2] = e } a.preloadedImages = {}, a.preloadedAudios = {}, ce(te = "web-ifc.wasm") || (ie = te, te = a.locateFile ? a.locateFile(ie, _) : _ + ie); var ge = { splitPath: function (e) { return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1) }, normalizeArray: function (e, t) { for (var i = 0, s = e.length - 1; 0 <= s; s--) { var r = e[s]; "." === r ? e.splice(s, 1) : ".." === r ? (e.splice(s, 1), i++) : i && (e.splice(s, 1), i--) } if (t) for (; i; i--)e.unshift(".."); return e }, normalize: function (e) { var t = "/" === e.charAt(0), i = "/" === e.substr(-1); return (e = (e = ge.normalizeArray(e.split("/").filter((function (e) { return !!e })), !t).join("/")) || t ? e : ".") && i && (e += "/"), (t ? "/" : "") + e }, dirname: function (e) { var t = (e = ge.splitPath(e))[0]; e = e[1]; return t || e ? t + (e && e.substr(0, e.length - 1)) : "." }, basename: function (e) { var t; return "/" === e ? "/" : -1 === (t = (e = (e = ge.normalize(e)).replace(/\/$/, "")).lastIndexOf("/")) ? e : e.substr(t + 1) }, extname: function (e) { return ge.splitPath(e)[3] }, join: function () { var e = Array.prototype.slice.call(arguments, 0); return ge.normalize(e.join("/")) }, join2: function (e, t) { return ge.normalize(e + "/" + t) } }, _e = { resolve: function () { for (var e = "", t = !1, i = arguments.length - 1; -1 <= i && !t; i--) { var s = 0 <= i ? arguments[i] : Te.cwd(); if ("string" != typeof s) throw new TypeError("Arguments to path.resolve must be strings"); if (!s) return ""; e = s + "/" + e, t = "/" === s.charAt(0) } return (t ? "/" : "") + ge.normalizeArray(e.split("/").filter((function (e) { return !!e })), !t).join("/") || "." }, relative: function (e, t) { function i(e) { for (var t = 0; t < e.length && "" === e[t]; t++); for (var i = e.length - 1; 0 <= i && "" === e[i]; i--); return i < t ? [] : e.slice(t, i - t + 1) } e = _e.resolve(e).substr(1), t = _e.resolve(t).substr(1); for (var s = i(e.split("/")), r = i(t.split("/")), a = Math.min(s.length, r.length), o = a, n = 0; n < a; n++)if (s[n] !== r[n]) { o = n; break } var h = []; for (n = o; n < s.length; n++)h.push(".."); return (h = h.concat(r.slice(o))).join("/") } }, ve = { ttys: [], init: function () { }, shutdown: function () { }, register: function (e, t) { ve.ttys[e] = { input: [], output: [], ops: t }, Te.registerDevice(e, ve.stream_ops) }, stream_ops: { open: function (e) { var t = ve.ttys[e.node.rdev]; if (!t) throw new Te.ErrnoError(43); e.tty = t, e.seekable = !1 }, close: function (e) { e.tty.ops.flush(e.tty) }, flush: function (e) { e.tty.ops.flush(e.tty) }, read: function (e, t, i, s, r) { if (!e.tty || !e.tty.ops.get_char) throw new Te.ErrnoError(60); for (var a, o = 0, n = 0; n < s; n++) { try { a = e.tty.ops.get_char(e.tty) } catch (e) { throw new Te.ErrnoError(29) } if (void 0 === a && 0 === o) throw new Te.ErrnoError(6); if (null == a) break; o++, t[i + n] = a } return o && (e.node.timestamp = Date.now()), o }, write: function (e, t, i, s, r) { if (!e.tty || !e.tty.ops.put_char) throw new Te.ErrnoError(60); try { for (var a = 0; a < s; a++)e.tty.ops.put_char(e.tty, t[i + a]) } catch (e) { throw new Te.ErrnoError(29) } return s && (e.node.timestamp = Date.now()), a } }, default_tty_ops: { get_char: function (e) { if (!e.input.length) { var t = null; if (g) { var i = Buffer.alloc(256), s = 0; try { s = c.readSync(process.stdin.fd, i, 0, 256, null) } catch (e) { if (!e.toString().includes("EOF")) throw e; s = 0 } t = 0 < s ? i.slice(0, s).toString("utf-8") : null } else "undefined" != typeof window && "function" == typeof window.prompt ? null !== (t = window.prompt("Input: ")) && (t += "\n") : "function" == typeof readline && null !== (t = readline()) && (t += "\n"); if (!t) return null; e.input = Bt(t, !0) } return e.input.shift() }, put_char: function (e, t) { null === t || 10 === t ? (y(A(e.output, 0)), e.output = []) : 0 != t && e.output.push(t) }, flush: function (e) { e.output && 0 < e.output.length && (y(A(e.output, 0)), e.output = []) } }, default_tty1_ops: { put_char: function (e, t) { null === t || 10 === t ? (T(A(e.output, 0)), e.output = []) : 0 != t && e.output.push(t) }, flush: function (e) { e.output && 0 < e.output.length && (T(A(e.output, 0)), e.output = []) } } }, ye = { ops_table: null, mount: function (e) { return ye.createNode(null, "/", 16895, 0) }, createNode: function (e, t, i, s) { if (Te.isBlkdev(i) || Te.isFIFO(i)) throw new Te.ErrnoError(63); return ye.ops_table || (ye.ops_table = { dir: { node: { getattr: ye.node_ops.getattr, setattr: ye.node_ops.setattr, lookup: ye.node_ops.lookup, mknod: ye.node_ops.mknod, rename: ye.node_ops.rename, unlink: ye.node_ops.unlink, rmdir: ye.node_ops.rmdir, readdir: ye.node_ops.readdir, symlink: ye.node_ops.symlink }, stream: { llseek: ye.stream_ops.llseek } }, file: { node: { getattr: ye.node_ops.getattr, setattr: ye.node_ops.setattr }, stream: { llseek: ye.stream_ops.llseek, read: ye.stream_ops.read, write: ye.stream_ops.write, allocate: ye.stream_ops.allocate, mmap: ye.stream_ops.mmap, msync: ye.stream_ops.msync } }, link: { node: { getattr: ye.node_ops.getattr, setattr: ye.node_ops.setattr, readlink: ye.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: ye.node_ops.getattr, setattr: ye.node_ops.setattr }, stream: Te.chrdev_stream_ops } }), i = Te.createNode(e, t, i, s), Te.isDir(i.mode) ? (i.node_ops = ye.ops_table.dir.node, i.stream_ops = ye.ops_table.dir.stream, i.contents = {}) : Te.isFile(i.mode) ? (i.node_ops = ye.ops_table.file.node, i.stream_ops = ye.ops_table.file.stream, i.usedBytes = 0, i.contents = null) : Te.isLink(i.mode) ? (i.node_ops = ye.ops_table.link.node, i.stream_ops = ye.ops_table.link.stream) : Te.isChrdev(i.mode) && (i.node_ops = ye.ops_table.chrdev.node, i.stream_ops = ye.ops_table.chrdev.stream), i.timestamp = Date.now(), e && (e.contents[t] = i, e.timestamp = i.timestamp), i }, getFileDataAsTypedArray: function (e) { return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0) }, expandFileStorage: function (e, t) { var i = e.contents ? e.contents.length : 0; (t >>>= 0) <= i || (t = Math.max(t, i * (i < 1048576 ? 2 : 1.125) >>> 0), 0 != i && (t = Math.max(t, 256)), i = e.contents, e.contents = new Uint8Array(t), 0 < e.usedBytes && e.contents.set(i.subarray(0, e.usedBytes), 0)) }, resizeFileStorage: function (e, t) { var i; e.usedBytes != (t >>>= 0) && (0 == t ? (e.contents = null, e.usedBytes = 0) : (i = e.contents, e.contents = new Uint8Array(t), i && e.contents.set(i.subarray(0, Math.min(t, e.usedBytes))), e.usedBytes = t)) }, node_ops: { getattr: function (e) { var t = {}; return t.dev = Te.isChrdev(e.mode) ? e.id : 1, t.ino = e.id, t.mode = e.mode, t.nlink = 1, t.uid = 0, t.gid = 0, t.rdev = e.rdev, Te.isDir(e.mode) ? t.size = 4096 : Te.isFile(e.mode) ? t.size = e.usedBytes : Te.isLink(e.mode) ? t.size = e.link.length : t.size = 0, t.atime = new Date(e.timestamp), t.mtime = new Date(e.timestamp), t.ctime = new Date(e.timestamp), t.blksize = 4096, t.blocks = Math.ceil(t.size / t.blksize), t }, setattr: function (e, t) { void 0 !== t.mode && (e.mode = t.mode), void 0 !== t.timestamp && (e.timestamp = t.timestamp), void 0 !== t.size && ye.resizeFileStorage(e, t.size) }, lookup: function (e, t) { throw Te.genericErrors[44] }, mknod: function (e, t, i, s) { return ye.createNode(e, t, i, s) }, rename: function (e, t, i) { if (Te.isDir(e.mode)) { var s; try { s = Te.lookupNode(t, i) } catch (e) { } if (s) for (var r in s.contents) throw new Te.ErrnoError(55) } delete e.parent.contents[e.name], e.parent.timestamp = Date.now(), e.name = i, t.contents[i] = e, t.timestamp = e.parent.timestamp, e.parent = t }, unlink: function (e, t) { delete e.contents[t], e.timestamp = Date.now() }, rmdir: function (e, t) { for (var i in Te.lookupNode(e, t).contents) throw new Te.ErrnoError(55); delete e.contents[t], e.timestamp = Date.now() }, readdir: function (e) { var t, i = [".", ".."]; for (t in e.contents) e.contents.hasOwnProperty(t) && i.push(t); return i }, symlink: function (e, t, i) { return (e = ye.createNode(e, t, 41471, 0)).link = i, e }, readlink: function (e) { if (Te.isLink(e.mode)) return e.link; throw new Te.ErrnoError(28) } }, stream_ops: { read: function (e, t, i, s, r) { var a = e.node.contents; if (r >= e.node.usedBytes) return 0; var o = Math.min(e.node.usedBytes - r, s); if (8 < o && a.subarray) t.set(a.subarray(r, r + o), i); else for (var n = 0; n < o; n++)t[i + n] = a[r + n]; return o }, write: function (e, t, i, s, r, a) { if (t.buffer === S.buffer && (a = !1), !s) return 0; var o = e.node; if (o.timestamp = Date.now(), t.subarray && (!o.contents || o.contents.subarray)) { if (a) return o.contents = t.subarray(i, i + s), o.usedBytes = s; if (0 === o.usedBytes && 0 === r) return o.contents = t.slice(i, i + s), o.usedBytes = s; if (r + s <= o.usedBytes) return o.contents.set(t.subarray(i, i + s), r), s } if (ye.expandFileStorage(o, r + s), o.contents.subarray && t.subarray) o.contents.set(t.subarray(i, i + s), r); else for (var n = 0; n < s; n++)o.contents[r + n] = t[i + n]; return o.usedBytes = Math.max(o.usedBytes, r + s), s }, llseek: function (e, t, i) { if (1 === i ? t += e.position : 2 === i && Te.isFile(e.node.mode) && (t += e.node.usedBytes), t < 0) throw new Te.ErrnoError(28); return t }, allocate: function (e, t, i) { ye.expandFileStorage(e.node, t + i), e.node.usedBytes = Math.max(e.node.usedBytes, t + i) }, mmap: function (e, t, i, s, r, a) { if (0 !== t) throw new Te.ErrnoError(28); if (!Te.isFile(e.node.mode)) throw new Te.ErrnoError(43); if (t = e.node.contents, 2 & a || t.buffer !== M) throw (0 < s || s + i < t.length) && (t = t.subarray ? t.subarray(s, s + i) : Array.prototype.slice.call(t, s, s + i)), le(), new Te.ErrnoError(48); return { ptr: t.byteOffset, allocated: !1 } }, msync: function (e, t, i, s, r) { if (Te.isFile(e.node.mode)) return 2 & r || ye.stream_ops.write(e, t, 0, s, i, !1), 0; throw new Te.ErrnoError(43) } } }, Te = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function (e, t) { if (t = t || {}, !(e = _e.resolve(Te.cwd(), e))) return { path: "", node: null }; var i, s = { follow_mount: !0, recurse_count: 0 }; for (i in s) void 0 === t[i] && (t[i] = s[i]); if (8 < t.recurse_count) throw new Te.ErrnoError(32); for (var r = ge.normalizeArray(e.split("/").filter((function (e) { return !!e })), !1), a = Te.root, o = "/", n = 0; n < r.length; n++) { var h = n === r.length - 1; if (h && t.parent) break; if (a = Te.lookupNode(a, r[n]), o = ge.join2(o, r[n]), !Te.isMountpoint(a) || h && !t.follow_mount || (a = a.mounted.root), !h || t.follow) for (var l = 0; Te.isLink(a.mode);) { var c = Te.readlink(o); o = _e.resolve(ge.dirname(o), c), a = Te.lookupPath(o, { recurse_count: t.recurse_count }).node; if (40 < l++) throw new Te.ErrnoError(32) } } return { path: o, node: a } }, getPath: function (e) { for (var t, i; ;) { if (Te.isRoot(e)) return i = e.mount.mountpoint, t ? "/" !== i[i.length - 1] ? i + "/" + t : i + t : i; t = t ? e.name + "/" + t : e.name, e = e.parent } }, hashName: function (e, t) { for (var i = 0, s = 0; s < t.length; s++)i = (i << 5) - i + t.charCodeAt(s) | 0; return (e + i >>> 0) % Te.nameTable.length }, hashAddNode: function (e) { var t = Te.hashName(e.parent.id, e.name); e.name_next = Te.nameTable[t], Te.nameTable[t] = e }, hashRemoveNode: function (e) { var t = Te.hashName(e.parent.id, e.name); if (Te.nameTable[t] === e) Te.nameTable[t] = e.name_next; else for (var i = Te.nameTable[t]; i;) { if (i.name_next === e) { i.name_next = e.name_next; break } i = i.name_next } }, lookupNode: function (e, t) { if (i = Te.mayLookup(e)) throw new Te.ErrnoError(i, e); for (var i = Te.hashName(e.id, t), s = Te.nameTable[i]; s; s = s.name_next) { var r = s.name; if (s.parent.id === e.id && r === t) return s } return Te.lookup(e, t) }, createNode: function (e, t, i, s) { return e = new Te.FSNode(e, t, i, s), Te.hashAddNode(e), e }, destroyNode: function (e) { Te.hashRemoveNode(e) }, isRoot: function (e) { return e === e.parent }, isMountpoint: function (e) { return !!e.mounted }, isFile: function (e) { return 32768 == (61440 & e) }, isDir: function (e) { return 16384 == (61440 & e) }, isLink: function (e) { return 40960 == (61440 & e) }, isChrdev: function (e) { return 8192 == (61440 & e) }, isBlkdev: function (e) { return 24576 == (61440 & e) }, isFIFO: function (e) { return 4096 == (61440 & e) }, isSocket: function (e) { return !(49152 & ~e) }, flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, modeStringToFlags: function (e) { var t = Te.flagModes[e]; if (void 0 === t) throw new Error("Unknown file open mode: " + e); return t }, flagsToPermissionString: function (e) { var t = ["r", "w", "rw"][3 & e]; return 512 & e && (t += "w"), t }, nodePermissions: function (e, t) { return Te.ignorePermissions || (!t.includes("r") || 292 & e.mode) && (!t.includes("w") || 146 & e.mode) && (!t.includes("x") || 73 & e.mode) ? 0 : 2 }, mayLookup: function (e) { return Te.nodePermissions(e, "x") || (e.node_ops.lookup ? 0 : 2) }, mayCreate: function (e, t) { try { return Te.lookupNode(e, t), 20 } catch (e) { } return Te.nodePermissions(e, "wx") }, mayDelete: function (e, t, i) { var s; try { s = Te.lookupNode(e, t) } catch (e) { return e.errno } if (t = Te.nodePermissions(e, "wx")) return t; if (i) { if (!Te.isDir(s.mode)) return 54; if (Te.isRoot(s) || Te.getPath(s) === Te.cwd()) return 10 } else if (Te.isDir(s.mode)) return 31; return 0 }, mayOpen: function (e, t) { return e ? Te.isLink(e.mode) ? 32 : Te.isDir(e.mode) && ("r" !== Te.flagsToPermissionString(t) || 512 & t) ? 31 : Te.nodePermissions(e, Te.flagsToPermissionString(t)) : 44 }, MAX_OPEN_FDS: 4096, nextfd: function (e, t) { t = t || Te.MAX_OPEN_FDS; for (var i = e = e || 0; i <= t; i++)if (!Te.streams[i]) return i; throw new Te.ErrnoError(33) }, getStream: function (e) { return Te.streams[e] }, createStream: function (e, t, i) { Te.FSStream || (Te.FSStream = function () { }, Te.FSStream.prototype = { object: { get: function () { return this.node }, set: function (e) { this.node = e } }, isRead: { get: function () { return 1 != (2097155 & this.flags) } }, isWrite: { get: function () { return !!(2097155 & this.flags) } }, isAppend: { get: function () { return 1024 & this.flags } } }); var s, r = new Te.FSStream; for (s in e) r[s] = e[s]; return e = r, t = Te.nextfd(t, i), e.fd = t, Te.streams[t] = e }, closeStream: function (e) { Te.streams[e] = null }, chrdev_stream_ops: { open: function (e) { var t = Te.getDevice(e.node.rdev); e.stream_ops = t.stream_ops, e.stream_ops.open && e.stream_ops.open(e) }, llseek: function () { throw new Te.ErrnoError(70) } }, major: function (e) { return e >> 8 }, minor: function (e) { return 255 & e }, makedev: function (e, t) { return e << 8 | t }, registerDevice: function (e, t) { Te.devices[e] = { stream_ops: t } }, getDevice: function (e) { return Te.devices[e] }, getMounts: function (e) { for (var t = [], i = [e]; i.length;) { var s = i.pop(); t.push(s), i.push.apply(i, s.mounts) } return t }, syncfs: function (e, t) { "function" == typeof e && (t = e, e = !1), Te.syncFSRequests++, 1 < Te.syncFSRequests && T("warning: " + Te.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work"); var i = Te.getMounts(Te.root.mount), s = 0; function r(e) { return Te.syncFSRequests--, t(e) } function a(e) { if (e) return a.errored ? void 0 : (a.errored = !0, r(e)); ++s >= i.length && r(null) } i.forEach((function (t) { if (!t.type.syncfs) return a(null); t.type.syncfs(t, e, a) })) }, mount: function (e, t, i) { var s, r = "/" === i, a = !i; if (r && Te.root) throw new Te.ErrnoError(10); if (!r && !a) { if (i = (a = Te.lookupPath(i, { follow_mount: !1 })).path, s = a.node, Te.isMountpoint(s)) throw new Te.ErrnoError(10); if (!Te.isDir(s.mode)) throw new Te.ErrnoError(54) } return ((t = e.mount(a = { type: e, opts: t, mountpoint: i, mounts: [] })).mount = a).root = t, r ? Te.root = t : s && (s.mounted = a, s.mount) && s.mount.mounts.push(a), t }, unmount: function (e) { if (e = Te.lookupPath(e, { follow_mount: !1 }), !Te.isMountpoint(e.node)) throw new Te.ErrnoError(28); var t = (e = e.node).mounted, i = Te.getMounts(t); Object.keys(Te.nameTable).forEach((function (e) { for (var t = Te.nameTable[e]; t;) { var s = t.name_next; i.includes(t.mount) && Te.destroyNode(t), t = s } })), e.mounted = null, t = e.mount.mounts.indexOf(t); e.mount.mounts.splice(t, 1) }, lookup: function (e, t) { return e.node_ops.lookup(e, t) }, mknod: function (e, t, i) { var s = Te.lookupPath(e, { parent: !0 }).node; if (!(e = ge.basename(e)) || "." === e || ".." === e) throw new Te.ErrnoError(28); var r = Te.mayCreate(s, e); if (r) throw new Te.ErrnoError(r); if (s.node_ops.mknod) return s.node_ops.mknod(s, e, t, i); throw new Te.ErrnoError(63) }, create: function (e, t) { return Te.mknod(e, t = 4095 & (void 0 !== t ? t : 438) | 32768, 0) }, mkdir: function (e, t) { return Te.mknod(e, t = 1023 & (void 0 !== t ? t : 511) | 16384, 0) }, mkdirTree: function (e, t) { for (var i = e.split("/"), s = "", r = 0; r < i.length; ++r)if (i[r]) { s += "/" + i[r]; try { Te.mkdir(s, t) } catch (e) { if (20 != e.errno) throw e } } }, mkdev: function (e, t, i) { return void 0 === i && (i = t, t = 438), Te.mknod(e, t |= 8192, i) }, symlink: function (e, t) { if (!_e.resolve(e)) throw new Te.ErrnoError(44); var i = Te.lookupPath(t, { parent: !0 }).node; if (!i) throw new Te.ErrnoError(44); t = ge.basename(t); var s = Te.mayCreate(i, t); if (s) throw new Te.ErrnoError(s); if (i.node_ops.symlink) return i.node_ops.symlink(i, t, e); throw new Te.ErrnoError(63) }, rename: function (e, t) { var i = ge.dirname(e), s = ge.dirname(t), r = ge.basename(e), a = ge.basename(t), o = (o = Te.lookupPath(e, { parent: !0 })).node, n = Te.lookupPath(t, { parent: !0 }).node; if (!o || !n) throw new Te.ErrnoError(44); if (o.mount !== n.mount) throw new Te.ErrnoError(75); var h, l = Te.lookupNode(o, r); if ("." !== (s = _e.relative(e, s)).charAt(0)) throw new Te.ErrnoError(28); if ("." !== (s = _e.relative(t, i)).charAt(0)) throw new Te.ErrnoError(55); try { h = Te.lookupNode(n, a) } catch (i) { } if (l !== h) { if (i = Te.isDir(l.mode), s = Te.mayDelete(o, r, i)) throw new Te.ErrnoError(s); if (s = h ? Te.mayDelete(n, a, i) : Te.mayCreate(n, a)) throw new Te.ErrnoError(s); if (!o.node_ops.rename) throw new Te.ErrnoError(63); if (Te.isMountpoint(l) || h && Te.isMountpoint(h)) throw new Te.ErrnoError(10); if (n !== o && (s = Te.nodePermissions(o, "w"))) throw new Te.ErrnoError(s); try { Te.trackingDelegate.willMovePath && Te.trackingDelegate.willMovePath(e, t) } catch (i) { T("FS.trackingDelegate['willMovePath']('" + e + "', '" + t + "') threw an exception: " + i.message) } Te.hashRemoveNode(l); try { o.node_ops.rename(l, n, a) } catch (i) { throw i } finally { Te.hashAddNode(l) } try { Te.trackingDelegate.onMovePath && Te.trackingDelegate.onMovePath(e, t) } catch (i) { T("FS.trackingDelegate['onMovePath']('" + e + "', '" + t + "') threw an exception: " + i.message) } } }, rmdir: function (e) { var t = Te.lookupPath(e, { parent: !0 }).node, i = ge.basename(e), s = Te.lookupNode(t, i), r = Te.mayDelete(t, i, !0); if (r) throw new Te.ErrnoError(r); if (!t.node_ops.rmdir) throw new Te.ErrnoError(63); if (Te.isMountpoint(s)) throw new Te.ErrnoError(10); try { Te.trackingDelegate.willDeletePath && Te.trackingDelegate.willDeletePath(e) } catch (t) { T("FS.trackingDelegate['willDeletePath']('" + e + "') threw an exception: " + t.message) } t.node_ops.rmdir(t, i), Te.destroyNode(s); try { Te.trackingDelegate.onDeletePath && Te.trackingDelegate.onDeletePath(e) } catch (t) { T("FS.trackingDelegate['onDeletePath']('" + e + "') threw an exception: " + t.message) } }, readdir: function (e) { if ((e = Te.lookupPath(e, { follow: !0 }).node).node_ops.readdir) return e.node_ops.readdir(e); throw new Te.ErrnoError(54) }, unlink: function (e) { var t = Te.lookupPath(e, { parent: !0 }).node, i = ge.basename(e), s = Te.lookupNode(t, i), r = Te.mayDelete(t, i, !1); if (r) throw new Te.ErrnoError(r); if (!t.node_ops.unlink) throw new Te.ErrnoError(63); if (Te.isMountpoint(s)) throw new Te.ErrnoError(10); try { Te.trackingDelegate.willDeletePath && Te.trackingDelegate.willDeletePath(e) } catch (t) { T("FS.trackingDelegate['willDeletePath']('" + e + "') threw an exception: " + t.message) } t.node_ops.unlink(t, i), Te.destroyNode(s); try { Te.trackingDelegate.onDeletePath && Te.trackingDelegate.onDeletePath(e) } catch (t) { T("FS.trackingDelegate['onDeletePath']('" + e + "') threw an exception: " + t.message) } }, readlink: function (e) { if (!(e = Te.lookupPath(e).node)) throw new Te.ErrnoError(44); if (e.node_ops.readlink) return _e.resolve(Te.getPath(e.parent), e.node_ops.readlink(e)); throw new Te.ErrnoError(28) }, stat: function (e, t) { if (!(e = Te.lookupPath(e, { follow: !t }).node)) throw new Te.ErrnoError(44); if (e.node_ops.getattr) return e.node_ops.getattr(e); throw new Te.ErrnoError(63) }, lstat: function (e) { return Te.stat(e, !0) }, chmod: function (e, t, i) { if (!(i = "string" == typeof e ? Te.lookupPath(e, { follow: !i }).node : e).node_ops.setattr) throw new Te.ErrnoError(63); i.node_ops.setattr(i, { mode: 4095 & t | -4096 & i.mode, timestamp: Date.now() }) }, lchmod: function (e, t) { Te.chmod(e, t, !0) }, fchmod: function (e, t) { if (!(e = Te.getStream(e))) throw new Te.ErrnoError(8); Te.chmod(e.node, t) }, chown: function (e, t, i, s) { if (!(s = "string" == typeof e ? Te.lookupPath(e, { follow: !s }).node : e).node_ops.setattr) throw new Te.ErrnoError(63); s.node_ops.setattr(s, { timestamp: Date.now() }) }, lchown: function (e, t, i) { Te.chown(e, t, i, !0) }, fchown: function (e, t, i) { if (!(e = Te.getStream(e))) throw new Te.ErrnoError(8); Te.chown(e.node, t, i) }, truncate: function (e, t) { if (t < 0) throw new Te.ErrnoError(28); if (!(e = "string" == typeof e ? Te.lookupPath(e, { follow: !0 }).node : e).node_ops.setattr) throw new Te.ErrnoError(63); if (Te.isDir(e.mode)) throw new Te.ErrnoError(31); if (!Te.isFile(e.mode)) throw new Te.ErrnoError(28); var i = Te.nodePermissions(e, "w"); if (i) throw new Te.ErrnoError(i); e.node_ops.setattr(e, { size: t, timestamp: Date.now() }) }, ftruncate: function (e, t) { if (!(e = Te.getStream(e))) throw new Te.ErrnoError(8); if (!(2097155 & e.flags)) throw new Te.ErrnoError(28); Te.truncate(e.node, t) }, utime: function (e, t, i) { (e = Te.lookupPath(e, { follow: !0 }).node).node_ops.setattr(e, { timestamp: Math.max(t, i) }) }, open: function (e, t, i, s, r) { if ("" === e) throw new Te.ErrnoError(44); if (i = void 0 === i ? 438 : i, i = 64 & (t = "string" == typeof t ? Te.modeStringToFlags(t) : t) ? 4095 & i | 32768 : 0, "object" == typeof e) o = e; else { e = ge.normalize(e); try { var o = Te.lookupPath(e, { follow: !(131072 & t) }).node } catch (t) { } } var n, h = !1; if (64 & t) if (o) { if (128 & t) throw new Te.ErrnoError(20) } else o = Te.mknod(e, i, 0), h = !0; if (!o) throw new Te.ErrnoError(44); if (Te.isChrdev(o.mode) && (t &= -513), 65536 & t && !Te.isDir(o.mode)) throw new Te.ErrnoError(54); if (!h && (i = Te.mayOpen(o, t))) throw new Te.ErrnoError(i); 512 & t && Te.truncate(o, 0), t &= -131713, (h = Te.createStream({ node: o, path: Te.getPath(o), flags: t, seekable: !0, position: 0, stream_ops: o.stream_ops, ungotten: [], error: !1 }, s, r)).stream_ops.open && h.stream_ops.open(h), !a.logReadFiles || 1 & t || (Te.readFiles || (Te.readFiles = {}), e in Te.readFiles) || (Te.readFiles[e] = 1, T("FS.trackingDelegate error on read file: " + e)); try { Te.trackingDelegate.onOpenFile && (n = 0, 1 != (2097155 & t) && (n |= Te.tracking.openFlags.READ), !!(2097155 & t) && (n |= Te.tracking.openFlags.WRITE), Te.trackingDelegate.onOpenFile(e, n)) } catch (t) { T("FS.trackingDelegate['onOpenFile']('" + e + "', flags) threw an exception: " + t.message) } return h }, close: function (e) { if (Te.isClosed(e)) throw new Te.ErrnoError(8); e.getdents && (e.getdents = null); try { e.stream_ops.close && e.stream_ops.close(e) } catch (e) { throw e } finally { Te.closeStream(e.fd) } e.fd = null }, isClosed: function (e) { return null === e.fd }, llseek: function (e, t, i) { if (Te.isClosed(e)) throw new Te.ErrnoError(8); if (!e.seekable || !e.stream_ops.llseek) throw new Te.ErrnoError(70); if (0 != i && 1 != i && 2 != i) throw new Te.ErrnoError(28); return e.position = e.stream_ops.llseek(e, t, i), e.ungotten = [], e.position }, read: function (e, t, i, s, r) { if (i >>>= 0, s < 0 || r < 0) throw new Te.ErrnoError(28); if (Te.isClosed(e)) throw new Te.ErrnoError(8); if (1 == (2097155 & e.flags)) throw new Te.ErrnoError(8); if (Te.isDir(e.node.mode)) throw new Te.ErrnoError(31); if (!e.stream_ops.read) throw new Te.ErrnoError(28); var a = void 0 !== r; if (a) { if (!e.seekable) throw new Te.ErrnoError(70) } else r = e.position; return t = e.stream_ops.read(e, t, i, s, r), a || (e.position += t), t }, write: function (e, t, i, s, r, a) { if (i >>>= 0, s < 0 || r < 0) throw new Te.ErrnoError(28); if (Te.isClosed(e)) throw new Te.ErrnoError(8); if (!(2097155 & e.flags)) throw new Te.ErrnoError(8); if (Te.isDir(e.node.mode)) throw new Te.ErrnoError(31); if (!e.stream_ops.write) throw new Te.ErrnoError(28); e.seekable && 1024 & e.flags && Te.llseek(e, 0, 2); var o = void 0 !== r; if (o) { if (!e.seekable) throw new Te.ErrnoError(70) } else r = e.position; t = e.stream_ops.write(e, t, i, s, r, a), o || (e.position += t); try { e.path && Te.trackingDelegate.onWriteToFile && Te.trackingDelegate.onWriteToFile(e.path) } catch (t) { T("FS.trackingDelegate['onWriteToFile']('" + e.path + "') threw an exception: " + t.message) } return t }, allocate: function (e, t, i) { if (Te.isClosed(e)) throw new Te.ErrnoError(8); if (t < 0 || i <= 0) throw new Te.ErrnoError(28); if (!(2097155 & e.flags)) throw new Te.ErrnoError(8); if (!Te.isFile(e.node.mode) && !Te.isDir(e.node.mode)) throw new Te.ErrnoError(43); if (!e.stream_ops.allocate) throw new Te.ErrnoError(138); e.stream_ops.allocate(e, t, i) }, mmap: function (e, t, i, s, r, a) { if (t >>>= 0, 2 & r && !(2 & a) && 2 != (2097155 & e.flags)) throw new Te.ErrnoError(2); if (1 == (2097155 & e.flags)) throw new Te.ErrnoError(2); if (e.stream_ops.mmap) return e.stream_ops.mmap(e, t, i, s, r, a); throw new Te.ErrnoError(43) }, msync: function (e, t, i, s, r) { return i >>>= 0, e && e.stream_ops.msync ? e.stream_ops.msync(e, t, i, s, r) : 0 }, munmap: function (e) { return 0 }, ioctl: function (e, t, i) { if (e.stream_ops.ioctl) return e.stream_ops.ioctl(e, t, i); throw new Te.ErrnoError(59) }, readFile: function (e, t) { if ((t = t || {}).flags = t.flags || 0, t.encoding = t.encoding || "binary", "utf8" !== t.encoding && "binary" !== t.encoding) throw new Error('Invalid encoding type "' + t.encoding + '"'); var i, s = Te.open(e, t.flags), r = (e = Te.stat(e).size, new Uint8Array(e)); return Te.read(s, r, 0, e, 0), "utf8" === t.encoding ? i = A(r, 0) : "binary" === t.encoding && (i = r), Te.close(s), i }, writeFile: function (e, t, i) { if ((i = i || {}).flags = i.flags || 577, e = Te.open(e, i.flags, i.mode), "string" == typeof t) { var s = new Uint8Array(w(t) + 1), r = R(t, s, 0, s.length); Te.write(e, s, 0, r, void 0, i.canOwn) } else { if (!ArrayBuffer.isView(t)) throw new Error("Unsupported data type"); Te.write(e, t, 0, t.byteLength, void 0, i.canOwn) } Te.close(e) }, cwd: function () { return Te.currentPath }, chdir: function (e) { if (null === (e = Te.lookupPath(e, { follow: !0 })).node) throw new Te.ErrnoError(44); if (!Te.isDir(e.node.mode)) throw new Te.ErrnoError(54); var t = Te.nodePermissions(e.node, "x"); if (t) throw new Te.ErrnoError(t); Te.currentPath = e.path }, createDefaultDirectories: function () { Te.mkdir("/tmp"), Te.mkdir("/home"), Te.mkdir("/home/web_user") }, createDefaultDevices: function () { Te.mkdir("/dev"), Te.registerDevice(Te.makedev(1, 3), { read: function () { return 0 }, write: function (e, t, i, s, r) { return s } }), Te.mkdev("/dev/null", Te.makedev(1, 3)), ve.register(Te.makedev(5, 0), ve.default_tty_ops), ve.register(Te.makedev(6, 0), ve.default_tty1_ops), Te.mkdev("/dev/tty", Te.makedev(5, 0)), Te.mkdev("/dev/tty1", Te.makedev(6, 0)); var e = function () { var e; if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) return e = new Uint8Array(1), function () { return crypto.getRandomValues(e), e[0] }; if (g) try { var t = require_crypto(); return function () { return t.randomBytes(1)[0] } } catch (e) { } return function () { le("randomDevice") } }(); Te.createDevice("/dev", "random", e), Te.createDevice("/dev", "urandom", e), Te.mkdir("/dev/shm"), Te.mkdir("/dev/shm/tmp") }, createSpecialDirectories: function () { Te.mkdir("/proc"); var e = Te.mkdir("/proc/self"); Te.mkdir("/proc/self/fd"), Te.mount({ mount: function () { var t = Te.createNode(e, "fd", 16895, 73); return t.node_ops = { lookup: function (e, t) { var i = Te.getStream(+t); if (i) return (t = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function () { return i.path } } }).parent = t; throw new Te.ErrnoError(8) } }, t } }, {}, "/proc/self/fd") }, createStandardStreams: function () { a.stdin ? Te.createDevice("/dev", "stdin", a.stdin) : Te.symlink("/dev/tty", "/dev/stdin"), a.stdout ? Te.createDevice("/dev", "stdout", null, a.stdout) : Te.symlink("/dev/tty", "/dev/stdout"), a.stderr ? Te.createDevice("/dev", "stderr", null, a.stderr) : Te.symlink("/dev/tty1", "/dev/stderr"), Te.open("/dev/stdin", 0), Te.open("/dev/stdout", 1), Te.open("/dev/stderr", 1) }, ensureErrnoError: function () { Te.ErrnoError || (Te.ErrnoError = function (e, t) { this.node = t, this.setErrno = function (e) { this.errno = e }, this.setErrno(e), this.message = "FS error" }, Te.ErrnoError.prototype = new Error, Te.ErrnoError.prototype.constructor = Te.ErrnoError, [44].forEach((function (e) { Te.genericErrors[e] = new Te.ErrnoError(e), Te.genericErrors[e].stack = "<generic error, no stack>" }))) }, staticInit: function () { Te.ensureErrnoError(), Te.nameTable = new Array(4096), Te.mount(ye, {}, "/"), Te.createDefaultDirectories(), Te.createDefaultDevices(), Te.createSpecialDirectories(), Te.filesystems = { MEMFS: ye } }, init: function (e, t, i) { Te.init.initialized = !0, Te.ensureErrnoError(), a.stdin = e || a.stdin, a.stdout = t || a.stdout, a.stderr = i || a.stderr, Te.createStandardStreams() }, quit: function () { Te.init.initialized = !1; var e = a._fflush; e && e(0); for (var t = 0; t < Te.streams.length; t++) { var i = Te.streams[t]; i && Te.close(i) } }, getMode: function (e, t) { var i = 0; return e && (i |= 365), t && (i |= 146), i }, findObject: function (e, t) { return (e = Te.analyzePath(e, t)).exists ? e.object : null }, analyzePath: function (e, t) { try { e = (s = Te.lookupPath(e, { follow: !t })).path } catch (e) { } var i = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null }; try { var s = Te.lookupPath(e, { parent: !0 }); i.parentExists = !0, i.parentPath = s.path, i.parentObject = s.node, i.name = ge.basename(e), s = Te.lookupPath(e, { follow: !t }), i.exists = !0, i.path = s.path, i.object = s.node, i.name = s.node.name, i.isRoot = "/" === s.path } catch (e) { i.error = e.errno } return i }, createPath: function (e, t, i, s) { e = "string" == typeof e ? e : Te.getPath(e); for (var r = t.split("/").reverse(); r.length;) { var a = r.pop(); if (a) { var o = ge.join2(e, a); try { Te.mkdir(o) } catch (e) { } e = o } } return o }, createFile: function (e, t, i, s, r) { return e = ge.join2("string" == typeof e ? e : Te.getPath(e), t), t = Te.getMode(s, r), Te.create(e, t) }, createDataFile: function (e, t, i, s, r, a) { if (t = t ? ge.join2("string" == typeof e ? e : Te.getPath(e), t) : e, e = Te.getMode(s, r), s = Te.create(t, e), i) { if ("string" == typeof i) { for (var o = new Array(i.length), n = 0, h = i.length; n < h; ++n)o[n] = i.charCodeAt(n); i = o } Te.chmod(s, 146 | e), r = Te.open(s, 577), Te.write(r, i, 0, i.length, 0, a), Te.close(r), Te.chmod(s, e) } return s }, createDevice: function (e, t, i, s) { e = ge.join2("string" == typeof e ? e : Te.getPath(e), t), t = Te.getMode(!!i, !!s); var r = (Te.createDevice.major || (Te.createDevice.major = 64), Te.makedev(Te.createDevice.major++, 0)); return Te.registerDevice(r, { open: function (e) { e.seekable = !1 }, close: function (e) { s && s.buffer && s.buffer.length && s(10) }, read: function (e, t, s, r, a) { for (var o, n = 0, h = 0; h < r; h++) { try { o = i() } catch (e) { throw new Te.ErrnoError(29) } if (void 0 === o && 0 === n) throw new Te.ErrnoError(6); if (null == o) break; n++, t[s + h] = o } return n && (e.node.timestamp = Date.now()), n }, write: function (e, t, i, r, a) { for (var o = 0; o < r; o++)try { s(t[i + o]) } catch (e) { throw new Te.ErrnoError(29) } return r && (e.node.timestamp = Date.now()), o } }), Te.mkdev(e, t, r) }, forceLoadFile: function (e) { if (e.isDevice || e.isFolder || e.link || e.contents) return !0; if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."); if (!n) throw new Error("Cannot load without read() or XMLHttpRequest."); try { e.contents = Bt(n(e.url), !0), e.usedBytes = e.contents.length } catch (e) { throw new Te.ErrnoError(29) } }, createLazyFile: function (e, t, i, s, r) { function a() { this.lengthKnown = !1, this.chunks = [] } if (a.prototype.get = function (e) { var t; if (!(e > this.length - 1 || e < 0)) return t = e % this.chunkSize, e = e / this.chunkSize | 0, this.getter(e)[t] }, a.prototype.setDataGetter = function (e) { this.getter = e }, a.prototype.cacheLength = function () { if ((r = new XMLHttpRequest).open("HEAD", i, !1), r.send(null), !(200 <= r.status && r.status < 300 || 304 === r.status)) throw new Error("Couldn't load " + i + ". Status: " + r.status); var e, t = Number(r.getResponseHeader("Content-length")), s = (e = r.getResponseHeader("Accept-Ranges")) && "bytes" === e, r = (e = r.getResponseHeader("Content-Encoding")) && "gzip" === e, a = 1048576, o = (s || (a = t), this); o.setDataGetter((function (e) { var s = e * a, r = (e + 1) * a - 1; r = Math.min(r, t - 1); if (void 0 === o.chunks[e] && (o.chunks[e] = function (e, s) { if (s < e) throw new Error("invalid range (" + e + ", " + s + ") or no bytes requested!"); if (t - 1 < s) throw new Error("only " + t + " bytes available! programmer error!"); var r = new XMLHttpRequest; if (r.open("GET", i, !1), t !== a && r.setRequestHeader("Range", "bytes=" + e + "-" + s), "undefined" != typeof Uint8Array && (r.responseType = "arraybuffer"), r.overrideMimeType && r.overrideMimeType("text/plain; charset=x-user-defined"), r.send(null), 200 <= r.status && r.status < 300 || 304 === r.status) return void 0 !== r.response ? new Uint8Array(r.response || []) : Bt(r.responseText || "", !0); throw new Error("Couldn't load " + i + ". Status: " + r.status) }(s, r)), void 0 === o.chunks[e]) throw new Error("doXHR failed!"); return o.chunks[e] })), !r && t || (a = t = 1, t = this.getter(0).length, a = t, y("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = t, this._chunkSize = a, this.lengthKnown = !0 }, "undefined" != typeof XMLHttpRequest) { if (!f) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var o = new a; o = (Object.defineProperties(o, { length: { get: function () { return this.lengthKnown || this.cacheLength(), this._length } }, chunkSize: { get: function () { return this.lengthKnown || this.cacheLength(), this._chunkSize } } }), { isDevice: !1, contents: o }) } else o = { isDevice: !1, url: i }; var n = Te.createFile(e, t, o, s, r), h = (o.contents ? n.contents = o.contents : o.url && (n.contents = null, n.url = o.url), Object.defineProperties(n, { usedBytes: { get: function () { return this.contents.length } } }), {}); return Object.keys(n.stream_ops).forEach((function (e) { var t = n.stream_ops[e]; h[e] = function () { return Te.forceLoadFile(n), t.apply(null, arguments) } })), h.read = function (e, t, i, s, r) { Te.forceLoadFile(n); var a = e.node.contents; if (r >= a.length) return 0; var o = Math.min(a.length - r, s); if (a.slice) for (var h = 0; h < o; h++)t[i + h] = a[r + h]; else for (h = 0; h < o; h++)t[i + h] = a.get(r + h); return o }, n.stream_ops = h, n }, createPreloadedFile: function (e, t, i, s, r, o, n, l, c, u) { Browser.init(); var p, d, m, f, g = t ? _e.resolve(ge.join2(e, t)) : e; function _(i) { function h(i) { u && u(), l || Te.createDataFile(e, t, i, s, r, c), o && o(), he() } var p = !1; a.preloadPlugins.forEach((function (e) { p || e.canHandle(g) && (e.handle(i, g, h, (function () { n && n(), he() })), p = !0) })), p || h(i) } ne(), "string" == typeof i ? (d = function (e) { _(e) }, m = n, f = "al " + (p = i), h(p, (function (e) { P(e, 'Loading data file "' + p + '" failed (no arrayBuffer).'), d(new Uint8Array(e)), f && he() }), (function (e) { if (!m) throw 'Loading data file "' + p + '" failed.'; m() })), f && ne()) : _(i) }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return "EM_FS_" + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (e, t, i) { t = t || function () { }, i = i || function () { }; var s = Te.indexedDB(); try { var r = s.open(Te.DB_NAME(), Te.DB_VERSION) } catch (s) { return i(s) } r.onupgradeneeded = function () { y("creating db"), r.result.createObjectStore(Te.DB_STORE_NAME) }, r.onsuccess = function () { var s = r.result.transaction([Te.DB_STORE_NAME], "readwrite"), a = s.objectStore(Te.DB_STORE_NAME), o = 0, n = 0, h = e.length; function l() { (0 == n ? t : i)() } e.forEach((function (e) { (e = a.put(Te.analyzePath(e).object.contents, e)).onsuccess = function () { ++o + n == h && l() }, e.onerror = function () { o + ++n == h && l() } })), s.onerror = i }, r.onerror = i }, loadFilesFromDB: function (e, t, i) { t = t || function () { }, i = i || function () { }; var s = Te.indexedDB(); try { var r = s.open(Te.DB_NAME(), Te.DB_VERSION) } catch (s) { return i(s) } r.onupgradeneeded = i, r.onsuccess = function () { var s = r.result; try { var a = s.transaction([Te.DB_STORE_NAME], "readonly") } catch (s) { return void i(s) } var o = a.objectStore(Te.DB_STORE_NAME), n = 0, h = 0, l = e.length; function c() { (0 == h ? t : i)() } e.forEach((function (e) { var t = o.get(e); t.onsuccess = function () { Te.analyzePath(e).exists && Te.unlink(e), Te.createDataFile(ge.dirname(e), ge.basename(e), t.result, !0, !0, !0), ++n + h == l && c() }, t.onerror = function () { n + ++h == l && c() } })), a.onerror = i }, r.onerror = i } }, Ie = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function (e, t, i) { if ("/" === t[0]) return t; var s; if (-100 === e) s = Te.cwd(); else { if (!(e = Te.getStream(e))) throw new Te.ErrnoError(8); s = e.path } if (0 != t.length) return ge.join2(s, t); if (i) return s; throw new Te.ErrnoError(44) }, doStat: function (e, t, i) { try { var s = e(t) } catch (e) { if (e && e.node && ge.normalize(t) !== ge.normalize(Te.getPath(e.node))) return -54; throw e } return N[i >>> 2] = s.dev, N[i + 4 >>> 2] = 0, N[i + 8 >>> 2] = s.ino, N[i + 12 >>> 2] = s.mode, N[i + 16 >>> 2] = s.nlink, N[i + 20 >>> 2] = s.uid, N[i + 24 >>> 2] = s.gid, N[i + 28 >>> 2] = s.rdev, N[i + 32 >>> 2] = 0, re = [s.size >>> 0, (se = s.size, 1 <= +Math.abs(se) ? 0 < se ? (0 | Math.min(+Math.floor(se / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((se - (~~se >>> 0)) / 4294967296) >>> 0 : 0)], N[i + 40 >>> 2] = re[0], N[i + 44 >>> 2] = re[1], N[i + 48 >>> 2] = 4096, N[i + 52 >>> 2] = s.blocks, N[i + 56 >>> 2] = s.atime.getTime() / 1e3 | 0, N[i + 60 >>> 2] = 0, N[i + 64 >>> 2] = s.mtime.getTime() / 1e3 | 0, N[i + 68 >>> 2] = 0, N[i + 72 >>> 2] = s.ctime.getTime() / 1e3 | 0, N[i + 76 >>> 2] = 0, re = [s.ino >>> 0, (se = s.ino, 1 <= +Math.abs(se) ? 0 < se ? (0 | Math.min(+Math.floor(se / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((se - (~~se >>> 0)) / 4294967296) >>> 0 : 0)], N[i + 80 >>> 2] = re[0], N[i + 84 >>> 2] = re[1], 0 }, doMsync: function (e, t, i, s, r) { e = x.slice(e, e + i), Te.msync(t, e, r, i, s) }, doMkdir: function (e, t) { return "/" === (e = ge.normalize(e))[e.length - 1] && (e = e.substr(0, e.length - 1)), Te.mkdir(e, t, 0), 0 }, doMknod: function (e, t, i) { switch (61440 & t) { case 32768: case 8192: case 24576: case 4096: case 49152: break; default: return -28 }return Te.mknod(e, t, i), 0 }, doReadlink: function (e, t, i) { var s, r; return i <= 0 ? -28 : (e = Te.readlink(e), s = Math.min(i, w(e)), r = S[t + s >>> 0], F(e, t, i + 1), S[t + s >>> 0] = r, s) }, doAccess: function (e, t) { var i; return -8 & t ? -28 : (e = Te.lookupPath(e, { follow: !0 }).node) ? (i = "", 4 & t && (i += "r"), 2 & t && (i += "w"), 1 & t && (i += "x"), i && Te.nodePermissions(e, i) ? -2 : 0) : -44 }, doDup: function (e, t, i) { var s = Te.getStream(i); return s && Te.close(s), Te.open(e, t, 0, i, i).fd }, doReadv: function (e, t, i, s) { for (var r = 0, a = 0; a < i; a++) { var o = N[t + 8 * a >>> 2], n = N[t + (8 * a + 4) >>> 2]; if ((o = Te.read(e, S, o, n, s)) < 0) return -1; if (r += o, o < n) break } return r }, doWritev: function (e, t, i, s) { for (var r = 0, a = 0; a < i; a++) { var o = N[t + 8 * a >>> 2], n = N[t + (8 * a + 4) >>> 2]; if ((o = Te.write(e, S, o, n, s)) < 0) return -1; r += o } return r }, varargs: void 0, get: function () { return Ie.varargs += 4, N[Ie.varargs - 4 >>> 2] }, getStr: function (e) { return D(e) }, getStreamFromFD: function (e) { if (e = Te.getStream(e)) return e; throw new Te.ErrnoError(8) }, get64: function (e, t) { return e } }, Ee = {}; function Ce(e) { for (; e.length;) { var t = e.pop(); e.pop()(t) } } function Pe(e) { return this.fromWireType(B[e >>> 2]) } var be = {}, Ae = {}, De = {}, Re = 48, Fe = 57; function we(e) { var t; return void 0 === e ? "_unknown" : (t = (e = e.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0), Re <= t && t <= Fe ? "_" + e : e) } function Me(e, t) { return e = we(e), new Function("body", "return function " + e + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(t) } function Se(e, t) { var i = Me(t, (function (e) { this.name = t, this.message = e, void 0 !== (e = new Error(e).stack) && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, "")) })); return i.prototype = Object.create(e.prototype), (i.prototype.constructor = i).prototype.toString = function () { return void 0 === this.message ? this.name : this.name + ": " + this.message }, i } var xe = void 0; function Le(e) { throw new xe(e) } function Oe(e, t, i) { function s(t) { var s = i(t); s.length !== e.length && Le("Mismatched type converter count"); for (var r = 0; r < e.length; ++r)He(e[r], s[r]) } e.forEach((function (e) { De[e] = t })); var r = new Array(t.length), a = [], o = 0; t.forEach((function (e, t) { Ae.hasOwnProperty(e) ? r[t] = Ae[e] : (a.push(e), be.hasOwnProperty(e) || (be[e] = []), be[e].push((function () { r[t] = Ae[e], ++o === a.length && s(r) }))) })), 0 === a.length && s(r) } var Ne = {}; function Be(e) { switch (e) { case 1: return 0; case 2: return 1; case 4: return 2; case 8: return 3; default: throw new TypeError("Unknown type size: " + e) } } var Ge = void 0; function Ue(e) { for (var t = "", i = e; x[i >>> 0];)t += Ge[x[i++ >>> 0]]; return t } var ke = void 0; function Ve(e) { throw new ke(e) } function He(e, t, i) { if (i = i || {}, !("argPackAdvance" in t)) throw new TypeError("registerType registeredInstance requires argPackAdvance"); var s = t.name; if (e || Ve('type "' + s + '" must have a positive integer typeid pointer'), Ae.hasOwnProperty(e)) { if (i.ignoreDuplicateRegistrations) return; Ve("Cannot register type '" + s + "' twice") } Ae[e] = t, delete De[e], be.hasOwnProperty(e) && (i = be[e], delete be[e], i.forEach((function (e) { e() }))) } function je(e) { Ve(e.$$.ptrType.registeredClass.name + " instance already deleted") } var ze = !1; function We(e) { } function Ye(e) { --e.count.value, 0 === e.count.value && (e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr)) } function $e(e) { return "undefined" == typeof FinalizationGroup ? ($e = function (e) { return e }, e) : (ze = new FinalizationGroup((function (e) { for (var t = e.next(); !t.done; t = e.next()) { var i = t.value; i.ptr ? Ye(i) : console.warn("object already deleted: " + i.ptr) } })), We = function (e) { ze.unregister(e.$$) }, ($e = function (e) { return ze.register(e, e.$$, e.$$), e })(e)) } var Xe = void 0, Ke = []; function Je() { for (; Ke.length;) { var e = Ke.pop(); e.$$.deleteScheduled = !1, e.delete() } } function Qe() { } var Ze = {}; function qe(e, t, i) { var s; void 0 === e[t].overloadTable && (s = e[t], e[t] = function () { return e[t].overloadTable.hasOwnProperty(arguments.length) || Ve("Function '" + i + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + e[t].overloadTable + ")!"), e[t].overloadTable[arguments.length].apply(this, arguments) }, e[t].overloadTable = [], e[t].overloadTable[s.argCount] = s) } function et(e, t, i) { a.hasOwnProperty(e) ? ((void 0 === i || void 0 !== a[e].overloadTable && void 0 !== a[e].overloadTable[i]) && Ve("Cannot register public name '" + e + "' twice"), qe(a, e, e), a.hasOwnProperty(i) && Ve("Cannot register multiple overloads of a function with the same number of arguments (" + i + ")!"), a[e].overloadTable[i] = t) : (a[e] = t, void 0 !== i && (a[e].numArguments = i)) } function tt(e, t, i, s, r, a, o, n) { this.name = e, this.constructor = t, this.instancePrototype = i, this.rawDestructor = s, this.baseClass = r, this.getActualType = a, this.upcast = o, this.downcast = n, this.pureVirtualFunctions = [] } function it(e, t, i) { for (; t !== i;)t.upcast || Ve("Expected null or instance of " + i.name + ", got an instance of " + t.name), e = t.upcast(e), t = t.baseClass; return e } function st(e, t) { if (null === t) return this.isReference && Ve("null is not a valid " + this.name), 0; t.$$ || Ve('Cannot pass "' + It(t) + '" as a ' + this.name), t.$$.ptr || Ve("Cannot pass deleted object as a pointer of type " + this.name); var i = t.$$.ptrType.registeredClass; return it(t.$$.ptr, i, this.registeredClass) } function rt(e, t) { if (null === t) return this.isReference && Ve("null is not a valid " + this.name), this.isSmartPointer ? (r = this.rawConstructor(), null !== e && e.push(this.rawDestructor, r), r) : 0; t.$$ || Ve('Cannot pass "' + It(t) + '" as a ' + this.name), t.$$.ptr || Ve("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && t.$$.ptrType.isConst && Ve("Cannot convert argument of type " + (t.$$.smartPtrType || t.$$.ptrType).name + " to parameter type " + this.name); var i, s = t.$$.ptrType.registeredClass, r = it(t.$$.ptr, s, this.registeredClass); if (this.isSmartPointer) switch (void 0 === t.$$.smartPtr && Ve("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) { case 0: t.$$.smartPtrType === this ? r = t.$$.smartPtr : Ve("Cannot convert argument of type " + (t.$$.smartPtrType || t.$$.ptrType).name + " to parameter type " + this.name); break; case 1: r = t.$$.smartPtr; break; case 2: t.$$.smartPtrType === this ? r = t.$$.smartPtr : (i = t.clone(), r = this.rawShare(r, yt((function () { i.delete() }))), null !== e && e.push(this.rawDestructor, r)); break; default: Ve("Unsupporting sharing policy") }return r } function at(e, t) { if (null === t) return this.isReference && Ve("null is not a valid " + this.name), 0; t.$$ || Ve('Cannot pass "' + It(t) + '" as a ' + this.name), t.$$.ptr || Ve("Cannot pass deleted object as a pointer of type " + this.name), t.$$.ptrType.isConst && Ve("Cannot convert argument of type " + t.$$.ptrType.name + " to parameter type " + this.name); var i = t.$$.ptrType.registeredClass; return it(t.$$.ptr, i, this.registeredClass) } var ot = {}; function nt(e, t) { return t.ptrType && t.ptr || Le("makeClassHandle requires ptr and ptrType"), !!t.smartPtrType != !!t.smartPtr && Le("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, $e(Object.create(e, { $$: { value: t } })) } function ht(e, t, i, s, r, a, o, n, h, l, c) { this.name = e, this.registeredClass = t, this.isReference = i, this.isConst = s, this.isSmartPointer = r, this.pointeeType = a, this.sharingPolicy = o, this.rawGetPointee = n, this.rawConstructor = h, this.rawShare = l, this.rawDestructor = c, r || void 0 !== t.baseClass ? this.toWireType = rt : (this.toWireType = s ? st : at, this.destructorFunction = null) } function lt(e, t, i) { a.hasOwnProperty(e) || Le("Replacing nonexistant public symbol"), void 0 !== a[e].overloadTable && void 0 !== i ? a[e].overloadTable[i] = t : (a[e] = t, a[e].argCount = i) } function ct(e, t) { var i, s, r, o = (e = Ue(e)).includes("j") ? (i = e, s = t, r = [], function () { r.length = arguments.length; for (var e, t, o, n, h = 0; h < arguments.length; h++)r[h] = arguments[h]; return t = s, o = r, (e = i).includes("j") ? (n = t, e = a["dynCall_" + e], o && o.length ? e.apply(null, [n].concat(o)) : e.call(null, n)) : k.get(t).apply(null, o) }) : k.get(t); return "function" != typeof o && Ve("unknown function pointer with signature " + e + ": " + t), o } var ut = void 0; function pt(e) { var t = Ue(e = Ht(e)); return Vt(e), t } function dt(e, t) { var i = [], s = {}; throw t.forEach((function e(t) { s[t] || Ae[t] || (De[t] ? De[t].forEach(e) : (i.push(t), s[t] = !0)) })), new ut(e + ": " + i.map(pt).join([", "])) } function mt(e, t) { for (var i = [], s = 0; s < e; s++)i.push(N[(t >> 2) + s >>> 0]); return i } function ft(e, t, i, s, r) { for (var a = t.length, o = (i = (a < 2 && Ve("argTypes array size mismatch! Must at least get return value and 'this' types!"), null !== t[1] && null !== i), !1), n = 1; n < t.length; ++n)if (null !== t[n] && void 0 === t[n].destructorFunction) { o = !0; break } var h = "void" !== t[0].name, l = "", c = ""; for (n = 0; n < a - 2; ++n)l += (0 !== n ? ", " : "") + "arg" + n, c += (0 !== n ? ", " : "") + "arg" + n + "Wired"; var u = "return function " + we(e) + "(" + l + ") {\nif (arguments.length !== " + (a - 2) + ") {\nthrowBindingError('function " + e + " called with ' + arguments.length + ' arguments, expected " + (a - 2) + " args!');\n}\n", p = (o && (u += "var destructors = [];\n"), o ? "destructors" : "null"), d = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"], m = [Ve, s, r, Ce, t[0], t[1]]; for (i && (u += "var thisWired = classParam.toWireType(" + p + ", this);\n"), n = 0; n < a - 2; ++n)u += "var arg" + n + "Wired = argType" + n + ".toWireType(" + p + ", arg" + n + "); // " + t[n + 2].name + "\n", d.push("argType" + n), m.push(t[n + 2]); if (u += (h ? "var rv = " : "") + "invoker(fn" + (0 < (c = i ? "thisWired" + (0 < c.length ? ", " : "") + c : c).length ? ", " : "") + c + ");\n", o) u += "runDestructors(destructors);\n"; else for (n = i ? 1 : 2; n < t.length; ++n) { var f = 1 === n ? "thisWired" : "arg" + (n - 2) + "Wired"; null !== t[n].destructorFunction && (u += f + "_dtor(" + f + "); // " + t[n].name + "\n", d.push(f + "_dtor"), m.push(t[n].destructorFunction)) } return h && (u += "var ret = retType.fromWireType(rv);\nreturn ret;\n"), d.push(u += "}\n"), function (e, t) { var i; if (e instanceof Function) return (i = Me(e.name || "unknownFunctionName", (function () { }))).prototype = e.prototype, i = new i, (t = e.apply(i, t)) instanceof Object ? t : i; throw new TypeError("new_ called with constructor type " + typeof e + " which is not a function") }(Function, d).apply(null, m) } var gt = [], _t = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }]; function vt(e) { 4 < e && 0 == --_t[e].refcount && (_t[e] = void 0, gt.push(e)) } function yt(e) { switch (e) { case void 0: return 1; case null: return 2; case !0: return 3; case !1: return 4; default: var t = gt.length ? gt.pop() : _t.length; return _t[t] = { refcount: 1, value: e }, t } } function Tt(e, t) { var i = Ae[e]; return void 0 === i && Ve(t + " has unknown type " + pt(e)), i } function It(e) { var t; return null === e ? "null" : "object" == (t = typeof e) || "array" == t || "function" == t ? e.toString() : "" + e } function Et(e) { return e || Ve("Cannot use deleted val. handle = " + e), _t[e].value } var Ct = {}; function Pt(e) { var t = Ct[e]; return void 0 === t ? Ue(e) : t } function bt() { return "object" == typeof globalThis ? globalThis : Function("return this")() } var At = g ? function () { var e = process.hrtime(); return 1e3 * e[0] + e[1] / 1e6 } : function () { return performance.now() }, Dt = {}; function Rt() { if (!Rt.strings) { var e = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: p || "./this.program" }; for (t in Dt) void 0 === Dt[t] ? delete e[t] : e[t] = Dt[t]; var t, i = []; for (t in e) i.push(t + "=" + e[t]); Rt.strings = i } return Rt.strings } function Ft(e) { return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0) } function wt(e, t) { for (var i = 0, s = 0; s <= t; i += e[s++]); return i } var Mt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], St = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function xt(e, t) { for (var i = new Date(e.getTime()); 0 < t;) { var s = Ft(i.getFullYear()), r = i.getMonth(); if (!(t > (s = (s ? Mt : St)[r]) - i.getDate())) return i.setDate(i.getDate() + t), i; t -= s - i.getDate() + 1, i.setDate(1), r < 11 ? i.setMonth(r + 1) : (i.setMonth(0), i.setFullYear(i.getFullYear() + 1)) } return i } function Lt(e, t, i, s) { this.parent = e = e || this, this.mount = e.mount, this.mounted = null, this.id = Te.nextInode++, this.name = t, this.mode = i, this.node_ops = {}, this.stream_ops = {}, this.rdev = s } Object.defineProperties(Lt.prototype, { read: { get: function () { return !(365 & ~this.mode) }, set: function (e) { e ? this.mode |= 365 : this.mode &= -366 } }, write: { get: function () { return !(146 & ~this.mode) }, set: function (e) { e ? this.mode |= 146 : this.mode &= -147 } }, isFolder: { get: function () { return Te.isDir(this.mode) } }, isDevice: { get: function () { return Te.isChrdev(this.mode) } } }), Te.FSNode = Lt, Te.staticInit(), a.FS_createPath = Te.createPath, a.FS_createDataFile = Te.createDataFile, a.FS_createPreloadedFile = Te.createPreloadedFile, a.FS_createLazyFile = Te.createLazyFile, a.FS_createDevice = Te.createDevice, a.FS_unlink = Te.unlink; xe = a.InternalError = Se(Error, "InternalError"); for (var Ot = new Array(256), Nt = 0; Nt < 256; ++Nt)Ot[Nt] = String.fromCharCode(Nt); function Bt(e, t, i) { return i = 0 < i ? i : w(e) + 1, e = R(e, i = new Array(i), 0, i.length), t && (i.length = e), i } Ge = Ot, ke = a.BindingError = Se(Error, "BindingError"), Qe.prototype.isAliasOf = function (e) { if (!(this instanceof Qe)) return !1; if (!(e instanceof Qe)) return !1; for (var t = this.$$.ptrType.registeredClass, i = this.$$.ptr, s = e.$$.ptrType.registeredClass, r = e.$$.ptr; t.baseClass;)i = t.upcast(i), t = t.baseClass; for (; s.baseClass;)r = s.upcast(r), s = s.baseClass; return t === s && i === r }, Qe.prototype.clone = function () { var e; return this.$$.ptr || je(this), this.$$.preservePointerOnDelete ? (this.$$.count.value += 1, this) : ((e = $e(Object.create(Object.getPrototypeOf(this), { $$: { value: { count: (e = this.$$).count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType } } }))).$$.count.value += 1, e.$$.deleteScheduled = !1, e) }, Qe.prototype.delete = function () { this.$$.ptr || je(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Ve("Object already scheduled for deletion"), We(this), Ye(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0) }, Qe.prototype.isDeleted = function () { return !this.$$.ptr }, Qe.prototype.deleteLater = function () { return this.$$.ptr || je(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Ve("Object already scheduled for deletion"), Ke.push(this), 1 === Ke.length && Xe && Xe(Je), this.$$.deleteScheduled = !0, this }, ht.prototype.getPointee = function (e) { return this.rawGetPointee ? this.rawGetPointee(e) : e }, ht.prototype.destructor = function (e) { this.rawDestructor && this.rawDestructor(e) }, ht.prototype.argPackAdvance = 8, ht.prototype.readValueFromPointer = Pe, ht.prototype.deleteObject = function (e) { null !== e && e.delete() }, ht.prototype.fromWireType = function (e) { var t, i, s = this.getPointee(e); return s ? void 0 !== (i = function (e, t) { for (void 0 === t && Ve("ptr should not be undefined"); e.baseClass;)t = e.upcast(t), e = e.baseClass; return t }(i = this.registeredClass, i = s), i = ot[i]) ? 0 === i.$$.count.value ? (i.$$.ptr = s, i.$$.smartPtr = e, i.clone()) : (i = i.clone(), this.destructor(e), i) : (i = this.registeredClass.getActualType(s), (i = Ze[i]) && (i = this.isConst ? i.constPointerType : i.pointerType, null !== (t = function e(t, i, s) { return i === s ? t : void 0 === s.baseClass || null === (t = e(t, i, s.baseClass)) ? null : s.downcast(t) }(s, this.registeredClass, i.registeredClass))) ? this.isSmartPointer ? nt(i.registeredClass.instancePrototype, { ptrType: i, ptr: t, smartPtrType: this, smartPtr: e }) : nt(i.registeredClass.instancePrototype, { ptrType: i, ptr: t }) : function () { return this.isSmartPointer ? nt(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: s, smartPtrType: this, smartPtr: e }) : nt(this.registeredClass.instancePrototype, { ptrType: this, ptr: e }) }.call(this)) : (this.destructor(e), null) }, a.getInheritedInstanceCount = function () { return Object.keys(ot).length }, a.getLiveInheritedInstances = function () { var e, t = []; for (e in ot) ot.hasOwnProperty(e) && t.push(ot[e]); return t }, a.flushPendingDeletes = Je, a.setDelayFunction = function (e) { Xe = e, Ke.length && Xe && Xe(Je) }, ut = a.UnboundTypeError = Se(Error, "UnboundTypeError"), a.count_emval_handles = function () { for (var e = 0, t = 5; t < _t.length; ++t)void 0 !== _t[t] && ++e; return e }, a.get_first_emval = function () { for (var e = 5; e < _t.length; ++e)if (void 0 !== _t[e]) return _t[e]; return null }; var Gt, Ut = { y: function (e, t, i, s) { le("Assertion failed: " + D(e) + ", at: " + [t ? D(t) : "unknown filename", i, s ? D(s) : "unknown function"]) }, x: function (e) { return kt(e + 16) + 16 }, w: function (e, t, i) { throw new me(e).init(t, i), e }, A: function (e, t, i) { Ie.varargs = i; try { var s = Ie.getStreamFromFD(e); switch (t) { case 0: return (r = Ie.get()) < 0 ? -28 : Te.open(s.path, s.flags, 0, r).fd; case 1: case 2: case 13: case 14: return 0; case 3: return s.flags; case 4: var r = Ie.get(); return s.flags |= r, 0; case 12: return r = Ie.get(), L[r + 0 >>> 1] = 2, 0; case 16: case 8: default: return -28; case 9: return fe(28), -1 } } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), -e.errno } }, O: function (e, t, i) { Ie.varargs = i; try { var s = Ie.getStreamFromFD(e); switch (t) { case 21509: case 21505: case 21510: case 21511: case 21512: case 21506: case 21507: case 21508: case 21523: case 21524: return s.tty ? 0 : -59; case 21519: return s.tty ? (r = Ie.get(), N[r >>> 2] = 0) : -59; case 21520: return s.tty ? -28 : -59; case 21531: var r = Ie.get(); return Te.ioctl(s, t, r); default: le("bad ioctl syscall " + t) } } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), -e.errno } }, P: function (e, t, i) { Ie.varargs = i; try { var s = Ie.getStr(e), r = i ? Ie.get() : 0; return Te.open(s, t, r).fd } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), -e.errno } }, Z: function (e) { var t = Ee[e], i = (delete Ee[e], t.elements), s = i.length, r = i.map((function (e) { return e.getterReturnType })).concat(i.map((function (e) { return e.setterArgumentType }))), a = t.rawConstructor, o = t.rawDestructor; Oe([e], r, (function (e) { return i.forEach((function (t, i) { var r = e[i], a = t.getter, o = t.getterContext, n = e[i + s], h = t.setter, l = t.setterContext; t.read = function (e) { return r.fromWireType(a(o, e)) }, t.write = function (e, t) { var i = []; h(l, e, n.toWireType(i, t)), Ce(i) } })), [{ name: t.name, fromWireType: function (e) { for (var t = new Array(s), r = 0; r < s; ++r)t[r] = i[r].read(e); return o(e), t }, toWireType: function (e, r) { if (s !== r.length) throw new TypeError("Incorrect number of tuple elements for " + t.name + ": expected=" + s + ", actual=" + r.length); for (var n = a(), h = 0; h < s; ++h)i[h].write(n, r[h]); return null !== e && e.push(o, n), n }, argPackAdvance: 8, readValueFromPointer: Pe, destructorFunction: o }] })) }, o: function (e) { var t = Ne[e], i = (delete Ne[e], t.rawConstructor), s = t.rawDestructor, r = t.fields; Oe([e], r.map((function (e) { return e.getterReturnType })).concat(r.map((function (e) { return e.setterArgumentType }))), (function (e) { var a = {}; return r.forEach((function (t, i) { var s = t.fieldName, o = e[i], n = t.getter, h = t.getterContext, l = e[i + r.length], c = t.setter, u = t.setterContext; a[s] = { read: function (e) { return o.fromWireType(n(h, e)) }, write: function (e, t) { var i = []; c(u, e, l.toWireType(i, t)), Ce(i) } } })), [{ name: t.name, fromWireType: function (e) { var t, i = {}; for (t in a) i[t] = a[t].read(e); return s(e), i }, toWireType: function (e, t) { for (var r in a) if (!(r in t)) throw new TypeError('Missing field:  "' + r + '"'); var o = i(); for (r in a) a[r].write(o, t[r]); return null !== e && e.push(s, o), o }, argPackAdvance: 8, readValueFromPointer: Pe, destructorFunction: s }] })) }, J: function (e, t, i, s, r) { }, W: function (e, t, i, s, r) { var a = Be(i); He(e, { name: t = Ue(t), fromWireType: function (e) { return !!e }, toWireType: function (e, t) { return t ? s : r }, argPackAdvance: 8, readValueFromPointer: function (e) { var s; if (1 === i) s = S; else if (2 === i) s = L; else { if (4 !== i) throw new TypeError("Unknown boolean type size: " + t); s = N } return this.fromWireType(s[e >>> a]) }, destructorFunction: null }) }, r: function (e, t, i, s, r, a, o, n, h, l, c, u, p) { c = Ue(c), a = ct(r, a), n = n && ct(o, n), l = l && ct(h, l), p = ct(u, p); var d = we(c); et(d, (function () { dt("Cannot construct " + c + " due to unbound types", [s]) })), Oe([e, t, i], s ? [s] : [], (function (t) { t = t[0], t = s ? (h = t.registeredClass).instancePrototype : Qe.prototype; var i = Me(d, (function () { if (Object.getPrototypeOf(this) !== r) throw new ke("Use 'new' to construct " + c); if (void 0 === o.constructor_body) throw new ke(c + " has no accessible constructor"); var e = o.constructor_body[arguments.length]; if (void 0 === e) throw new ke("Tried to invoke ctor of " + c + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(o.constructor_body).toString() + ") parameters instead!"); return e.apply(this, arguments) })), r = Object.create(t, { constructor: { value: i } }), o = (i.prototype = r, new tt(c, i, r, p, h, a, n, l)), h = (t = new ht(c, o, !0, !1, !1), new ht(c + "*", o, !1, !1, !1)), u = new ht(c + " const*", o, !1, !0, !1); return Ze[e] = { pointerType: h, constPointerType: u }, lt(d, i), [t, h, u] })) }, q: function (e, t, i, s, r, a) { P(0 < t); var o = mt(t, i), n = (r = ct(s, r), [a]), h = []; Oe([], [e], (function (e) { var i = "constructor " + (e = e[0]).name; if (void 0 === e.registeredClass.constructor_body && (e.registeredClass.constructor_body = []), void 0 !== e.registeredClass.constructor_body[t - 1]) throw new ke("Cannot register multiple constructors with identical number of parameters (" + (t - 1) + ") for class '" + e.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!"); return e.registeredClass.constructor_body[t - 1] = function () { dt("Cannot construct " + e.name + " due to unbound types", o) }, Oe([], o, (function (s) { return e.registeredClass.constructor_body[t - 1] = function () { arguments.length !== t - 1 && Ve(i + " called with " + arguments.length + " arguments, expected " + (t - 1)), h.length = 0, n.length = t; for (var e = 1; e < t; ++e)n[e] = s[e].toWireType(h, arguments[e - 1]); var a = r.apply(null, n); return Ce(h), s[0].fromWireType(a) }, [] })), [] })) }, b: function (e, t, i, s, r, a, o, n) { var h = mt(i, s); t = Ue(t), a = ct(r, a), Oe([], [e], (function (e) { var s = (e = e[0]).name + "." + t; function r() { dt("Cannot call " + s + " due to unbound types", h) } t.startsWith("@@") && (t = Symbol[t.substring(2)]), n && e.registeredClass.pureVirtualFunctions.push(t); var l = e.registeredClass.instancePrototype, c = l[t]; return void 0 === c || void 0 === c.overloadTable && c.className !== e.name && c.argCount === i - 2 ? (r.argCount = i - 2, r.className = e.name, l[t] = r) : (qe(l, t, s), l[t].overloadTable[i - 2] = r), Oe([], h, (function (r) { return r = ft(s, r, e, a, o), void 0 === l[t].overloadTable ? (r.argCount = i - 2, l[t] = r) : l[t].overloadTable[i - 2] = r, [] })), [] })) }, V: function (e, t) { He(e, { name: t = Ue(t), fromWireType: function (e) { var t = _t[e].value; return vt(e), t }, toWireType: function (e, t) { return yt(t) }, argPackAdvance: 8, readValueFromPointer: Pe, destructorFunction: null }) }, Y: function (e, t, i, s) { function r() { } i = Be(i), t = Ue(t), r.values = {}, He(e, { name: t, constructor: r, fromWireType: function (e) { return this.constructor.values[e] }, toWireType: function (e, t) { return t.value }, argPackAdvance: 8, readValueFromPointer: function (e, t) { switch (i) { case 0: return function (e) { var i = t ? S : x; return this.fromWireType(i[e >>> 0]) }; case 1: return function (e) { var i = t ? L : O; return this.fromWireType(i[e >>> 1]) }; case 2: return function (e) { var i = t ? N : B; return this.fromWireType(i[e >>> 2]) }; default: throw new TypeError("Unknown integer type: " + e) } }(t, s), destructorFunction: null }), et(t, r) }, t: function (e, t, i) { e = Tt(e, "enum"); var s = (t = Ue(t), e.constructor); e = Object.create(e.constructor.prototype, { value: { value: i }, constructor: { value: Me(e.name + "_" + t, (function () { })) } }); s.values[i] = e, s[t] = e }, D: function (e, t, i) { i = Be(i), He(e, { name: t = Ue(t), fromWireType: function (e) { return e }, toWireType: function (e, t) { if ("number" != typeof t && "boolean" != typeof t) throw new TypeError('Cannot convert "' + It(t) + '" to ' + this.name); return t }, argPackAdvance: 8, readValueFromPointer: function (e) { switch (i) { case 2: return function (e) { return this.fromWireType(G[e >>> 2]) }; case 3: return function (e) { return this.fromWireType(U[e >>> 3]) }; default: throw new TypeError("Unknown float type: " + e) } }(t), destructorFunction: null }) }, e: function (e, t, i, s, r, a) { var o = mt(t, i); e = Ue(e), r = ct(s, r), et(e, (function () { dt("Cannot call " + e + " due to unbound types", o) }), t - 1), Oe([], o, (function (i) { return i = [i[0], null].concat(i.slice(1)), lt(e, ft(e, i, null, r, a), t - 1), [] })) }, n: function (e, t, i, s, r) { t = Ue(t), -1 === r && (r = 4294967295); var a, o = Be(i), n = function (e) { return e }, h = (0 === s && (a = 32 - 8 * i, n = function (e) { return e << a >>> a }), t.includes("unsigned")); He(e, { name: t, fromWireType: n, toWireType: function (e, i) { if ("number" != typeof i && "boolean" != typeof i) throw new TypeError('Cannot convert "' + It(i) + '" to ' + this.name); if (i < s || r < i) throw new TypeError('Passing a number "' + It(i) + '" from JS side to C/C++ side to an argument of type "' + t + '", which is outside the valid range [' + s + ", " + r + "]!"); return h ? i >>> 0 : 0 | i }, argPackAdvance: 8, readValueFromPointer: function (e, t) { switch (o) { case 0: return t ? function (e) { return S[e >>> 0] } : function (e) { return x[e >>> 0] }; case 1: return t ? function (e) { return L[e >>> 1] } : function (e) { return O[e >>> 1] }; case 2: return t ? function (e) { return N[e >>> 2] } : function (e) { return B[e >>> 2] }; default: throw new TypeError("Unknown integer type: " + e) } }(t, 0 !== s), destructorFunction: null }) }, j: function (e, t, i) { var s = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][t]; function r(e) { var t = B[(e >>= 2) >>> 0]; e = B[e + 1 >>> 0]; return new s(M, e, t) } He(e, { name: i = Ue(i), fromWireType: r, argPackAdvance: 8, readValueFromPointer: r }, { ignoreDuplicateRegistrations: !0 }) }, E: function (e, t) { var i = "std::string" === (t = Ue(t)); He(e, { name: t, fromWireType: function (e) { var t = B[e >>> 2]; if (i) for (var s = e + 4, r = 0; r <= t; ++r) { var a, o, n = e + 4 + r; r != t && 0 != x[n >>> 0] || (a = D(s, n - s), o = void 0 === o ? a : o + String.fromCharCode(0) + a, s = n + 1) } else { var h = new Array(t); for (r = 0; r < t; ++r)h[r] = String.fromCharCode(x[e + 4 + r >>> 0]); o = h.join("") } return Vt(e), o }, toWireType: function (e, t) { var s = "string" == typeof (t = t instanceof ArrayBuffer ? new Uint8Array(t) : t), r = (s || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int8Array || Ve("Cannot pass non-string to std::string"), (i && s ? function () { return w(t) } : function () { return t.length })()), a = kt(4 + r + 1); if (B[(a >>>= 0) >>> 2] = r, i && s) F(t, 4 + a, r + 1); else if (s) for (var o = 0; o < r; ++o) { var n = t.charCodeAt(o); 255 < n && (Vt(a), Ve("String has UTF-16 code units that do not fit in 8 bits")), x[4 + a + o >>> 0] = n } else for (o = 0; o < r; ++o)x[4 + a + o >>> 0] = t[o]; return null !== e && e.push(Vt, a), a }, argPackAdvance: 8, readValueFromPointer: Pe, destructorFunction: function (e) { Vt(e) } }) }, v: function (e, t, i) { var s, r, a, o, n; i = Ue(i), 2 === t ? (s = H, r = j, o = z, a = function () { return O }, n = 1) : 4 === t && (s = W, r = Y, o = $, a = function () { return B }, n = 2), He(e, { name: i, fromWireType: function (e) { for (var i = B[e >>> 2], r = a(), o = e + 4, h = 0; h <= i; ++h) { var l, c, u = e + 4 + h * t; h != i && 0 != r[u >>> n] || (l = s(o, u - o), c = void 0 === c ? l : c + String.fromCharCode(0) + l, o = u + t) } return Vt(e), c }, toWireType: function (e, s) { "string" != typeof s && Ve("Cannot pass non-string to C++ string type " + i); var a = o(s), h = kt(4 + a + t); return B[(h >>>= 0) >>> 2] = a >> n, r(s, 4 + h, a + t), null !== e && e.push(Vt, h), h }, argPackAdvance: 8, readValueFromPointer: Pe, destructorFunction: function (e) { Vt(e) } }) }, _: function (e, t, i, s, r, a) { Ee[e] = { name: Ue(t), rawConstructor: ct(i, s), rawDestructor: ct(r, a), elements: [] } }, g: function (e, t, i, s, r, a, o, n, h) { Ee[e].elements.push({ getterReturnType: t, getter: ct(i, s), getterContext: r, setterArgumentType: a, setter: ct(o, n), setterContext: h }) }, p: function (e, t, i, s, r, a) { Ne[e] = { name: Ue(t), rawConstructor: ct(i, s), rawDestructor: ct(r, a), fields: [] } }, d: function (e, t, i, s, r, a, o, n, h, l) { Ne[e].fields.push({ fieldName: Ue(t), getterReturnType: i, getter: ct(s, r), getterContext: a, setterArgumentType: o, setter: ct(n, h), setterContext: l }) }, X: function (e, t) { He(e, { isVoid: !0, name: t = Ue(t), argPackAdvance: 0, fromWireType: function () { }, toWireType: function (e, t) { } }) }, l: function (e, t, i) { e = Et(e), t = Tt(t, "emval::as"); var s = [], r = yt(s); return N[i >>> 2] = r, t.toWireType(s, e) }, F: function (e, t, i, s) { e = Et(e); for (var r = function (e, t) { for (var i = new Array(e), s = 0; s < e; ++s)i[s] = Tt(N[(t >> 2) + s >>> 0], "parameter " + s); return i }(t, i), a = new Array(t), o = 0; o < t; ++o) { var n = r[o]; a[o] = n.readValueFromPointer(s), s += n.argPackAdvance } return yt(e.apply(void 0, a)) }, a: vt, H: function (e) { return 0 === e ? yt(bt()) : (e = Pt(e), yt(bt()[e])) }, m: function (e, t) { return yt((e = Et(e))[t = Et(t)]) }, i: function (e) { 4 < e && (_t[e].refcount += 1) }, L: function (e, t) { return (e = Et(e)) instanceof Et(t) }, G: function (e) { return "number" == typeof Et(e) }, z: function () { return yt([]) }, f: function (e) { return yt(Pt(e)) }, s: function () { return yt({}) }, k: function (e) { Ce(_t[e].value), vt(e) }, h: function (e, t, i) { e = Et(e), t = Et(t), i = Et(i), e[t] = i }, c: function (e, t) { return yt((e = Tt(e, "_emval_take_value")).readValueFromPointer(t)) }, C: function () { le() }, N: function (e, t) { var i; if (0 === e) i = Date.now(); else { if (1 !== e && 4 !== e) return fe(28), -1; i = At() } return N[t >>> 2] = i / 1e3 | 0, N[t + 4 >>> 2] = i % 1e3 * 1e3 * 1e3 | 0, 0 }, M: function (e, t, i) { x.copyWithin(e >>> 0, t >>> 0, t + i >>> 0) }, u: function (e) { var t = x.length; if (!(4294901760 < (e >>>= 0))) for (var i = 1; i <= 4; i *= 2) { var s = t * (1 + .2 / i); s = Math.min(s, e + 100663296); if (function (e) { try { return I.grow(e - M.byteLength + 65535 >>> 16), X(I.buffer), 1 } catch (e) { } }(Math.min(4294901760, (0 < (s = Math.max(e, s)) % 65536 && (s += 65536 - s % 65536), s)))) return !0 } return !1 }, R: function (e, t) { try { var i = 0; return Rt().forEach((function (s, r) { for (var a = t + i, o = s, n = N[e + 4 * r >>> 2] = a, h = (r = void 0, 0); h < o.length; ++h)S[n++ >>> 0] = o.charCodeAt(h); r || (S[n >>> 0] = 0), i += s.length + 1 })), 0 } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, S: function (e, t) { try { var i = Rt(), s = (N[e >>> 2] = i.length, 0); return i.forEach((function (e) { s += e.length + 1 })), N[t >>> 2] = s, 0 } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, B: function (e) { try { var t = Ie.getStreamFromFD(e); return Te.close(t), 0 } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, U: function (e, t, i, s) { try { var r = Ie.getStreamFromFD(e), a = Ie.doReadv(r, t, i); return N[s >>> 2] = a, 0 } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, I: function (e, t, i, s, r) { try { var a = Ie.getStreamFromFD(e), o = 4294967296 * i + (t >>> 0), n = 9007199254740992; return o <= -n || n <= o ? -61 : (Te.llseek(a, o, s), re = [a.position >>> 0, (se = a.position, 1 <= +Math.abs(se) ? 0 < se ? (0 | Math.min(+Math.floor(se / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((se - (~~se >>> 0)) / 4294967296) >>> 0 : 0)], N[r >>> 2] = re[0], N[r + 4 >>> 2] = re[1], a.getdents && 0 == o && 0 === s && (a.getdents = null), 0) } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, T: function (e, t, i, s) { try { var r = Ie.getStreamFromFD(e), a = Ie.doWritev(r, t, i); return N[s >>> 2] = a, 0 } catch (e) { return void 0 !== Te && e instanceof Te.ErrnoError || le(e), e.errno } }, K: function (e) { }, Q: function (e, t, i, s) { var r = N[s + 40 >>> 2], a = { tm_sec: N[s >>> 2], tm_min: N[s + 4 >>> 2], tm_hour: N[s + 8 >>> 2], tm_mday: N[s + 12 >>> 2], tm_mon: N[s + 16 >>> 2], tm_year: N[s + 20 >>> 2], tm_wday: N[s + 24 >>> 2], tm_yday: N[s + 28 >>> 2], tm_isdst: N[s + 32 >>> 2], tm_gmtoff: N[s + 36 >>> 2], tm_zone: r ? D(r) : "" }, o = D(i), n = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }; for (f in n) o = o.replace(new RegExp(f, "g"), n[f]); var h = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], l = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function c(e, t, i) { for (var s = "number" == typeof e ? e.toString() : e || ""; s.length < t;)s = i[0] + s; return s } function u(e, t) { return c(e, t, "0") } function p(e, t) { function i(e) { return e < 0 ? -1 : 0 < e ? 1 : 0 } var s; return 0 === (s = i(e.getFullYear() - t.getFullYear())) && 0 === (s = i(e.getMonth() - t.getMonth())) ? i(e.getDate() - t.getDate()) : s } function d(e) { switch (e.getDay()) { case 0: return new Date(e.getFullYear() - 1, 11, 29); case 1: return e; case 2: return new Date(e.getFullYear(), 0, 3); case 3: return new Date(e.getFullYear(), 0, 2); case 4: return new Date(e.getFullYear(), 0, 1); case 5: return new Date(e.getFullYear() - 1, 11, 31); case 6: return new Date(e.getFullYear() - 1, 11, 30) } } function m(e) { e = xt(new Date(e.tm_year + 1900, 0, 1), e.tm_yday); var t = new Date(e.getFullYear(), 0, 4), i = new Date(e.getFullYear() + 1, 0, 4); t = d(t), i = d(i); return p(t, e) <= 0 ? p(i, e) <= 0 ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1 } var f, g = { "%a": function (e) { return h[e.tm_wday].substring(0, 3) }, "%A": function (e) { return h[e.tm_wday] }, "%b": function (e) { return l[e.tm_mon].substring(0, 3) }, "%B": function (e) { return l[e.tm_mon] }, "%C": function (e) { return u((e.tm_year + 1900) / 100 | 0, 2) }, "%d": function (e) { return u(e.tm_mday, 2) }, "%e": function (e) { return c(e.tm_mday, 2, " ") }, "%g": function (e) { return m(e).toString().substring(2) }, "%G": m, "%H": function (e) { return u(e.tm_hour, 2) }, "%I": function (e) { return 0 == (e = e.tm_hour) ? e = 12 : 12 < e && (e -= 12), u(e, 2) }, "%j": function (e) { return u(e.tm_mday + wt(Ft(e.tm_year + 1900) ? Mt : St, e.tm_mon - 1), 3) }, "%m": function (e) { return u(e.tm_mon + 1, 2) }, "%M": function (e) { return u(e.tm_min, 2) }, "%n": function () { return "\n" }, "%p": function (e) { return 0 <= e.tm_hour && e.tm_hour < 12 ? "AM" : "PM" }, "%S": function (e) { return u(e.tm_sec, 2) }, "%t": function () { return "\t" }, "%u": function (e) { return e.tm_wday || 7 }, "%U": function (e) { var t, i = new Date(e.tm_year + 1900, 0, 1), s = 0 === i.getDay() ? i : xt(i, 7 - i.getDay()); return p(s, e = new Date(e.tm_year + 1900, e.tm_mon, e.tm_mday)) < 0 ? (t = wt(Ft(e.getFullYear()) ? Mt : St, e.getMonth() - 1) - 31, t = 31 - s.getDate() + t + e.getDate(), u(Math.ceil(t / 7), 2)) : 0 === p(s, i) ? "01" : "00" }, "%V": function (e) { var t = new Date(e.tm_year + 1900, 0, 4), i = new Date(e.tm_year + 1901, 0, 4), s = (t = d(t), i = d(i), xt(new Date(e.tm_year + 1900, 0, 1), e.tm_yday)); return p(s, t) < 0 ? "53" : p(i, s) <= 0 ? "01" : (i = t.getFullYear() < e.tm_year + 1900 ? e.tm_yday + 32 - t.getDate() : e.tm_yday + 1 - t.getDate(), u(Math.ceil(i / 7), 2)) }, "%w": function (e) { return e.tm_wday }, "%W": function (e) { var t, i = new Date(e.tm_year, 0, 1), s = 1 === i.getDay() ? i : xt(i, 0 === i.getDay() ? 1 : 7 - i.getDay() + 1); return p(s, e = new Date(e.tm_year + 1900, e.tm_mon, e.tm_mday)) < 0 ? (t = wt(Ft(e.getFullYear()) ? Mt : St, e.getMonth() - 1) - 31, t = 31 - s.getDate() + t + e.getDate(), u(Math.ceil(t / 7), 2)) : 0 === p(s, i) ? "01" : "00" }, "%y": function (e) { return (e.tm_year + 1900).toString().substring(2) }, "%Y": function (e) { return e.tm_year + 1900 }, "%z": function (e) { var t = 0 <= (e = e.tm_gmtoff); e = Math.abs(e) / 60; return (t ? "+" : "-") + String("0000" + (e / 60 * 100 + e % 60)).slice(-4) }, "%Z": function (e) { return e.tm_zone }, "%%": function () { return "%" } }; for (f in g) o.includes(f) && (o = o.replace(new RegExp(f, "g"), g[f](a))); return (s = Bt(o, !1)).length > t ? 0 : (S.set(s, e >>> 0), s.length - 1) } }, kt = (function () { var e = { a: Ut }; function t(e, t) { e = e.exports, a.asm = e, X((I = a.asm.$).buffer), k = a.asm.ha, e = a.asm.aa, J.unshift(e), he() } function s(e) { t(e.instance) } function r(t) { return function () { if (!v && (m || f)) { if ("function" == typeof fetch && !ue(te)) return fetch(te, { credentials: "same-origin" }).then((function (e) { if (e.ok) return e.arrayBuffer(); throw "failed to load wasm binary file at '" + te + "'" })).catch((function () { return pe(te) })); if (h) return new Promise((function (e, t) { h(te, (function (t) { e(new Uint8Array(t)) }), t) })) } return Promise.resolve().then((function () { return pe(te) })) }().then((function (t) { return WebAssembly.instantiate(t, e) })).then(t, (function (e) { T("failed to asynchronously prepare wasm: " + e), le(e) })) } if (ne(), a.instantiateWasm) try { return a.instantiateWasm(e, t) } catch (e) { return T("Module.instantiateWasm callback failed with error: " + e) } (v || "function" != typeof WebAssembly.instantiateStreaming || ce(te) || ue(te) || "function" != typeof fetch ? r(s) : fetch(te, { credentials: "same-origin" }).then((function (t) { return WebAssembly.instantiateStreaming(t, e).then(s, (function (e) { return T("wasm streaming compile failed: " + e), T("falling back to ArrayBuffer instantiation"), r(s) })) }))).catch(i) }(), a.___wasm_call_ctors = function () { return (a.___wasm_call_ctors = a.asm.aa).apply(null, arguments) }, a._main = function () { return (a._main = a.asm.ba).apply(null, arguments) }, a._malloc = function () { return (kt = a._malloc = a.asm.ca).apply(null, arguments) }), Vt = a._free = function () { return (Vt = a._free = a.asm.da).apply(null, arguments) }, Ht = a.___getTypeName = function () { return (Ht = a.___getTypeName = a.asm.ea).apply(null, arguments) }, jt = (a.___embind_register_native_and_builtin_types = function () { return (a.___embind_register_native_and_builtin_types = a.asm.fa).apply(null, arguments) }, a.___errno_location = function () { return (jt = a.___errno_location = a.asm.ga).apply(null, arguments) }); function zt(e) { this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e } function Wt(e) { function i() { if (!Gt && (Gt = !0, a.calledRun = !0, !C)) { if (a.noFSInit || Te.init.initialized || Te.init(), Te.ignorePermissions = !1, de(J), de(Q), t(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), Yt) { var e = a._main; try { var i = e(0, 0); ee() || (a.onExit && a.onExit(i), C = !0), d(i, new zt(i)) } catch (i) { i instanceof zt || "unwind" == i || ((e = i) && "object" == typeof i && i.stack && (e = [i, i.stack]), T("exception thrown: " + e), d(1, i)) } } if (a.postRun) for ("function" == typeof a.postRun && (a.postRun = [a.postRun]); a.postRun.length;)s = a.postRun.shift(), Z.unshift(s); var s; de(Z) } } 0 < ae || (function () { if (a.preRun) for ("function" == typeof a.preRun && (a.preRun = [a.preRun]); a.preRun.length;)e = a.preRun.shift(), K.unshift(e); var e; de(K) }(), 0 < ae) || (a.setStatus ? (a.setStatus("Running..."), setTimeout((function () { setTimeout((function () { a.setStatus("") }), 1), i() }), 1)) : i()) } if (a.dynCall_jiji = function () { return (a.dynCall_jiji = a.asm.ia).apply(null, arguments) }, a.dynCall_viijii = function () { return (a.dynCall_viijii = a.asm.ja).apply(null, arguments) }, a.dynCall_iiiiij = function () { return (a.dynCall_iiiiij = a.asm.ka).apply(null, arguments) }, a.dynCall_iiiiijj = function () { return (a.dynCall_iiiiijj = a.asm.la).apply(null, arguments) }, a.dynCall_iiiiiijj = function () { return (a.dynCall_iiiiiijj = a.asm.ma).apply(null, arguments) }, a.addRunDependency = ne, a.removeRunDependency = he, a.FS_createPath = Te.createPath, a.FS_createDataFile = Te.createDataFile, a.FS_createPreloadedFile = Te.createPreloadedFile, a.FS_createLazyFile = Te.createLazyFile, a.FS_createDevice = Te.createDevice, a.FS_unlink = Te.unlink, a.FS = Te, oe = function e() { Gt || Wt(), Gt || (oe = e) }, a.run = Wt, a.preInit) for ("function" == typeof a.preInit && (a.preInit = [a.preInit]); 0 < a.preInit.length;)a.preInit.pop()(); var Yt = !0; return a.noInitialRun && (Yt = !1), Wt(), e.ready } var s = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0; "undefined" != typeof __filename && (s = s || __filename), "object" == typeof e && "object" == typeof t ? t.exports = i : "function" == typeof define && define.amd ? define([], (function () { return i })) : "object" == typeof e && (e.WebIFCWasm = i) } }), IFCACTIONREQUEST = 3821786052, IFCACTOR = 2296667514, IFCACTORROLE = 3630933823, IFCACTUATOR = 4288193352, IFCACTUATORTYPE = 2874132201, IFCADDRESS = 618182010, IFCADVANCEDBREP = 1635779807, IFCADVANCEDBREPWITHVOIDS = 2603310189, IFCADVANCEDFACE = 3406155212, IFCAIRTERMINAL = 1634111441, IFCAIRTERMINALBOX = 177149247, IFCAIRTERMINALBOXTYPE = 1411407467, IFCAIRTERMINALTYPE = 3352864051, IFCAIRTOAIRHEATRECOVERY = 2056796094, IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353, IFCALARM = 3087945054, IFCALARMTYPE = 3001207471, IFCALIGNMENT = 325726236, IFCALIGNMENT2DHORIZONTAL = 749761778, IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722, IFCALIGNMENT2DSEGMENT = 2483840362, IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081, IFCALIGNMENT2DVERSEGLINE = 3239324667, IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512, IFCALIGNMENT2DVERTICAL = 53199957, IFCALIGNMENT2DVERTICALSEGMENT = 2029264950, IFCALIGNMENTCURVE = 3512275521, IFCANNOTATION = 1674181508, IFCANNOTATIONFILLAREA = 669184980, IFCAPPLICATION = 639542469, IFCAPPLIEDVALUE = 411424972, IFCAPPROVAL = 130549933, IFCAPPROVALRELATIONSHIP = 3869604511, IFCARBITRARYCLOSEDPROFILEDEF = 3798115385, IFCARBITRARYOPENPROFILEDEF = 1310608509, IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697, IFCASSET = 3460190687, IFCASYMMETRICISHAPEPROFILEDEF = 3207858831, IFCAUDIOVISUALAPPLIANCE = 277319702, IFCAUDIOVISUALAPPLIANCETYPE = 1532957894, IFCAXIS1PLACEMENT = 4261334040, IFCAXIS2PLACEMENT2D = 3125803723, IFCAXIS2PLACEMENT3D = 2740243338, IFCBSPLINECURVE = 1967976161, IFCBSPLINECURVEWITHKNOTS = 2461110595, IFCBSPLINESURFACE = 2887950389, IFCBSPLINESURFACEWITHKNOTS = 167062518, IFCBEAM = 753842376, IFCBEAMSTANDARDCASE = 2906023776, IFCBEAMTYPE = 819618141, IFCBEARING = 4196446775, IFCBEARINGTYPE = 3649138523, IFCBLOBTEXTURE = 616511568, IFCBLOCK = 1334484129, IFCBOILER = 32344328, IFCBOILERTYPE = 231477066, IFCBOOLEANCLIPPINGRESULT = 3649129432, IFCBOOLEANRESULT = 2736907675, IFCBOUNDARYCONDITION = 4037036970, IFCBOUNDARYCURVE = 1136057603, IFCBOUNDARYEDGECONDITION = 1560379544, IFCBOUNDARYFACECONDITION = 3367102660, IFCBOUNDARYNODECONDITION = 1387855156, IFCBOUNDARYNODECONDITIONWARPING = 2069777674, IFCBOUNDEDCURVE = 1260505505, IFCBOUNDEDSURFACE = 4182860854, IFCBOUNDINGBOX = 2581212453, IFCBOXEDHALFSPACE = 2713105998, IFCBRIDGE = 644574406, IFCBRIDGEPART = 963979645, IFCBUILDING = 4031249490, IFCBUILDINGELEMENT = 3299480353, IFCBUILDINGELEMENTPART = 2979338954, IFCBUILDINGELEMENTPARTTYPE = 39481116, IFCBUILDINGELEMENTPROXY = 1095909175, IFCBUILDINGELEMENTPROXYTYPE = 1909888760, IFCBUILDINGELEMENTTYPE = 1950629157, IFCBUILDINGSTOREY = 3124254112, IFCBUILDINGSYSTEM = 1177604601, IFCBURNER = 2938176219, IFCBURNERTYPE = 2188180465, IFCCSHAPEPROFILEDEF = 2898889636, IFCCABLECARRIERFITTING = 635142910, IFCCABLECARRIERFITTINGTYPE = 395041908, IFCCABLECARRIERSEGMENT = 3758799889, IFCCABLECARRIERSEGMENTTYPE = 3293546465, IFCCABLEFITTING = 1051757585, IFCCABLEFITTINGTYPE = 2674252688, IFCCABLESEGMENT = 4217484030, IFCCABLESEGMENTTYPE = 1285652485, IFCCAISSONFOUNDATION = 3999819293, IFCCAISSONFOUNDATIONTYPE = 3203706013, IFCCARTESIANPOINT = 1123145078, IFCCARTESIANPOINTLIST = 574549367, IFCCARTESIANPOINTLIST2D = 1675464909, IFCCARTESIANPOINTLIST3D = 2059837836, IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748, IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601, IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946, IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920, IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885, IFCCENTERLINEPROFILEDEF = 3150382593, IFCCHILLER = 3902619387, IFCCHILLERTYPE = 2951183804, IFCCHIMNEY = 3296154744, IFCCHIMNEYTYPE = 2197970202, IFCCIRCLE = 2611217952, IFCCIRCLEHOLLOWPROFILEDEF = 2937912522, IFCCIRCLEPROFILEDEF = 1383045692, IFCCIRCULARARCSEGMENT2D = 1062206242, IFCCIVILELEMENT = 1677625105, IFCCIVILELEMENTTYPE = 3893394355, IFCCLASSIFICATION = 747523909, IFCCLASSIFICATIONREFERENCE = 647927063, IFCCLOSEDSHELL = 2205249479, IFCCOIL = 639361253, IFCCOILTYPE = 2301859152, IFCCOLOURRGB = 776857604, IFCCOLOURRGBLIST = 3285139300, IFCCOLOURSPECIFICATION = 3264961684, IFCCOLUMN = 843113511, IFCCOLUMNSTANDARDCASE = 905975707, IFCCOLUMNTYPE = 300633059, IFCCOMMUNICATIONSAPPLIANCE = 3221913625, IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858, IFCCOMPLEXPROPERTY = 2542286263, IFCCOMPLEXPROPERTYTEMPLATE = 3875453745, IFCCOMPOSITECURVE = 3732776249, IFCCOMPOSITECURVEONSURFACE = 15328376, IFCCOMPOSITECURVESEGMENT = 2485617015, IFCCOMPOSITEPROFILEDEF = 1485152156, IFCCOMPRESSOR = 3571504051, IFCCOMPRESSORTYPE = 3850581409, IFCCONDENSER = 2272882330, IFCCONDENSERTYPE = 2816379211, IFCCONIC = 2510884976, IFCCONNECTEDFACESET = 370225590, IFCCONNECTIONCURVEGEOMETRY = 1981873012, IFCCONNECTIONGEOMETRY = 2859738748, IFCCONNECTIONPOINTECCENTRICITY = 45288368, IFCCONNECTIONPOINTGEOMETRY = 2614616156, IFCCONNECTIONSURFACEGEOMETRY = 2732653382, IFCCONNECTIONVOLUMEGEOMETRY = 775493141, IFCCONSTRAINT = 1959218052, IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240, IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099, IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209, IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743, IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124, IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444, IFCCONSTRUCTIONRESOURCE = 2559216714, IFCCONSTRUCTIONRESOURCETYPE = 2574617495, IFCCONTEXT = 3419103109, IFCCONTEXTDEPENDENTUNIT = 3050246964, IFCCONTROL = 3293443760, IFCCONTROLLER = 25142252, IFCCONTROLLERTYPE = 578613899, IFCCONVERSIONBASEDUNIT = 2889183280, IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722, IFCCOOLEDBEAM = 4136498852, IFCCOOLEDBEAMTYPE = 335055490, IFCCOOLINGTOWER = 3640358203, IFCCOOLINGTOWERTYPE = 2954562838, IFCCOORDINATEOPERATION = 1785450214, IFCCOORDINATEREFERENCESYSTEM = 1466758467, IFCCOSTITEM = 3895139033, IFCCOSTSCHEDULE = 1419761937, IFCCOSTVALUE = 602808272, IFCCOVERING = 1973544240, IFCCOVERINGTYPE = 1916426348, IFCCREWRESOURCE = 3295246426, IFCCREWRESOURCETYPE = 1815067380, IFCCSGPRIMITIVE3D = 2506170314, IFCCSGSOLID = 2147822146, IFCCURRENCYRELATIONSHIP = 539742890, IFCCURTAINWALL = 3495092785, IFCCURTAINWALLTYPE = 1457835157, IFCCURVE = 2601014836, IFCCURVEBOUNDEDPLANE = 2827736869, IFCCURVEBOUNDEDSURFACE = 2629017746, IFCCURVESEGMENT2D = 1186437898, IFCCURVESTYLE = 3800577675, IFCCURVESTYLEFONT = 1105321065, IFCCURVESTYLEFONTANDSCALING = 2367409068, IFCCURVESTYLEFONTPATTERN = 3510044353, IFCCYLINDRICALSURFACE = 1213902940, IFCDAMPER = 4074379575, IFCDAMPERTYPE = 3961806047, IFCDEEPFOUNDATION = 3426335179, IFCDEEPFOUNDATIONTYPE = 1306400036, IFCDERIVEDPROFILEDEF = 3632507154, IFCDERIVEDUNIT = 1765591967, IFCDERIVEDUNITELEMENT = 1045800335, IFCDIMENSIONALEXPONENTS = 2949456006, IFCDIRECTION = 32440307, IFCDISCRETEACCESSORY = 1335981549, IFCDISCRETEACCESSORYTYPE = 2635815018, IFCDISTANCEEXPRESSION = 1945343521, IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943, IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980, IFCDISTRIBUTIONCIRCUIT = 562808652, IFCDISTRIBUTIONCONTROLELEMENT = 1062813311, IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501, IFCDISTRIBUTIONELEMENT = 1945004755, IFCDISTRIBUTIONELEMENTTYPE = 3256556792, IFCDISTRIBUTIONFLOWELEMENT = 3040386961, IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793, IFCDISTRIBUTIONPORT = 3041715199, IFCDISTRIBUTIONSYSTEM = 3205830791, IFCDOCUMENTINFORMATION = 1154170062, IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208, IFCDOCUMENTREFERENCE = 3732053477, IFCDOOR = 395920057, IFCDOORLININGPROPERTIES = 2963535650, IFCDOORPANELPROPERTIES = 1714330368, IFCDOORSTANDARDCASE = 3242481149, IFCDOORSTYLE = 526551008, IFCDOORTYPE = 2323601079, IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917, IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654, IFCDUCTFITTING = 342316401, IFCDUCTFITTINGTYPE = 869906466, IFCDUCTSEGMENT = 3518393246, IFCDUCTSEGMENTTYPE = 3760055223, IFCDUCTSILENCER = 1360408905, IFCDUCTSILENCERTYPE = 2030761528, IFCEDGE = 3900360178, IFCEDGECURVE = 476780140, IFCEDGELOOP = 1472233963, IFCELECTRICAPPLIANCE = 1904799276, IFCELECTRICAPPLIANCETYPE = 663422040, IFCELECTRICDISTRIBUTIONBOARD = 862014818, IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758, IFCELECTRICFLOWSTORAGEDEVICE = 3310460725, IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161, IFCELECTRICGENERATOR = 264262732, IFCELECTRICGENERATORTYPE = 1534661035, IFCELECTRICMOTOR = 402227799, IFCELECTRICMOTORTYPE = 1217240411, IFCELECTRICTIMECONTROL = 1003880860, IFCELECTRICTIMECONTROLTYPE = 712377611, IFCELEMENT = 1758889154, IFCELEMENTASSEMBLY = 4123344466, IFCELEMENTASSEMBLYTYPE = 2397081782, IFCELEMENTCOMPONENT = 1623761950, IFCELEMENTCOMPONENTTYPE = 2590856083, IFCELEMENTQUANTITY = 1883228015, IFCELEMENTTYPE = 339256511, IFCELEMENTARYSURFACE = 2777663545, IFCELLIPSE = 1704287377, IFCELLIPSEPROFILEDEF = 2835456948, IFCENERGYCONVERSIONDEVICE = 1658829314, IFCENERGYCONVERSIONDEVICETYPE = 2107101300, IFCENGINE = 2814081492, IFCENGINETYPE = 132023988, IFCEVAPORATIVECOOLER = 3747195512, IFCEVAPORATIVECOOLERTYPE = 3174744832, IFCEVAPORATOR = 484807127, IFCEVAPORATORTYPE = 3390157468, IFCEVENT = 4148101412, IFCEVENTTIME = 211053100, IFCEVENTTYPE = 4024345920, IFCEXTENDEDPROPERTIES = 297599258, IFCEXTERNALINFORMATION = 4294318154, IFCEXTERNALREFERENCE = 3200245327, IFCEXTERNALREFERENCERELATIONSHIP = 1437805879, IFCEXTERNALSPATIALELEMENT = 1209101575, IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674, IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968, IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647, IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201, IFCEXTRUDEDAREASOLID = 477187591, IFCEXTRUDEDAREASOLIDTAPERED = 2804161546, IFCFACE = 2556980723, IFCFACEBASEDSURFACEMODEL = 2047409740, IFCFACEBOUND = 1809719519, IFCFACEOUTERBOUND = 803316827, IFCFACESURFACE = 3008276851, IFCFACETEDBREP = 807026263, IFCFACETEDBREPWITHVOIDS = 3737207727, IFCFACILITY = 24185140, IFCFACILITYPART = 1310830890, IFCFAILURECONNECTIONCONDITION = 4219587988, IFCFAN = 3415622556, IFCFANTYPE = 346874300, IFCFASTENER = 647756555, IFCFASTENERTYPE = 2489546625, IFCFEATUREELEMENT = 2827207264, IFCFEATUREELEMENTADDITION = 2143335405, IFCFEATUREELEMENTSUBTRACTION = 1287392070, IFCFILLAREASTYLE = 738692330, IFCFILLAREASTYLEHATCHING = 374418227, IFCFILLAREASTYLETILES = 315944413, IFCFILTER = 819412036, IFCFILTERTYPE = 1810631287, IFCFIRESUPPRESSIONTERMINAL = 1426591983, IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408, IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860, IFCFLOWCONTROLLER = 2058353004, IFCFLOWCONTROLLERTYPE = 3907093117, IFCFLOWFITTING = 4278956645, IFCFLOWFITTINGTYPE = 3198132628, IFCFLOWINSTRUMENT = 182646315, IFCFLOWINSTRUMENTTYPE = 4037862832, IFCFLOWMETER = 2188021234, IFCFLOWMETERTYPE = 3815607619, IFCFLOWMOVINGDEVICE = 3132237377, IFCFLOWMOVINGDEVICETYPE = 1482959167, IFCFLOWSEGMENT = 987401354, IFCFLOWSEGMENTTYPE = 1834744321, IFCFLOWSTORAGEDEVICE = 707683696, IFCFLOWSTORAGEDEVICETYPE = 1339347760, IFCFLOWTERMINAL = 2223149337, IFCFLOWTERMINALTYPE = 2297155007, IFCFLOWTREATMENTDEVICE = 3508470533, IFCFLOWTREATMENTDEVICETYPE = 3009222698, IFCFOOTING = 900683007, IFCFOOTINGTYPE = 1893162501, IFCFURNISHINGELEMENT = 263784265, IFCFURNISHINGELEMENTTYPE = 4238390223, IFCFURNITURE = 1509553395, IFCFURNITURETYPE = 1268542332, IFCGEOGRAPHICELEMENT = 3493046030, IFCGEOGRAPHICELEMENTTYPE = 4095422895, IFCGEOMETRICCURVESET = 987898635, IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350, IFCGEOMETRICREPRESENTATIONITEM = 2453401579, IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618, IFCGEOMETRICSET = 3590301190, IFCGRID = 3009204131, IFCGRIDAXIS = 852622518, IFCGRIDPLACEMENT = 178086475, IFCGROUP = 2706460486, IFCHALFSPACESOLID = 812098782, IFCHEATEXCHANGER = 3319311131, IFCHEATEXCHANGERTYPE = 1251058090, IFCHUMIDIFIER = 2068733104, IFCHUMIDIFIERTYPE = 1806887404, IFCISHAPEPROFILEDEF = 1484403080, IFCIMAGETEXTURE = 3905492369, IFCINDEXEDCOLOURMAP = 3570813810, IFCINDEXEDPOLYCURVE = 2571569899, IFCINDEXEDPOLYGONALFACE = 178912537, IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976, IFCINDEXEDTEXTUREMAP = 1437953363, IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955, IFCINTERCEPTOR = 4175244083, IFCINTERCEPTORTYPE = 3946677679, IFCINTERSECTIONCURVE = 3113134337, IFCINVENTORY = 2391368822, IFCIRREGULARTIMESERIES = 3741457305, IFCIRREGULARTIMESERIESVALUE = 3020489413, IFCJUNCTIONBOX = 2176052936, IFCJUNCTIONBOXTYPE = 4288270099, IFCLSHAPEPROFILEDEF = 572779678, IFCLABORRESOURCE = 3827777499, IFCLABORRESOURCETYPE = 428585644, IFCLAGTIME = 1585845231, IFCLAMP = 76236018, IFCLAMPTYPE = 1051575348, IFCLIBRARYINFORMATION = 2655187982, IFCLIBRARYREFERENCE = 3452421091, IFCLIGHTDISTRIBUTIONDATA = 4162380809, IFCLIGHTFIXTURE = 629592764, IFCLIGHTFIXTURETYPE = 1161773419, IFCLIGHTINTENSITYDISTRIBUTION = 1566485204, IFCLIGHTSOURCE = 1402838566, IFCLIGHTSOURCEAMBIENT = 125510826, IFCLIGHTSOURCEDIRECTIONAL = 2604431987, IFCLIGHTSOURCEGONIOMETRIC = 4266656042, IFCLIGHTSOURCEPOSITIONAL = 1520743889, IFCLIGHTSOURCESPOT = 3422422726, IFCLINE = 1281925730, IFCLINESEGMENT2D = 3092502836, IFCLINEARPLACEMENT = 388784114, IFCLINEARPOSITIONINGELEMENT = 1154579445, IFCLOCALPLACEMENT = 2624227202, IFCLOOP = 1008929658, IFCMANIFOLDSOLIDBREP = 1425443689, IFCMAPCONVERSION = 3057273783, IFCMAPPEDITEM = 2347385850, IFCMATERIAL = 1838606355, IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766, IFCMATERIALCONSTITUENT = 3708119e3, IFCMATERIALCONSTITUENTSET = 2852063980, IFCMATERIALDEFINITION = 760658860, IFCMATERIALDEFINITIONREPRESENTATION = 2022407955, IFCMATERIALLAYER = 248100487, IFCMATERIALLAYERSET = 3303938423, IFCMATERIALLAYERSETUSAGE = 1303795690, IFCMATERIALLAYERWITHOFFSETS = 1847252529, IFCMATERIALLIST = 2199411900, IFCMATERIALPROFILE = 2235152071, IFCMATERIALPROFILESET = 164193824, IFCMATERIALPROFILESETUSAGE = 3079605661, IFCMATERIALPROFILESETUSAGETAPERING = 3404854881, IFCMATERIALPROFILEWITHOFFSETS = 552965576, IFCMATERIALPROPERTIES = 3265635763, IFCMATERIALRELATIONSHIP = 853536259, IFCMATERIALUSAGEDEFINITION = 1507914824, IFCMEASUREWITHUNIT = 2597039031, IFCMECHANICALFASTENER = 377706215, IFCMECHANICALFASTENERTYPE = 2108223431, IFCMEDICALDEVICE = 1437502449, IFCMEDICALDEVICETYPE = 1114901282, IFCMEMBER = 1073191201, IFCMEMBERSTANDARDCASE = 1911478936, IFCMEMBERTYPE = 3181161470, IFCMETRIC = 3368373690, IFCMIRROREDPROFILEDEF = 2998442950, IFCMONETARYUNIT = 2706619895, IFCMOTORCONNECTION = 2474470126, IFCMOTORCONNECTIONTYPE = 977012517, IFCNAMEDUNIT = 1918398963, IFCOBJECT = 3888040117, IFCOBJECTDEFINITION = 219451334, IFCOBJECTPLACEMENT = 3701648758, IFCOBJECTIVE = 2251480897, IFCOCCUPANT = 4143007308, IFCOFFSETCURVE = 590820931, IFCOFFSETCURVE2D = 3388369263, IFCOFFSETCURVE3D = 3505215534, IFCOFFSETCURVEBYDISTANCES = 2485787929, IFCOPENSHELL = 2665983363, IFCOPENINGELEMENT = 3588315303, IFCOPENINGSTANDARDCASE = 3079942009, IFCORGANIZATION = 4251960020, IFCORGANIZATIONRELATIONSHIP = 1411181986, IFCORIENTATIONEXPRESSION = 643959842, IFCORIENTEDEDGE = 1029017970, IFCOUTERBOUNDARYCURVE = 144952367, IFCOUTLET = 3694346114, IFCOUTLETTYPE = 2837617999, IFCOWNERHISTORY = 1207048766, IFCPARAMETERIZEDPROFILEDEF = 2529465313, IFCPATH = 2519244187, IFCPCURVE = 1682466193, IFCPERFORMANCEHISTORY = 2382730787, IFCPERMEABLECOVERINGPROPERTIES = 3566463478, IFCPERMIT = 3327091369, IFCPERSON = 2077209135, IFCPERSONANDORGANIZATION = 101040310, IFCPHYSICALCOMPLEXQUANTITY = 3021840470, IFCPHYSICALQUANTITY = 2483315170, IFCPHYSICALSIMPLEQUANTITY = 2226359599, IFCPILE = 1687234759, IFCPILETYPE = 1158309216, IFCPIPEFITTING = 310824031, IFCPIPEFITTINGTYPE = 804291784, IFCPIPESEGMENT = 3612865200, IFCPIPESEGMENTTYPE = 4231323485, IFCPIXELTEXTURE = 597895409, IFCPLACEMENT = 2004835150, IFCPLANARBOX = 603570806, IFCPLANAREXTENT = 1663979128, IFCPLANE = 220341763, IFCPLATE = 3171933400, IFCPLATESTANDARDCASE = 1156407060, IFCPLATETYPE = 4017108033, IFCPOINT = 2067069095, IFCPOINTONCURVE = 4022376103, IFCPOINTONSURFACE = 1423911732, IFCPOLYLOOP = 2924175390, IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180, IFCPOLYGONALFACESET = 2839578677, IFCPOLYLINE = 3724593414, IFCPORT = 3740093272, IFCPOSITIONINGELEMENT = 1946335990, IFCPOSTALADDRESS = 3355820592, IFCPREDEFINEDCOLOUR = 759155922, IFCPREDEFINEDCURVEFONT = 2559016684, IFCPREDEFINEDITEM = 3727388367, IFCPREDEFINEDPROPERTIES = 3778827333, IFCPREDEFINEDPROPERTYSET = 3967405729, IFCPREDEFINEDTEXTFONT = 1775413392, IFCPRESENTATIONITEM = 677532197, IFCPRESENTATIONLAYERASSIGNMENT = 2022622350, IFCPRESENTATIONLAYERWITHSTYLE = 1304840413, IFCPRESENTATIONSTYLE = 3119450353, IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796, IFCPROCEDURE = 2744685151, IFCPROCEDURETYPE = 569719735, IFCPROCESS = 2945172077, IFCPRODUCT = 4208778838, IFCPRODUCTDEFINITIONSHAPE = 673634403, IFCPRODUCTREPRESENTATION = 2095639259, IFCPROFILEDEF = 3958567839, IFCPROFILEPROPERTIES = 2802850158, IFCPROJECT = 103090709, IFCPROJECTLIBRARY = 653396225, IFCPROJECTORDER = 2904328755, IFCPROJECTEDCRS = 3843373140, IFCPROJECTIONELEMENT = 3651124850, IFCPROPERTY = 2598011224, IFCPROPERTYABSTRACTION = 986844984, IFCPROPERTYBOUNDEDVALUE = 871118103, IFCPROPERTYDEFINITION = 1680319473, IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276, IFCPROPERTYENUMERATEDVALUE = 4166981789, IFCPROPERTYENUMERATION = 3710013099, IFCPROPERTYLISTVALUE = 2752243245, IFCPROPERTYREFERENCEVALUE = 941946838, IFCPROPERTYSET = 1451395588, IFCPROPERTYSETDEFINITION = 3357820518, IFCPROPERTYSETTEMPLATE = 492091185, IFCPROPERTYSINGLEVALUE = 3650150729, IFCPROPERTYTABLEVALUE = 110355661, IFCPROPERTYTEMPLATE = 3521284610, IFCPROPERTYTEMPLATEDEFINITION = 1482703590, IFCPROTECTIVEDEVICE = 738039164, IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155, IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474, IFCPROTECTIVEDEVICETYPE = 1842657554, IFCPROXY = 3219374653, IFCPUMP = 90941305, IFCPUMPTYPE = 2250791053, IFCQUANTITYAREA = 2044713172, IFCQUANTITYCOUNT = 2093928680, IFCQUANTITYLENGTH = 931644368, IFCQUANTITYSET = 2090586900, IFCQUANTITYTIME = 3252649465, IFCQUANTITYVOLUME = 2405470396, IFCQUANTITYWEIGHT = 825690147, IFCRAILING = 2262370178, IFCRAILINGTYPE = 2893384427, IFCRAMP = 3024970846, IFCRAMPFLIGHT = 3283111854, IFCRAMPFLIGHTTYPE = 2324767716, IFCRAMPTYPE = 1469900589, IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972, IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671, IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689, IFCRECTANGLEPROFILEDEF = 3615266464, IFCRECTANGULARPYRAMID = 2798486643, IFCRECTANGULARTRIMMEDSURFACE = 3454111270, IFCRECURRENCEPATTERN = 3915482550, IFCREFERENCE = 2433181523, IFCREFERENT = 4021432810, IFCREGULARTIMESERIES = 3413951693, IFCREINFORCEMENTBARPROPERTIES = 1580146022, IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017, IFCREINFORCINGBAR = 979691226, IFCREINFORCINGBARTYPE = 2572171363, IFCREINFORCINGELEMENT = 3027567501, IFCREINFORCINGELEMENTTYPE = 964333572, IFCREINFORCINGMESH = 2320036040, IFCREINFORCINGMESHTYPE = 2310774935, IFCRELAGGREGATES = 160246688, IFCRELASSIGNS = 3939117080, IFCRELASSIGNSTOACTOR = 1683148259, IFCRELASSIGNSTOCONTROL = 2495723537, IFCRELASSIGNSTOGROUP = 1307041759, IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054, IFCRELASSIGNSTOPROCESS = 4278684876, IFCRELASSIGNSTOPRODUCT = 2857406711, IFCRELASSIGNSTORESOURCE = 205026976, IFCRELASSOCIATES = 1865459582, IFCRELASSOCIATESAPPROVAL = 4095574036, IFCRELASSOCIATESCLASSIFICATION = 919958153, IFCRELASSOCIATESCONSTRAINT = 2728634034, IFCRELASSOCIATESDOCUMENT = 982818633, IFCRELASSOCIATESLIBRARY = 3840914261, IFCRELASSOCIATESMATERIAL = 2655215786, IFCRELCONNECTS = 826625072, IFCRELCONNECTSELEMENTS = 1204542856, IFCRELCONNECTSPATHELEMENTS = 3945020480, IFCRELCONNECTSPORTTOELEMENT = 4201705270, IFCRELCONNECTSPORTS = 3190031847, IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289, IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189, IFCRELCONNECTSWITHECCENTRICITY = 504942748, IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232, IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779, IFCRELCOVERSBLDGELEMENTS = 886880790, IFCRELCOVERSSPACES = 2802773753, IFCRELDECLARES = 2565941209, IFCRELDECOMPOSES = 2551354335, IFCRELDEFINES = 693640335, IFCRELDEFINESBYOBJECT = 1462361463, IFCRELDEFINESBYPROPERTIES = 4186316022, IFCRELDEFINESBYTEMPLATE = 307848117, IFCRELDEFINESBYTYPE = 781010003, IFCRELFILLSELEMENT = 3940055652, IFCRELFLOWCONTROLELEMENTS = 279856033, IFCRELINTERFERESELEMENTS = 427948657, IFCRELNESTS = 3268803585, IFCRELPOSITIONS = 1441486842, IFCRELPROJECTSELEMENT = 750771296, IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292, IFCRELSEQUENCE = 4122056220, IFCRELSERVICESBUILDINGS = 366585022, IFCRELSPACEBOUNDARY = 3451746338, IFCRELSPACEBOUNDARY1STLEVEL = 3523091289, IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863, IFCRELVOIDSELEMENT = 1401173127, IFCRELATIONSHIP = 478536968, IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949, IFCREPRESENTATION = 1076942058, IFCREPRESENTATIONCONTEXT = 3377609919, IFCREPRESENTATIONITEM = 3008791417, IFCREPRESENTATIONMAP = 1660063152, IFCRESOURCE = 2914609552, IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501, IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552, IFCRESOURCELEVELRELATIONSHIP = 2439245199, IFCRESOURCETIME = 1042787934, IFCREVOLVEDAREASOLID = 1856042241, IFCREVOLVEDAREASOLIDTAPERED = 3243963512, IFCRIGHTCIRCULARCONE = 4158566097, IFCRIGHTCIRCULARCYLINDER = 3626867408, IFCROOF = 2016517767, IFCROOFTYPE = 2781568857, IFCROOT = 2341007311, IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089, IFCSIUNIT = 448429030, IFCSANITARYTERMINAL = 3053780830, IFCSANITARYTERMINALTYPE = 1768891740, IFCSCHEDULINGTIME = 1054537805, IFCSEAMCURVE = 2157484638, IFCSECTIONPROPERTIES = 2042790032, IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628, IFCSECTIONEDSOLID = 1862484736, IFCSECTIONEDSOLIDHORIZONTAL = 1290935644, IFCSECTIONEDSPINE = 1509187699, IFCSENSOR = 4086658281, IFCSENSORTYPE = 1783015770, IFCSHADINGDEVICE = 1329646415, IFCSHADINGDEVICETYPE = 4074543187, IFCSHAPEASPECT = 867548509, IFCSHAPEMODEL = 3982875396, IFCSHAPEREPRESENTATION = 4240577450, IFCSHELLBASEDSURFACEMODEL = 4124623270, IFCSIMPLEPROPERTY = 3692461612, IFCSIMPLEPROPERTYTEMPLATE = 3663146110, IFCSITE = 4097777520, IFCSLAB = 1529196076, IFCSLABELEMENTEDCASE = 3127900445, IFCSLABSTANDARDCASE = 3027962421, IFCSLABTYPE = 2533589738, IFCSLIPPAGECONNECTIONCONDITION = 2609359061, IFCSOLARDEVICE = 3420628829, IFCSOLARDEVICETYPE = 1072016465, IFCSOLIDMODEL = 723233188, IFCSPACE = 3856911033, IFCSPACEHEATER = 1999602285, IFCSPACEHEATERTYPE = 1305183839, IFCSPACETYPE = 3812236995, IFCSPATIALELEMENT = 1412071761, IFCSPATIALELEMENTTYPE = 710998568, IFCSPATIALSTRUCTUREELEMENT = 2706606064, IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262, IFCSPATIALZONE = 463610769, IFCSPATIALZONETYPE = 2481509218, IFCSPHERE = 451544542, IFCSPHERICALSURFACE = 4015995234, IFCSTACKTERMINAL = 1404847402, IFCSTACKTERMINALTYPE = 3112655638, IFCSTAIR = 331165859, IFCSTAIRFLIGHT = 4252922144, IFCSTAIRFLIGHTTYPE = 1039846685, IFCSTAIRTYPE = 338393293, IFCSTRUCTURALACTION = 682877961, IFCSTRUCTURALACTIVITY = 3544373492, IFCSTRUCTURALANALYSISMODEL = 2515109513, IFCSTRUCTURALCONNECTION = 1179482911, IFCSTRUCTURALCONNECTIONCONDITION = 2273995522, IFCSTRUCTURALCURVEACTION = 1004757350, IFCSTRUCTURALCURVECONNECTION = 4243806635, IFCSTRUCTURALCURVEMEMBER = 214636428, IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289, IFCSTRUCTURALCURVEREACTION = 2757150158, IFCSTRUCTURALITEM = 3136571912, IFCSTRUCTURALLINEARACTION = 1807405624, IFCSTRUCTURALLOAD = 2162789131, IFCSTRUCTURALLOADCASE = 385403989, IFCSTRUCTURALLOADCONFIGURATION = 3478079324, IFCSTRUCTURALLOADGROUP = 1252848954, IFCSTRUCTURALLOADLINEARFORCE = 1595516126, IFCSTRUCTURALLOADORRESULT = 609421318, IFCSTRUCTURALLOADPLANARFORCE = 2668620305, IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415, IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258, IFCSTRUCTURALLOADSINGLEFORCE = 1597423693, IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807, IFCSTRUCTURALLOADSTATIC = 2525727697, IFCSTRUCTURALLOADTEMPERATURE = 3408363356, IFCSTRUCTURALMEMBER = 530289379, IFCSTRUCTURALPLANARACTION = 1621171031, IFCSTRUCTURALPOINTACTION = 2082059205, IFCSTRUCTURALPOINTCONNECTION = 734778138, IFCSTRUCTURALPOINTREACTION = 1235345126, IFCSTRUCTURALREACTION = 3689010777, IFCSTRUCTURALRESULTGROUP = 2986769608, IFCSTRUCTURALSURFACEACTION = 3657597509, IFCSTRUCTURALSURFACECONNECTION = 1975003073, IFCSTRUCTURALSURFACEMEMBER = 3979015343, IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070, IFCSTRUCTURALSURFACEREACTION = 603775116, IFCSTYLEMODEL = 2830218821, IFCSTYLEDITEM = 3958052878, IFCSTYLEDREPRESENTATION = 3049322572, IFCSUBCONTRACTRESOURCE = 148013059, IFCSUBCONTRACTRESOURCETYPE = 4095615324, IFCSUBEDGE = 2233826070, IFCSURFACE = 2513912981, IFCSURFACECURVE = 699246055, IFCSURFACECURVESWEPTAREASOLID = 2028607225, IFCSURFACEFEATURE = 3101698114, IFCSURFACEOFLINEAREXTRUSION = 2809605785, IFCSURFACEOFREVOLUTION = 4124788165, IFCSURFACEREINFORCEMENTAREA = 2934153892, IFCSURFACESTYLE = 1300840506, IFCSURFACESTYLELIGHTING = 3303107099, IFCSURFACESTYLEREFRACTION = 1607154358, IFCSURFACESTYLERENDERING = 1878645084, IFCSURFACESTYLESHADING = 846575682, IFCSURFACESTYLEWITHTEXTURES = 1351298697, IFCSURFACETEXTURE = 626085974, IFCSWEPTAREASOLID = 2247615214, IFCSWEPTDISKSOLID = 1260650574, IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881, IFCSWEPTSURFACE = 230924584, IFCSWITCHINGDEVICE = 1162798199, IFCSWITCHINGDEVICETYPE = 2315554128, IFCSYSTEM = 2254336722, IFCSYSTEMFURNITUREELEMENT = 413509423, IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250, IFCTSHAPEPROFILEDEF = 3071757647, IFCTABLE = 985171141, IFCTABLECOLUMN = 2043862942, IFCTABLEROW = 531007025, IFCTANK = 812556717, IFCTANKTYPE = 5716631, IFCTASK = 3473067441, IFCTASKTIME = 1549132990, IFCTASKTIMERECURRING = 2771591690, IFCTASKTYPE = 3206491090, IFCTELECOMADDRESS = 912023232, IFCTENDON = 3824725483, IFCTENDONANCHOR = 2347447852, IFCTENDONANCHORTYPE = 3081323446, IFCTENDONCONDUIT = 3663046924, IFCTENDONCONDUITTYPE = 2281632017, IFCTENDONTYPE = 2415094496, IFCTESSELLATEDFACESET = 2387106220, IFCTESSELLATEDITEM = 901063453, IFCTEXTLITERAL = 4282788508, IFCTEXTLITERALWITHEXTENT = 3124975700, IFCTEXTSTYLE = 1447204868, IFCTEXTSTYLEFONTMODEL = 1983826977, IFCTEXTSTYLEFORDEFINEDFONT = 2636378356, IFCTEXTSTYLETEXTMODEL = 1640371178, IFCTEXTURECOORDINATE = 280115917, IFCTEXTURECOORDINATEGENERATOR = 1742049831, IFCTEXTUREMAP = 2552916305, IFCTEXTUREVERTEX = 1210645708, IFCTEXTUREVERTEXLIST = 3611470254, IFCTIMEPERIOD = 1199560280, IFCTIMESERIES = 3101149627, IFCTIMESERIESVALUE = 581633288, IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343, IFCTOPOLOGYREPRESENTATION = 1735638870, IFCTOROIDALSURFACE = 1935646853, IFCTRANSFORMER = 3825984169, IFCTRANSFORMERTYPE = 1692211062, IFCTRANSITIONCURVESEGMENT2D = 2595432518, IFCTRANSPORTELEMENT = 1620046519, IFCTRANSPORTELEMENTTYPE = 2097647324, IFCTRAPEZIUMPROFILEDEF = 2715220739, IFCTRIANGULATEDFACESET = 2916149573, IFCTRIANGULATEDIRREGULARNETWORK = 1229763772, IFCTRIMMEDCURVE = 3593883385, IFCTUBEBUNDLE = 3026737570, IFCTUBEBUNDLETYPE = 1600972822, IFCTYPEOBJECT = 1628702193, IFCTYPEPROCESS = 3736923433, IFCTYPEPRODUCT = 2347495698, IFCTYPERESOURCE = 3698973494, IFCUSHAPEPROFILEDEF = 427810014, IFCUNITASSIGNMENT = 180925521, IFCUNITARYCONTROLELEMENT = 630975310, IFCUNITARYCONTROLELEMENTTYPE = 3179687236, IFCUNITARYEQUIPMENT = 4292641817, IFCUNITARYEQUIPMENTTYPE = 1911125066, IFCVALVE = 4207607924, IFCVALVETYPE = 728799441, IFCVECTOR = 1417489154, IFCVERTEX = 2799835756, IFCVERTEXLOOP = 2759199220, IFCVERTEXPOINT = 1907098498, IFCVIBRATIONDAMPER = 1530820697, IFCVIBRATIONDAMPERTYPE = 3956297820, IFCVIBRATIONISOLATOR = 2391383451, IFCVIBRATIONISOLATORTYPE = 3313531582, IFCVIRTUALELEMENT = 2769231204, IFCVIRTUALGRIDINTERSECTION = 891718957, IFCVOIDINGFEATURE = 926996030, IFCWALL = 2391406946, IFCWALLELEMENTEDCASE = 4156078855, IFCWALLSTANDARDCASE = 3512223829, IFCWALLTYPE = 1898987631, IFCWASTETERMINAL = 4237592921, IFCWASTETERMINALTYPE = 1133259667, IFCWINDOW = 3304561284, IFCWINDOWLININGPROPERTIES = 336235671, IFCWINDOWPANELPROPERTIES = 512836454, IFCWINDOWSTANDARDCASE = 486154966, IFCWINDOWSTYLE = 1299126871, IFCWINDOWTYPE = 4009809668, IFCWORKCALENDAR = 4088093105, IFCWORKCONTROL = 1028945134, IFCWORKPLAN = 4218914973, IFCWORKSCHEDULE = 3342526732, IFCWORKTIME = 1236880293, IFCZSHAPEPROFILEDEF = 2543172580, IFCZONE = 1033361043, IfcElements = [IFCACTUATOR, IFCAIRTERMINAL, IFCAIRTERMINALBOX, IFCAIRTOAIRHEATRECOVERY, IFCALARM, IFCALIGNMENT, IFCANNOTATION, IFCAUDIOVISUALAPPLIANCE, IFCBEAM, IFCBEAMSTANDARDCASE, IFCBEARING, IFCBOILER, IFCBRIDGE, IFCBRIDGEPART, IFCBUILDING, IFCBUILDINGELEMENT, IFCBUILDINGELEMENTPART, IFCBUILDINGELEMENTPROXY, IFCBUILDINGSTOREY, IFCBURNER, IFCCABLECARRIERFITTING, IFCCABLECARRIERSEGMENT, IFCCABLEFITTING, IFCCABLESEGMENT, IFCCAISSONFOUNDATION, IFCCHILLER, IFCCHIMNEY, IFCCIVILELEMENT, IFCCOIL, IFCCOLUMN, IFCCOLUMNSTANDARDCASE, IFCCOMMUNICATIONSAPPLIANCE, IFCCOMPRESSOR, IFCCONDENSER, IFCCONTROLLER, IFCCOOLEDBEAM, IFCCOOLINGTOWER, IFCCOVERING, IFCCURTAINWALL, IFCDAMPER, IFCDEEPFOUNDATION, IFCDISCRETEACCESSORY, IFCDISTRIBUTIONCHAMBERELEMENT, IFCDISTRIBUTIONCONTROLELEMENT, IFCDISTRIBUTIONELEMENT, IFCDISTRIBUTIONFLOWELEMENT, IFCDISTRIBUTIONPORT, IFCDOOR, IFCDOORSTANDARDCASE, IFCDUCTFITTING, IFCDUCTSEGMENT, IFCDUCTSILENCER, IFCELECTRICAPPLIANCE, IFCELECTRICDISTRIBUTIONBOARD, IFCELECTRICFLOWSTORAGEDEVICE, IFCELECTRICGENERATOR, IFCELECTRICMOTOR, IFCELECTRICTIMECONTROL, IFCELEMENT, IFCELEMENTASSEMBLY, IFCELEMENTCOMPONENT, IFCENERGYCONVERSIONDEVICE, IFCENGINE, IFCEVAPORATIVECOOLER, IFCEVAPORATOR, IFCEXTERNALSPATIALELEMENT, IFCEXTERNALSPATIALSTRUCTUREELEMENT, IFCFACILITY, IFCFACILITYPART, IFCFAN, IFCFASTENER, IFCFEATUREELEMENT, IFCFEATUREELEMENTADDITION, IFCFEATUREELEMENTSUBTRACTION, IFCFILTER, IFCFIRESUPPRESSIONTERMINAL, IFCFLOWCONTROLLER, IFCFLOWFITTING, IFCFLOWINSTRUMENT, IFCFLOWMETER, IFCFLOWMOVINGDEVICE, IFCFLOWSEGMENT, IFCFLOWSTORAGEDEVICE, IFCFLOWTERMINAL, IFCFLOWTREATMENTDEVICE, IFCFOOTING, IFCFURNISHINGELEMENT, IFCFURNITURE, IFCGEOGRAPHICELEMENT, IFCGRID, IFCHEATEXCHANGER, IFCHUMIDIFIER, IFCINTERCEPTOR, IFCJUNCTIONBOX, IFCLAMP, IFCLIGHTFIXTURE, IFCLINEARPOSITIONINGELEMENT, IFCMECHANICALFASTENER, IFCMEDICALDEVICE, IFCMEMBER, IFCMEMBERSTANDARDCASE, IFCMOTORCONNECTION, IFCOPENINGELEMENT, IFCOPENINGSTANDARDCASE, IFCOUTLET, IFCPILE, IFCPIPEFITTING, IFCPIPESEGMENT, IFCPLATE, IFCPLATESTANDARDCASE, IFCPORT, IFCPOSITIONINGELEMENT, IFCPROJECTIONELEMENT, IFCPROTECTIVEDEVICE, IFCPROTECTIVEDEVICETRIPPINGUNIT, IFCPROXY, IFCPUMP, IFCRAILING, IFCRAMP, IFCRAMPFLIGHT, IFCREFERENT, IFCREINFORCINGBAR, IFCREINFORCINGELEMENT, IFCREINFORCINGMESH, IFCROOF, IFCSANITARYTERMINAL, IFCSENSOR, IFCSHADINGDEVICE, IFCSITE, IFCSLAB, IFCSLABELEMENTEDCASE, IFCSLABSTANDARDCASE, IFCSOLARDEVICE, IFCSPACE, IFCSPACEHEATER, IFCSPATIALELEMENT, IFCSPATIALSTRUCTUREELEMENT, IFCSPATIALZONE, IFCSTACKTERMINAL, IFCSTAIR, IFCSTAIRFLIGHT, IFCSTRUCTURALACTION, IFCSTRUCTURALACTIVITY, IFCSTRUCTURALCONNECTION, IFCSTRUCTURALCURVEACTION, IFCSTRUCTURALCURVECONNECTION, IFCSTRUCTURALCURVEMEMBER, IFCSTRUCTURALCURVEMEMBERVARYING, IFCSTRUCTURALCURVEREACTION, IFCSTRUCTURALITEM, IFCSTRUCTURALLINEARACTION, IFCSTRUCTURALMEMBER, IFCSTRUCTURALPLANARACTION, IFCSTRUCTURALPOINTACTION, IFCSTRUCTURALPOINTCONNECTION, IFCSTRUCTURALPOINTREACTION, IFCSTRUCTURALREACTION, IFCSTRUCTURALSURFACEACTION, IFCSTRUCTURALSURFACECONNECTION, IFCSTRUCTURALSURFACEMEMBER, IFCSTRUCTURALSURFACEMEMBERVARYING, IFCSTRUCTURALSURFACEREACTION, IFCSURFACEFEATURE, IFCSWITCHINGDEVICE, IFCSYSTEMFURNITUREELEMENT, IFCTANK, IFCTENDON, IFCTENDONANCHOR, IFCTENDONCONDUIT, IFCTRANSFORMER, IFCTRANSPORTELEMENT, IFCTUBEBUNDLE, IFCUNITARYCONTROLELEMENT, IFCUNITARYEQUIPMENT, IFCVALVE, IFCVIBRATIONDAMPER, IFCVIBRATIONISOLATOR, IFCVIRTUALELEMENT, IFCVOIDINGFEATURE, IFCWALL, IFCWALLELEMENTEDCASE, IFCWALLSTANDARDCASE, IFCWASTETERMINAL, IFCWINDOW, IFCWINDOWSTANDARDCASE], FromRawLineData = {}; FromRawLineData[IFCACTIONREQUEST] = e => IfcActionRequest.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCACTOR] = e => IfcActor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCACTORROLE] = e => IfcActorRole.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCACTUATOR] = e => IfcActuator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCACTUATORTYPE] = e => IfcActuatorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCADDRESS] = e => IfcAddress.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCADVANCEDBREP] = e => IfcAdvancedBrep.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = e => IfcAdvancedBrepWithVoids.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCADVANCEDFACE] = e => IfcAdvancedFace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTERMINAL] = e => IfcAirTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTERMINALBOX] = e => IfcAirTerminalBox.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTERMINALBOXTYPE] = e => IfcAirTerminalBoxType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTERMINALTYPE] = e => IfcAirTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = e => IfcAirToAirHeatRecovery.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = e => IfcAirToAirHeatRecoveryType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALARM] = e => IfcAlarm.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALARMTYPE] = e => IfcAlarmType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT] = e => IfcAlignment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = e => IfcAlignment2DHorizontal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = e => IfcAlignment2DHorizontalSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DSEGMENT] = e => IfcAlignment2DSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = e => IfcAlignment2DVerSegCircularArc.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = e => IfcAlignment2DVerSegLine.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = e => IfcAlignment2DVerSegParabolicArc.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DVERTICAL] = e => IfcAlignment2DVertical.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = e => IfcAlignment2DVerticalSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCALIGNMENTCURVE] = e => IfcAlignmentCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCANNOTATION] = e => IfcAnnotation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCANNOTATIONFILLAREA] = e => IfcAnnotationFillArea.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAPPLICATION] = e => IfcApplication.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAPPLIEDVALUE] = e => IfcAppliedValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAPPROVAL] = e => IfcApproval.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAPPROVALRELATIONSHIP] = e => IfcApprovalRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = e => IfcArbitraryClosedProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = e => IfcArbitraryOpenProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = e => IfcArbitraryProfileDefWithVoids.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCASSET] = e => IfcAsset.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = e => IfcAsymmetricIShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = e => IfcAudioVisualAppliance.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = e => IfcAudioVisualApplianceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAXIS1PLACEMENT] = e => IfcAxis1Placement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAXIS2PLACEMENT2D] = e => IfcAxis2Placement2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCAXIS2PLACEMENT3D] = e => IfcAxis2Placement3D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBSPLINECURVE] = e => IfcBSplineCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = e => IfcBSplineCurveWithKnots.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBSPLINESURFACE] = e => IfcBSplineSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = e => IfcBSplineSurfaceWithKnots.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBEAM] = e => IfcBeam.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBEAMSTANDARDCASE] = e => IfcBeamStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBEAMTYPE] = e => IfcBeamType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBEARING] = e => IfcBearing.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBEARINGTYPE] = e => IfcBearingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBLOBTEXTURE] = e => IfcBlobTexture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBLOCK] = e => IfcBlock.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOILER] = e => IfcBoiler.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOILERTYPE] = e => IfcBoilerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = e => IfcBooleanClippingResult.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOOLEANRESULT] = e => IfcBooleanResult.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYCONDITION] = e => IfcBoundaryCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYCURVE] = e => IfcBoundaryCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYEDGECONDITION] = e => IfcBoundaryEdgeCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYFACECONDITION] = e => IfcBoundaryFaceCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYNODECONDITION] = e => IfcBoundaryNodeCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = e => IfcBoundaryNodeConditionWarping.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDEDCURVE] = e => IfcBoundedCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDEDSURFACE] = e => IfcBoundedSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOUNDINGBOX] = e => IfcBoundingBox.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBOXEDHALFSPACE] = e => IfcBoxedHalfSpace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBRIDGE] = e => IfcBridge.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBRIDGEPART] = e => IfcBridgePart.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDING] = e => IfcBuilding.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENT] = e => IfcBuildingElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENTPART] = e => IfcBuildingElementPart.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = e => IfcBuildingElementPartType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENTPROXY] = e => IfcBuildingElementProxy.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = e => IfcBuildingElementProxyType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGELEMENTTYPE] = e => IfcBuildingElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGSTOREY] = e => IfcBuildingStorey.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBUILDINGSYSTEM] = e => IfcBuildingSystem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBURNER] = e => IfcBurner.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCBURNERTYPE] = e => IfcBurnerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCSHAPEPROFILEDEF] = e => IfcCShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLECARRIERFITTING] = e => IfcCableCarrierFitting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = e => IfcCableCarrierFittingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLECARRIERSEGMENT] = e => IfcCableCarrierSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = e => IfcCableCarrierSegmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLEFITTING] = e => IfcCableFitting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLEFITTINGTYPE] = e => IfcCableFittingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLESEGMENT] = e => IfcCableSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCABLESEGMENTTYPE] = e => IfcCableSegmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCAISSONFOUNDATION] = e => IfcCaissonFoundation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = e => IfcCaissonFoundationType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANPOINT] = e => IfcCartesianPoint.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANPOINTLIST] = e => IfcCartesianPointList.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANPOINTLIST2D] = e => IfcCartesianPointList2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANPOINTLIST3D] = e => IfcCartesianPointList3D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = e => IfcCartesianTransformationOperator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = e => IfcCartesianTransformationOperator2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = e => IfcCartesianTransformationOperator2DnonUniform.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = e => IfcCartesianTransformationOperator3D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = e => IfcCartesianTransformationOperator3DnonUniform.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCENTERLINEPROFILEDEF] = e => IfcCenterLineProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCHILLER] = e => IfcChiller.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCHILLERTYPE] = e => IfcChillerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCHIMNEY] = e => IfcChimney.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCHIMNEYTYPE] = e => IfcChimneyType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIRCLE] = e => IfcCircle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = e => IfcCircleHollowProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIRCLEPROFILEDEF] = e => IfcCircleProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIRCULARARCSEGMENT2D] = e => IfcCircularArcSegment2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIVILELEMENT] = e => IfcCivilElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCIVILELEMENTTYPE] = e => IfcCivilElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCLASSIFICATION] = e => IfcClassification.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCLASSIFICATIONREFERENCE] = e => IfcClassificationReference.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCLOSEDSHELL] = e => IfcClosedShell.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOIL] = e => IfcCoil.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOILTYPE] = e => IfcCoilType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLOURRGB] = e => IfcColourRgb.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLOURRGBLIST] = e => IfcColourRgbList.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLOURSPECIFICATION] = e => IfcColourSpecification.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLUMN] = e => IfcColumn.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLUMNSTANDARDCASE] = e => IfcColumnStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOLUMNTYPE] = e => IfcColumnType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = e => IfcCommunicationsAppliance.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = e => IfcCommunicationsApplianceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPLEXPROPERTY] = e => IfcComplexProperty.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = e => IfcComplexPropertyTemplate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPOSITECURVE] = e => IfcCompositeCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = e => IfcCompositeCurveOnSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPOSITECURVESEGMENT] = e => IfcCompositeCurveSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPOSITEPROFILEDEF] = e => IfcCompositeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPRESSOR] = e => IfcCompressor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOMPRESSORTYPE] = e => IfcCompressorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONDENSER] = e => IfcCondenser.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONDENSERTYPE] = e => IfcCondenserType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONIC] = e => IfcConic.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTEDFACESET] = e => IfcConnectedFaceSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = e => IfcConnectionCurveGeometry.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONGEOMETRY] = e => IfcConnectionGeometry.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = e => IfcConnectionPointEccentricity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = e => IfcConnectionPointGeometry.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = e => IfcConnectionSurfaceGeometry.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = e => IfcConnectionVolumeGeometry.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRAINT] = e => IfcConstraint.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = e => IfcConstructionEquipmentResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = e => IfcConstructionEquipmentResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = e => IfcConstructionMaterialResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = e => IfcConstructionMaterialResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = e => IfcConstructionProductResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = e => IfcConstructionProductResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONRESOURCE] = e => IfcConstructionResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = e => IfcConstructionResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONTEXT] = e => IfcContext.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = e => IfcContextDependentUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONTROL] = e => IfcControl.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONTROLLER] = e => IfcController.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONTROLLERTYPE] = e => IfcControllerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONVERSIONBASEDUNIT] = e => IfcConversionBasedUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = e => IfcConversionBasedUnitWithOffset.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOOLEDBEAM] = e => IfcCooledBeam.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOOLEDBEAMTYPE] = e => IfcCooledBeamType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOOLINGTOWER] = e => IfcCoolingTower.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOOLINGTOWERTYPE] = e => IfcCoolingTowerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOORDINATEOPERATION] = e => IfcCoordinateOperation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = e => IfcCoordinateReferenceSystem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOSTITEM] = e => IfcCostItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOSTSCHEDULE] = e => IfcCostSchedule.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOSTVALUE] = e => IfcCostValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOVERING] = e => IfcCovering.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCOVERINGTYPE] = e => IfcCoveringType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCREWRESOURCE] = e => IfcCrewResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCREWRESOURCETYPE] = e => IfcCrewResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCSGPRIMITIVE3D] = e => IfcCsgPrimitive3D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCSGSOLID] = e => IfcCsgSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURRENCYRELATIONSHIP] = e => IfcCurrencyRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURTAINWALL] = e => IfcCurtainWall.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURTAINWALLTYPE] = e => IfcCurtainWallType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVE] = e => IfcCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVEBOUNDEDPLANE] = e => IfcCurveBoundedPlane.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVEBOUNDEDSURFACE] = e => IfcCurveBoundedSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVESEGMENT2D] = e => IfcCurveSegment2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVESTYLE] = e => IfcCurveStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVESTYLEFONT] = e => IfcCurveStyleFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = e => IfcCurveStyleFontAndScaling.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCURVESTYLEFONTPATTERN] = e => IfcCurveStyleFontPattern.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCCYLINDRICALSURFACE] = e => IfcCylindricalSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDAMPER] = e => IfcDamper.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDAMPERTYPE] = e => IfcDamperType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDEEPFOUNDATION] = e => IfcDeepFoundation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDEEPFOUNDATIONTYPE] = e => IfcDeepFoundationType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDERIVEDPROFILEDEF] = e => IfcDerivedProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDERIVEDUNIT] = e => IfcDerivedUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDERIVEDUNITELEMENT] = e => IfcDerivedUnitElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDIMENSIONALEXPONENTS] = e => IfcDimensionalExponents.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDIRECTION] = e => IfcDirection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISCRETEACCESSORY] = e => IfcDiscreteAccessory.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISCRETEACCESSORYTYPE] = e => IfcDiscreteAccessoryType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTANCEEXPRESSION] = e => IfcDistanceExpression.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = e => IfcDistributionChamberElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = e => IfcDistributionChamberElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = e => IfcDistributionCircuit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = e => IfcDistributionControlElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = e => IfcDistributionControlElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONELEMENT] = e => IfcDistributionElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = e => IfcDistributionElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = e => IfcDistributionFlowElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = e => IfcDistributionFlowElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONPORT] = e => IfcDistributionPort.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDISTRIBUTIONSYSTEM] = e => IfcDistributionSystem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOCUMENTINFORMATION] = e => IfcDocumentInformation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = e => IfcDocumentInformationRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOCUMENTREFERENCE] = e => IfcDocumentReference.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOOR] = e => IfcDoor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOORLININGPROPERTIES] = e => IfcDoorLiningProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOORPANELPROPERTIES] = e => IfcDoorPanelProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOORSTANDARDCASE] = e => IfcDoorStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOORSTYLE] = e => IfcDoorStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDOORTYPE] = e => IfcDoorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = e => IfcDraughtingPreDefinedColour.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = e => IfcDraughtingPreDefinedCurveFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTFITTING] = e => IfcDuctFitting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTFITTINGTYPE] = e => IfcDuctFittingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTSEGMENT] = e => IfcDuctSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTSEGMENTTYPE] = e => IfcDuctSegmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTSILENCER] = e => IfcDuctSilencer.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCDUCTSILENCERTYPE] = e => IfcDuctSilencerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEDGE] = e => IfcEdge.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEDGECURVE] = e => IfcEdgeCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEDGELOOP] = e => IfcEdgeLoop.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICAPPLIANCE] = e => IfcElectricAppliance.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICAPPLIANCETYPE] = e => IfcElectricApplianceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = e => IfcElectricDistributionBoard.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = e => IfcElectricDistributionBoardType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = e => IfcElectricFlowStorageDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = e => IfcElectricFlowStorageDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICGENERATOR] = e => IfcElectricGenerator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICGENERATORTYPE] = e => IfcElectricGeneratorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICMOTOR] = e => IfcElectricMotor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICMOTORTYPE] = e => IfcElectricMotorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICTIMECONTROL] = e => IfcElectricTimeControl.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = e => IfcElectricTimeControlType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENT] = e => IfcElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTASSEMBLY] = e => IfcElementAssembly.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTASSEMBLYTYPE] = e => IfcElementAssemblyType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTCOMPONENT] = e => IfcElementComponent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTCOMPONENTTYPE] = e => IfcElementComponentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTQUANTITY] = e => IfcElementQuantity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTTYPE] = e => IfcElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELEMENTARYSURFACE] = e => IfcElementarySurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELLIPSE] = e => IfcEllipse.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCELLIPSEPROFILEDEF] = e => IfcEllipseProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCENERGYCONVERSIONDEVICE] = e => IfcEnergyConversionDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = e => IfcEnergyConversionDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCENGINE] = e => IfcEngine.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCENGINETYPE] = e => IfcEngineType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVAPORATIVECOOLER] = e => IfcEvaporativeCooler.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = e => IfcEvaporativeCoolerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVAPORATOR] = e => IfcEvaporator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVAPORATORTYPE] = e => IfcEvaporatorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVENT] = e => IfcEvent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVENTTIME] = e => IfcEventTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEVENTTYPE] = e => IfcEventType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTENDEDPROPERTIES] = e => IfcExtendedProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALINFORMATION] = e => IfcExternalInformation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALREFERENCE] = e => IfcExternalReference.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = e => IfcExternalReferenceRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALSPATIALELEMENT] = e => IfcExternalSpatialElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = e => IfcExternalSpatialStructureElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = e => IfcExternallyDefinedHatchStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = e => IfcExternallyDefinedSurfaceStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = e => IfcExternallyDefinedTextFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTRUDEDAREASOLID] = e => IfcExtrudedAreaSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = e => IfcExtrudedAreaSolidTapered.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACE] = e => IfcFace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACEBASEDSURFACEMODEL] = e => IfcFaceBasedSurfaceModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACEBOUND] = e => IfcFaceBound.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACEOUTERBOUND] = e => IfcFaceOuterBound.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACESURFACE] = e => IfcFaceSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACETEDBREP] = e => IfcFacetedBrep.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACETEDBREPWITHVOIDS] = e => IfcFacetedBrepWithVoids.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACILITY] = e => IfcFacility.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFACILITYPART] = e => IfcFacilityPart.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFAILURECONNECTIONCONDITION] = e => IfcFailureConnectionCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFAN] = e => IfcFan.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFANTYPE] = e => IfcFanType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFASTENER] = e => IfcFastener.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFASTENERTYPE] = e => IfcFastenerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFEATUREELEMENT] = e => IfcFeatureElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFEATUREELEMENTADDITION] = e => IfcFeatureElementAddition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = e => IfcFeatureElementSubtraction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFILLAREASTYLE] = e => IfcFillAreaStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFILLAREASTYLEHATCHING] = e => IfcFillAreaStyleHatching.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFILLAREASTYLETILES] = e => IfcFillAreaStyleTiles.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFILTER] = e => IfcFilter.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFILTERTYPE] = e => IfcFilterType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = e => IfcFireSuppressionTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = e => IfcFireSuppressionTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = e => IfcFixedReferenceSweptAreaSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWCONTROLLER] = e => IfcFlowController.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWCONTROLLERTYPE] = e => IfcFlowControllerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWFITTING] = e => IfcFlowFitting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWFITTINGTYPE] = e => IfcFlowFittingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWINSTRUMENT] = e => IfcFlowInstrument.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWINSTRUMENTTYPE] = e => IfcFlowInstrumentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWMETER] = e => IfcFlowMeter.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWMETERTYPE] = e => IfcFlowMeterType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWMOVINGDEVICE] = e => IfcFlowMovingDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = e => IfcFlowMovingDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWSEGMENT] = e => IfcFlowSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWSEGMENTTYPE] = e => IfcFlowSegmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWSTORAGEDEVICE] = e => IfcFlowStorageDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = e => IfcFlowStorageDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWTERMINAL] = e => IfcFlowTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWTERMINALTYPE] = e => IfcFlowTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWTREATMENTDEVICE] = e => IfcFlowTreatmentDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = e => IfcFlowTreatmentDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFOOTING] = e => IfcFooting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFOOTINGTYPE] = e => IfcFootingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFURNISHINGELEMENT] = e => IfcFurnishingElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFURNISHINGELEMENTTYPE] = e => IfcFurnishingElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFURNITURE] = e => IfcFurniture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCFURNITURETYPE] = e => IfcFurnitureType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOGRAPHICELEMENT] = e => IfcGeographicElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = e => IfcGeographicElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOMETRICCURVESET] = e => IfcGeometricCurveSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = e => IfcGeometricRepresentationContext.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = e => IfcGeometricRepresentationItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = e => IfcGeometricRepresentationSubContext.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGEOMETRICSET] = e => IfcGeometricSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGRID] = e => IfcGrid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGRIDAXIS] = e => IfcGridAxis.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGRIDPLACEMENT] = e => IfcGridPlacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCGROUP] = e => IfcGroup.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCHALFSPACESOLID] = e => IfcHalfSpaceSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCHEATEXCHANGER] = e => IfcHeatExchanger.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCHEATEXCHANGERTYPE] = e => IfcHeatExchangerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCHUMIDIFIER] = e => IfcHumidifier.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCHUMIDIFIERTYPE] = e => IfcHumidifierType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCISHAPEPROFILEDEF] = e => IfcIShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCIMAGETEXTURE] = e => IfcImageTexture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDCOLOURMAP] = e => IfcIndexedColourMap.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDPOLYCURVE] = e => IfcIndexedPolyCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDPOLYGONALFACE] = e => IfcIndexedPolygonalFace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = e => IfcIndexedPolygonalFaceWithVoids.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDTEXTUREMAP] = e => IfcIndexedTextureMap.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = e => IfcIndexedTriangleTextureMap.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINTERCEPTOR] = e => IfcInterceptor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINTERCEPTORTYPE] = e => IfcInterceptorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINTERSECTIONCURVE] = e => IfcIntersectionCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCINVENTORY] = e => IfcInventory.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCIRREGULARTIMESERIES] = e => IfcIrregularTimeSeries.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = e => IfcIrregularTimeSeriesValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCJUNCTIONBOX] = e => IfcJunctionBox.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCJUNCTIONBOXTYPE] = e => IfcJunctionBoxType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLSHAPEPROFILEDEF] = e => IfcLShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLABORRESOURCE] = e => IfcLaborResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLABORRESOURCETYPE] = e => IfcLaborResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLAGTIME] = e => IfcLagTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLAMP] = e => IfcLamp.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLAMPTYPE] = e => IfcLampType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIBRARYINFORMATION] = e => IfcLibraryInformation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIBRARYREFERENCE] = e => IfcLibraryReference.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = e => IfcLightDistributionData.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTFIXTURE] = e => IfcLightFixture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTFIXTURETYPE] = e => IfcLightFixtureType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = e => IfcLightIntensityDistribution.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCE] = e => IfcLightSource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCEAMBIENT] = e => IfcLightSourceAmbient.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = e => IfcLightSourceDirectional.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = e => IfcLightSourceGoniometric.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = e => IfcLightSourcePositional.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLIGHTSOURCESPOT] = e => IfcLightSourceSpot.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLINE] = e => IfcLine.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLINESEGMENT2D] = e => IfcLineSegment2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLINEARPLACEMENT] = e => IfcLinearPlacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = e => IfcLinearPositioningElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLOCALPLACEMENT] = e => IfcLocalPlacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCLOOP] = e => IfcLoop.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMANIFOLDSOLIDBREP] = e => IfcManifoldSolidBrep.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMAPCONVERSION] = e => IfcMapConversion.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMAPPEDITEM] = e => IfcMappedItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIAL] = e => IfcMaterial.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = e => IfcMaterialClassificationRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALCONSTITUENT] = e => IfcMaterialConstituent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALCONSTITUENTSET] = e => IfcMaterialConstituentSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALDEFINITION] = e => IfcMaterialDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = e => IfcMaterialDefinitionRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALLAYER] = e => IfcMaterialLayer.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALLAYERSET] = e => IfcMaterialLayerSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALLAYERSETUSAGE] = e => IfcMaterialLayerSetUsage.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = e => IfcMaterialLayerWithOffsets.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALLIST] = e => IfcMaterialList.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROFILE] = e => IfcMaterialProfile.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROFILESET] = e => IfcMaterialProfileSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROFILESETUSAGE] = e => IfcMaterialProfileSetUsage.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = e => IfcMaterialProfileSetUsageTapering.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = e => IfcMaterialProfileWithOffsets.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALPROPERTIES] = e => IfcMaterialProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALRELATIONSHIP] = e => IfcMaterialRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMATERIALUSAGEDEFINITION] = e => IfcMaterialUsageDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEASUREWITHUNIT] = e => IfcMeasureWithUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMECHANICALFASTENER] = e => IfcMechanicalFastener.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMECHANICALFASTENERTYPE] = e => IfcMechanicalFastenerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEDICALDEVICE] = e => IfcMedicalDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEDICALDEVICETYPE] = e => IfcMedicalDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEMBER] = e => IfcMember.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEMBERSTANDARDCASE] = e => IfcMemberStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMEMBERTYPE] = e => IfcMemberType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMETRIC] = e => IfcMetric.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMIRROREDPROFILEDEF] = e => IfcMirroredProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMONETARYUNIT] = e => IfcMonetaryUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMOTORCONNECTION] = e => IfcMotorConnection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCMOTORCONNECTIONTYPE] = e => IfcMotorConnectionType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCNAMEDUNIT] = e => IfcNamedUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOBJECT] = e => IfcObject.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOBJECTDEFINITION] = e => IfcObjectDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOBJECTPLACEMENT] = e => IfcObjectPlacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOBJECTIVE] = e => IfcObjective.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOCCUPANT] = e => IfcOccupant.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOFFSETCURVE] = e => IfcOffsetCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOFFSETCURVE2D] = e => IfcOffsetCurve2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOFFSETCURVE3D] = e => IfcOffsetCurve3D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = e => IfcOffsetCurveByDistances.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOPENSHELL] = e => IfcOpenShell.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOPENINGELEMENT] = e => IfcOpeningElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOPENINGSTANDARDCASE] = e => IfcOpeningStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCORGANIZATION] = e => IfcOrganization.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = e => IfcOrganizationRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCORIENTATIONEXPRESSION] = e => IfcOrientationExpression.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCORIENTEDEDGE] = e => IfcOrientedEdge.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOUTERBOUNDARYCURVE] = e => IfcOuterBoundaryCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOUTLET] = e => IfcOutlet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOUTLETTYPE] = e => IfcOutletType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCOWNERHISTORY] = e => IfcOwnerHistory.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = e => IfcParameterizedProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPATH] = e => IfcPath.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPCURVE] = e => IfcPcurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPERFORMANCEHISTORY] = e => IfcPerformanceHistory.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = e => IfcPermeableCoveringProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPERMIT] = e => IfcPermit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPERSON] = e => IfcPerson.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPERSONANDORGANIZATION] = e => IfcPersonAndOrganization.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = e => IfcPhysicalComplexQuantity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPHYSICALQUANTITY] = e => IfcPhysicalQuantity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = e => IfcPhysicalSimpleQuantity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPILE] = e => IfcPile.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPILETYPE] = e => IfcPileType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPIPEFITTING] = e => IfcPipeFitting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPIPEFITTINGTYPE] = e => IfcPipeFittingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPIPESEGMENT] = e => IfcPipeSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPIPESEGMENTTYPE] = e => IfcPipeSegmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPIXELTEXTURE] = e => IfcPixelTexture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLACEMENT] = e => IfcPlacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLANARBOX] = e => IfcPlanarBox.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLANAREXTENT] = e => IfcPlanarExtent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLANE] = e => IfcPlane.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLATE] = e => IfcPlate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLATESTANDARDCASE] = e => IfcPlateStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPLATETYPE] = e => IfcPlateType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOINT] = e => IfcPoint.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOINTONCURVE] = e => IfcPointOnCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOINTONSURFACE] = e => IfcPointOnSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOLYLOOP] = e => IfcPolyLoop.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = e => IfcPolygonalBoundedHalfSpace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOLYGONALFACESET] = e => IfcPolygonalFaceSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOLYLINE] = e => IfcPolyline.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPORT] = e => IfcPort.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOSITIONINGELEMENT] = e => IfcPositioningElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPOSTALADDRESS] = e => IfcPostalAddress.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDCOLOUR] = e => IfcPreDefinedColour.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDCURVEFONT] = e => IfcPreDefinedCurveFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDITEM] = e => IfcPreDefinedItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDPROPERTIES] = e => IfcPreDefinedProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDPROPERTYSET] = e => IfcPreDefinedPropertySet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPREDEFINEDTEXTFONT] = e => IfcPreDefinedTextFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRESENTATIONITEM] = e => IfcPresentationItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = e => IfcPresentationLayerAssignment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = e => IfcPresentationLayerWithStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRESENTATIONSTYLE] = e => IfcPresentationStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = e => IfcPresentationStyleAssignment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROCEDURE] = e => IfcProcedure.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROCEDURETYPE] = e => IfcProcedureType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROCESS] = e => IfcProcess.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRODUCT] = e => IfcProduct.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = e => IfcProductDefinitionShape.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPRODUCTREPRESENTATION] = e => IfcProductRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROFILEDEF] = e => IfcProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROFILEPROPERTIES] = e => IfcProfileProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROJECT] = e => IfcProject.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROJECTLIBRARY] = e => IfcProjectLibrary.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROJECTORDER] = e => IfcProjectOrder.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROJECTEDCRS] = e => IfcProjectedCRS.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROJECTIONELEMENT] = e => IfcProjectionElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTY] = e => IfcProperty.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYABSTRACTION] = e => IfcPropertyAbstraction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = e => IfcPropertyBoundedValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYDEFINITION] = e => IfcPropertyDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = e => IfcPropertyDependencyRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = e => IfcPropertyEnumeratedValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYENUMERATION] = e => IfcPropertyEnumeration.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYLISTVALUE] = e => IfcPropertyListValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYREFERENCEVALUE] = e => IfcPropertyReferenceValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYSET] = e => IfcPropertySet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYSETDEFINITION] = e => IfcPropertySetDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYSETTEMPLATE] = e => IfcPropertySetTemplate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYSINGLEVALUE] = e => IfcPropertySingleValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYTABLEVALUE] = e => IfcPropertyTableValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYTEMPLATE] = e => IfcPropertyTemplate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = e => IfcPropertyTemplateDefinition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROTECTIVEDEVICE] = e => IfcProtectiveDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = e => IfcProtectiveDeviceTrippingUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = e => IfcProtectiveDeviceTrippingUnitType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROTECTIVEDEVICETYPE] = e => IfcProtectiveDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPROXY] = e => IfcProxy.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPUMP] = e => IfcPump.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCPUMPTYPE] = e => IfcPumpType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYAREA] = e => IfcQuantityArea.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYCOUNT] = e => IfcQuantityCount.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYLENGTH] = e => IfcQuantityLength.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYSET] = e => IfcQuantitySet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYTIME] = e => IfcQuantityTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYVOLUME] = e => IfcQuantityVolume.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCQUANTITYWEIGHT] = e => IfcQuantityWeight.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAILING] = e => IfcRailing.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAILINGTYPE] = e => IfcRailingType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAMP] = e => IfcRamp.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAMPFLIGHT] = e => IfcRampFlight.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAMPFLIGHTTYPE] = e => IfcRampFlightType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRAMPTYPE] = e => IfcRampType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = e => IfcRationalBSplineCurveWithKnots.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = e => IfcRationalBSplineSurfaceWithKnots.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = e => IfcRectangleHollowProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRECTANGLEPROFILEDEF] = e => IfcRectangleProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRECTANGULARPYRAMID] = e => IfcRectangularPyramid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = e => IfcRectangularTrimmedSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRECURRENCEPATTERN] = e => IfcRecurrencePattern.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREFERENCE] = e => IfcReference.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREFERENT] = e => IfcReferent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREGULARTIMESERIES] = e => IfcRegularTimeSeries.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = e => IfcReinforcementBarProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = e => IfcReinforcementDefinitionProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGBAR] = e => IfcReinforcingBar.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGBARTYPE] = e => IfcReinforcingBarType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGELEMENT] = e => IfcReinforcingElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGELEMENTTYPE] = e => IfcReinforcingElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGMESH] = e => IfcReinforcingMesh.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREINFORCINGMESHTYPE] = e => IfcReinforcingMeshType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELAGGREGATES] = e => IfcRelAggregates.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNS] = e => IfcRelAssigns.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOACTOR] = e => IfcRelAssignsToActor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOCONTROL] = e => IfcRelAssignsToControl.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOGROUP] = e => IfcRelAssignsToGroup.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = e => IfcRelAssignsToGroupByFactor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOPROCESS] = e => IfcRelAssignsToProcess.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTOPRODUCT] = e => IfcRelAssignsToProduct.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSIGNSTORESOURCE] = e => IfcRelAssignsToResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATES] = e => IfcRelAssociates.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESAPPROVAL] = e => IfcRelAssociatesApproval.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = e => IfcRelAssociatesClassification.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = e => IfcRelAssociatesConstraint.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESDOCUMENT] = e => IfcRelAssociatesDocument.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESLIBRARY] = e => IfcRelAssociatesLibrary.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELASSOCIATESMATERIAL] = e => IfcRelAssociatesMaterial.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTS] = e => IfcRelConnects.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSELEMENTS] = e => IfcRelConnectsElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = e => IfcRelConnectsPathElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = e => IfcRelConnectsPortToElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSPORTS] = e => IfcRelConnectsPorts.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = e => IfcRelConnectsStructuralActivity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = e => IfcRelConnectsStructuralMember.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = e => IfcRelConnectsWithEccentricity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = e => IfcRelConnectsWithRealizingElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = e => IfcRelContainedInSpatialStructure.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = e => IfcRelCoversBldgElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELCOVERSSPACES] = e => IfcRelCoversSpaces.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDECLARES] = e => IfcRelDeclares.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDECOMPOSES] = e => IfcRelDecomposes.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDEFINES] = e => IfcRelDefines.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDEFINESBYOBJECT] = e => IfcRelDefinesByObject.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDEFINESBYPROPERTIES] = e => IfcRelDefinesByProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDEFINESBYTEMPLATE] = e => IfcRelDefinesByTemplate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELDEFINESBYTYPE] = e => IfcRelDefinesByType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELFILLSELEMENT] = e => IfcRelFillsElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = e => IfcRelFlowControlElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELINTERFERESELEMENTS] = e => IfcRelInterferesElements.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELNESTS] = e => IfcRelNests.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELPOSITIONS] = e => IfcRelPositions.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELPROJECTSELEMENT] = e => IfcRelProjectsElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = e => IfcRelReferencedInSpatialStructure.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELSEQUENCE] = e => IfcRelSequence.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELSERVICESBUILDINGS] = e => IfcRelServicesBuildings.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELSPACEBOUNDARY] = e => IfcRelSpaceBoundary.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = e => IfcRelSpaceBoundary1stLevel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = e => IfcRelSpaceBoundary2ndLevel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELVOIDSELEMENT] = e => IfcRelVoidsElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRELATIONSHIP] = e => IfcRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = e => IfcReparametrisedCompositeCurveSegment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREPRESENTATION] = e => IfcRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREPRESENTATIONCONTEXT] = e => IfcRepresentationContext.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREPRESENTATIONITEM] = e => IfcRepresentationItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREPRESENTATIONMAP] = e => IfcRepresentationMap.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRESOURCE] = e => IfcResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = e => IfcResourceApprovalRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = e => IfcResourceConstraintRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = e => IfcResourceLevelRelationship.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRESOURCETIME] = e => IfcResourceTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREVOLVEDAREASOLID] = e => IfcRevolvedAreaSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = e => IfcRevolvedAreaSolidTapered.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRIGHTCIRCULARCONE] = e => IfcRightCircularCone.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = e => IfcRightCircularCylinder.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCROOF] = e => IfcRoof.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCROOFTYPE] = e => IfcRoofType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCROOT] = e => IfcRoot.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = e => IfcRoundedRectangleProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSIUNIT] = e => IfcSIUnit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSANITARYTERMINAL] = e => IfcSanitaryTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSANITARYTERMINALTYPE] = e => IfcSanitaryTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSCHEDULINGTIME] = e => IfcSchedulingTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSEAMCURVE] = e => IfcSeamCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSECTIONPROPERTIES] = e => IfcSectionProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = e => IfcSectionReinforcementProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSECTIONEDSOLID] = e => IfcSectionedSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = e => IfcSectionedSolidHorizontal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSECTIONEDSPINE] = e => IfcSectionedSpine.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSENSOR] = e => IfcSensor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSENSORTYPE] = e => IfcSensorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHADINGDEVICE] = e => IfcShadingDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHADINGDEVICETYPE] = e => IfcShadingDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHAPEASPECT] = e => IfcShapeAspect.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHAPEMODEL] = e => IfcShapeModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHAPEREPRESENTATION] = e => IfcShapeRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = e => IfcShellBasedSurfaceModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSIMPLEPROPERTY] = e => IfcSimpleProperty.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = e => IfcSimplePropertyTemplate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSITE] = e => IfcSite.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSLAB] = e => IfcSlab.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSLABELEMENTEDCASE] = e => IfcSlabElementedCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSLABSTANDARDCASE] = e => IfcSlabStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSLABTYPE] = e => IfcSlabType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = e => IfcSlippageConnectionCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSOLARDEVICE] = e => IfcSolarDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSOLARDEVICETYPE] = e => IfcSolarDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSOLIDMODEL] = e => IfcSolidModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPACE] = e => IfcSpace.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPACEHEATER] = e => IfcSpaceHeater.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPACEHEATERTYPE] = e => IfcSpaceHeaterType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPACETYPE] = e => IfcSpaceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALELEMENT] = e => IfcSpatialElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALELEMENTTYPE] = e => IfcSpatialElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = e => IfcSpatialStructureElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = e => IfcSpatialStructureElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALZONE] = e => IfcSpatialZone.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPATIALZONETYPE] = e => IfcSpatialZoneType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPHERE] = e => IfcSphere.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSPHERICALSURFACE] = e => IfcSphericalSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTACKTERMINAL] = e => IfcStackTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTACKTERMINALTYPE] = e => IfcStackTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTAIR] = e => IfcStair.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTAIRFLIGHT] = e => IfcStairFlight.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTAIRFLIGHTTYPE] = e => IfcStairFlightType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTAIRTYPE] = e => IfcStairType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALACTION] = e => IfcStructuralAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALACTIVITY] = e => IfcStructuralActivity.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = e => IfcStructuralAnalysisModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCONNECTION] = e => IfcStructuralConnection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = e => IfcStructuralConnectionCondition.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCURVEACTION] = e => IfcStructuralCurveAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = e => IfcStructuralCurveConnection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = e => IfcStructuralCurveMember.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = e => IfcStructuralCurveMemberVarying.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALCURVEREACTION] = e => IfcStructuralCurveReaction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALITEM] = e => IfcStructuralItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLINEARACTION] = e => IfcStructuralLinearAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOAD] = e => IfcStructuralLoad.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADCASE] = e => IfcStructuralLoadCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = e => IfcStructuralLoadConfiguration.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADGROUP] = e => IfcStructuralLoadGroup.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = e => IfcStructuralLoadLinearForce.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADORRESULT] = e => IfcStructuralLoadOrResult.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = e => IfcStructuralLoadPlanarForce.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = e => IfcStructuralLoadSingleDisplacement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = e => IfcStructuralLoadSingleDisplacementDistortion.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = e => IfcStructuralLoadSingleForce.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = e => IfcStructuralLoadSingleForceWarping.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADSTATIC] = e => IfcStructuralLoadStatic.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = e => IfcStructuralLoadTemperature.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALMEMBER] = e => IfcStructuralMember.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALPLANARACTION] = e => IfcStructuralPlanarAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALPOINTACTION] = e => IfcStructuralPointAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = e => IfcStructuralPointConnection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALPOINTREACTION] = e => IfcStructuralPointReaction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALREACTION] = e => IfcStructuralReaction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALRESULTGROUP] = e => IfcStructuralResultGroup.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALSURFACEACTION] = e => IfcStructuralSurfaceAction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = e => IfcStructuralSurfaceConnection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = e => IfcStructuralSurfaceMember.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = e => IfcStructuralSurfaceMemberVarying.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = e => IfcStructuralSurfaceReaction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTYLEMODEL] = e => IfcStyleModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTYLEDITEM] = e => IfcStyledItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSTYLEDREPRESENTATION] = e => IfcStyledRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSUBCONTRACTRESOURCE] = e => IfcSubContractResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = e => IfcSubContractResourceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSUBEDGE] = e => IfcSubedge.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACE] = e => IfcSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACECURVE] = e => IfcSurfaceCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = e => IfcSurfaceCurveSweptAreaSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACEFEATURE] = e => IfcSurfaceFeature.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = e => IfcSurfaceOfLinearExtrusion.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACEOFREVOLUTION] = e => IfcSurfaceOfRevolution.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = e => IfcSurfaceReinforcementArea.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLE] = e => IfcSurfaceStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLELIGHTING] = e => IfcSurfaceStyleLighting.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLEREFRACTION] = e => IfcSurfaceStyleRefraction.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLERENDERING] = e => IfcSurfaceStyleRendering.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLESHADING] = e => IfcSurfaceStyleShading.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = e => IfcSurfaceStyleWithTextures.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSURFACETEXTURE] = e => IfcSurfaceTexture.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWEPTAREASOLID] = e => IfcSweptAreaSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWEPTDISKSOLID] = e => IfcSweptDiskSolid.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = e => IfcSweptDiskSolidPolygonal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWEPTSURFACE] = e => IfcSweptSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWITCHINGDEVICE] = e => IfcSwitchingDevice.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSWITCHINGDEVICETYPE] = e => IfcSwitchingDeviceType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSYSTEM] = e => IfcSystem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = e => IfcSystemFurnitureElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = e => IfcSystemFurnitureElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTSHAPEPROFILEDEF] = e => IfcTShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTABLE] = e => IfcTable.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTABLECOLUMN] = e => IfcTableColumn.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTABLEROW] = e => IfcTableRow.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTANK] = e => IfcTank.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTANKTYPE] = e => IfcTankType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTASK] = e => IfcTask.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTASKTIME] = e => IfcTaskTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTASKTIMERECURRING] = e => IfcTaskTimeRecurring.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTASKTYPE] = e => IfcTaskType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTELECOMADDRESS] = e => IfcTelecomAddress.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDON] = e => IfcTendon.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDONANCHOR] = e => IfcTendonAnchor.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDONANCHORTYPE] = e => IfcTendonAnchorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDONCONDUIT] = e => IfcTendonConduit.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDONCONDUITTYPE] = e => IfcTendonConduitType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTENDONTYPE] = e => IfcTendonType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTESSELLATEDFACESET] = e => IfcTessellatedFaceSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTESSELLATEDITEM] = e => IfcTessellatedItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTLITERAL] = e => IfcTextLiteral.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTLITERALWITHEXTENT] = e => IfcTextLiteralWithExtent.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTSTYLE] = e => IfcTextStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTSTYLEFONTMODEL] = e => IfcTextStyleFontModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = e => IfcTextStyleForDefinedFont.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTSTYLETEXTMODEL] = e => IfcTextStyleTextModel.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTURECOORDINATE] = e => IfcTextureCoordinate.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = e => IfcTextureCoordinateGenerator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTUREMAP] = e => IfcTextureMap.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTUREVERTEX] = e => IfcTextureVertex.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTEXTUREVERTEXLIST] = e => IfcTextureVertexList.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTIMEPERIOD] = e => IfcTimePeriod.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTIMESERIES] = e => IfcTimeSeries.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTIMESERIESVALUE] = e => IfcTimeSeriesValue.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = e => IfcTopologicalRepresentationItem.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTOPOLOGYREPRESENTATION] = e => IfcTopologyRepresentation.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTOROIDALSURFACE] = e => IfcToroidalSurface.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRANSFORMER] = e => IfcTransformer.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRANSFORMERTYPE] = e => IfcTransformerType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = e => IfcTransitionCurveSegment2D.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRANSPORTELEMENT] = e => IfcTransportElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRANSPORTELEMENTTYPE] = e => IfcTransportElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = e => IfcTrapeziumProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRIANGULATEDFACESET] = e => IfcTriangulatedFaceSet.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = e => IfcTriangulatedIrregularNetwork.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTRIMMEDCURVE] = e => IfcTrimmedCurve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTUBEBUNDLE] = e => IfcTubeBundle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTUBEBUNDLETYPE] = e => IfcTubeBundleType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTYPEOBJECT] = e => IfcTypeObject.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTYPEPROCESS] = e => IfcTypeProcess.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTYPEPRODUCT] = e => IfcTypeProduct.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCTYPERESOURCE] = e => IfcTypeResource.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUSHAPEPROFILEDEF] = e => IfcUShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUNITASSIGNMENT] = e => IfcUnitAssignment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUNITARYCONTROLELEMENT] = e => IfcUnitaryControlElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = e => IfcUnitaryControlElementType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUNITARYEQUIPMENT] = e => IfcUnitaryEquipment.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = e => IfcUnitaryEquipmentType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVALVE] = e => IfcValve.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVALVETYPE] = e => IfcValveType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVECTOR] = e => IfcVector.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVERTEX] = e => IfcVertex.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVERTEXLOOP] = e => IfcVertexLoop.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVERTEXPOINT] = e => IfcVertexPoint.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIBRATIONDAMPER] = e => IfcVibrationDamper.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIBRATIONDAMPERTYPE] = e => IfcVibrationDamperType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIBRATIONISOLATOR] = e => IfcVibrationIsolator.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIBRATIONISOLATORTYPE] = e => IfcVibrationIsolatorType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIRTUALELEMENT] = e => IfcVirtualElement.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = e => IfcVirtualGridIntersection.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCVOIDINGFEATURE] = e => IfcVoidingFeature.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWALL] = e => IfcWall.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWALLELEMENTEDCASE] = e => IfcWallElementedCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWALLSTANDARDCASE] = e => IfcWallStandardCase.FromTape(e.ID, e.type, e.arguments); FromRawLineData[IFCWALLTYPE] = e => IfcWallType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWASTETERMINAL] = e => IfcWasteTerminal.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWASTETERMINALTYPE] = e => IfcWasteTerminalType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOW] = e => IfcWindow.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOWLININGPROPERTIES] = e => IfcWindowLiningProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOWPANELPROPERTIES] = e => IfcWindowPanelProperties.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOWSTANDARDCASE] = e => IfcWindowStandardCase.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOWSTYLE] = e => IfcWindowStyle.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWINDOWTYPE] = e => IfcWindowType.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWORKCALENDAR] = e => IfcWorkCalendar.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWORKCONTROL] = e => IfcWorkControl.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWORKPLAN] = e => IfcWorkPlan.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWORKSCHEDULE] = e => IfcWorkSchedule.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCWORKTIME] = e => IfcWorkTime.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCZSHAPEPROFILEDEF] = e => IfcZShapeProfileDef.FromTape(e.ID, e.type, e.arguments), FromRawLineData[IFCZONE] = e => IfcZone.FromTape(e.ID, e.type, e.arguments); var IfcActionRequest = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.PredefinedType = h, this.Status = l, this.LongDescription = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcActionRequest(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.PredefinedType), e.push(this.Status), e.push(this.LongDescription), e } }, IfcActor = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.TheActor = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcActor(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.TheActor), e } }, IfcActorRole = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Role = i, this.UserDefinedRole = s, this.Description = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcActorRole(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Role), e.push(this.UserDefinedRole), e.push(this.Description), e } }, IfcActuator = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcActuator(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcActuatorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcActuatorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAddress = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Purpose = i, this.Description = s, this.UserDefinedPurpose = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcAddress(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Purpose), e.push(this.Description), e.push(this.UserDefinedPurpose), e } }, IfcAdvancedBrep = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Outer = i } static FromTape(e, t, i) { return i = i[0], new IfcAdvancedBrep(e, t, i) } ToTape() { var e = []; return e.push(this.Outer), e } }, IfcAdvancedBrepWithVoids = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Outer = i, this.Voids = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcAdvancedBrepWithVoids(e, t, s, i) } ToTape() { var e = []; return e.push(this.Outer), e.push(this.Voids), e } }, IfcAdvancedFace = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Bounds = i, this.FaceSurface = s, this.SameSense = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcAdvancedFace(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Bounds), e.push(this.FaceSurface), e.push(this.SameSense), e } }, IfcAirTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAirTerminal(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcAirTerminalBox = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAirTerminalBox(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcAirTerminalBoxType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAirTerminalBoxType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAirTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAirTerminalType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAirToAirHeatRecovery = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAirToAirHeatRecovery(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcAirToAirHeatRecoveryType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAirToAirHeatRecoveryType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAlarm = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAlarm(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcAlarmType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAlarmType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAlignment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Axis = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAlignment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Axis), e.push(this.PredefinedType), e } }, IfcAlignment2DHorizontal = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.StartDistAlong = i, this.Segments = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcAlignment2DHorizontal(e, t, s, i) } ToTape() { var e = []; return e.push(this.StartDistAlong), e.push(this.Segments), e } }, IfcAlignment2DHorizontalSegment = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r, this.CurveGeometry = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcAlignment2DHorizontalSegment(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e.push(this.CurveGeometry), e } }, IfcAlignment2DSegment = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcAlignment2DSegment(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e } }, IfcAlignment2DVerSegCircularArc = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r, this.StartDistAlong = a, this.HorizontalLength = o, this.StartHeight = n, this.StartGradient = h, this.Radius = l, this.IsConvex = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAlignment2DVerSegCircularArc(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e.push(this.StartDistAlong), e.push(this.HorizontalLength), e.push(this.StartHeight), e.push(this.StartGradient), e.push(this.Radius), e.push(this.IsConvex), e } }, IfcAlignment2DVerSegLine = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r, this.StartDistAlong = a, this.HorizontalLength = o, this.StartHeight = n, this.StartGradient = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcAlignment2DVerSegLine(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e.push(this.StartDistAlong), e.push(this.HorizontalLength), e.push(this.StartHeight), e.push(this.StartGradient), e } }, IfcAlignment2DVerSegParabolicArc = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r, this.StartDistAlong = a, this.HorizontalLength = o, this.StartHeight = n, this.StartGradient = h, this.ParabolaConstant = l, this.IsConvex = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAlignment2DVerSegParabolicArc(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e.push(this.StartDistAlong), e.push(this.HorizontalLength), e.push(this.StartHeight), e.push(this.StartGradient), e.push(this.ParabolaConstant), e.push(this.IsConvex), e } }, IfcAlignment2DVertical = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Segments = i } static FromTape(e, t, i) { return i = i[0], new IfcAlignment2DVertical(e, t, i) } ToTape() { var e = []; return e.push(this.Segments), e } }, IfcAlignment2DVerticalSegment = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.TangentialContinuity = i, this.StartTag = s, this.EndTag = r, this.StartDistAlong = a, this.HorizontalLength = o, this.StartHeight = n, this.StartGradient = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcAlignment2DVerticalSegment(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.TangentialContinuity), e.push(this.StartTag), e.push(this.EndTag), e.push(this.StartDistAlong), e.push(this.HorizontalLength), e.push(this.StartHeight), e.push(this.StartGradient), e } }, IfcAlignmentCurve = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Horizontal = i, this.Vertical = s, this.Tag = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcAlignmentCurve(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Horizontal), e.push(this.Vertical), e.push(this.Tag), e } }, IfcAnnotation = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcAnnotation(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcAnnotationFillArea = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.OuterBoundary = i, this.InnerBoundaries = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcAnnotationFillArea(e, t, s, i) } ToTape() { var e = []; return e.push(this.OuterBoundary), e.push(this.InnerBoundaries), e } }, IfcApplication = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ApplicationDeveloper = i, this.Version = s, this.ApplicationFullName = r, this.ApplicationIdentifier = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcApplication(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ApplicationDeveloper), e.push(this.Version), e.push(this.ApplicationFullName), e.push(this.ApplicationIdentifier), e } }, IfcAppliedValue = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.AppliedValue = r, this.UnitBasis = a, this.ApplicableDate = o, this.FixedUntilDate = n, this.Category = h, this.Condition = l, this.ArithmeticOperator = c, this.Components = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAppliedValue(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.AppliedValue), e.push(this.UnitBasis), e.push(this.ApplicableDate), e.push(this.FixedUntilDate), e.push(this.Category), e.push(this.Condition), e.push(this.ArithmeticOperator), e.push(this.Components), e } }, IfcApproval = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Identifier = i, this.Name = s, this.Description = r, this.TimeOfApproval = a, this.Status = o, this.Level = n, this.Qualifier = h, this.RequestingApproval = l, this.GivingApproval = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcApproval(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Identifier), e.push(this.Name), e.push(this.Description), e.push(this.TimeOfApproval), e.push(this.Status), e.push(this.Level), e.push(this.Qualifier), e.push(this.RequestingApproval), e.push(this.GivingApproval), e } }, IfcApprovalRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingApproval = r, this.RelatedApprovals = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcApprovalRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingApproval), e.push(this.RelatedApprovals), e } }, IfcArbitraryClosedProfileDef = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.OuterCurve = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcArbitraryClosedProfileDef(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.OuterCurve), e } }, IfcArbitraryOpenProfileDef = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Curve = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcArbitraryOpenProfileDef(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Curve), e } }, IfcArbitraryProfileDefWithVoids = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.OuterCurve = r, this.InnerCurves = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcArbitraryProfileDefWithVoids(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.OuterCurve), e.push(this.InnerCurves), e } }, IfcAsset = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.OriginalValue = h, this.CurrentValue = l, this.TotalReplacementCost = c, this.Owner = u, this.User = p, this.ResponsiblePerson = d, this.IncorporationDate = m, this.DepreciatedValue = f } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[+s], d = i[9], m = i[10], f = i[11]; s = i[12], i = i[13]; return new IfcAsset(e, t, r, a, o, n, h, l, c, u, p, d, m, f, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.OriginalValue), e.push(this.CurrentValue), e.push(this.TotalReplacementCost), e.push(this.Owner), e.push(this.User), e.push(this.ResponsiblePerson), e.push(this.IncorporationDate), e.push(this.DepreciatedValue), e } }, IfcAsymmetricIShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.BottomFlangeWidth = a, this.OverallDepth = o, this.WebThickness = n, this.BottomFlangeThickness = h, this.BottomFlangeFilletRadius = l, this.TopFlangeWidth = c, this.TopFlangeThickness = u, this.TopFlangeFilletRadius = p, this.BottomFlangeEdgeRadius = d, this.BottomFlangeSlope = m, this.TopFlangeEdgeRadius = f, this.TopFlangeSlope = g } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[+s], m = i[10], f = i[11], g = i[12]; s = i[13], i = i[14]; return new IfcAsymmetricIShapeProfileDef(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.BottomFlangeWidth), e.push(this.OverallDepth), e.push(this.WebThickness), e.push(this.BottomFlangeThickness), e.push(this.BottomFlangeFilletRadius), e.push(this.TopFlangeWidth), e.push(this.TopFlangeThickness), e.push(this.TopFlangeFilletRadius), e.push(this.BottomFlangeEdgeRadius), e.push(this.BottomFlangeSlope), e.push(this.TopFlangeEdgeRadius), e.push(this.TopFlangeSlope), e } }, IfcAudioVisualAppliance = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcAudioVisualAppliance(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcAudioVisualApplianceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcAudioVisualApplianceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcAxis1Placement = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Location = i, this.Axis = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcAxis1Placement(e, t, s, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Axis), e } }, IfcAxis2Placement2D = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Location = i, this.RefDirection = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcAxis2Placement2D(e, t, s, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.RefDirection), e } }, IfcAxis2Placement3D = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Location = i, this.Axis = s, this.RefDirection = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcAxis2Placement3D(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Axis), e.push(this.RefDirection), e } }, IfcBSplineCurve = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Degree = i, this.ControlPointsList = s, this.CurveForm = r, this.ClosedCurve = a, this.SelfIntersect = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcBSplineCurve(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Degree), e.push(this.ControlPointsList), e.push(this.CurveForm), e.push(this.ClosedCurve), e.push(this.SelfIntersect), e } }, IfcBSplineCurveWithKnots = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Degree = i, this.ControlPointsList = s, this.CurveForm = r, this.ClosedCurve = a, this.SelfIntersect = o, this.KnotMultiplicities = n, this.Knots = h, this.KnotSpec = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcBSplineCurveWithKnots(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Degree), e.push(this.ControlPointsList), e.push(this.CurveForm), e.push(this.ClosedCurve), e.push(this.SelfIntersect), e.push(this.KnotMultiplicities), e.push(this.Knots), e.push(this.KnotSpec), e } }, IfcBSplineSurface = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.UDegree = i, this.VDegree = s, this.ControlPointsList = r, this.SurfaceForm = a, this.UClosed = o, this.VClosed = n, this.SelfIntersect = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcBSplineSurface(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.UDegree), e.push(this.VDegree), e.push(this.ControlPointsList), e.push(this.SurfaceForm), e.push(this.UClosed), e.push(this.VClosed), e.push(this.SelfIntersect), e } }, IfcBSplineSurfaceWithKnots = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.UDegree = i, this.VDegree = s, this.ControlPointsList = r, this.SurfaceForm = a, this.UClosed = o, this.VClosed = n, this.SelfIntersect = h, this.UMultiplicities = l, this.VMultiplicities = c, this.UKnots = u, this.VKnots = p, this.KnotSpec = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcBSplineSurfaceWithKnots(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.UDegree), e.push(this.VDegree), e.push(this.ControlPointsList), e.push(this.SurfaceForm), e.push(this.UClosed), e.push(this.VClosed), e.push(this.SelfIntersect), e.push(this.UMultiplicities), e.push(this.VMultiplicities), e.push(this.UKnots), e.push(this.VKnots), e.push(this.KnotSpec), e } }, IfcBeam = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBeam(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBeamStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBeamStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBeamType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBeamType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcBearing = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBearing(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBearingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBearingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcBlobTexture = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.RepeatS = i, this.RepeatT = s, this.Mode = r, this.TextureTransform = a, this.Parameter = o, this.RasterFormat = n, this.RasterCode = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcBlobTexture(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.RepeatS), e.push(this.RepeatT), e.push(this.Mode), e.push(this.TextureTransform), e.push(this.Parameter), e.push(this.RasterFormat), e.push(this.RasterCode), e } }, IfcBlock = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Position = i, this.XLength = s, this.YLength = r, this.ZLength = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcBlock(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.XLength), e.push(this.YLength), e.push(this.ZLength), e } }, IfcBoiler = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBoiler(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBoilerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBoilerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcBooleanClippingResult = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Operator = i, this.FirstOperand = s, this.SecondOperand = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcBooleanClippingResult(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Operator), e.push(this.FirstOperand), e.push(this.SecondOperand), e } }, IfcBooleanResult = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Operator = i, this.FirstOperand = s, this.SecondOperand = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcBooleanResult(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Operator), e.push(this.FirstOperand), e.push(this.SecondOperand), e } }, IfcBoundaryCondition = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcBoundaryCondition(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcBoundaryCurve = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Segments = i, this.SelfIntersect = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcBoundaryCurve(e, t, s, i) } ToTape() { var e = []; return e.push(this.Segments), e.push(this.SelfIntersect), e } }, IfcBoundaryEdgeCondition = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.TranslationalStiffnessByLengthX = s, this.TranslationalStiffnessByLengthY = r, this.TranslationalStiffnessByLengthZ = a, this.RotationalStiffnessByLengthX = o, this.RotationalStiffnessByLengthY = n, this.RotationalStiffnessByLengthZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcBoundaryEdgeCondition(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TranslationalStiffnessByLengthX), e.push(this.TranslationalStiffnessByLengthY), e.push(this.TranslationalStiffnessByLengthZ), e.push(this.RotationalStiffnessByLengthX), e.push(this.RotationalStiffnessByLengthY), e.push(this.RotationalStiffnessByLengthZ), e } }, IfcBoundaryFaceCondition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.TranslationalStiffnessByAreaX = s, this.TranslationalStiffnessByAreaY = r, this.TranslationalStiffnessByAreaZ = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcBoundaryFaceCondition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TranslationalStiffnessByAreaX), e.push(this.TranslationalStiffnessByAreaY), e.push(this.TranslationalStiffnessByAreaZ), e } }, IfcBoundaryNodeCondition = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.TranslationalStiffnessX = s, this.TranslationalStiffnessY = r, this.TranslationalStiffnessZ = a, this.RotationalStiffnessX = o, this.RotationalStiffnessY = n, this.RotationalStiffnessZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcBoundaryNodeCondition(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TranslationalStiffnessX), e.push(this.TranslationalStiffnessY), e.push(this.TranslationalStiffnessZ), e.push(this.RotationalStiffnessX), e.push(this.RotationalStiffnessY), e.push(this.RotationalStiffnessZ), e } }, IfcBoundaryNodeConditionWarping = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.TranslationalStiffnessX = s, this.TranslationalStiffnessY = r, this.TranslationalStiffnessZ = a, this.RotationalStiffnessX = o, this.RotationalStiffnessY = n, this.RotationalStiffnessZ = h, this.WarpingStiffness = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcBoundaryNodeConditionWarping(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TranslationalStiffnessX), e.push(this.TranslationalStiffnessY), e.push(this.TranslationalStiffnessZ), e.push(this.RotationalStiffnessX), e.push(this.RotationalStiffnessY), e.push(this.RotationalStiffnessZ), e.push(this.WarpingStiffness), e } }, IfcBoundedCurve = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcBoundedCurve(e, t) } ToTape() { return [] } }, IfcBoundedSurface = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcBoundedSurface(e, t) } ToTape() { return [] } }, IfcBoundingBox = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Corner = i, this.XDim = s, this.YDim = r, this.ZDim = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcBoundingBox(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Corner), e.push(this.XDim), e.push(this.YDim), e.push(this.ZDim), e } }, IfcBoxedHalfSpace = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BaseSurface = i, this.AgreementFlag = s, this.Enclosure = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcBoxedHalfSpace(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BaseSurface), e.push(this.AgreementFlag), e.push(this.Enclosure), e } }, IfcBridge = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBridge(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.PredefinedType), e } }, IfcBridgePart = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBridgePart(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.PredefinedType), e } }, IfcBuilding = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.ElevationOfRefHeight = u, this.ElevationOfTerrain = p, this.BuildingAddress = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcBuilding(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.ElevationOfRefHeight), e.push(this.ElevationOfTerrain), e.push(this.BuildingAddress), e } }, IfcBuildingElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcBuildingElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcBuildingElementPart = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBuildingElementPart(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBuildingElementPartType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBuildingElementPartType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcBuildingElementProxy = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBuildingElementProxy(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBuildingElementProxyType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBuildingElementProxyType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcBuildingElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBuildingElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcBuildingStorey = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.Elevation = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBuildingStorey(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.Elevation), e } }, IfcBuildingSystem = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.PredefinedType = n, this.LongName = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcBuildingSystem(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.PredefinedType), e.push(this.LongName), e } }, IfcBurner = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcBurner(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcBurnerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcBurnerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Depth = a, this.Width = o, this.WallThickness = n, this.Girth = h, this.InternalFilletRadius = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcCShapeProfileDef(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Depth), e.push(this.Width), e.push(this.WallThickness), e.push(this.Girth), e.push(this.InternalFilletRadius), e } }, IfcCableCarrierFitting = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCableCarrierFitting(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCableCarrierFittingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCableCarrierFittingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCableCarrierSegment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCableCarrierSegment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCableCarrierSegmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCableCarrierSegmentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCableFitting = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCableFitting(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCableFittingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCableFittingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCableSegment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCableSegment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCableSegmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCableSegmentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCaissonFoundation = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCaissonFoundation(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCaissonFoundationType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCaissonFoundationType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCartesianPoint = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Coordinates = i } static FromTape(e, t, i) { return i = i[0], new IfcCartesianPoint(e, t, i) } ToTape() { var e = []; return e.push(this.Coordinates), e } }, IfcCartesianPointList = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcCartesianPointList(e, t) } ToTape() { return [] } }, IfcCartesianPointList2D = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.CoordList = i, this.TagList = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCartesianPointList2D(e, t, s, i) } ToTape() { var e = []; return e.push(this.CoordList), e.push(this.TagList), e } }, IfcCartesianPointList3D = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.CoordList = i, this.TagList = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCartesianPointList3D(e, t, s, i) } ToTape() { var e = []; return e.push(this.CoordList), e.push(this.TagList), e } }, IfcCartesianTransformationOperator = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Axis1 = i, this.Axis2 = s, this.LocalOrigin = r, this.Scale = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCartesianTransformationOperator(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Axis1), e.push(this.Axis2), e.push(this.LocalOrigin), e.push(this.Scale), e } }, IfcCartesianTransformationOperator2D = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Axis1 = i, this.Axis2 = s, this.LocalOrigin = r, this.Scale = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCartesianTransformationOperator2D(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Axis1), e.push(this.Axis2), e.push(this.LocalOrigin), e.push(this.Scale), e } }, IfcCartesianTransformationOperator2DnonUniform = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Axis1 = i, this.Axis2 = s, this.LocalOrigin = r, this.Scale = a, this.Scale2 = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcCartesianTransformationOperator2DnonUniform(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Axis1), e.push(this.Axis2), e.push(this.LocalOrigin), e.push(this.Scale), e.push(this.Scale2), e } }, IfcCartesianTransformationOperator3D = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Axis1 = i, this.Axis2 = s, this.LocalOrigin = r, this.Scale = a, this.Axis3 = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcCartesianTransformationOperator3D(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Axis1), e.push(this.Axis2), e.push(this.LocalOrigin), e.push(this.Scale), e.push(this.Axis3), e } }, IfcCartesianTransformationOperator3DnonUniform = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Axis1 = i, this.Axis2 = s, this.LocalOrigin = r, this.Scale = a, this.Axis3 = o, this.Scale2 = n, this.Scale3 = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcCartesianTransformationOperator3DnonUniform(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Axis1), e.push(this.Axis2), e.push(this.LocalOrigin), e.push(this.Scale), e.push(this.Axis3), e.push(this.Scale2), e.push(this.Scale3), e } }, IfcCenterLineProfileDef = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Curve = r, this.Thickness = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCenterLineProfileDef(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Curve), e.push(this.Thickness), e } }, IfcChiller = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcChiller(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcChillerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcChillerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcChimney = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcChimney(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcChimneyType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcChimneyType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCircle = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Position = i, this.Radius = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCircle(e, t, s, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Radius), e } }, IfcCircleHollowProfileDef = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Radius = a, this.WallThickness = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcCircleHollowProfileDef(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Radius), e.push(this.WallThickness), e } }, IfcCircleProfileDef = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Radius = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCircleProfileDef(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Radius), e } }, IfcCircularArcSegment2D = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.StartPoint = i, this.StartDirection = s, this.SegmentLength = r, this.Radius = a, this.IsCCW = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcCircularArcSegment2D(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.StartPoint), e.push(this.StartDirection), e.push(this.SegmentLength), e.push(this.Radius), e.push(this.IsCCW), e } }, IfcCivilElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcCivilElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcCivilElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCivilElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcClassification = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Source = i, this.Edition = s, this.EditionDate = r, this.Name = a, this.Description = o, this.Location = n, this.ReferenceTokens = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcClassification(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Source), e.push(this.Edition), e.push(this.EditionDate), e.push(this.Name), e.push(this.Description), e.push(this.Location), e.push(this.ReferenceTokens), e } }, IfcClassificationReference = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r, this.ReferencedSource = a, this.Description = o, this.Sort = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcClassificationReference(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e.push(this.ReferencedSource), e.push(this.Description), e.push(this.Sort), e } }, IfcClosedShell = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.CfsFaces = i } static FromTape(e, t, i) { return i = i[0], new IfcClosedShell(e, t, i) } ToTape() { var e = []; return e.push(this.CfsFaces), e } }, IfcCoil = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCoil(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCoilType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCoilType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcColourRgb = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Red = s, this.Green = r, this.Blue = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcColourRgb(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Red), e.push(this.Green), e.push(this.Blue), e } }, IfcColourRgbList = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.ColourList = i } static FromTape(e, t, i) { return i = i[0], new IfcColourRgbList(e, t, i) } ToTape() { var e = []; return e.push(this.ColourList), e } }, IfcColourSpecification = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcColourSpecification(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcColumn = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcColumn(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcColumnStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcColumnStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcColumnType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcColumnType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCommunicationsAppliance = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCommunicationsAppliance(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCommunicationsApplianceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCommunicationsApplianceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcComplexProperty = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.UsageName = r, this.HasProperties = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcComplexProperty(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.UsageName), e.push(this.HasProperties), e } }, IfcComplexPropertyTemplate = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.UsageName = o, this.TemplateType = n, this.HasPropertyTemplates = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcComplexPropertyTemplate(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.UsageName), e.push(this.TemplateType), e.push(this.HasPropertyTemplates), e } }, IfcCompositeCurve = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Segments = i, this.SelfIntersect = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCompositeCurve(e, t, s, i) } ToTape() { var e = []; return e.push(this.Segments), e.push(this.SelfIntersect), e } }, IfcCompositeCurveOnSurface = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Segments = i, this.SelfIntersect = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCompositeCurveOnSurface(e, t, s, i) } ToTape() { var e = []; return e.push(this.Segments), e.push(this.SelfIntersect), e } }, IfcCompositeCurveSegment = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Transition = i, this.SameSense = s, this.ParentCurve = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcCompositeCurveSegment(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Transition), e.push(this.SameSense), e.push(this.ParentCurve), e } }, IfcCompositeProfileDef = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Profiles = r, this.Label = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCompositeProfileDef(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Profiles), e.push(this.Label), e } }, IfcCompressor = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCompressor(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCompressorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCompressorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCondenser = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCondenser(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCondenserType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCondenserType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcConic = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Position = i } static FromTape(e, t, i) { return i = i[0], new IfcConic(e, t, i) } ToTape() { var e = []; return e.push(this.Position), e } }, IfcConnectedFaceSet = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.CfsFaces = i } static FromTape(e, t, i) { return i = i[0], new IfcConnectedFaceSet(e, t, i) } ToTape() { var e = []; return e.push(this.CfsFaces), e } }, IfcConnectionCurveGeometry = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.CurveOnRelatingElement = i, this.CurveOnRelatedElement = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcConnectionCurveGeometry(e, t, s, i) } ToTape() { var e = []; return e.push(this.CurveOnRelatingElement), e.push(this.CurveOnRelatedElement), e } }, IfcConnectionGeometry = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcConnectionGeometry(e, t) } ToTape() { return [] } }, IfcConnectionPointEccentricity = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.PointOnRelatingElement = i, this.PointOnRelatedElement = s, this.EccentricityInX = r, this.EccentricityInY = a, this.EccentricityInZ = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcConnectionPointEccentricity(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.PointOnRelatingElement), e.push(this.PointOnRelatedElement), e.push(this.EccentricityInX), e.push(this.EccentricityInY), e.push(this.EccentricityInZ), e } }, IfcConnectionPointGeometry = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.PointOnRelatingElement = i, this.PointOnRelatedElement = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcConnectionPointGeometry(e, t, s, i) } ToTape() { var e = []; return e.push(this.PointOnRelatingElement), e.push(this.PointOnRelatedElement), e } }, IfcConnectionSurfaceGeometry = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SurfaceOnRelatingElement = i, this.SurfaceOnRelatedElement = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcConnectionSurfaceGeometry(e, t, s, i) } ToTape() { var e = []; return e.push(this.SurfaceOnRelatingElement), e.push(this.SurfaceOnRelatedElement), e } }, IfcConnectionVolumeGeometry = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.VolumeOnRelatingElement = i, this.VolumeOnRelatedElement = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcConnectionVolumeGeometry(e, t, s, i) } ToTape() { var e = []; return e.push(this.VolumeOnRelatingElement), e.push(this.VolumeOnRelatedElement), e } }, IfcConstraint = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.ConstraintGrade = r, this.ConstraintSource = a, this.CreatingActor = o, this.CreationTime = n, this.UserDefinedGrade = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcConstraint(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.ConstraintGrade), e.push(this.ConstraintSource), e.push(this.CreatingActor), e.push(this.CreationTime), e.push(this.UserDefinedGrade), e } }, IfcConstructionEquipmentResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcConstructionEquipmentResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionEquipmentResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcConstructionEquipmentResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionMaterialResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcConstructionMaterialResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionMaterialResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcConstructionMaterialResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionProductResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcConstructionProductResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionProductResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcConstructionProductResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcConstructionResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcConstructionResource(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e } }, IfcConstructionResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcConstructionResourceType(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e } }, IfcContext = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n, this.Phase = h, this.RepresentationContexts = l, this.UnitsInContext = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcContext(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e.push(this.Phase), e.push(this.RepresentationContexts), e.push(this.UnitsInContext), e } }, IfcContextDependentUnit = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Dimensions = i, this.UnitType = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcContextDependentUnit(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Dimensions), e.push(this.UnitType), e.push(this.Name), e } }, IfcControl = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcControl(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e } }, IfcController = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcController(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcControllerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcControllerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcConversionBasedUnit = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Dimensions = i, this.UnitType = s, this.Name = r, this.ConversionFactor = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcConversionBasedUnit(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Dimensions), e.push(this.UnitType), e.push(this.Name), e.push(this.ConversionFactor), e } }, IfcConversionBasedUnitWithOffset = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Dimensions = i, this.UnitType = s, this.Name = r, this.ConversionFactor = a, this.ConversionOffset = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcConversionBasedUnitWithOffset(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Dimensions), e.push(this.UnitType), e.push(this.Name), e.push(this.ConversionFactor), e.push(this.ConversionOffset), e } }, IfcCooledBeam = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCooledBeam(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCooledBeamType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCooledBeamType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCoolingTower = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCoolingTower(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCoolingTowerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCoolingTowerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCoordinateOperation = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SourceCRS = i, this.TargetCRS = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCoordinateOperation(e, t, s, i) } ToTape() { var e = []; return e.push(this.SourceCRS), e.push(this.TargetCRS), e } }, IfcCoordinateReferenceSystem = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.GeodeticDatum = r, this.VerticalDatum = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcCoordinateReferenceSystem(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.GeodeticDatum), e.push(this.VerticalDatum), e } }, IfcCostItem = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.PredefinedType = h, this.CostValues = l, this.CostQuantities = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCostItem(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.PredefinedType), e.push(this.CostValues), e.push(this.CostQuantities), e } }, IfcCostSchedule = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.PredefinedType = h, this.Status = l, this.SubmittedOn = c, this.UpdateDate = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCostSchedule(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.PredefinedType), e.push(this.Status), e.push(this.SubmittedOn), e.push(this.UpdateDate), e } }, IfcCostValue = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.AppliedValue = r, this.UnitBasis = a, this.ApplicableDate = o, this.FixedUntilDate = n, this.Category = h, this.Condition = l, this.ArithmeticOperator = c, this.Components = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCostValue(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.AppliedValue), e.push(this.UnitBasis), e.push(this.ApplicableDate), e.push(this.FixedUntilDate), e.push(this.Category), e.push(this.Condition), e.push(this.ArithmeticOperator), e.push(this.Components), e } }, IfcCovering = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCovering(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCoveringType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCoveringType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCrewResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcCrewResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcCrewResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcCrewResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcCsgPrimitive3D = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Position = i } static FromTape(e, t, i) { return i = i[0], new IfcCsgPrimitive3D(e, t, i) } ToTape() { var e = []; return e.push(this.Position), e } }, IfcCsgSolid = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.TreeRootExpression = i } static FromTape(e, t, i) { return i = i[0], new IfcCsgSolid(e, t, i) } ToTape() { var e = []; return e.push(this.TreeRootExpression), e } }, IfcCurrencyRelationship = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingMonetaryUnit = r, this.RelatedMonetaryUnit = a, this.ExchangeRate = o, this.RateDateTime = n, this.RateSource = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcCurrencyRelationship(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingMonetaryUnit), e.push(this.RelatedMonetaryUnit), e.push(this.ExchangeRate), e.push(this.RateDateTime), e.push(this.RateSource), e } }, IfcCurtainWall = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcCurtainWall(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcCurtainWallType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcCurtainWallType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcCurve = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcCurve(e, t) } ToTape() { return [] } }, IfcCurveBoundedPlane = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BasisSurface = i, this.OuterBoundary = s, this.InnerBoundaries = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcCurveBoundedPlane(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BasisSurface), e.push(this.OuterBoundary), e.push(this.InnerBoundaries), e } }, IfcCurveBoundedSurface = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BasisSurface = i, this.Boundaries = s, this.ImplicitOuter = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcCurveBoundedSurface(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BasisSurface), e.push(this.Boundaries), e.push(this.ImplicitOuter), e } }, IfcCurveSegment2D = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.StartPoint = i, this.StartDirection = s, this.SegmentLength = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcCurveSegment2D(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.StartPoint), e.push(this.StartDirection), e.push(this.SegmentLength), e } }, IfcCurveStyle = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.CurveFont = s, this.CurveWidth = r, this.CurveColour = a, this.ModelOrDraughting = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcCurveStyle(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.CurveFont), e.push(this.CurveWidth), e.push(this.CurveColour), e.push(this.ModelOrDraughting), e } }, IfcCurveStyleFont = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Name = i, this.PatternList = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCurveStyleFont(e, t, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.PatternList), e } }, IfcCurveStyleFontAndScaling = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.CurveFont = s, this.CurveFontScaling = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcCurveStyleFontAndScaling(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.CurveFont), e.push(this.CurveFontScaling), e } }, IfcCurveStyleFontPattern = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.VisibleSegmentLength = i, this.InvisibleSegmentLength = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCurveStyleFontPattern(e, t, s, i) } ToTape() { var e = []; return e.push(this.VisibleSegmentLength), e.push(this.InvisibleSegmentLength), e } }, IfcCylindricalSurface = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Position = i, this.Radius = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcCylindricalSurface(e, t, s, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Radius), e } }, IfcDamper = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDamper(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDamperType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDamperType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcDeepFoundation = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcDeepFoundation(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcDeepFoundationType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDeepFoundationType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcDerivedProfileDef = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.ParentProfile = r, this.Operator = a, this.Label = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcDerivedProfileDef(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.ParentProfile), e.push(this.Operator), e.push(this.Label), e } }, IfcDerivedUnit = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Elements = i, this.UnitType = s, this.UserDefinedType = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcDerivedUnit(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Elements), e.push(this.UnitType), e.push(this.UserDefinedType), e } }, IfcDerivedUnitElement = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Unit = i, this.Exponent = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcDerivedUnitElement(e, t, s, i) } ToTape() { var e = []; return e.push(this.Unit), e.push(this.Exponent), e } }, IfcDimensionalExponents = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.LengthExponent = i, this.MassExponent = s, this.TimeExponent = r, this.ElectricCurrentExponent = a, this.ThermodynamicTemperatureExponent = o, this.AmountOfSubstanceExponent = n, this.LuminousIntensityExponent = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcDimensionalExponents(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.LengthExponent), e.push(this.MassExponent), e.push(this.TimeExponent), e.push(this.ElectricCurrentExponent), e.push(this.ThermodynamicTemperatureExponent), e.push(this.AmountOfSubstanceExponent), e.push(this.LuminousIntensityExponent), e } }, IfcDirection = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.DirectionRatios = i } static FromTape(e, t, i) { return i = i[0], new IfcDirection(e, t, i) } ToTape() { var e = []; return e.push(this.DirectionRatios), e } }, IfcDiscreteAccessory = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDiscreteAccessory(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDiscreteAccessoryType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDiscreteAccessoryType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcDistanceExpression = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.DistanceAlong = i, this.OffsetLateral = s, this.OffsetVertical = r, this.OffsetLongitudinal = a, this.AlongHorizontal = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcDistanceExpression(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.DistanceAlong), e.push(this.OffsetLateral), e.push(this.OffsetVertical), e.push(this.OffsetLongitudinal), e.push(this.AlongHorizontal), e } }, IfcDistributionChamberElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDistributionChamberElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDistributionChamberElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDistributionChamberElementType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcDistributionCircuit = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n, this.PredefinedType = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcDistributionCircuit(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e.push(this.PredefinedType), e } }, IfcDistributionControlElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcDistributionControlElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcDistributionControlElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDistributionControlElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcDistributionElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcDistributionElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcDistributionElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDistributionElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcDistributionFlowElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcDistributionFlowElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcDistributionFlowElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDistributionFlowElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcDistributionPort = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.FlowDirection = l, this.PredefinedType = c, this.SystemType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDistributionPort(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.FlowDirection), e.push(this.PredefinedType), e.push(this.SystemType), e } }, IfcDistributionSystem = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n, this.PredefinedType = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcDistributionSystem(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e.push(this.PredefinedType), e } }, IfcDocumentInformation = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v) { this.expressID = e, this.type = t, this.Identification = i, this.Name = s, this.Description = r, this.Location = a, this.Purpose = o, this.IntendedUse = n, this.Scope = h, this.Revision = l, this.DocumentOwner = c, this.Editors = u, this.CreationTime = p, this.LastRevisionTime = d, this.ElectronicFormat = m, this.ValidFrom = f, this.ValidUntil = g, this.Confidentiality = _, this.Status = v } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[+s], g = i[12], _ = i[13], v = i[14]; s = i[15], i = i[16]; return new IfcDocumentInformation(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, s, i) } ToTape() { var e = []; return e.push(this.Identification), e.push(this.Name), e.push(this.Description), e.push(this.Location), e.push(this.Purpose), e.push(this.IntendedUse), e.push(this.Scope), e.push(this.Revision), e.push(this.DocumentOwner), e.push(this.Editors), e.push(this.CreationTime), e.push(this.LastRevisionTime), e.push(this.ElectronicFormat), e.push(this.ValidFrom), e.push(this.ValidUntil), e.push(this.Confidentiality), e.push(this.Status), e } }, IfcDocumentInformationRelationship = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingDocument = r, this.RelatedDocuments = a, this.RelationshipType = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcDocumentInformationRelationship(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingDocument), e.push(this.RelatedDocuments), e.push(this.RelationshipType), e } }, IfcDocumentReference = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r, this.Description = a, this.ReferencedDocument = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcDocumentReference(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e.push(this.Description), e.push(this.ReferencedDocument), e } }, IfcDoor = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.OverallHeight = c, this.OverallWidth = u, this.PredefinedType = p, this.OperationType = d, this.UserDefinedOperationType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcDoor(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.OverallHeight), e.push(this.OverallWidth), e.push(this.PredefinedType), e.push(this.OperationType), e.push(this.UserDefinedOperationType), e } }, IfcDoorLiningProperties = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.LiningDepth = o, this.LiningThickness = n, this.ThresholdDepth = h, this.ThresholdThickness = l, this.TransomThickness = c, this.TransomOffset = u, this.LiningOffset = p, this.ThresholdOffset = d, this.CasingThickness = m, this.CasingDepth = f, this.ShapeAspectStyle = g, this.LiningToPanelOffsetX = _, this.LiningToPanelOffsetY = v } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[+s], g = i[12], _ = i[13], v = i[14]; s = i[15], i = i[16]; return new IfcDoorLiningProperties(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.LiningDepth), e.push(this.LiningThickness), e.push(this.ThresholdDepth), e.push(this.ThresholdThickness), e.push(this.TransomThickness), e.push(this.TransomOffset), e.push(this.LiningOffset), e.push(this.ThresholdOffset), e.push(this.CasingThickness), e.push(this.CasingDepth), e.push(this.ShapeAspectStyle), e.push(this.LiningToPanelOffsetX), e.push(this.LiningToPanelOffsetY), e } }, IfcDoorPanelProperties = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.PanelDepth = o, this.PanelOperation = n, this.PanelWidth = h, this.PanelPosition = l, this.ShapeAspectStyle = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDoorPanelProperties(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.PanelDepth), e.push(this.PanelOperation), e.push(this.PanelWidth), e.push(this.PanelPosition), e.push(this.ShapeAspectStyle), e } }, IfcDoorStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.OverallHeight = c, this.OverallWidth = u, this.PredefinedType = p, this.OperationType = d, this.UserDefinedOperationType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcDoorStandardCase(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.OverallHeight), e.push(this.OverallWidth), e.push(this.PredefinedType), e.push(this.OperationType), e.push(this.UserDefinedOperationType), e } }, IfcDoorStyle = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.OperationType = c, this.ConstructionType = u, this.ParameterTakesPrecedence = p, this.Sizeable = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcDoorStyle(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.OperationType), e.push(this.ConstructionType), e.push(this.ParameterTakesPrecedence), e.push(this.Sizeable), e } }, IfcDoorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.OperationType = p, this.ParameterTakesPrecedence = d, this.UserDefinedOperationType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcDoorType(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.OperationType), e.push(this.ParameterTakesPrecedence), e.push(this.UserDefinedOperationType), e } }, IfcDraughtingPreDefinedColour = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcDraughtingPreDefinedColour(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcDraughtingPreDefinedCurveFont = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcDraughtingPreDefinedCurveFont(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcDuctFitting = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDuctFitting(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDuctFittingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDuctFittingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcDuctSegment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDuctSegment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDuctSegmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDuctSegmentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcDuctSilencer = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcDuctSilencer(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcDuctSilencerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcDuctSilencerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcEdge = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.EdgeStart = i, this.EdgeEnd = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcEdge(e, t, s, i) } ToTape() { var e = []; return e.push(this.EdgeStart), e.push(this.EdgeEnd), e } }, IfcEdgeCurve = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.EdgeStart = i, this.EdgeEnd = s, this.EdgeGeometry = r, this.SameSense = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcEdgeCurve(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.EdgeStart), e.push(this.EdgeEnd), e.push(this.EdgeGeometry), e.push(this.SameSense), e } }, IfcEdgeLoop = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.EdgeList = i } static FromTape(e, t, i) { return i = i[0], new IfcEdgeLoop(e, t, i) } ToTape() { var e = []; return e.push(this.EdgeList), e } }, IfcElectricAppliance = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricAppliance(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricApplianceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricApplianceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElectricDistributionBoard = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricDistributionBoard(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricDistributionBoardType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricDistributionBoardType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElectricFlowStorageDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricFlowStorageDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricFlowStorageDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricFlowStorageDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElectricGenerator = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricGenerator(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricGeneratorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricGeneratorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElectricMotor = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricMotor(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricMotorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricMotorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElectricTimeControl = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElectricTimeControl(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcElectricTimeControlType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElectricTimeControlType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcElementAssembly = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.AssemblyPlace = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElementAssembly(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.AssemblyPlace), e.push(this.PredefinedType), e } }, IfcElementAssemblyType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcElementAssemblyType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcElementComponent = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcElementComponent(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcElementComponentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElementComponentType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcElementQuantity = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.MethodOfMeasurement = o, this.Quantities = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcElementQuantity(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.MethodOfMeasurement), e.push(this.Quantities), e } }, IfcElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcElementarySurface = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Position = i } static FromTape(e, t, i) { return i = i[0], new IfcElementarySurface(e, t, i) } ToTape() { var e = []; return e.push(this.Position), e } }, IfcEllipse = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Position = i, this.SemiAxis1 = s, this.SemiAxis2 = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcEllipse(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.SemiAxis1), e.push(this.SemiAxis2), e } }, IfcEllipseProfileDef = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.SemiAxis1 = a, this.SemiAxis2 = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcEllipseProfileDef(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.SemiAxis1), e.push(this.SemiAxis2), e } }, IfcEnergyConversionDevice = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcEnergyConversionDevice(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcEnergyConversionDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcEnergyConversionDeviceType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcEngine = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcEngine(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcEngineType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcEngineType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcEvaporativeCooler = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcEvaporativeCooler(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcEvaporativeCoolerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcEvaporativeCoolerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcEvaporator = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcEvaporator(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcEvaporatorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcEvaporatorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcEvent = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.PredefinedType = l, this.EventTriggerType = c, this.UserDefinedEventTriggerType = u, this.EventOccurenceTime = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcEvent(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.PredefinedType), e.push(this.EventTriggerType), e.push(this.UserDefinedEventTriggerType), e.push(this.EventOccurenceTime), e } }, IfcEventTime = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.ActualDate = a, this.EarlyDate = o, this.LateDate = n, this.ScheduleDate = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcEventTime(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.ActualDate), e.push(this.EarlyDate), e.push(this.LateDate), e.push(this.ScheduleDate), e } }, IfcEventType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ProcessType = c, this.PredefinedType = u, this.EventTriggerType = p, this.UserDefinedEventTriggerType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcEventType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ProcessType), e.push(this.PredefinedType), e.push(this.EventTriggerType), e.push(this.UserDefinedEventTriggerType), e } }, IfcExtendedProperties = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Properties = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcExtendedProperties(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Properties), e } }, IfcExternalInformation = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcExternalInformation(e, t) } ToTape() { return [] } }, IfcExternalReference = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcExternalReference(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e } }, IfcExternalReferenceRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingReference = r, this.RelatedResourceObjects = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcExternalReferenceRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingReference), e.push(this.RelatedResourceObjects), e } }, IfcExternalSpatialElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcExternalSpatialElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.PredefinedType), e } }, IfcExternalSpatialStructureElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcExternalSpatialStructureElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e } }, IfcExternallyDefinedHatchStyle = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcExternallyDefinedHatchStyle(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e } }, IfcExternallyDefinedSurfaceStyle = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcExternallyDefinedSurfaceStyle(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e } }, IfcExternallyDefinedTextFont = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcExternallyDefinedTextFont(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e } }, IfcExtrudedAreaSolid = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.ExtrudedDirection = r, this.Depth = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcExtrudedAreaSolid(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.ExtrudedDirection), e.push(this.Depth), e } }, IfcExtrudedAreaSolidTapered = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.ExtrudedDirection = r, this.Depth = a, this.EndSweptArea = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcExtrudedAreaSolidTapered(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.ExtrudedDirection), e.push(this.Depth), e.push(this.EndSweptArea), e } }, IfcFace = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Bounds = i } static FromTape(e, t, i) { return i = i[0], new IfcFace(e, t, i) } ToTape() { var e = []; return e.push(this.Bounds), e } }, IfcFaceBasedSurfaceModel = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.FbsmFaces = i } static FromTape(e, t, i) { return i = i[0], new IfcFaceBasedSurfaceModel(e, t, i) } ToTape() { var e = []; return e.push(this.FbsmFaces), e } }, IfcFaceBound = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Bound = i, this.Orientation = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcFaceBound(e, t, s, i) } ToTape() { var e = []; return e.push(this.Bound), e.push(this.Orientation), e } }, IfcFaceOuterBound = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Bound = i, this.Orientation = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcFaceOuterBound(e, t, s, i) } ToTape() { var e = []; return e.push(this.Bound), e.push(this.Orientation), e } }, IfcFaceSurface = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Bounds = i, this.FaceSurface = s, this.SameSense = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcFaceSurface(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Bounds), e.push(this.FaceSurface), e.push(this.SameSense), e } }, IfcFacetedBrep = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Outer = i } static FromTape(e, t, i) { return i = i[0], new IfcFacetedBrep(e, t, i) } ToTape() { var e = []; return e.push(this.Outer), e } }, IfcFacetedBrepWithVoids = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Outer = i, this.Voids = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcFacetedBrepWithVoids(e, t, s, i) } ToTape() { var e = []; return e.push(this.Outer), e.push(this.Voids), e } }, IfcFacility = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFacility(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e } }, IfcFacilityPart = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFacilityPart(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e } }, IfcFailureConnectionCondition = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.TensionFailureX = s, this.TensionFailureY = r, this.TensionFailureZ = a, this.CompressionFailureX = o, this.CompressionFailureY = n, this.CompressionFailureZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcFailureConnectionCondition(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TensionFailureX), e.push(this.TensionFailureY), e.push(this.TensionFailureZ), e.push(this.CompressionFailureX), e.push(this.CompressionFailureY), e.push(this.CompressionFailureZ), e } }, IfcFan = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFan(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFanType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFanType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFastener = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFastener(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFastenerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFastenerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFeatureElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFeatureElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFeatureElementAddition = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFeatureElementAddition(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFeatureElementSubtraction = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFeatureElementSubtraction(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFillAreaStyle = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.FillStyles = s, this.ModelorDraughting = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcFillAreaStyle(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.FillStyles), e.push(this.ModelorDraughting), e } }, IfcFillAreaStyleHatching = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.HatchLineAppearance = i, this.StartOfNextHatchLine = s, this.PointOfReferenceHatchLine = r, this.PatternStart = a, this.HatchLineAngle = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcFillAreaStyleHatching(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.HatchLineAppearance), e.push(this.StartOfNextHatchLine), e.push(this.PointOfReferenceHatchLine), e.push(this.PatternStart), e.push(this.HatchLineAngle), e } }, IfcFillAreaStyleTiles = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.TilingPattern = i, this.Tiles = s, this.TilingScale = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcFillAreaStyleTiles(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.TilingPattern), e.push(this.Tiles), e.push(this.TilingScale), e } }, IfcFilter = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFilter(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFilterType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFilterType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFireSuppressionTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFireSuppressionTerminal(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFireSuppressionTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFireSuppressionTerminalType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFixedReferenceSweptAreaSolid = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.Directrix = r, this.StartParam = a, this.EndParam = o, this.FixedReference = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcFixedReferenceSweptAreaSolid(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.Directrix), e.push(this.StartParam), e.push(this.EndParam), e.push(this.FixedReference), e } }, IfcFlowController = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowController(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowControllerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowControllerType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowFitting = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowFitting(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowFittingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowFittingType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowInstrument = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowInstrument(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFlowInstrumentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFlowInstrumentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFlowMeter = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowMeter(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFlowMeterType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFlowMeterType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFlowMovingDevice = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowMovingDevice(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowMovingDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowMovingDeviceType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowSegment = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowSegment(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowSegmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowSegmentType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowStorageDevice = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowStorageDevice(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowStorageDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowStorageDeviceType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowTerminal(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowTerminalType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFlowTreatmentDevice = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFlowTreatmentDevice(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFlowTreatmentDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFlowTreatmentDeviceType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFooting = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFooting(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFootingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcFootingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcFurnishingElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcFurnishingElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcFurnishingElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFurnishingElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcFurniture = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcFurniture(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcFurnitureType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.AssemblyPlace = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcFurnitureType(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.AssemblyPlace), e.push(this.PredefinedType), e } }, IfcGeographicElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcGeographicElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcGeographicElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcGeographicElementType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcGeometricCurveSet = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Elements = i } static FromTape(e, t, i) { return i = i[0], new IfcGeometricCurveSet(e, t, i) } ToTape() { var e = []; return e.push(this.Elements), e } }, IfcGeometricRepresentationContext = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.ContextIdentifier = i, this.ContextType = s, this.CoordinateSpaceDimension = r, this.Precision = a, this.WorldCoordinateSystem = o, this.TrueNorth = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcGeometricRepresentationContext(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.ContextIdentifier), e.push(this.ContextType), e.push(this.CoordinateSpaceDimension), e.push(this.Precision), e.push(this.WorldCoordinateSystem), e.push(this.TrueNorth), e } }, IfcGeometricRepresentationItem = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcGeometricRepresentationItem(e, t) } ToTape() { return [] } }, IfcGeometricRepresentationSubContext = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.ContextIdentifier = i, this.ContextType = s, this.CoordinateSpaceDimension = r, this.Precision = a, this.WorldCoordinateSystem = o, this.TrueNorth = n, this.ParentContext = h, this.TargetScale = l, this.TargetView = c, this.UserDefinedTargetView = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcGeometricRepresentationSubContext(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.ContextIdentifier), e.push(this.ContextType), e.push(this.CoordinateSpaceDimension), e.push(this.Precision), e.push(this.WorldCoordinateSystem), e.push(this.TrueNorth), e.push(this.ParentContext), e.push(this.TargetScale), e.push(this.TargetView), e.push(this.UserDefinedTargetView), e } }, IfcGeometricSet = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Elements = i } static FromTape(e, t, i) { return i = i[0], new IfcGeometricSet(e, t, i) } ToTape() { var e = []; return e.push(this.Elements), e } }, IfcGrid = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.UAxes = l, this.VAxes = c, this.WAxes = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcGrid(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.UAxes), e.push(this.VAxes), e.push(this.WAxes), e.push(this.PredefinedType), e } }, IfcGridAxis = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.AxisTag = i, this.AxisCurve = s, this.SameSense = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcGridAxis(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.AxisTag), e.push(this.AxisCurve), e.push(this.SameSense), e } }, IfcGridPlacement = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.PlacementRelTo = i, this.PlacementLocation = s, this.PlacementRefDirection = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcGridPlacement(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.PlacementRelTo), e.push(this.PlacementLocation), e.push(this.PlacementRefDirection), e } }, IfcGroup = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcGroup(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e } }, IfcHalfSpaceSolid = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.BaseSurface = i, this.AgreementFlag = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcHalfSpaceSolid(e, t, s, i) } ToTape() { var e = []; return e.push(this.BaseSurface), e.push(this.AgreementFlag), e } }, IfcHeatExchanger = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcHeatExchanger(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcHeatExchangerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcHeatExchangerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcHumidifier = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcHumidifier(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcHumidifierType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcHumidifierType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcIShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.OverallWidth = a, this.OverallDepth = o, this.WebThickness = n, this.FlangeThickness = h, this.FilletRadius = l, this.FlangeEdgeRadius = c, this.FlangeSlope = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcIShapeProfileDef(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.OverallWidth), e.push(this.OverallDepth), e.push(this.WebThickness), e.push(this.FlangeThickness), e.push(this.FilletRadius), e.push(this.FlangeEdgeRadius), e.push(this.FlangeSlope), e } }, IfcImageTexture = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.RepeatS = i, this.RepeatT = s, this.Mode = r, this.TextureTransform = a, this.Parameter = o, this.URLReference = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcImageTexture(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.RepeatS), e.push(this.RepeatT), e.push(this.Mode), e.push(this.TextureTransform), e.push(this.Parameter), e.push(this.URLReference), e } }, IfcIndexedColourMap = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.MappedTo = i, this.Opacity = s, this.Colours = r, this.ColourIndex = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcIndexedColourMap(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.MappedTo), e.push(this.Opacity), e.push(this.Colours), e.push(this.ColourIndex), e } }, IfcIndexedPolyCurve = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Points = i, this.Segments = s, this.SelfIntersect = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcIndexedPolyCurve(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Points), e.push(this.Segments), e.push(this.SelfIntersect), e } }, IfcIndexedPolygonalFace = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.CoordIndex = i } static FromTape(e, t, i) { return i = i[0], new IfcIndexedPolygonalFace(e, t, i) } ToTape() { var e = []; return e.push(this.CoordIndex), e } }, IfcIndexedPolygonalFaceWithVoids = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.CoordIndex = i, this.InnerCoordIndices = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcIndexedPolygonalFaceWithVoids(e, t, s, i) } ToTape() { var e = []; return e.push(this.CoordIndex), e.push(this.InnerCoordIndices), e } }, IfcIndexedTextureMap = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Maps = i, this.MappedTo = s, this.TexCoords = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcIndexedTextureMap(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Maps), e.push(this.MappedTo), e.push(this.TexCoords), e } }, IfcIndexedTriangleTextureMap = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Maps = i, this.MappedTo = s, this.TexCoords = r, this.TexCoordIndex = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcIndexedTriangleTextureMap(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Maps), e.push(this.MappedTo), e.push(this.TexCoords), e.push(this.TexCoordIndex), e } }, IfcInterceptor = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcInterceptor(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcInterceptorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcInterceptorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcIntersectionCurve = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Curve3D = i, this.AssociatedGeometry = s, this.MasterRepresentation = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcIntersectionCurve(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Curve3D), e.push(this.AssociatedGeometry), e.push(this.MasterRepresentation), e } }, IfcInventory = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.PredefinedType = n, this.Jurisdiction = h, this.ResponsiblePersons = l, this.LastUpdateDate = c, this.CurrentValue = u, this.OriginalValue = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcInventory(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.PredefinedType), e.push(this.Jurisdiction), e.push(this.ResponsiblePersons), e.push(this.LastUpdateDate), e.push(this.CurrentValue), e.push(this.OriginalValue), e } }, IfcIrregularTimeSeries = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.StartTime = r, this.EndTime = a, this.TimeSeriesDataType = o, this.DataOrigin = n, this.UserDefinedDataOrigin = h, this.Unit = l, this.Values = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcIrregularTimeSeries(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.StartTime), e.push(this.EndTime), e.push(this.TimeSeriesDataType), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.Unit), e.push(this.Values), e } }, IfcIrregularTimeSeriesValue = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.TimeStamp = i, this.ListValues = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcIrregularTimeSeriesValue(e, t, s, i) } ToTape() { var e = []; return e.push(this.TimeStamp), e.push(this.ListValues), e } }, IfcJunctionBox = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcJunctionBox(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcJunctionBoxType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcJunctionBoxType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcLShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Depth = a, this.Width = o, this.Thickness = n, this.FilletRadius = h, this.EdgeRadius = l, this.LegSlope = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcLShapeProfileDef(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Depth), e.push(this.Width), e.push(this.Thickness), e.push(this.FilletRadius), e.push(this.EdgeRadius), e.push(this.LegSlope), e } }, IfcLaborResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcLaborResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcLaborResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcLaborResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcLagTime = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.LagValue = a, this.DurationType = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcLagTime(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.LagValue), e.push(this.DurationType), e } }, IfcLamp = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcLamp(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcLampType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcLampType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcLibraryInformation = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.Version = s, this.Publisher = r, this.VersionDate = a, this.Location = o, this.Description = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcLibraryInformation(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Version), e.push(this.Publisher), e.push(this.VersionDate), e.push(this.Location), e.push(this.Description), e } }, IfcLibraryReference = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Location = i, this.Identification = s, this.Name = r, this.Description = a, this.Language = o, this.ReferencedLibrary = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcLibraryReference(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Location), e.push(this.Identification), e.push(this.Name), e.push(this.Description), e.push(this.Language), e.push(this.ReferencedLibrary), e } }, IfcLightDistributionData = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.MainPlaneAngle = i, this.SecondaryPlaneAngle = s, this.LuminousIntensity = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcLightDistributionData(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.MainPlaneAngle), e.push(this.SecondaryPlaneAngle), e.push(this.LuminousIntensity), e } }, IfcLightFixture = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcLightFixture(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcLightFixtureType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcLightFixtureType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcLightIntensityDistribution = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.LightDistributionCurve = i, this.DistributionData = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcLightIntensityDistribution(e, t, s, i) } ToTape() { var e = []; return e.push(this.LightDistributionCurve), e.push(this.DistributionData), e } }, IfcLightSource = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcLightSource(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e } }, IfcLightSourceAmbient = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcLightSourceAmbient(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e } }, IfcLightSourceDirectional = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a, this.Orientation = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcLightSourceDirectional(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e.push(this.Orientation), e } }, IfcLightSourceGoniometric = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a, this.Position = o, this.ColourAppearance = n, this.ColourTemperature = h, this.LuminousFlux = l, this.LightEmissionSource = c, this.LightDistributionDataSource = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcLightSourceGoniometric(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e.push(this.Position), e.push(this.ColourAppearance), e.push(this.ColourTemperature), e.push(this.LuminousFlux), e.push(this.LightEmissionSource), e.push(this.LightDistributionDataSource), e } }, IfcLightSourcePositional = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a, this.Position = o, this.Radius = n, this.ConstantAttenuation = h, this.DistanceAttenuation = l, this.QuadricAttenuation = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcLightSourcePositional(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e.push(this.Position), e.push(this.Radius), e.push(this.ConstantAttenuation), e.push(this.DistanceAttenuation), e.push(this.QuadricAttenuation), e } }, IfcLightSourceSpot = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.Name = i, this.LightColour = s, this.AmbientIntensity = r, this.Intensity = a, this.Position = o, this.Radius = n, this.ConstantAttenuation = h, this.DistanceAttenuation = l, this.QuadricAttenuation = c, this.Orientation = u, this.ConcentrationExponent = p, this.SpreadAngle = d, this.BeamWidthAngle = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcLightSourceSpot(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LightColour), e.push(this.AmbientIntensity), e.push(this.Intensity), e.push(this.Position), e.push(this.Radius), e.push(this.ConstantAttenuation), e.push(this.DistanceAttenuation), e.push(this.QuadricAttenuation), e.push(this.Orientation), e.push(this.ConcentrationExponent), e.push(this.SpreadAngle), e.push(this.BeamWidthAngle), e } }, IfcLine = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Pnt = i, this.Dir = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcLine(e, t, s, i) } ToTape() { var e = []; return e.push(this.Pnt), e.push(this.Dir), e } }, IfcLineSegment2D = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.StartPoint = i, this.StartDirection = s, this.SegmentLength = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcLineSegment2D(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.StartPoint), e.push(this.StartDirection), e.push(this.SegmentLength), e } }, IfcLinearPlacement = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.PlacementRelTo = i, this.PlacementMeasuredAlong = s, this.Distance = r, this.Orientation = a, this.CartesianPosition = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcLinearPlacement(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.PlacementRelTo), e.push(this.PlacementMeasuredAlong), e.push(this.Distance), e.push(this.Orientation), e.push(this.CartesianPosition), e } }, IfcLinearPositioningElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Axis = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcLinearPositioningElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Axis), e } }, IfcLocalPlacement = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.PlacementRelTo = i, this.RelativePlacement = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcLocalPlacement(e, t, s, i) } ToTape() { var e = []; return e.push(this.PlacementRelTo), e.push(this.RelativePlacement), e } }, IfcLoop = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcLoop(e, t) } ToTape() { return [] } }, IfcManifoldSolidBrep = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Outer = i } static FromTape(e, t, i) { return i = i[0], new IfcManifoldSolidBrep(e, t, i) } ToTape() { var e = []; return e.push(this.Outer), e } }, IfcMapConversion = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.SourceCRS = i, this.TargetCRS = s, this.Eastings = r, this.Northings = a, this.OrthogonalHeight = o, this.XAxisAbscissa = n, this.XAxisOrdinate = h, this.Scale = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcMapConversion(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.SourceCRS), e.push(this.TargetCRS), e.push(this.Eastings), e.push(this.Northings), e.push(this.OrthogonalHeight), e.push(this.XAxisAbscissa), e.push(this.XAxisOrdinate), e.push(this.Scale), e } }, IfcMappedItem = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.MappingSource = i, this.MappingTarget = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcMappedItem(e, t, s, i) } ToTape() { var e = []; return e.push(this.MappingSource), e.push(this.MappingTarget), e } }, IfcMaterial = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Category = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcMaterial(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Category), e } }, IfcMaterialClassificationRelationship = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.MaterialClassifications = i, this.ClassifiedMaterial = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcMaterialClassificationRelationship(e, t, s, i) } ToTape() { var e = []; return e.push(this.MaterialClassifications), e.push(this.ClassifiedMaterial), e } }, IfcMaterialConstituent = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Material = r, this.Fraction = a, this.Category = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcMaterialConstituent(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Material), e.push(this.Fraction), e.push(this.Category), e } }, IfcMaterialConstituentSet = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.MaterialConstituents = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcMaterialConstituentSet(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.MaterialConstituents), e } }, IfcMaterialDefinition = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcMaterialDefinition(e, t) } ToTape() { return [] } }, IfcMaterialDefinitionRepresentation = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Representations = r, this.RepresentedMaterial = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcMaterialDefinitionRepresentation(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Representations), e.push(this.RepresentedMaterial), e } }, IfcMaterialLayer = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Material = i, this.LayerThickness = s, this.IsVentilated = r, this.Name = a, this.Description = o, this.Category = n, this.Priority = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcMaterialLayer(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Material), e.push(this.LayerThickness), e.push(this.IsVentilated), e.push(this.Name), e.push(this.Description), e.push(this.Category), e.push(this.Priority), e } }, IfcMaterialLayerSet = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.MaterialLayers = i, this.LayerSetName = s, this.Description = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcMaterialLayerSet(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.MaterialLayers), e.push(this.LayerSetName), e.push(this.Description), e } }, IfcMaterialLayerSetUsage = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ForLayerSet = i, this.LayerSetDirection = s, this.DirectionSense = r, this.OffsetFromReferenceLine = a, this.ReferenceExtent = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcMaterialLayerSetUsage(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ForLayerSet), e.push(this.LayerSetDirection), e.push(this.DirectionSense), e.push(this.OffsetFromReferenceLine), e.push(this.ReferenceExtent), e } }, IfcMaterialLayerWithOffsets = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Material = i, this.LayerThickness = s, this.IsVentilated = r, this.Name = a, this.Description = o, this.Category = n, this.Priority = h, this.OffsetDirection = l, this.OffsetValues = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcMaterialLayerWithOffsets(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Material), e.push(this.LayerThickness), e.push(this.IsVentilated), e.push(this.Name), e.push(this.Description), e.push(this.Category), e.push(this.Priority), e.push(this.OffsetDirection), e.push(this.OffsetValues), e } }, IfcMaterialList = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Materials = i } static FromTape(e, t, i) { return i = i[0], new IfcMaterialList(e, t, i) } ToTape() { var e = []; return e.push(this.Materials), e } }, IfcMaterialProfile = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Material = r, this.Profile = a, this.Priority = o, this.Category = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcMaterialProfile(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Material), e.push(this.Profile), e.push(this.Priority), e.push(this.Category), e } }, IfcMaterialProfileSet = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.MaterialProfiles = r, this.CompositeProfile = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcMaterialProfileSet(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.MaterialProfiles), e.push(this.CompositeProfile), e } }, IfcMaterialProfileSetUsage = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.ForProfileSet = i, this.CardinalPoint = s, this.ReferenceExtent = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcMaterialProfileSetUsage(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.ForProfileSet), e.push(this.CardinalPoint), e.push(this.ReferenceExtent), e } }, IfcMaterialProfileSetUsageTapering = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ForProfileSet = i, this.CardinalPoint = s, this.ReferenceExtent = r, this.ForProfileEndSet = a, this.CardinalEndPoint = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcMaterialProfileSetUsageTapering(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ForProfileSet), e.push(this.CardinalPoint), e.push(this.ReferenceExtent), e.push(this.ForProfileEndSet), e.push(this.CardinalEndPoint), e } }, IfcMaterialProfileWithOffsets = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Material = r, this.Profile = a, this.Priority = o, this.Category = n, this.OffsetValues = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcMaterialProfileWithOffsets(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Material), e.push(this.Profile), e.push(this.Priority), e.push(this.Category), e.push(this.OffsetValues), e } }, IfcMaterialProperties = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Properties = r, this.Material = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcMaterialProperties(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Properties), e.push(this.Material), e } }, IfcMaterialRelationship = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingMaterial = r, this.RelatedMaterials = a, this.Expression = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcMaterialRelationship(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingMaterial), e.push(this.RelatedMaterials), e.push(this.Expression), e } }, IfcMaterialUsageDefinition = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcMaterialUsageDefinition(e, t) } ToTape() { return [] } }, IfcMeasureWithUnit = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.ValueComponent = i, this.UnitComponent = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcMeasureWithUnit(e, t, s, i) } ToTape() { var e = []; return e.push(this.ValueComponent), e.push(this.UnitComponent), e } }, IfcMechanicalFastener = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.NominalDiameter = c, this.NominalLength = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcMechanicalFastener(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.NominalDiameter), e.push(this.NominalLength), e.push(this.PredefinedType), e } }, IfcMechanicalFastenerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.NominalDiameter = p, this.NominalLength = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcMechanicalFastenerType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.NominalDiameter), e.push(this.NominalLength), e } }, IfcMedicalDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcMedicalDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcMedicalDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcMedicalDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcMember = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcMember(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcMemberStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcMemberStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcMemberType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcMemberType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcMetric = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.ConstraintGrade = r, this.ConstraintSource = a, this.CreatingActor = o, this.CreationTime = n, this.UserDefinedGrade = h, this.Benchmark = l, this.ValueSource = c, this.DataValue = u, this.ReferencePath = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcMetric(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.ConstraintGrade), e.push(this.ConstraintSource), e.push(this.CreatingActor), e.push(this.CreationTime), e.push(this.UserDefinedGrade), e.push(this.Benchmark), e.push(this.ValueSource), e.push(this.DataValue), e.push(this.ReferencePath), e } }, IfcMirroredProfileDef = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.ParentProfile = r, this.Operator = a, this.Label = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcMirroredProfileDef(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.ParentProfile), e.push(this.Operator), e.push(this.Label), e } }, IfcMonetaryUnit = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Currency = i } static FromTape(e, t, i) { return i = i[0], new IfcMonetaryUnit(e, t, i) } ToTape() { var e = []; return e.push(this.Currency), e } }, IfcMotorConnection = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcMotorConnection(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcMotorConnectionType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcMotorConnectionType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcNamedUnit = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Dimensions = i, this.UnitType = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcNamedUnit(e, t, s, i) } ToTape() { var e = []; return e.push(this.Dimensions), e.push(this.UnitType), e } }, IfcObject = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcObject(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e } }, IfcObjectDefinition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcObjectDefinition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcObjectPlacement = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.PlacementRelTo = i } static FromTape(e, t, i) { return i = i[0], new IfcObjectPlacement(e, t, i) } ToTape() { var e = []; return e.push(this.PlacementRelTo), e } }, IfcObjective = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.ConstraintGrade = r, this.ConstraintSource = a, this.CreatingActor = o, this.CreationTime = n, this.UserDefinedGrade = h, this.BenchmarkValues = l, this.LogicalAggregator = c, this.ObjectiveQualifier = u, this.UserDefinedQualifier = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcObjective(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.ConstraintGrade), e.push(this.ConstraintSource), e.push(this.CreatingActor), e.push(this.CreationTime), e.push(this.UserDefinedGrade), e.push(this.BenchmarkValues), e.push(this.LogicalAggregator), e.push(this.ObjectiveQualifier), e.push(this.UserDefinedQualifier), e } }, IfcOccupant = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.TheActor = n, this.PredefinedType = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcOccupant(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.TheActor), e.push(this.PredefinedType), e } }, IfcOffsetCurve = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.BasisCurve = i } static FromTape(e, t, i) { return i = i[0], new IfcOffsetCurve(e, t, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e } }, IfcOffsetCurve2D = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BasisCurve = i, this.Distance = s, this.SelfIntersect = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcOffsetCurve2D(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e.push(this.Distance), e.push(this.SelfIntersect), e } }, IfcOffsetCurve3D = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.BasisCurve = i, this.Distance = s, this.SelfIntersect = r, this.RefDirection = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcOffsetCurve3D(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e.push(this.Distance), e.push(this.SelfIntersect), e.push(this.RefDirection), e } }, IfcOffsetCurveByDistances = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BasisCurve = i, this.OffsetValues = s, this.Tag = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcOffsetCurveByDistances(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e.push(this.OffsetValues), e.push(this.Tag), e } }, IfcOpenShell = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.CfsFaces = i } static FromTape(e, t, i) { return i = i[0], new IfcOpenShell(e, t, i) } ToTape() { var e = []; return e.push(this.CfsFaces), e } }, IfcOpeningElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcOpeningElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcOpeningStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcOpeningStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcOrganization = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Identification = i, this.Name = s, this.Description = r, this.Roles = a, this.Addresses = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcOrganization(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Identification), e.push(this.Name), e.push(this.Description), e.push(this.Roles), e.push(this.Addresses), e } }, IfcOrganizationRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingOrganization = r, this.RelatedOrganizations = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcOrganizationRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingOrganization), e.push(this.RelatedOrganizations), e } }, IfcOrientationExpression = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.LateralAxisDirection = i, this.VerticalAxisDirection = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcOrientationExpression(e, t, s, i) } ToTape() { var e = []; return e.push(this.LateralAxisDirection), e.push(this.VerticalAxisDirection), e } }, IfcOrientedEdge = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.EdgeStart = i, this.EdgeEnd = s, this.EdgeElement = r, this.Orientation = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcOrientedEdge(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.EdgeStart), e.push(this.EdgeEnd), e.push(this.EdgeElement), e.push(this.Orientation), e } }, IfcOuterBoundaryCurve = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Segments = i, this.SelfIntersect = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcOuterBoundaryCurve(e, t, s, i) } ToTape() { var e = []; return e.push(this.Segments), e.push(this.SelfIntersect), e } }, IfcOutlet = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcOutlet(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcOutletType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcOutletType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcOwnerHistory = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.OwningUser = i, this.OwningApplication = s, this.State = r, this.ChangeAction = a, this.LastModifiedDate = o, this.LastModifyingUser = n, this.LastModifyingApplication = h, this.CreationDate = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcOwnerHistory(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.OwningUser), e.push(this.OwningApplication), e.push(this.State), e.push(this.ChangeAction), e.push(this.LastModifiedDate), e.push(this.LastModifyingUser), e.push(this.LastModifyingApplication), e.push(this.CreationDate), e } }, IfcParameterizedProfileDef = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcParameterizedProfileDef(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e } }, IfcPath = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.EdgeList = i } static FromTape(e, t, i) { return i = i[0], new IfcPath(e, t, i) } ToTape() { var e = []; return e.push(this.EdgeList), e } }, IfcPcurve = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.BasisSurface = i, this.ReferenceCurve = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcPcurve(e, t, s, i) } ToTape() { var e = []; return e.push(this.BasisSurface), e.push(this.ReferenceCurve), e } }, IfcPerformanceHistory = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LifeCyclePhase = h, this.PredefinedType = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcPerformanceHistory(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LifeCyclePhase), e.push(this.PredefinedType), e } }, IfcPermeableCoveringProperties = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.OperationType = o, this.PanelPosition = n, this.FrameDepth = h, this.FrameThickness = l, this.ShapeAspectStyle = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPermeableCoveringProperties(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.OperationType), e.push(this.PanelPosition), e.push(this.FrameDepth), e.push(this.FrameThickness), e.push(this.ShapeAspectStyle), e } }, IfcPermit = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.PredefinedType = h, this.Status = l, this.LongDescription = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPermit(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.PredefinedType), e.push(this.Status), e.push(this.LongDescription), e } }, IfcPerson = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Identification = i, this.FamilyName = s, this.GivenName = r, this.MiddleNames = a, this.PrefixTitles = o, this.SuffixTitles = n, this.Roles = h, this.Addresses = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcPerson(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Identification), e.push(this.FamilyName), e.push(this.GivenName), e.push(this.MiddleNames), e.push(this.PrefixTitles), e.push(this.SuffixTitles), e.push(this.Roles), e.push(this.Addresses), e } }, IfcPersonAndOrganization = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.ThePerson = i, this.TheOrganization = s, this.Roles = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcPersonAndOrganization(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.ThePerson), e.push(this.TheOrganization), e.push(this.Roles), e } }, IfcPhysicalComplexQuantity = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.HasQuantities = r, this.Discrimination = a, this.Quality = o, this.Usage = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcPhysicalComplexQuantity(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.HasQuantities), e.push(this.Discrimination), e.push(this.Quality), e.push(this.Usage), e } }, IfcPhysicalQuantity = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Name = i, this.Description = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcPhysicalQuantity(e, t, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e } }, IfcPhysicalSimpleQuantity = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcPhysicalSimpleQuantity(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e } }, IfcPile = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c, this.ConstructionType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPile(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e.push(this.ConstructionType), e } }, IfcPileType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPileType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcPipeFitting = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPipeFitting(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcPipeFittingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPipeFittingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcPipeSegment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPipeSegment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcPipeSegmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPipeSegmentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcPixelTexture = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.RepeatS = i, this.RepeatT = s, this.Mode = r, this.TextureTransform = a, this.Parameter = o, this.Width = n, this.Height = h, this.ColourComponents = l, this.Pixel = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPixelTexture(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.RepeatS), e.push(this.RepeatT), e.push(this.Mode), e.push(this.TextureTransform), e.push(this.Parameter), e.push(this.Width), e.push(this.Height), e.push(this.ColourComponents), e.push(this.Pixel), e } }, IfcPlacement = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Location = i } static FromTape(e, t, i) { return i = i[0], new IfcPlacement(e, t, i) } ToTape() { var e = []; return e.push(this.Location), e } }, IfcPlanarBox = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.SizeInX = i, this.SizeInY = s, this.Placement = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcPlanarBox(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.SizeInX), e.push(this.SizeInY), e.push(this.Placement), e } }, IfcPlanarExtent = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SizeInX = i, this.SizeInY = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcPlanarExtent(e, t, s, i) } ToTape() { var e = []; return e.push(this.SizeInX), e.push(this.SizeInY), e } }, IfcPlane = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Position = i } static FromTape(e, t, i) { return i = i[0], new IfcPlane(e, t, i) } ToTape() { var e = []; return e.push(this.Position), e } }, IfcPlate = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPlate(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcPlateStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPlateStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcPlateType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPlateType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcPoint = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcPoint(e, t) } ToTape() { return [] } }, IfcPointOnCurve = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.BasisCurve = i, this.PointParameter = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcPointOnCurve(e, t, s, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e.push(this.PointParameter), e } }, IfcPointOnSurface = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.BasisSurface = i, this.PointParameterU = s, this.PointParameterV = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcPointOnSurface(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.BasisSurface), e.push(this.PointParameterU), e.push(this.PointParameterV), e } }, IfcPolyLoop = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Polygon = i } static FromTape(e, t, i) { return i = i[0], new IfcPolyLoop(e, t, i) } ToTape() { var e = []; return e.push(this.Polygon), e } }, IfcPolygonalBoundedHalfSpace = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.BaseSurface = i, this.AgreementFlag = s, this.Position = r, this.PolygonalBoundary = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPolygonalBoundedHalfSpace(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.BaseSurface), e.push(this.AgreementFlag), e.push(this.Position), e.push(this.PolygonalBoundary), e } }, IfcPolygonalFaceSet = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Coordinates = i, this.Closed = s, this.Faces = r, this.PnIndex = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPolygonalFaceSet(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Coordinates), e.push(this.Closed), e.push(this.Faces), e.push(this.PnIndex), e } }, IfcPolyline = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Points = i } static FromTape(e, t, i) { return i = i[0], new IfcPolyline(e, t, i) } ToTape() { var e = []; return e.push(this.Points), e } }, IfcPort = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcPort(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcPositioningElement = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcPositioningElement(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcPostalAddress = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.Purpose = i, this.Description = s, this.UserDefinedPurpose = r, this.InternalLocation = a, this.AddressLines = o, this.PostalBox = n, this.Town = h, this.Region = l, this.PostalCode = c, this.Country = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPostalAddress(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.Purpose), e.push(this.Description), e.push(this.UserDefinedPurpose), e.push(this.InternalLocation), e.push(this.AddressLines), e.push(this.PostalBox), e.push(this.Town), e.push(this.Region), e.push(this.PostalCode), e.push(this.Country), e } }, IfcPreDefinedColour = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcPreDefinedColour(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcPreDefinedCurveFont = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcPreDefinedCurveFont(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcPreDefinedItem = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcPreDefinedItem(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcPreDefinedProperties = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcPreDefinedProperties(e, t) } ToTape() { return [] } }, IfcPreDefinedPropertySet = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPreDefinedPropertySet(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcPreDefinedTextFont = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcPreDefinedTextFont(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcPresentationItem = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcPresentationItem(e, t) } ToTape() { return [] } }, IfcPresentationLayerAssignment = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.AssignedItems = r, this.Identifier = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPresentationLayerAssignment(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.AssignedItems), e.push(this.Identifier), e } }, IfcPresentationLayerWithStyle = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.AssignedItems = r, this.Identifier = a, this.LayerOn = o, this.LayerFrozen = n, this.LayerBlocked = h, this.LayerStyles = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcPresentationLayerWithStyle(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.AssignedItems), e.push(this.Identifier), e.push(this.LayerOn), e.push(this.LayerFrozen), e.push(this.LayerBlocked), e.push(this.LayerStyles), e } }, IfcPresentationStyle = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcPresentationStyle(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcPresentationStyleAssignment = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Styles = i } static FromTape(e, t, i) { return i = i[0], new IfcPresentationStyleAssignment(e, t, i) } ToTape() { var e = []; return e.push(this.Styles), e } }, IfcProcedure = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.PredefinedType = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcProcedure(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.PredefinedType), e } }, IfcProcedureType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ProcessType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcProcedureType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ProcessType), e.push(this.PredefinedType), e } }, IfcProcess = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcProcess(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e } }, IfcProduct = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcProduct(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcProductDefinitionShape = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Representations = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcProductDefinitionShape(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Representations), e } }, IfcProductRepresentation = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Representations = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcProductRepresentation(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Representations), e } }, IfcProfileDef = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcProfileDef(e, t, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e } }, IfcProfileProperties = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Properties = r, this.ProfileDefinition = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcProfileProperties(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Properties), e.push(this.ProfileDefinition), e } }, IfcProject = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n, this.Phase = h, this.RepresentationContexts = l, this.UnitsInContext = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProject(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e.push(this.Phase), e.push(this.RepresentationContexts), e.push(this.UnitsInContext), e } }, IfcProjectLibrary = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n, this.Phase = h, this.RepresentationContexts = l, this.UnitsInContext = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProjectLibrary(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e.push(this.Phase), e.push(this.RepresentationContexts), e.push(this.UnitsInContext), e } }, IfcProjectOrder = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.PredefinedType = h, this.Status = l, this.LongDescription = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProjectOrder(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.PredefinedType), e.push(this.Status), e.push(this.LongDescription), e } }, IfcProjectedCRS = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.GeodeticDatum = r, this.VerticalDatum = a, this.MapProjection = o, this.MapZone = n, this.MapUnit = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcProjectedCRS(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.GeodeticDatum), e.push(this.VerticalDatum), e.push(this.MapProjection), e.push(this.MapZone), e.push(this.MapUnit), e } }, IfcProjectionElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProjectionElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcProperty = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Name = i, this.Description = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcProperty(e, t, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e } }, IfcPropertyAbstraction = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcPropertyAbstraction(e, t) } ToTape() { return [] } }, IfcPropertyBoundedValue = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.UpperBoundValue = r, this.LowerBoundValue = a, this.Unit = o, this.SetPointValue = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcPropertyBoundedValue(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.UpperBoundValue), e.push(this.LowerBoundValue), e.push(this.Unit), e.push(this.SetPointValue), e } }, IfcPropertyDefinition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyDefinition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcPropertyDependencyRelationship = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.DependingProperty = r, this.DependantProperty = a, this.Expression = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcPropertyDependencyRelationship(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.DependingProperty), e.push(this.DependantProperty), e.push(this.Expression), e } }, IfcPropertyEnumeratedValue = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.EnumerationValues = r, this.EnumerationReference = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyEnumeratedValue(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.EnumerationValues), e.push(this.EnumerationReference), e } }, IfcPropertyEnumeration = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.EnumerationValues = s, this.Unit = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcPropertyEnumeration(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.EnumerationValues), e.push(this.Unit), e } }, IfcPropertyListValue = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.ListValues = r, this.Unit = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyListValue(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.ListValues), e.push(this.Unit), e } }, IfcPropertyReferenceValue = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.UsageName = r, this.PropertyReference = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyReferenceValue(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.UsageName), e.push(this.PropertyReference), e } }, IfcPropertySet = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.HasProperties = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcPropertySet(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.HasProperties), e } }, IfcPropertySetDefinition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertySetDefinition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcPropertySetTemplate = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.TemplateType = o, this.ApplicableEntity = n, this.HasPropertyTemplates = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcPropertySetTemplate(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.TemplateType), e.push(this.ApplicableEntity), e.push(this.HasPropertyTemplates), e } }, IfcPropertySingleValue = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.NominalValue = r, this.Unit = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertySingleValue(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.NominalValue), e.push(this.Unit), e } }, IfcPropertyTableValue = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.DefiningValues = r, this.DefinedValues = a, this.Expression = o, this.DefiningUnit = n, this.DefinedUnit = h, this.CurveInterpolation = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcPropertyTableValue(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.DefiningValues), e.push(this.DefinedValues), e.push(this.Expression), e.push(this.DefiningUnit), e.push(this.DefinedUnit), e.push(this.CurveInterpolation), e } }, IfcPropertyTemplate = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyTemplate(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcPropertyTemplateDefinition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcPropertyTemplateDefinition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcProtectiveDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProtectiveDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcProtectiveDeviceTrippingUnit = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProtectiveDeviceTrippingUnit(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcProtectiveDeviceTrippingUnitType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcProtectiveDeviceTrippingUnitType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcProtectiveDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcProtectiveDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcProxy = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.ProxyType = l, this.Tag = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcProxy(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.ProxyType), e.push(this.Tag), e } }, IfcPump = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcPump(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcPumpType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcPumpType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcQuantityArea = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.AreaValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityArea(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.AreaValue), e.push(this.Formula), e } }, IfcQuantityCount = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.CountValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityCount(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.CountValue), e.push(this.Formula), e } }, IfcQuantityLength = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.LengthValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityLength(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.LengthValue), e.push(this.Formula), e } }, IfcQuantitySet = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcQuantitySet(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcQuantityTime = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.TimeValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityTime(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.TimeValue), e.push(this.Formula), e } }, IfcQuantityVolume = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.VolumeValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityVolume(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.VolumeValue), e.push(this.Formula), e } }, IfcQuantityWeight = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.Unit = r, this.WeightValue = a, this.Formula = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcQuantityWeight(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.WeightValue), e.push(this.Formula), e } }, IfcRailing = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRailing(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcRailingType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRailingType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcRamp = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRamp(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcRampFlight = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRampFlight(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcRampFlightType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRampFlightType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcRampType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRampType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcRationalBSplineCurveWithKnots = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Degree = i, this.ControlPointsList = s, this.CurveForm = r, this.ClosedCurve = a, this.SelfIntersect = o, this.KnotMultiplicities = n, this.Knots = h, this.KnotSpec = l, this.WeightsData = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRationalBSplineCurveWithKnots(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Degree), e.push(this.ControlPointsList), e.push(this.CurveForm), e.push(this.ClosedCurve), e.push(this.SelfIntersect), e.push(this.KnotMultiplicities), e.push(this.Knots), e.push(this.KnotSpec), e.push(this.WeightsData), e } }, IfcRationalBSplineSurfaceWithKnots = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.UDegree = i, this.VDegree = s, this.ControlPointsList = r, this.SurfaceForm = a, this.UClosed = o, this.VClosed = n, this.SelfIntersect = h, this.UMultiplicities = l, this.VMultiplicities = c, this.UKnots = u, this.VKnots = p, this.KnotSpec = d, this.WeightsData = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcRationalBSplineSurfaceWithKnots(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.UDegree), e.push(this.VDegree), e.push(this.ControlPointsList), e.push(this.SurfaceForm), e.push(this.UClosed), e.push(this.VClosed), e.push(this.SelfIntersect), e.push(this.UMultiplicities), e.push(this.VMultiplicities), e.push(this.UKnots), e.push(this.VKnots), e.push(this.KnotSpec), e.push(this.WeightsData), e } }, IfcRectangleHollowProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.XDim = a, this.YDim = o, this.WallThickness = n, this.InnerFilletRadius = h, this.OuterFilletRadius = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcRectangleHollowProfileDef(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.XDim), e.push(this.YDim), e.push(this.WallThickness), e.push(this.InnerFilletRadius), e.push(this.OuterFilletRadius), e } }, IfcRectangleProfileDef = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.XDim = a, this.YDim = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcRectangleProfileDef(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.XDim), e.push(this.YDim), e } }, IfcRectangularPyramid = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Position = i, this.XLength = s, this.YLength = r, this.Height = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRectangularPyramid(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.XLength), e.push(this.YLength), e.push(this.Height), e } }, IfcRectangularTrimmedSurface = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.BasisSurface = i, this.U1 = s, this.V1 = r, this.U2 = a, this.V2 = o, this.Usense = n, this.Vsense = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRectangularTrimmedSurface(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.BasisSurface), e.push(this.U1), e.push(this.V1), e.push(this.U2), e.push(this.V2), e.push(this.Usense), e.push(this.Vsense), e } }, IfcRecurrencePattern = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.RecurrenceType = i, this.DayComponent = s, this.WeekdayComponent = r, this.MonthComponent = a, this.Position = o, this.Interval = n, this.Occurrences = h, this.TimePeriods = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcRecurrencePattern(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.RecurrenceType), e.push(this.DayComponent), e.push(this.WeekdayComponent), e.push(this.MonthComponent), e.push(this.Position), e.push(this.Interval), e.push(this.Occurrences), e.push(this.TimePeriods), e } }, IfcReference = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.TypeIdentifier = i, this.AttributeIdentifier = s, this.InstanceName = r, this.ListPositions = a, this.InnerReference = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcReference(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.TypeIdentifier), e.push(this.AttributeIdentifier), e.push(this.InstanceName), e.push(this.ListPositions), e.push(this.InnerReference), e } }, IfcReferent = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.PredefinedType = l, this.RestartDistance = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcReferent(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.PredefinedType), e.push(this.RestartDistance), e } }, IfcRegularTimeSeries = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.StartTime = r, this.EndTime = a, this.TimeSeriesDataType = o, this.DataOrigin = n, this.UserDefinedDataOrigin = h, this.Unit = l, this.TimeStep = c, this.Values = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRegularTimeSeries(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.StartTime), e.push(this.EndTime), e.push(this.TimeSeriesDataType), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.Unit), e.push(this.TimeStep), e.push(this.Values), e } }, IfcReinforcementBarProperties = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.TotalCrossSectionArea = i, this.SteelGrade = s, this.BarSurface = r, this.EffectiveDepth = a, this.NominalBarDiameter = o, this.BarCount = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcReinforcementBarProperties(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.TotalCrossSectionArea), e.push(this.SteelGrade), e.push(this.BarSurface), e.push(this.EffectiveDepth), e.push(this.NominalBarDiameter), e.push(this.BarCount), e } }, IfcReinforcementDefinitionProperties = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.DefinitionType = o, this.ReinforcementSectionDefinitions = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcReinforcementDefinitionProperties(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.DefinitionType), e.push(this.ReinforcementSectionDefinitions), e } }, IfcReinforcingBar = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c, this.NominalDiameter = u, this.CrossSectionArea = p, this.BarLength = d, this.PredefinedType = m, this.BarSurface = f } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[+s], d = i[9], m = i[10], f = i[11]; s = i[12], i = i[13]; return new IfcReinforcingBar(e, t, r, a, o, n, h, l, c, u, p, d, m, f, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e.push(this.NominalDiameter), e.push(this.CrossSectionArea), e.push(this.BarLength), e.push(this.PredefinedType), e.push(this.BarSurface), e } }, IfcReinforcingBarType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.NominalDiameter = p, this.CrossSectionArea = d, this.BarLength = m, this.BarSurface = f, this.BendingShapeCode = g, this.BendingParameters = _ } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[+s], f = i[11], g = i[12], _ = i[13]; s = i[14], i = i[15]; return new IfcReinforcingBarType(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.NominalDiameter), e.push(this.CrossSectionArea), e.push(this.BarLength), e.push(this.BarSurface), e.push(this.BendingShapeCode), e.push(this.BendingParameters), e } }, IfcReinforcingElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcReinforcingElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e } }, IfcReinforcingElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcReinforcingElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcReinforcingMesh = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c, this.MeshLength = u, this.MeshWidth = p, this.LongitudinalBarNominalDiameter = d, this.TransverseBarNominalDiameter = m, this.LongitudinalBarCrossSectionArea = f, this.TransverseBarCrossSectionArea = g, this.LongitudinalBarSpacing = _, this.TransverseBarSpacing = v, this.PredefinedType = y } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[s++], g = i[+s], _ = i[13], v = i[14], y = i[15]; s = i[16], i = i[17]; return new IfcReinforcingMesh(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e.push(this.MeshLength), e.push(this.MeshWidth), e.push(this.LongitudinalBarNominalDiameter), e.push(this.TransverseBarNominalDiameter), e.push(this.LongitudinalBarCrossSectionArea), e.push(this.TransverseBarCrossSectionArea), e.push(this.LongitudinalBarSpacing), e.push(this.TransverseBarSpacing), e.push(this.PredefinedType), e } }, IfcReinforcingMeshType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.MeshLength = p, this.MeshWidth = d, this.LongitudinalBarNominalDiameter = m, this.TransverseBarNominalDiameter = f, this.LongitudinalBarCrossSectionArea = g, this.TransverseBarCrossSectionArea = _, this.LongitudinalBarSpacing = v, this.TransverseBarSpacing = y, this.BendingShapeCode = T, this.BendingParameters = I } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[s++], g = i[s++], _ = i[s++], v = i[+s], y = i[15], T = i[16], I = i[17]; s = i[18], i = i[19]; return new IfcReinforcingMeshType(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.MeshLength), e.push(this.MeshWidth), e.push(this.LongitudinalBarNominalDiameter), e.push(this.TransverseBarNominalDiameter), e.push(this.LongitudinalBarCrossSectionArea), e.push(this.TransverseBarCrossSectionArea), e.push(this.LongitudinalBarSpacing), e.push(this.TransverseBarSpacing), e.push(this.BendingShapeCode), e.push(this.BendingParameters), e } }, IfcRelAggregates = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingObject = o, this.RelatedObjects = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAggregates(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingObject), e.push(this.RelatedObjects), e } }, IfcRelAssigns = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssigns(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e } }, IfcRelAssignsToActor = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingActor = h, this.ActingRole = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcRelAssignsToActor(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingActor), e.push(this.ActingRole), e } }, IfcRelAssignsToControl = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingControl = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelAssignsToControl(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingControl), e } }, IfcRelAssignsToGroup = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingGroup = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelAssignsToGroup(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingGroup), e } }, IfcRelAssignsToGroupByFactor = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingGroup = h, this.Factor = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcRelAssignsToGroupByFactor(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingGroup), e.push(this.Factor), e } }, IfcRelAssignsToProcess = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingProcess = h, this.QuantityInProcess = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcRelAssignsToProcess(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingProcess), e.push(this.QuantityInProcess), e } }, IfcRelAssignsToProduct = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingProduct = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelAssignsToProduct(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingProduct), e } }, IfcRelAssignsToResource = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatedObjectsType = n, this.RelatingResource = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelAssignsToResource(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatedObjectsType), e.push(this.RelatingResource), e } }, IfcRelAssociates = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcRelAssociates(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e } }, IfcRelAssociatesApproval = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingApproval = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssociatesApproval(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingApproval), e } }, IfcRelAssociatesClassification = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingClassification = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssociatesClassification(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingClassification), e } }, IfcRelAssociatesConstraint = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.Intent = n, this.RelatingConstraint = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelAssociatesConstraint(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.Intent), e.push(this.RelatingConstraint), e } }, IfcRelAssociatesDocument = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingDocument = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssociatesDocument(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingDocument), e } }, IfcRelAssociatesLibrary = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingLibrary = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssociatesLibrary(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingLibrary), e } }, IfcRelAssociatesMaterial = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingMaterial = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelAssociatesMaterial(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingMaterial), e } }, IfcRelConnects = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRelConnects(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcRelConnectsElements = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ConnectionGeometry = o, this.RelatingElement = n, this.RelatedElement = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelConnectsElements(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ConnectionGeometry), e.push(this.RelatingElement), e.push(this.RelatedElement), e } }, IfcRelConnectsPathElements = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ConnectionGeometry = o, this.RelatingElement = n, this.RelatedElement = h, this.RelatingPriorities = l, this.RelatedPriorities = c, this.RelatedConnectionType = u, this.RelatingConnectionType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcRelConnectsPathElements(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ConnectionGeometry), e.push(this.RelatingElement), e.push(this.RelatedElement), e.push(this.RelatingPriorities), e.push(this.RelatedPriorities), e.push(this.RelatedConnectionType), e.push(this.RelatingConnectionType), e } }, IfcRelConnectsPortToElement = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingPort = o, this.RelatedElement = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelConnectsPortToElement(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingPort), e.push(this.RelatedElement), e } }, IfcRelConnectsPorts = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingPort = o, this.RelatedPort = n, this.RealizingElement = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcRelConnectsPorts(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingPort), e.push(this.RelatedPort), e.push(this.RealizingElement), e } }, IfcRelConnectsStructuralActivity = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingElement = o, this.RelatedStructuralActivity = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelConnectsStructuralActivity(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingElement), e.push(this.RelatedStructuralActivity), e } }, IfcRelConnectsStructuralMember = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingStructuralMember = o, this.RelatedStructuralConnection = n, this.AppliedCondition = h, this.AdditionalConditions = l, this.SupportedLength = c, this.ConditionCoordinateSystem = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRelConnectsStructuralMember(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingStructuralMember), e.push(this.RelatedStructuralConnection), e.push(this.AppliedCondition), e.push(this.AdditionalConditions), e.push(this.SupportedLength), e.push(this.ConditionCoordinateSystem), e } }, IfcRelConnectsWithEccentricity = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingStructuralMember = o, this.RelatedStructuralConnection = n, this.AppliedCondition = h, this.AdditionalConditions = l, this.SupportedLength = c, this.ConditionCoordinateSystem = u, this.ConnectionConstraint = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcRelConnectsWithEccentricity(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingStructuralMember), e.push(this.RelatedStructuralConnection), e.push(this.AppliedCondition), e.push(this.AdditionalConditions), e.push(this.SupportedLength), e.push(this.ConditionCoordinateSystem), e.push(this.ConnectionConstraint), e } }, IfcRelConnectsWithRealizingElements = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ConnectionGeometry = o, this.RelatingElement = n, this.RelatedElement = h, this.RealizingElements = l, this.ConnectionType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRelConnectsWithRealizingElements(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ConnectionGeometry), e.push(this.RelatingElement), e.push(this.RelatedElement), e.push(this.RealizingElements), e.push(this.ConnectionType), e } }, IfcRelContainedInSpatialStructure = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedElements = o, this.RelatingStructure = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelContainedInSpatialStructure(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedElements), e.push(this.RelatingStructure), e } }, IfcRelCoversBldgElements = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingBuildingElement = o, this.RelatedCoverings = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelCoversBldgElements(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingBuildingElement), e.push(this.RelatedCoverings), e } }, IfcRelCoversSpaces = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingSpace = o, this.RelatedCoverings = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelCoversSpaces(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingSpace), e.push(this.RelatedCoverings), e } }, IfcRelDeclares = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingContext = o, this.RelatedDefinitions = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelDeclares(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingContext), e.push(this.RelatedDefinitions), e } }, IfcRelDecomposes = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRelDecomposes(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcRelDefines = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRelDefines(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcRelDefinesByObject = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingObject = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelDefinesByObject(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingObject), e } }, IfcRelDefinesByProperties = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingPropertyDefinition = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelDefinesByProperties(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingPropertyDefinition), e } }, IfcRelDefinesByTemplate = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedPropertySets = o, this.RelatingTemplate = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelDefinesByTemplate(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedPropertySets), e.push(this.RelatingTemplate), e } }, IfcRelDefinesByType = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedObjects = o, this.RelatingType = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelDefinesByType(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedObjects), e.push(this.RelatingType), e } }, IfcRelFillsElement = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingOpeningElement = o, this.RelatedBuildingElement = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelFillsElement(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingOpeningElement), e.push(this.RelatedBuildingElement), e } }, IfcRelFlowControlElements = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedControlElements = o, this.RelatingFlowElement = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelFlowControlElements(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedControlElements), e.push(this.RelatingFlowElement), e } }, IfcRelInterferesElements = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingElement = o, this.RelatedElement = n, this.InterferenceGeometry = h, this.InterferenceType = l, this.ImpliedOrder = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRelInterferesElements(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingElement), e.push(this.RelatedElement), e.push(this.InterferenceGeometry), e.push(this.InterferenceType), e.push(this.ImpliedOrder), e } }, IfcRelNests = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingObject = o, this.RelatedObjects = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelNests(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingObject), e.push(this.RelatedObjects), e } }, IfcRelPositions = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingPositioningElement = o, this.RelatedProducts = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelPositions(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingPositioningElement), e.push(this.RelatedProducts), e } }, IfcRelProjectsElement = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingElement = o, this.RelatedFeatureElement = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelProjectsElement(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingElement), e.push(this.RelatedFeatureElement), e } }, IfcRelReferencedInSpatialStructure = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatedElements = o, this.RelatingStructure = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelReferencedInSpatialStructure(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatedElements), e.push(this.RelatingStructure), e } }, IfcRelSequence = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingProcess = o, this.RelatedProcess = n, this.TimeLag = h, this.SequenceType = l, this.UserDefinedSequenceType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRelSequence(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingProcess), e.push(this.RelatedProcess), e.push(this.TimeLag), e.push(this.SequenceType), e.push(this.UserDefinedSequenceType), e } }, IfcRelServicesBuildings = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingSystem = o, this.RelatedBuildings = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelServicesBuildings(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingSystem), e.push(this.RelatedBuildings), e } }, IfcRelSpaceBoundary = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingSpace = o, this.RelatedBuildingElement = n, this.ConnectionGeometry = h, this.PhysicalOrVirtualBoundary = l, this.InternalOrExternalBoundary = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRelSpaceBoundary(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingSpace), e.push(this.RelatedBuildingElement), e.push(this.ConnectionGeometry), e.push(this.PhysicalOrVirtualBoundary), e.push(this.InternalOrExternalBoundary), e } }, IfcRelSpaceBoundary1stLevel = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingSpace = o, this.RelatedBuildingElement = n, this.ConnectionGeometry = h, this.PhysicalOrVirtualBoundary = l, this.InternalOrExternalBoundary = c, this.ParentBoundary = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRelSpaceBoundary1stLevel(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingSpace), e.push(this.RelatedBuildingElement), e.push(this.ConnectionGeometry), e.push(this.PhysicalOrVirtualBoundary), e.push(this.InternalOrExternalBoundary), e.push(this.ParentBoundary), e } }, IfcRelSpaceBoundary2ndLevel = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingSpace = o, this.RelatedBuildingElement = n, this.ConnectionGeometry = h, this.PhysicalOrVirtualBoundary = l, this.InternalOrExternalBoundary = c, this.ParentBoundary = u, this.CorrespondingBoundary = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcRelSpaceBoundary2ndLevel(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingSpace), e.push(this.RelatedBuildingElement), e.push(this.ConnectionGeometry), e.push(this.PhysicalOrVirtualBoundary), e.push(this.InternalOrExternalBoundary), e.push(this.ParentBoundary), e.push(this.CorrespondingBoundary), e } }, IfcRelVoidsElement = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.RelatingBuildingElement = o, this.RelatedOpeningElement = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRelVoidsElement(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.RelatingBuildingElement), e.push(this.RelatedOpeningElement), e } }, IfcRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcReparametrisedCompositeCurveSegment = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Transition = i, this.SameSense = s, this.ParentCurve = r, this.ParamLength = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcReparametrisedCompositeCurveSegment(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Transition), e.push(this.SameSense), e.push(this.ParentCurve), e.push(this.ParamLength), e } }, IfcRepresentation = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRepresentation(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcRepresentationContext = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.ContextIdentifier = i, this.ContextType = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcRepresentationContext(e, t, s, i) } ToTape() { var e = []; return e.push(this.ContextIdentifier), e.push(this.ContextType), e } }, IfcRepresentationItem = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcRepresentationItem(e, t) } ToTape() { return [] } }, IfcRepresentationMap = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.MappingOrigin = i, this.MappedRepresentation = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcRepresentationMap(e, t, s, i) } ToTape() { var e = []; return e.push(this.MappingOrigin), e.push(this.MappedRepresentation), e } }, IfcResource = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcResource(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e } }, IfcResourceApprovalRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatedResourceObjects = r, this.RelatingApproval = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcResourceApprovalRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatedResourceObjects), e.push(this.RelatingApproval), e } }, IfcResourceConstraintRelationship = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.RelatingConstraint = r, this.RelatedResourceObjects = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcResourceConstraintRelationship(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.RelatingConstraint), e.push(this.RelatedResourceObjects), e } }, IfcResourceLevelRelationship = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Name = i, this.Description = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcResourceLevelRelationship(e, t, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e } }, IfcResourceTime = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.ScheduleWork = a, this.ScheduleUsage = o, this.ScheduleStart = n, this.ScheduleFinish = h, this.ScheduleContour = l, this.LevelingDelay = c, this.IsOverAllocated = u, this.StatusTime = p, this.ActualWork = d, this.ActualUsage = m, this.ActualStart = f, this.ActualFinish = g, this.RemainingWork = _, this.RemainingUsage = v, this.Completion = y } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[s++], g = i[+s], _ = i[13], v = i[14], y = i[15]; s = i[16], i = i[17]; return new IfcResourceTime(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.ScheduleWork), e.push(this.ScheduleUsage), e.push(this.ScheduleStart), e.push(this.ScheduleFinish), e.push(this.ScheduleContour), e.push(this.LevelingDelay), e.push(this.IsOverAllocated), e.push(this.StatusTime), e.push(this.ActualWork), e.push(this.ActualUsage), e.push(this.ActualStart), e.push(this.ActualFinish), e.push(this.RemainingWork), e.push(this.RemainingUsage), e.push(this.Completion), e } }, IfcRevolvedAreaSolid = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.Axis = r, this.Angle = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRevolvedAreaSolid(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.Axis), e.push(this.Angle), e } }, IfcRevolvedAreaSolidTapered = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.Axis = r, this.Angle = a, this.EndSweptArea = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcRevolvedAreaSolidTapered(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.Axis), e.push(this.Angle), e.push(this.EndSweptArea), e } }, IfcRightCircularCone = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Position = i, this.Height = s, this.BottomRadius = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcRightCircularCone(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Height), e.push(this.BottomRadius), e } }, IfcRightCircularCylinder = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Position = i, this.Height = s, this.Radius = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcRightCircularCylinder(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Height), e.push(this.Radius), e } }, IfcRoof = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcRoof(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcRoofType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcRoofType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcRoot = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcRoot(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e } }, IfcRoundedRectangleProfileDef = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.XDim = a, this.YDim = o, this.RoundingRadius = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcRoundedRectangleProfileDef(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.XDim), e.push(this.YDim), e.push(this.RoundingRadius), e } }, IfcSIUnit = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Dimensions = i, this.UnitType = s, this.Prefix = r, this.Name = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSIUnit(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Dimensions), e.push(this.UnitType), e.push(this.Prefix), e.push(this.Name), e } }, IfcSanitaryTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSanitaryTerminal(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSanitaryTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSanitaryTerminalType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcSchedulingTime = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSchedulingTime(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e } }, IfcSeamCurve = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Curve3D = i, this.AssociatedGeometry = s, this.MasterRepresentation = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSeamCurve(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Curve3D), e.push(this.AssociatedGeometry), e.push(this.MasterRepresentation), e } }, IfcSectionProperties = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.SectionType = i, this.StartProfile = s, this.EndProfile = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSectionProperties(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.SectionType), e.push(this.StartProfile), e.push(this.EndProfile), e } }, IfcSectionReinforcementProperties = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.LongitudinalStartPosition = i, this.LongitudinalEndPosition = s, this.TransversePosition = r, this.ReinforcementRole = a, this.SectionDefinition = o, this.CrossSectionReinforcementDefinitions = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcSectionReinforcementProperties(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.LongitudinalStartPosition), e.push(this.LongitudinalEndPosition), e.push(this.TransversePosition), e.push(this.ReinforcementRole), e.push(this.SectionDefinition), e.push(this.CrossSectionReinforcementDefinitions), e } }, IfcSectionedSolid = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Directrix = i, this.CrossSections = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSectionedSolid(e, t, s, i) } ToTape() { var e = []; return e.push(this.Directrix), e.push(this.CrossSections), e } }, IfcSectionedSolidHorizontal = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Directrix = i, this.CrossSections = s, this.CrossSectionPositions = r, this.FixedAxisVertical = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSectionedSolidHorizontal(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Directrix), e.push(this.CrossSections), e.push(this.CrossSectionPositions), e.push(this.FixedAxisVertical), e } }, IfcSectionedSpine = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.SpineCurve = i, this.CrossSections = s, this.CrossSectionPositions = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSectionedSpine(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.SpineCurve), e.push(this.CrossSections), e.push(this.CrossSectionPositions), e } }, IfcSensor = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSensor(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSensorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSensorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcShadingDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcShadingDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcShadingDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcShadingDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcShapeAspect = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.ShapeRepresentations = i, this.Name = s, this.Description = r, this.ProductDefinitional = a, this.PartOfProductDefinitionShape = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcShapeAspect(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.ShapeRepresentations), e.push(this.Name), e.push(this.Description), e.push(this.ProductDefinitional), e.push(this.PartOfProductDefinitionShape), e } }, IfcShapeModel = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcShapeModel(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcShapeRepresentation = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcShapeRepresentation(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcShellBasedSurfaceModel = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.SbsmBoundary = i } static FromTape(e, t, i) { return i = i[0], new IfcShellBasedSurfaceModel(e, t, i) } ToTape() { var e = []; return e.push(this.SbsmBoundary), e } }, IfcSimpleProperty = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Name = i, this.Description = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSimpleProperty(e, t, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e } }, IfcSimplePropertyTemplate = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.TemplateType = o, this.PrimaryMeasureType = n, this.SecondaryMeasureType = h, this.Enumerators = l, this.PrimaryUnit = c, this.SecondaryUnit = u, this.Expression = p, this.AccessState = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcSimplePropertyTemplate(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.TemplateType), e.push(this.PrimaryMeasureType), e.push(this.SecondaryMeasureType), e.push(this.Enumerators), e.push(this.PrimaryUnit), e.push(this.SecondaryUnit), e.push(this.Expression), e.push(this.AccessState), e } }, IfcSite = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.RefLatitude = u, this.RefLongitude = p, this.RefElevation = d, this.LandTitleNumber = m, this.SiteAddress = f } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[+s], d = i[9], m = i[10], f = i[11]; s = i[12], i = i[13]; return new IfcSite(e, t, r, a, o, n, h, l, c, u, p, d, m, f, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.RefLatitude), e.push(this.RefLongitude), e.push(this.RefElevation), e.push(this.LandTitleNumber), e.push(this.SiteAddress), e } }, IfcSlab = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSlab(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSlabElementedCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSlabElementedCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSlabStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSlabStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSlabType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSlabType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcSlippageConnectionCondition = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.SlippageX = s, this.SlippageY = r, this.SlippageZ = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSlippageConnectionCondition(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.SlippageX), e.push(this.SlippageY), e.push(this.SlippageZ), e } }, IfcSolarDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSolarDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSolarDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSolarDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcSolidModel = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcSolidModel(e, t) } ToTape() { return [] } }, IfcSpace = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c, this.PredefinedType = u, this.ElevationWithFlooring = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcSpace(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e.push(this.PredefinedType), e.push(this.ElevationWithFlooring), e } }, IfcSpaceHeater = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSpaceHeater(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSpaceHeaterType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSpaceHeaterType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcSpaceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.LongName = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcSpaceType(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.LongName), e } }, IfcSpatialElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcSpatialElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e } }, IfcSpatialElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSpatialElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcSpatialStructureElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.CompositionType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSpatialStructureElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.CompositionType), e } }, IfcSpatialStructureElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSpatialStructureElementType(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e } }, IfcSpatialZone = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.LongName = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSpatialZone(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.LongName), e.push(this.PredefinedType), e } }, IfcSpatialZoneType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.LongName = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcSpatialZoneType(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.LongName), e } }, IfcSphere = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Position = i, this.Radius = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSphere(e, t, s, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Radius), e } }, IfcSphericalSurface = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Position = i, this.Radius = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSphericalSurface(e, t, s, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.Radius), e } }, IfcStackTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStackTerminal(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcStackTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStackTerminalType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcStair = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStair(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcStairFlight = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.NumberOfRisers = c, this.NumberOfTreads = u, this.RiserHeight = p, this.TreadLength = d, this.PredefinedType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcStairFlight(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.NumberOfRisers), e.push(this.NumberOfTreads), e.push(this.RiserHeight), e.push(this.TreadLength), e.push(this.PredefinedType), e } }, IfcStairFlightType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStairFlightType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcStairType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStairType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcStructuralAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralAction(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e } }, IfcStructuralActivity = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralActivity(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e } }, IfcStructuralAnalysisModel = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.PredefinedType = n, this.OrientationOf2DPlane = h, this.LoadedBy = l, this.HasResults = c, this.SharedPlacement = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralAnalysisModel(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.PredefinedType), e.push(this.OrientationOf2DPlane), e.push(this.LoadedBy), e.push(this.HasResults), e.push(this.SharedPlacement), e } }, IfcStructuralConnection = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedCondition = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcStructuralConnection(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedCondition), e } }, IfcStructuralConnectionCondition = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcStructuralConnectionCondition(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcStructuralCurveAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u, this.ProjectedOrTrue = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcStructuralCurveAction(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e.push(this.ProjectedOrTrue), e.push(this.PredefinedType), e } }, IfcStructuralCurveConnection = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedCondition = l, this.Axis = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralCurveConnection(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedCondition), e.push(this.Axis), e } }, IfcStructuralCurveMember = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.PredefinedType = l, this.Axis = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralCurveMember(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.PredefinedType), e.push(this.Axis), e } }, IfcStructuralCurveMemberVarying = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.PredefinedType = l, this.Axis = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralCurveMemberVarying(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.PredefinedType), e.push(this.Axis), e } }, IfcStructuralCurveReaction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralCurveReaction(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.PredefinedType), e } }, IfcStructuralItem = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcStructuralItem(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcStructuralLinearAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u, this.ProjectedOrTrue = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcStructuralLinearAction(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e.push(this.ProjectedOrTrue), e.push(this.PredefinedType), e } }, IfcStructuralLoad = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcStructuralLoad(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcStructuralLoadCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.PredefinedType = n, this.ActionType = h, this.ActionSource = l, this.Coefficient = c, this.Purpose = u, this.SelfWeightCoefficients = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcStructuralLoadCase(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.PredefinedType), e.push(this.ActionType), e.push(this.ActionSource), e.push(this.Coefficient), e.push(this.Purpose), e.push(this.SelfWeightCoefficients), e } }, IfcStructuralLoadConfiguration = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Values = s, this.Locations = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcStructuralLoadConfiguration(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Values), e.push(this.Locations), e } }, IfcStructuralLoadGroup = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.PredefinedType = n, this.ActionType = h, this.ActionSource = l, this.Coefficient = c, this.Purpose = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralLoadGroup(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.PredefinedType), e.push(this.ActionType), e.push(this.ActionSource), e.push(this.Coefficient), e.push(this.Purpose), e } }, IfcStructuralLoadLinearForce = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.LinearForceX = s, this.LinearForceY = r, this.LinearForceZ = a, this.LinearMomentX = o, this.LinearMomentY = n, this.LinearMomentZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcStructuralLoadLinearForce(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.LinearForceX), e.push(this.LinearForceY), e.push(this.LinearForceZ), e.push(this.LinearMomentX), e.push(this.LinearMomentY), e.push(this.LinearMomentZ), e } }, IfcStructuralLoadOrResult = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcStructuralLoadOrResult(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcStructuralLoadPlanarForce = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.PlanarForceX = s, this.PlanarForceY = r, this.PlanarForceZ = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcStructuralLoadPlanarForce(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.PlanarForceX), e.push(this.PlanarForceY), e.push(this.PlanarForceZ), e } }, IfcStructuralLoadSingleDisplacement = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.DisplacementX = s, this.DisplacementY = r, this.DisplacementZ = a, this.RotationalDisplacementRX = o, this.RotationalDisplacementRY = n, this.RotationalDisplacementRZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcStructuralLoadSingleDisplacement(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DisplacementX), e.push(this.DisplacementY), e.push(this.DisplacementZ), e.push(this.RotationalDisplacementRX), e.push(this.RotationalDisplacementRY), e.push(this.RotationalDisplacementRZ), e } }, IfcStructuralLoadSingleDisplacementDistortion = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.DisplacementX = s, this.DisplacementY = r, this.DisplacementZ = a, this.RotationalDisplacementRX = o, this.RotationalDisplacementRY = n, this.RotationalDisplacementRZ = h, this.Distortion = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcStructuralLoadSingleDisplacementDistortion(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DisplacementX), e.push(this.DisplacementY), e.push(this.DisplacementZ), e.push(this.RotationalDisplacementRX), e.push(this.RotationalDisplacementRY), e.push(this.RotationalDisplacementRZ), e.push(this.Distortion), e } }, IfcStructuralLoadSingleForce = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.Name = i, this.ForceX = s, this.ForceY = r, this.ForceZ = a, this.MomentX = o, this.MomentY = n, this.MomentZ = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcStructuralLoadSingleForce(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.ForceX), e.push(this.ForceY), e.push(this.ForceZ), e.push(this.MomentX), e.push(this.MomentY), e.push(this.MomentZ), e } }, IfcStructuralLoadSingleForceWarping = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.ForceX = s, this.ForceY = r, this.ForceZ = a, this.MomentX = o, this.MomentY = n, this.MomentZ = h, this.WarpingMoment = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcStructuralLoadSingleForceWarping(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.ForceX), e.push(this.ForceY), e.push(this.ForceZ), e.push(this.MomentX), e.push(this.MomentY), e.push(this.MomentZ), e.push(this.WarpingMoment), e } }, IfcStructuralLoadStatic = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Name = i } static FromTape(e, t, i) { return i = i[0], new IfcStructuralLoadStatic(e, t, i) } ToTape() { var e = []; return e.push(this.Name), e } }, IfcStructuralLoadTemperature = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.DeltaTConstant = s, this.DeltaTY = r, this.DeltaTZ = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcStructuralLoadTemperature(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DeltaTConstant), e.push(this.DeltaTY), e.push(this.DeltaTZ), e } }, IfcStructuralMember = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcStructuralMember(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e } }, IfcStructuralPlanarAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u, this.ProjectedOrTrue = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcStructuralPlanarAction(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e.push(this.ProjectedOrTrue), e.push(this.PredefinedType), e } }, IfcStructuralPointAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralPointAction(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e } }, IfcStructuralPointConnection = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedCondition = l, this.ConditionCoordinateSystem = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralPointConnection(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedCondition), e.push(this.ConditionCoordinateSystem), e } }, IfcStructuralPointReaction = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralPointReaction(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e } }, IfcStructuralReaction = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralReaction(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e } }, IfcStructuralResultGroup = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.TheoryType = n, this.ResultForLoadGroup = h, this.IsLinear = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcStructuralResultGroup(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.TheoryType), e.push(this.ResultForLoadGroup), e.push(this.IsLinear), e } }, IfcStructuralSurfaceAction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.DestabilizingLoad = u, this.ProjectedOrTrue = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcStructuralSurfaceAction(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.DestabilizingLoad), e.push(this.ProjectedOrTrue), e.push(this.PredefinedType), e } }, IfcStructuralSurfaceConnection = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedCondition = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcStructuralSurfaceConnection(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedCondition), e } }, IfcStructuralSurfaceMember = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.PredefinedType = l, this.Thickness = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralSurfaceMember(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.PredefinedType), e.push(this.Thickness), e } }, IfcStructuralSurfaceMemberVarying = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.PredefinedType = l, this.Thickness = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcStructuralSurfaceMemberVarying(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.PredefinedType), e.push(this.Thickness), e } }, IfcStructuralSurfaceReaction = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.AppliedLoad = l, this.GlobalOrLocal = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcStructuralSurfaceReaction(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.AppliedLoad), e.push(this.GlobalOrLocal), e.push(this.PredefinedType), e } }, IfcStyleModel = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcStyleModel(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcStyledItem = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Item = i, this.Styles = s, this.Name = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcStyledItem(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Item), e.push(this.Styles), e.push(this.Name), e } }, IfcStyledRepresentation = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcStyledRepresentation(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcSubContractResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Usage = l, this.BaseCosts = c, this.BaseQuantity = u, this.PredefinedType = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcSubContractResource(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Usage), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcSubContractResourceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c, this.BaseCosts = u, this.BaseQuantity = p, this.PredefinedType = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcSubContractResourceType(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e.push(this.BaseCosts), e.push(this.BaseQuantity), e.push(this.PredefinedType), e } }, IfcSubedge = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.EdgeStart = i, this.EdgeEnd = s, this.ParentEdge = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSubedge(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.EdgeStart), e.push(this.EdgeEnd), e.push(this.ParentEdge), e } }, IfcSurface = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcSurface(e, t) } ToTape() { return [] } }, IfcSurfaceCurve = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Curve3D = i, this.AssociatedGeometry = s, this.MasterRepresentation = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSurfaceCurve(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Curve3D), e.push(this.AssociatedGeometry), e.push(this.MasterRepresentation), e } }, IfcSurfaceCurveSweptAreaSolid = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s, this.Directrix = r, this.StartParam = a, this.EndParam = o, this.ReferenceSurface = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcSurfaceCurveSweptAreaSolid(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e.push(this.Directrix), e.push(this.StartParam), e.push(this.EndParam), e.push(this.ReferenceSurface), e } }, IfcSurfaceFeature = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSurfaceFeature(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSurfaceOfLinearExtrusion = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.SweptCurve = i, this.Position = s, this.ExtrudedDirection = r, this.Depth = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSurfaceOfLinearExtrusion(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.SweptCurve), e.push(this.Position), e.push(this.ExtrudedDirection), e.push(this.Depth), e } }, IfcSurfaceOfRevolution = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.SweptCurve = i, this.Position = s, this.AxisPosition = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSurfaceOfRevolution(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.SweptCurve), e.push(this.Position), e.push(this.AxisPosition), e } }, IfcSurfaceReinforcementArea = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.Name = i, this.SurfaceReinforcement1 = s, this.SurfaceReinforcement2 = r, this.ShearReinforcement = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSurfaceReinforcementArea(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.SurfaceReinforcement1), e.push(this.SurfaceReinforcement2), e.push(this.ShearReinforcement), e } }, IfcSurfaceStyle = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Side = s, this.Styles = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcSurfaceStyle(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Side), e.push(this.Styles), e } }, IfcSurfaceStyleLighting = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.DiffuseTransmissionColour = i, this.DiffuseReflectionColour = s, this.TransmissionColour = r, this.ReflectanceColour = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcSurfaceStyleLighting(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.DiffuseTransmissionColour), e.push(this.DiffuseReflectionColour), e.push(this.TransmissionColour), e.push(this.ReflectanceColour), e } }, IfcSurfaceStyleRefraction = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.RefractionIndex = i, this.DispersionFactor = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSurfaceStyleRefraction(e, t, s, i) } ToTape() { var e = []; return e.push(this.RefractionIndex), e.push(this.DispersionFactor), e } }, IfcSurfaceStyleRendering = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.SurfaceColour = i, this.Transparency = s, this.DiffuseColour = r, this.TransmissionColour = a, this.DiffuseTransmissionColour = o, this.ReflectionColour = n, this.SpecularColour = h, this.SpecularHighlight = l, this.ReflectanceMethod = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSurfaceStyleRendering(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.SurfaceColour), e.push(this.Transparency), e.push(this.DiffuseColour), e.push(this.TransmissionColour), e.push(this.DiffuseTransmissionColour), e.push(this.ReflectionColour), e.push(this.SpecularColour), e.push(this.SpecularHighlight), e.push(this.ReflectanceMethod), e } }, IfcSurfaceStyleShading = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SurfaceColour = i, this.Transparency = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSurfaceStyleShading(e, t, s, i) } ToTape() { var e = []; return e.push(this.SurfaceColour), e.push(this.Transparency), e } }, IfcSurfaceStyleWithTextures = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Textures = i } static FromTape(e, t, i) { return i = i[0], new IfcSurfaceStyleWithTextures(e, t, i) } ToTape() { var e = []; return e.push(this.Textures), e } }, IfcSurfaceTexture = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.RepeatS = i, this.RepeatT = s, this.Mode = r, this.TextureTransform = a, this.Parameter = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcSurfaceTexture(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.RepeatS), e.push(this.RepeatT), e.push(this.Mode), e.push(this.TextureTransform), e.push(this.Parameter), e } }, IfcSweptAreaSolid = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SweptArea = i, this.Position = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSweptAreaSolid(e, t, s, i) } ToTape() { var e = []; return e.push(this.SweptArea), e.push(this.Position), e } }, IfcSweptDiskSolid = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Directrix = i, this.Radius = s, this.InnerRadius = r, this.StartParam = a, this.EndParam = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcSweptDiskSolid(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Directrix), e.push(this.Radius), e.push(this.InnerRadius), e.push(this.StartParam), e.push(this.EndParam), e } }, IfcSweptDiskSolidPolygonal = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Directrix = i, this.Radius = s, this.InnerRadius = r, this.StartParam = a, this.EndParam = o, this.FilletRadius = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcSweptDiskSolidPolygonal(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Directrix), e.push(this.Radius), e.push(this.InnerRadius), e.push(this.StartParam), e.push(this.EndParam), e.push(this.FilletRadius), e } }, IfcSweptSurface = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.SweptCurve = i, this.Position = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcSweptSurface(e, t, s, i) } ToTape() { var e = []; return e.push(this.SweptCurve), e.push(this.Position), e } }, IfcSwitchingDevice = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSwitchingDevice(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSwitchingDeviceType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSwitchingDeviceType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcSystem = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcSystem(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e } }, IfcSystemFurnitureElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcSystemFurnitureElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcSystemFurnitureElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcSystemFurnitureElementType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Depth = a, this.FlangeWidth = o, this.WebThickness = n, this.FlangeThickness = h, this.FilletRadius = l, this.FlangeEdgeRadius = c, this.WebEdgeRadius = u, this.WebSlope = p, this.FlangeSlope = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcTShapeProfileDef(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Depth), e.push(this.FlangeWidth), e.push(this.WebThickness), e.push(this.FlangeThickness), e.push(this.FilletRadius), e.push(this.FlangeEdgeRadius), e.push(this.WebEdgeRadius), e.push(this.WebSlope), e.push(this.FlangeSlope), e } }, IfcTable = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Name = i, this.Rows = s, this.Columns = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcTable(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Rows), e.push(this.Columns), e } }, IfcTableColumn = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Identifier = i, this.Name = s, this.Description = r, this.Unit = a, this.ReferencePath = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcTableColumn(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Identifier), e.push(this.Name), e.push(this.Description), e.push(this.Unit), e.push(this.ReferencePath), e } }, IfcTableRow = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.RowCells = i, this.IsHeading = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcTableRow(e, t, s, i) } ToTape() { var e = []; return e.push(this.RowCells), e.push(this.IsHeading), e } }, IfcTank = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTank(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcTankType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTankType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTask = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.LongDescription = h, this.Status = l, this.WorkMethod = c, this.IsMilestone = u, this.Priority = p, this.TaskTime = d, this.PredefinedType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcTask(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.LongDescription), e.push(this.Status), e.push(this.WorkMethod), e.push(this.IsMilestone), e.push(this.Priority), e.push(this.TaskTime), e.push(this.PredefinedType), e } }, IfcTaskTime = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.DurationType = a, this.ScheduleDuration = o, this.ScheduleStart = n, this.ScheduleFinish = h, this.EarlyStart = l, this.EarlyFinish = c, this.LateStart = u, this.LateFinish = p, this.FreeFloat = d, this.TotalFloat = m, this.IsCritical = f, this.StatusTime = g, this.ActualDuration = _, this.ActualStart = v, this.ActualFinish = y, this.RemainingTime = T, this.Completion = I } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[s++], g = i[s++], _ = i[s++], v = i[+s], y = i[15], T = i[16], I = i[17]; s = i[18], i = i[19]; return new IfcTaskTime(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.DurationType), e.push(this.ScheduleDuration), e.push(this.ScheduleStart), e.push(this.ScheduleFinish), e.push(this.EarlyStart), e.push(this.EarlyFinish), e.push(this.LateStart), e.push(this.LateFinish), e.push(this.FreeFloat), e.push(this.TotalFloat), e.push(this.IsCritical), e.push(this.StatusTime), e.push(this.ActualDuration), e.push(this.ActualStart), e.push(this.ActualFinish), e.push(this.RemainingTime), e.push(this.Completion), e } }, IfcTaskTimeRecurring = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I, E) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.DurationType = a, this.ScheduleDuration = o, this.ScheduleStart = n, this.ScheduleFinish = h, this.EarlyStart = l, this.EarlyFinish = c, this.LateStart = u, this.LateFinish = p, this.FreeFloat = d, this.TotalFloat = m, this.IsCritical = f, this.StatusTime = g, this.ActualDuration = _, this.ActualStart = v, this.ActualFinish = y, this.RemainingTime = T, this.Completion = I, this.Recurrence = E } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[s++], g = i[s++], _ = i[s++], v = i[s++], y = i[+s], T = i[16], I = i[17], E = i[18]; s = i[19], i = i[20]; return new IfcTaskTimeRecurring(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, y, T, I, E, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.DurationType), e.push(this.ScheduleDuration), e.push(this.ScheduleStart), e.push(this.ScheduleFinish), e.push(this.EarlyStart), e.push(this.EarlyFinish), e.push(this.LateStart), e.push(this.LateFinish), e.push(this.FreeFloat), e.push(this.TotalFloat), e.push(this.IsCritical), e.push(this.StatusTime), e.push(this.ActualDuration), e.push(this.ActualStart), e.push(this.ActualFinish), e.push(this.RemainingTime), e.push(this.Completion), e.push(this.Recurrence), e } }, IfcTaskType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ProcessType = c, this.PredefinedType = u, this.WorkMethod = p } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[+s], c = i[6], u = i[7], p = i[8]; s = i[9], i = i[10]; return new IfcTaskType(e, t, r, a, o, n, h, l, c, u, p, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ProcessType), e.push(this.PredefinedType), e.push(this.WorkMethod), e } }, IfcTelecomAddress = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.Purpose = i, this.Description = s, this.UserDefinedPurpose = r, this.TelephoneNumbers = a, this.FacsimileNumbers = o, this.PagerNumber = n, this.ElectronicMailAddresses = h, this.WWWHomePageURL = l, this.MessagingIDs = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTelecomAddress(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.Purpose), e.push(this.Description), e.push(this.UserDefinedPurpose), e.push(this.TelephoneNumbers), e.push(this.FacsimileNumbers), e.push(this.PagerNumber), e.push(this.ElectronicMailAddresses), e.push(this.WWWHomePageURL), e.push(this.MessagingIDs), e } }, IfcTendon = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c, this.PredefinedType = u, this.NominalDiameter = p, this.CrossSectionArea = d, this.TensionForce = m, this.PreStress = f, this.FrictionCoefficient = g, this.AnchorageSlip = _, this.MinCurvatureRadius = v } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[s++], f = i[+s], g = i[12], _ = i[13], v = i[14]; s = i[15], i = i[16]; return new IfcTendon(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, v, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e.push(this.PredefinedType), e.push(this.NominalDiameter), e.push(this.CrossSectionArea), e.push(this.TensionForce), e.push(this.PreStress), e.push(this.FrictionCoefficient), e.push(this.AnchorageSlip), e.push(this.MinCurvatureRadius), e } }, IfcTendonAnchor = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTendonAnchor(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e.push(this.PredefinedType), e } }, IfcTendonAnchorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTendonAnchorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTendonConduit = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.SteelGrade = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTendonConduit(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.SteelGrade), e.push(this.PredefinedType), e } }, IfcTendonConduitType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTendonConduitType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTendonType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.NominalDiameter = p, this.CrossSectionArea = d, this.SheathDiameter = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcTendonType(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.NominalDiameter), e.push(this.CrossSectionArea), e.push(this.SheathDiameter), e } }, IfcTessellatedFaceSet = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Coordinates = i } static FromTape(e, t, i) { return i = i[0], new IfcTessellatedFaceSet(e, t, i) } ToTape() { var e = []; return e.push(this.Coordinates), e } }, IfcTessellatedItem = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcTessellatedItem(e, t) } ToTape() { return [] } }, IfcTextLiteral = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Literal = i, this.Placement = s, this.Path = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcTextLiteral(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Literal), e.push(this.Placement), e.push(this.Path), e } }, IfcTextLiteralWithExtent = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Literal = i, this.Placement = s, this.Path = r, this.Extent = a, this.BoxAlignment = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcTextLiteralWithExtent(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Literal), e.push(this.Placement), e.push(this.Path), e.push(this.Extent), e.push(this.BoxAlignment), e } }, IfcTextStyle = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Name = i, this.TextCharacterAppearance = s, this.TextStyle = r, this.TextFontStyle = a, this.ModelOrDraughting = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcTextStyle(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.TextCharacterAppearance), e.push(this.TextStyle), e.push(this.TextFontStyle), e.push(this.ModelOrDraughting), e } }, IfcTextStyleFontModel = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.FontFamily = s, this.FontStyle = r, this.FontVariant = a, this.FontWeight = o, this.FontSize = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcTextStyleFontModel(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.FontFamily), e.push(this.FontStyle), e.push(this.FontVariant), e.push(this.FontWeight), e.push(this.FontSize), e } }, IfcTextStyleForDefinedFont = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Colour = i, this.BackgroundColour = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcTextStyleForDefinedFont(e, t, s, i) } ToTape() { var e = []; return e.push(this.Colour), e.push(this.BackgroundColour), e } }, IfcTextStyleTextModel = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.TextIndent = i, this.TextAlign = s, this.TextDecoration = r, this.LetterSpacing = a, this.WordSpacing = o, this.TextTransform = n, this.LineHeight = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcTextStyleTextModel(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.TextIndent), e.push(this.TextAlign), e.push(this.TextDecoration), e.push(this.LetterSpacing), e.push(this.WordSpacing), e.push(this.TextTransform), e.push(this.LineHeight), e } }, IfcTextureCoordinate = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Maps = i } static FromTape(e, t, i) { return i = i[0], new IfcTextureCoordinate(e, t, i) } ToTape() { var e = []; return e.push(this.Maps), e } }, IfcTextureCoordinateGenerator = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Maps = i, this.Mode = s, this.Parameter = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcTextureCoordinateGenerator(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Maps), e.push(this.Mode), e.push(this.Parameter), e } }, IfcTextureMap = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Maps = i, this.Vertices = s, this.MappedTo = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcTextureMap(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Maps), e.push(this.Vertices), e.push(this.MappedTo), e } }, IfcTextureVertex = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Coordinates = i } static FromTape(e, t, i) { return i = i[0], new IfcTextureVertex(e, t, i) } ToTape() { var e = []; return e.push(this.Coordinates), e } }, IfcTextureVertexList = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.TexCoordsList = i } static FromTape(e, t, i) { return i = i[0], new IfcTextureVertexList(e, t, i) } ToTape() { var e = []; return e.push(this.TexCoordsList), e } }, IfcTimePeriod = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.StartTime = i, this.EndTime = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcTimePeriod(e, t, s, i) } ToTape() { var e = []; return e.push(this.StartTime), e.push(this.EndTime), e } }, IfcTimeSeries = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.Name = i, this.Description = s, this.StartTime = r, this.EndTime = a, this.TimeSeriesDataType = o, this.DataOrigin = n, this.UserDefinedDataOrigin = h, this.Unit = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcTimeSeries(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.Description), e.push(this.StartTime), e.push(this.EndTime), e.push(this.TimeSeriesDataType), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.Unit), e } }, IfcTimeSeriesValue = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.ListValues = i } static FromTape(e, t, i) { return i = i[0], new IfcTimeSeriesValue(e, t, i) } ToTape() { var e = []; return e.push(this.ListValues), e } }, IfcTopologicalRepresentationItem = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcTopologicalRepresentationItem(e, t) } ToTape() { return [] } }, IfcTopologyRepresentation = class { constructor(e, t, i, s, r, a) { this.expressID = e, this.type = t, this.ContextOfItems = i, this.RepresentationIdentifier = s, this.RepresentationType = r, this.Items = a } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2]; i = i[3]; return new IfcTopologyRepresentation(e, t, s, r, a, i) } ToTape() { var e = []; return e.push(this.ContextOfItems), e.push(this.RepresentationIdentifier), e.push(this.RepresentationType), e.push(this.Items), e } }, IfcToroidalSurface = class { constructor(e, t, i, s, r) { this.expressID = e, this.type = t, this.Position = i, this.MajorRadius = s, this.MinorRadius = r } static FromTape(e, t, i) { var s = i[0], r = i[1]; i = i[2]; return new IfcToroidalSurface(e, t, s, r, i) } ToTape() { var e = []; return e.push(this.Position), e.push(this.MajorRadius), e.push(this.MinorRadius), e } }, IfcTransformer = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTransformer(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcTransformerType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTransformerType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTransitionCurveSegment2D = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.StartPoint = i, this.StartDirection = s, this.SegmentLength = r, this.StartRadius = a, this.EndRadius = o, this.IsStartRadiusCCW = n, this.IsEndRadiusCCW = h, this.TransitionCurveType = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcTransitionCurveSegment2D(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.StartPoint), e.push(this.StartDirection), e.push(this.SegmentLength), e.push(this.StartRadius), e.push(this.EndRadius), e.push(this.IsStartRadiusCCW), e.push(this.IsEndRadiusCCW), e.push(this.TransitionCurveType), e } }, IfcTransportElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTransportElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcTransportElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTransportElementType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTrapeziumProfileDef = class { constructor(e, t, i, s, r, a, o, n, h) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.BottomXDim = a, this.TopXDim = o, this.YDim = n, this.TopXOffset = h } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[+s], o = i[2], n = i[3], h = i[4]; s = i[5], i = i[6]; return new IfcTrapeziumProfileDef(e, t, r, a, o, n, h, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.BottomXDim), e.push(this.TopXDim), e.push(this.YDim), e.push(this.TopXOffset), e } }, IfcTriangulatedFaceSet = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.Coordinates = i, this.Normals = s, this.Closed = r, this.CoordIndex = a, this.PnIndex = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcTriangulatedFaceSet(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.Coordinates), e.push(this.Normals), e.push(this.Closed), e.push(this.CoordIndex), e.push(this.PnIndex), e } }, IfcTriangulatedIrregularNetwork = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Coordinates = i, this.Normals = s, this.Closed = r, this.CoordIndex = a, this.PnIndex = o, this.Flags = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcTriangulatedIrregularNetwork(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Coordinates), e.push(this.Normals), e.push(this.Closed), e.push(this.CoordIndex), e.push(this.PnIndex), e.push(this.Flags), e } }, IfcTrimmedCurve = class { constructor(e, t, i, s, r, a, o) { this.expressID = e, this.type = t, this.BasisCurve = i, this.Trim1 = s, this.Trim2 = r, this.SenseAgreement = a, this.MasterRepresentation = o } static FromTape(e, t, i) { var s = i[0], r = i[1], a = i[2], o = i[3]; i = i[4]; return new IfcTrimmedCurve(e, t, s, r, a, o, i) } ToTape() { var e = []; return e.push(this.BasisCurve), e.push(this.Trim1), e.push(this.Trim2), e.push(this.SenseAgreement), e.push(this.MasterRepresentation), e } }, IfcTubeBundle = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTubeBundle(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcTubeBundleType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcTubeBundleType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcTypeObject = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcTypeObject(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e } }, IfcTypeProcess = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ProcessType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTypeProcess(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ProcessType), e } }, IfcTypeProduct = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcTypeProduct(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e } }, IfcTypeResource = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.Identification = h, this.LongDescription = l, this.ResourceType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcTypeResource(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.Identification), e.push(this.LongDescription), e.push(this.ResourceType), e } }, IfcUShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Depth = a, this.FlangeWidth = o, this.WebThickness = n, this.FlangeThickness = h, this.FilletRadius = l, this.EdgeRadius = c, this.FlangeSlope = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcUShapeProfileDef(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Depth), e.push(this.FlangeWidth), e.push(this.WebThickness), e.push(this.FlangeThickness), e.push(this.FilletRadius), e.push(this.EdgeRadius), e.push(this.FlangeSlope), e } }, IfcUnitAssignment = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.Units = i } static FromTape(e, t, i) { return i = i[0], new IfcUnitAssignment(e, t, i) } ToTape() { var e = []; return e.push(this.Units), e } }, IfcUnitaryControlElement = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcUnitaryControlElement(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcUnitaryControlElementType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcUnitaryControlElementType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcUnitaryEquipment = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcUnitaryEquipment(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcUnitaryEquipmentType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcUnitaryEquipmentType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcValve = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcValve(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcValveType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcValveType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcVector = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.Orientation = i, this.Magnitude = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcVector(e, t, s, i) } ToTape() { var e = []; return e.push(this.Orientation), e.push(this.Magnitude), e } }, IfcVertex = class { constructor(e, t) { this.expressID = e, this.type = t } static FromTape(e, t, i) { return new IfcVertex(e, t) } ToTape() { return [] } }, IfcVertexLoop = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.LoopVertex = i } static FromTape(e, t, i) { return i = i[0], new IfcVertexLoop(e, t, i) } ToTape() { var e = []; return e.push(this.LoopVertex), e } }, IfcVertexPoint = class { constructor(e, t, i) { this.expressID = e, this.type = t, this.VertexGeometry = i } static FromTape(e, t, i) { return i = i[0], new IfcVertexPoint(e, t, i) } ToTape() { var e = []; return e.push(this.VertexGeometry), e } }, IfcVibrationDamper = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcVibrationDamper(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcVibrationDamperType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcVibrationDamperType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcVibrationIsolator = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcVibrationIsolator(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcVibrationIsolatorType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcVibrationIsolatorType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcVirtualElement = class { constructor(e, t, i, s, r, a, o, n, h, l) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[+s], n = i[3], h = i[4], l = i[5]; s = i[6], i = i[7]; return new IfcVirtualElement(e, t, r, a, o, n, h, l, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e } }, IfcVirtualGridIntersection = class { constructor(e, t, i, s) { this.expressID = e, this.type = t, this.IntersectingAxes = i, this.OffsetDistances = s } static FromTape(e, t, i) { var s = i[0]; i = i[1]; return new IfcVirtualGridIntersection(e, t, s, i) } ToTape() { var e = []; return e.push(this.IntersectingAxes), e.push(this.OffsetDistances), e } }, IfcVoidingFeature = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcVoidingFeature(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcWall = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWall(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcWallElementedCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWallElementedCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcWallStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWallStandardCase(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcWallType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcWallType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcWasteTerminal = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWasteTerminal(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.PredefinedType), e } }, IfcWasteTerminalType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[+s], l = i[5], c = i[6], u = i[7]; s = i[8], i = i[9]; return new IfcWasteTerminalType(e, t, r, a, o, n, h, l, c, u, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e } }, IfcWindow = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.OverallHeight = c, this.OverallWidth = u, this.PredefinedType = p, this.PartitioningType = d, this.UserDefinedPartitioningType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcWindow(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.OverallHeight), e.push(this.OverallWidth), e.push(this.PredefinedType), e.push(this.PartitioningType), e.push(this.UserDefinedPartitioningType), e } }, IfcWindowLiningProperties = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f, g, _) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.LiningDepth = o, this.LiningThickness = n, this.TransomThickness = h, this.MullionThickness = l, this.FirstTransomOffset = c, this.SecondTransomOffset = u, this.FirstMullionOffset = p, this.SecondMullionOffset = d, this.ShapeAspectStyle = m, this.LiningOffset = f, this.LiningToPanelOffsetX = g, this.LiningToPanelOffsetY = _ } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[s++], d = i[s++], m = i[+s], f = i[11], g = i[12], _ = i[13]; s = i[14], i = i[15]; return new IfcWindowLiningProperties(e, t, r, a, o, n, h, l, c, u, p, d, m, f, g, _, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.LiningDepth), e.push(this.LiningThickness), e.push(this.TransomThickness), e.push(this.MullionThickness), e.push(this.FirstTransomOffset), e.push(this.SecondTransomOffset), e.push(this.FirstMullionOffset), e.push(this.SecondMullionOffset), e.push(this.ShapeAspectStyle), e.push(this.LiningOffset), e.push(this.LiningToPanelOffsetX), e.push(this.LiningToPanelOffsetY), e } }, IfcWindowPanelProperties = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.OperationType = o, this.PanelPosition = n, this.FrameDepth = h, this.FrameThickness = l, this.ShapeAspectStyle = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWindowPanelProperties(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.OperationType), e.push(this.PanelPosition), e.push(this.FrameDepth), e.push(this.FrameThickness), e.push(this.ShapeAspectStyle), e } }, IfcWindowStandardCase = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.ObjectPlacement = n, this.Representation = h, this.Tag = l, this.OverallHeight = c, this.OverallWidth = u, this.PredefinedType = p, this.PartitioningType = d, this.UserDefinedPartitioningType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcWindowStandardCase(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.ObjectPlacement), e.push(this.Representation), e.push(this.Tag), e.push(this.OverallHeight), e.push(this.OverallWidth), e.push(this.PredefinedType), e.push(this.PartitioningType), e.push(this.UserDefinedPartitioningType), e } }, IfcWindowStyle = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ConstructionType = c, this.OperationType = u, this.ParameterTakesPrecedence = p, this.Sizeable = d } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[+s], u = i[7], p = i[8], d = i[9]; s = i[10], i = i[11]; return new IfcWindowStyle(e, t, r, a, o, n, h, l, c, u, p, d, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ConstructionType), e.push(this.OperationType), e.push(this.ParameterTakesPrecedence), e.push(this.Sizeable), e } }, IfcWindowType = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ApplicableOccurrence = o, this.HasPropertySets = n, this.RepresentationMaps = h, this.Tag = l, this.ElementType = c, this.PredefinedType = u, this.PartitioningType = p, this.ParameterTakesPrecedence = d, this.UserDefinedPartitioningType = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcWindowType(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ApplicableOccurrence), e.push(this.HasPropertySets), e.push(this.RepresentationMaps), e.push(this.Tag), e.push(this.ElementType), e.push(this.PredefinedType), e.push(this.PartitioningType), e.push(this.ParameterTakesPrecedence), e.push(this.UserDefinedPartitioningType), e } }, IfcWorkCalendar = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.WorkingTimes = h, this.ExceptionTimes = l, this.PredefinedType = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcWorkCalendar(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.WorkingTimes), e.push(this.ExceptionTimes), e.push(this.PredefinedType), e } }, IfcWorkControl = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.CreationDate = h, this.Creators = l, this.Purpose = c, this.Duration = u, this.TotalFloat = p, this.StartTime = d, this.FinishTime = m } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[+s], p = i[8], d = i[9], m = i[10]; s = i[11], i = i[12]; return new IfcWorkControl(e, t, r, a, o, n, h, l, c, u, p, d, m, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.CreationDate), e.push(this.Creators), e.push(this.Purpose), e.push(this.Duration), e.push(this.TotalFloat), e.push(this.StartTime), e.push(this.FinishTime), e } }, IfcWorkPlan = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.CreationDate = h, this.Creators = l, this.Purpose = c, this.Duration = u, this.TotalFloat = p, this.StartTime = d, this.FinishTime = m, this.PredefinedType = f } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[+s], d = i[9], m = i[10], f = i[11]; s = i[12], i = i[13]; return new IfcWorkPlan(e, t, r, a, o, n, h, l, c, u, p, d, m, f, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.CreationDate), e.push(this.Creators), e.push(this.Purpose), e.push(this.Duration), e.push(this.TotalFloat), e.push(this.StartTime), e.push(this.FinishTime), e.push(this.PredefinedType), e } }, IfcWorkSchedule = class { constructor(e, t, i, s, r, a, o, n, h, l, c, u, p, d, m, f) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.Identification = n, this.CreationDate = h, this.Creators = l, this.Purpose = c, this.Duration = u, this.TotalFloat = p, this.StartTime = d, this.FinishTime = m, this.PredefinedType = f } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[s++], h = i[s++], l = i[s++], c = i[s++], u = i[s++], p = i[+s], d = i[9], m = i[10], f = i[11]; s = i[12], i = i[13]; return new IfcWorkSchedule(e, t, r, a, o, n, h, l, c, u, p, d, m, f, s, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.Identification), e.push(this.CreationDate), e.push(this.Creators), e.push(this.Purpose), e.push(this.Duration), e.push(this.TotalFloat), e.push(this.StartTime), e.push(this.FinishTime), e.push(this.PredefinedType), e } }, IfcWorkTime = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.Name = i, this.DataOrigin = s, this.UserDefinedDataOrigin = r, this.RecurrencePattern = a, this.Start = o, this.Finish = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcWorkTime(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.Name), e.push(this.DataOrigin), e.push(this.UserDefinedDataOrigin), e.push(this.RecurrencePattern), e.push(this.Start), e.push(this.Finish), e } }, IfcZShapeProfileDef = class { constructor(e, t, i, s, r, a, o, n, h, l, c) { this.expressID = e, this.type = t, this.ProfileType = i, this.ProfileName = s, this.Position = r, this.Depth = a, this.FlangeWidth = o, this.WebThickness = n, this.FlangeThickness = h, this.FilletRadius = l, this.EdgeRadius = c } static FromTape(e, t, i) { var s = 0, r = i[s++], a = i[s++], o = i[s++], n = i[+s], h = i[4], l = i[5], c = i[6]; s = i[7], i = i[8]; return new IfcZShapeProfileDef(e, t, r, a, o, n, h, l, c, s, i) } ToTape() { var e = []; return e.push(this.ProfileType), e.push(this.ProfileName), e.push(this.Position), e.push(this.Depth), e.push(this.FlangeWidth), e.push(this.WebThickness), e.push(this.FlangeThickness), e.push(this.FilletRadius), e.push(this.EdgeRadius), e } }, IfcZone = class { constructor(e, t, i, s, r, a, o, n) { this.expressID = e, this.type = t, this.GlobalId = i, this.OwnerHistory = s, this.Name = r, this.Description = a, this.ObjectType = o, this.LongName = n } static FromTape(e, t, i) { var s = i[+(n = 0)], r = i[1], a = i[2], o = i[3], n = i[4]; i = i[5]; return new IfcZone(e, t, s, r, a, o, n, i) } ToTape() { var e = []; return e.push(this.GlobalId), e.push(this.OwnerHistory), e.push(this.Name), e.push(this.Description), e.push(this.ObjectType), e.push(this.LongName), e } }, IfcElements2 = { 103090709: "IFCPROJECT", 4097777520: "IFCSITE", 4031249490: "IFCBUILDING", 3124254112: "IFCBUILDINGSTOREY", 3856911033: "IFCSPACE", 1674181508: "IFCANNOTATION", 25142252: "IFCCONTROLLER", 32344328: "IFCBOILER", 76236018: "IFCLAMP", 90941305: "IFCPUMP", 177149247: "IFCAIRTERMINALBOX", 182646315: "IFCFLOWINSTRUMENT", 263784265: "IFCFURNISHINGELEMENT", 264262732: "IFCELECTRICGENERATOR", 277319702: "IFCAUDIOVISUALAPPLIANCE", 310824031: "IFCPIPEFITTING", 331165859: "IFCSTAIR", 342316401: "IFCDUCTFITTING", 377706215: "IFCMECHANICALFASTENER", 395920057: "IFCDOOR", 402227799: "IFCELECTRICMOTOR", 413509423: "IFCSYSTEMFURNITUREELEMENT", 484807127: "IFCEVAPORATOR", 486154966: "IFCWINDOWSTANDARDCASE", 629592764: "IFCLIGHTFIXTURE", 630975310: "IFCUNITARYCONTROLELEMENT", 635142910: "IFCCABLECARRIERFITTING", 639361253: "IFCCOIL", 647756555: "IFCFASTENER", 707683696: "IFCFLOWSTORAGEDEVICE", 738039164: "IFCPROTECTIVEDEVICE", 753842376: "IFCBEAM", 812556717: "IFCTANK", 819412036: "IFCFILTER", 843113511: "IFCCOLUMN", 862014818: "IFCELECTRICDISTRIBUTIONBOARD", 900683007: "IFCFOOTING", 905975707: "IFCCOLUMNSTANDARDCASE", 926996030: "IFCVOIDINGFEATURE", 979691226: "IFCREINFORCINGBAR", 987401354: "IFCFLOWSEGMENT", 1003880860: "IFCELECTRICTIMECONTROL", 1051757585: "IFCCABLEFITTING", 1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT", 1062813311: "IFCDISTRIBUTIONCONTROLELEMENT", 1073191201: "IFCMEMBER", 1095909175: "IFCBUILDINGELEMENTPROXY", 1156407060: "IFCPLATESTANDARDCASE", 1162798199: "IFCSWITCHINGDEVICE", 1329646415: "IFCSHADINGDEVICE", 1335981549: "IFCDISCRETEACCESSORY", 1360408905: "IFCDUCTSILENCER", 1404847402: "IFCSTACKTERMINAL", 1426591983: "IFCFIRESUPPRESSIONTERMINAL", 1437502449: "IFCMEDICALDEVICE", 1509553395: "IFCFURNITURE", 1529196076: "IFCSLAB", 1620046519: "IFCTRANSPORTELEMENT", 1634111441: "IFCAIRTERMINAL", 1658829314: "IFCENERGYCONVERSIONDEVICE", 1677625105: "IFCCIVILELEMENT", 1687234759: "IFCPILE", 1904799276: "IFCELECTRICAPPLIANCE", 1911478936: "IFCMEMBERSTANDARDCASE", 1945004755: "IFCDISTRIBUTIONELEMENT", 1973544240: "IFCCOVERING", 1999602285: "IFCSPACEHEATER", 2016517767: "IFCROOF", 2056796094: "IFCAIRTOAIRHEATRECOVERY", 2058353004: "IFCFLOWCONTROLLER", 2068733104: "IFCHUMIDIFIER", 2176052936: "IFCJUNCTIONBOX", 2188021234: "IFCFLOWMETER", 2223149337: "IFCFLOWTERMINAL", 2262370178: "IFCRAILING", 2272882330: "IFCCONDENSER", 2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT", 2320036040: "IFCREINFORCINGMESH", 2347447852: "IFCTENDONANCHOR", 2391383451: "IFCVIBRATIONISOLATOR", 2391406946: "IFCWALL", 2474470126: "IFCMOTORCONNECTION", 2769231204: "IFCVIRTUALELEMENT", 2814081492: "IFCENGINE", 2906023776: "IFCBEAMSTANDARDCASE", 2938176219: "IFCBURNER", 2979338954: "IFCBUILDINGELEMENTPART", 3024970846: "IFCRAMP", 3026737570: "IFCTUBEBUNDLE", 3027962421: "IFCSLABSTANDARDCASE", 3040386961: "IFCDISTRIBUTIONFLOWELEMENT", 3053780830: "IFCSANITARYTERMINAL", 3079942009: "IFCOPENINGSTANDARDCASE", 3087945054: "IFCALARM", 3101698114: "IFCSURFACEFEATURE", 3127900445: "IFCSLABELEMENTEDCASE", 3132237377: "IFCFLOWMOVINGDEVICE", 3171933400: "IFCPLATE", 3221913625: "IFCCOMMUNICATIONSAPPLIANCE", 3242481149: "IFCDOORSTANDARDCASE", 3283111854: "IFCRAMPFLIGHT", 3296154744: "IFCCHIMNEY", 3304561284: "IFCWINDOW", 3310460725: "IFCELECTRICFLOWSTORAGEDEVICE", 3319311131: "IFCHEATEXCHANGER", 3415622556: "IFCFAN", 3420628829: "IFCSOLARDEVICE", 3493046030: "IFCGEOGRAPHICELEMENT", 3495092785: "IFCCURTAINWALL", 3508470533: "IFCFLOWTREATMENTDEVICE", 3512223829: "IFCWALLSTANDARDCASE", 3518393246: "IFCDUCTSEGMENT", 3571504051: "IFCCOMPRESSOR", 3588315303: "IFCOPENINGELEMENT", 3612865200: "IFCPIPESEGMENT", 3640358203: "IFCCOOLINGTOWER", 3651124850: "IFCPROJECTIONELEMENT", 3694346114: "IFCOUTLET", 3747195512: "IFCEVAPORATIVECOOLER", 3758799889: "IFCCABLECARRIERSEGMENT", 3824725483: "IFCTENDON", 3825984169: "IFCTRANSFORMER", 3902619387: "IFCCHILLER", 4074379575: "IFCDAMPER", 4086658281: "IFCSENSOR", 4123344466: "IFCELEMENTASSEMBLY", 4136498852: "IFCCOOLEDBEAM", 4156078855: "IFCWALLELEMENTEDCASE", 4175244083: "IFCINTERCEPTOR", 4207607924: "IFCVALVE", 4217484030: "IFCCABLESEGMENT", 4237592921: "IFCWASTETERMINAL", 4252922144: "IFCSTAIRFLIGHT", 4278956645: "IFCFLOWFITTING", 4288193352: "IFCACTUATOR", 4292641817: "IFCUNITARYEQUIPMENT", 3009204131: "IFCGRID" }, IfcTypesMap = { 3821786052: "IFCACTIONREQUEST", 2296667514: "IFCACTOR", 3630933823: "IFCACTORROLE", 4288193352: "IFCACTUATOR", 2874132201: "IFCACTUATORTYPE", 618182010: "IFCADDRESS", 1635779807: "IFCADVANCEDBREP", 2603310189: "IFCADVANCEDBREPWITHVOIDS", 3406155212: "IFCADVANCEDFACE", 1634111441: "IFCAIRTERMINAL", 177149247: "IFCAIRTERMINALBOX", 1411407467: "IFCAIRTERMINALBOXTYPE", 3352864051: "IFCAIRTERMINALTYPE", 2056796094: "IFCAIRTOAIRHEATRECOVERY", 1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE", 3087945054: "IFCALARM", 3001207471: "IFCALARMTYPE", 325726236: "IFCALIGNMENT", 749761778: "IFCALIGNMENT2DHORIZONTAL", 3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT", 2483840362: "IFCALIGNMENT2DSEGMENT", 3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC", 3239324667: "IFCALIGNMENT2DVERSEGLINE", 4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC", 53199957: "IFCALIGNMENT2DVERTICAL", 2029264950: "IFCALIGNMENT2DVERTICALSEGMENT", 3512275521: "IFCALIGNMENTCURVE", 1674181508: "IFCANNOTATION", 669184980: "IFCANNOTATIONFILLAREA", 639542469: "IFCAPPLICATION", 411424972: "IFCAPPLIEDVALUE", 130549933: "IFCAPPROVAL", 3869604511: "IFCAPPROVALRELATIONSHIP", 3798115385: "IFCARBITRARYCLOSEDPROFILEDEF", 1310608509: "IFCARBITRARYOPENPROFILEDEF", 2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS", 3460190687: "IFCASSET", 3207858831: "IFCASYMMETRICISHAPEPROFILEDEF", 277319702: "IFCAUDIOVISUALAPPLIANCE", 1532957894: "IFCAUDIOVISUALAPPLIANCETYPE", 4261334040: "IFCAXIS1PLACEMENT", 3125803723: "IFCAXIS2PLACEMENT2D", 2740243338: "IFCAXIS2PLACEMENT3D", 1967976161: "IFCBSPLINECURVE", 2461110595: "IFCBSPLINECURVEWITHKNOTS", 2887950389: "IFCBSPLINESURFACE", 167062518: "IFCBSPLINESURFACEWITHKNOTS", 753842376: "IFCBEAM", 2906023776: "IFCBEAMSTANDARDCASE", 819618141: "IFCBEAMTYPE", 4196446775: "IFCBEARING", 3649138523: "IFCBEARINGTYPE", 616511568: "IFCBLOBTEXTURE", 1334484129: "IFCBLOCK", 32344328: "IFCBOILER", 231477066: "IFCBOILERTYPE", 3649129432: "IFCBOOLEANCLIPPINGRESULT", 2736907675: "IFCBOOLEANRESULT", 4037036970: "IFCBOUNDARYCONDITION", 1136057603: "IFCBOUNDARYCURVE", 1560379544: "IFCBOUNDARYEDGECONDITION", 3367102660: "IFCBOUNDARYFACECONDITION", 1387855156: "IFCBOUNDARYNODECONDITION", 2069777674: "IFCBOUNDARYNODECONDITIONWARPING", 1260505505: "IFCBOUNDEDCURVE", 4182860854: "IFCBOUNDEDSURFACE", 2581212453: "IFCBOUNDINGBOX", 2713105998: "IFCBOXEDHALFSPACE", 644574406: "IFCBRIDGE", 963979645: "IFCBRIDGEPART", 4031249490: "IFCBUILDING", 3299480353: "IFCBUILDINGELEMENT", 2979338954: "IFCBUILDINGELEMENTPART", 39481116: "IFCBUILDINGELEMENTPARTTYPE", 1095909175: "IFCBUILDINGELEMENTPROXY", 1909888760: "IFCBUILDINGELEMENTPROXYTYPE", 1950629157: "IFCBUILDINGELEMENTTYPE", 3124254112: "IFCBUILDINGSTOREY", 1177604601: "IFCBUILDINGSYSTEM", 2938176219: "IFCBURNER", 2188180465: "IFCBURNERTYPE", 2898889636: "IFCCSHAPEPROFILEDEF", 635142910: "IFCCABLECARRIERFITTING", 395041908: "IFCCABLECARRIERFITTINGTYPE", 3758799889: "IFCCABLECARRIERSEGMENT", 3293546465: "IFCCABLECARRIERSEGMENTTYPE", 1051757585: "IFCCABLEFITTING", 2674252688: "IFCCABLEFITTINGTYPE", 4217484030: "IFCCABLESEGMENT", 1285652485: "IFCCABLESEGMENTTYPE", 3999819293: "IFCCAISSONFOUNDATION", 3203706013: "IFCCAISSONFOUNDATIONTYPE", 1123145078: "IFCCARTESIANPOINT", 574549367: "IFCCARTESIANPOINTLIST", 1675464909: "IFCCARTESIANPOINTLIST2D", 2059837836: "IFCCARTESIANPOINTLIST3D", 59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR", 3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D", 3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM", 3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D", 1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM", 3150382593: "IFCCENTERLINEPROFILEDEF", 3902619387: "IFCCHILLER", 2951183804: "IFCCHILLERTYPE", 3296154744: "IFCCHIMNEY", 2197970202: "IFCCHIMNEYTYPE", 2611217952: "IFCCIRCLE", 2937912522: "IFCCIRCLEHOLLOWPROFILEDEF", 1383045692: "IFCCIRCLEPROFILEDEF", 1062206242: "IFCCIRCULARARCSEGMENT2D", 1677625105: "IFCCIVILELEMENT", 3893394355: "IFCCIVILELEMENTTYPE", 747523909: "IFCCLASSIFICATION", 647927063: "IFCCLASSIFICATIONREFERENCE", 2205249479: "IFCCLOSEDSHELL", 639361253: "IFCCOIL", 2301859152: "IFCCOILTYPE", 776857604: "IFCCOLOURRGB", 3285139300: "IFCCOLOURRGBLIST", 3264961684: "IFCCOLOURSPECIFICATION", 843113511: "IFCCOLUMN", 905975707: "IFCCOLUMNSTANDARDCASE", 300633059: "IFCCOLUMNTYPE", 3221913625: "IFCCOMMUNICATIONSAPPLIANCE", 400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE", 2542286263: "IFCCOMPLEXPROPERTY", 3875453745: "IFCCOMPLEXPROPERTYTEMPLATE", 3732776249: "IFCCOMPOSITECURVE", 15328376: "IFCCOMPOSITECURVEONSURFACE", 2485617015: "IFCCOMPOSITECURVESEGMENT", 1485152156: "IFCCOMPOSITEPROFILEDEF", 3571504051: "IFCCOMPRESSOR", 3850581409: "IFCCOMPRESSORTYPE", 2272882330: "IFCCONDENSER", 2816379211: "IFCCONDENSERTYPE", 2510884976: "IFCCONIC", 370225590: "IFCCONNECTEDFACESET", 1981873012: "IFCCONNECTIONCURVEGEOMETRY", 2859738748: "IFCCONNECTIONGEOMETRY", 45288368: "IFCCONNECTIONPOINTECCENTRICITY", 2614616156: "IFCCONNECTIONPOINTGEOMETRY", 2732653382: "IFCCONNECTIONSURFACEGEOMETRY", 775493141: "IFCCONNECTIONVOLUMEGEOMETRY", 1959218052: "IFCCONSTRAINT", 3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE", 2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE", 1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE", 4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE", 488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE", 1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE", 2559216714: "IFCCONSTRUCTIONRESOURCE", 2574617495: "IFCCONSTRUCTIONRESOURCETYPE", 3419103109: "IFCCONTEXT", 3050246964: "IFCCONTEXTDEPENDENTUNIT", 3293443760: "IFCCONTROL", 25142252: "IFCCONTROLLER", 578613899: "IFCCONTROLLERTYPE", 2889183280: "IFCCONVERSIONBASEDUNIT", 2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET", 4136498852: "IFCCOOLEDBEAM", 335055490: "IFCCOOLEDBEAMTYPE", 3640358203: "IFCCOOLINGTOWER", 2954562838: "IFCCOOLINGTOWERTYPE", 1785450214: "IFCCOORDINATEOPERATION", 1466758467: "IFCCOORDINATEREFERENCESYSTEM", 3895139033: "IFCCOSTITEM", 1419761937: "IFCCOSTSCHEDULE", 602808272: "IFCCOSTVALUE", 1973544240: "IFCCOVERING", 1916426348: "IFCCOVERINGTYPE", 3295246426: "IFCCREWRESOURCE", 1815067380: "IFCCREWRESOURCETYPE", 2506170314: "IFCCSGPRIMITIVE3D", 2147822146: "IFCCSGSOLID", 539742890: "IFCCURRENCYRELATIONSHIP", 3495092785: "IFCCURTAINWALL", 1457835157: "IFCCURTAINWALLTYPE", 2601014836: "IFCCURVE", 2827736869: "IFCCURVEBOUNDEDPLANE", 2629017746: "IFCCURVEBOUNDEDSURFACE", 1186437898: "IFCCURVESEGMENT2D", 3800577675: "IFCCURVESTYLE", 1105321065: "IFCCURVESTYLEFONT", 2367409068: "IFCCURVESTYLEFONTANDSCALING", 3510044353: "IFCCURVESTYLEFONTPATTERN", 1213902940: "IFCCYLINDRICALSURFACE", 4074379575: "IFCDAMPER", 3961806047: "IFCDAMPERTYPE", 3426335179: "IFCDEEPFOUNDATION", 1306400036: "IFCDEEPFOUNDATIONTYPE", 3632507154: "IFCDERIVEDPROFILEDEF", 1765591967: "IFCDERIVEDUNIT", 1045800335: "IFCDERIVEDUNITELEMENT", 2949456006: "IFCDIMENSIONALEXPONENTS", 32440307: "IFCDIRECTION", 1335981549: "IFCDISCRETEACCESSORY", 2635815018: "IFCDISCRETEACCESSORYTYPE", 1945343521: "IFCDISTANCEEXPRESSION", 1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT", 1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE", 562808652: "IFCDISTRIBUTIONCIRCUIT", 1062813311: "IFCDISTRIBUTIONCONTROLELEMENT", 2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE", 1945004755: "IFCDISTRIBUTIONELEMENT", 3256556792: "IFCDISTRIBUTIONELEMENTTYPE", 3040386961: "IFCDISTRIBUTIONFLOWELEMENT", 3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE", 3041715199: "IFCDISTRIBUTIONPORT", 3205830791: "IFCDISTRIBUTIONSYSTEM", 1154170062: "IFCDOCUMENTINFORMATION", 770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP", 3732053477: "IFCDOCUMENTREFERENCE", 395920057: "IFCDOOR", 2963535650: "IFCDOORLININGPROPERTIES", 1714330368: "IFCDOORPANELPROPERTIES", 3242481149: "IFCDOORSTANDARDCASE", 526551008: "IFCDOORSTYLE", 2323601079: "IFCDOORTYPE", 445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR", 4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT", 342316401: "IFCDUCTFITTING", 869906466: "IFCDUCTFITTINGTYPE", 3518393246: "IFCDUCTSEGMENT", 3760055223: "IFCDUCTSEGMENTTYPE", 1360408905: "IFCDUCTSILENCER", 2030761528: "IFCDUCTSILENCERTYPE", 3900360178: "IFCEDGE", 476780140: "IFCEDGECURVE", 1472233963: "IFCEDGELOOP", 1904799276: "IFCELECTRICAPPLIANCE", 663422040: "IFCELECTRICAPPLIANCETYPE", 862014818: "IFCELECTRICDISTRIBUTIONBOARD", 2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE", 3310460725: "IFCELECTRICFLOWSTORAGEDEVICE", 3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE", 264262732: "IFCELECTRICGENERATOR", 1534661035: "IFCELECTRICGENERATORTYPE", 402227799: "IFCELECTRICMOTOR", 1217240411: "IFCELECTRICMOTORTYPE", 1003880860: "IFCELECTRICTIMECONTROL", 712377611: "IFCELECTRICTIMECONTROLTYPE", 1758889154: "IFCELEMENT", 4123344466: "IFCELEMENTASSEMBLY", 2397081782: "IFCELEMENTASSEMBLYTYPE", 1623761950: "IFCELEMENTCOMPONENT", 2590856083: "IFCELEMENTCOMPONENTTYPE", 1883228015: "IFCELEMENTQUANTITY", 339256511: "IFCELEMENTTYPE", 2777663545: "IFCELEMENTARYSURFACE", 1704287377: "IFCELLIPSE", 2835456948: "IFCELLIPSEPROFILEDEF", 1658829314: "IFCENERGYCONVERSIONDEVICE", 2107101300: "IFCENERGYCONVERSIONDEVICETYPE", 2814081492: "IFCENGINE", 132023988: "IFCENGINETYPE", 3747195512: "IFCEVAPORATIVECOOLER", 3174744832: "IFCEVAPORATIVECOOLERTYPE", 484807127: "IFCEVAPORATOR", 3390157468: "IFCEVAPORATORTYPE", 4148101412: "IFCEVENT", 211053100: "IFCEVENTTIME", 4024345920: "IFCEVENTTYPE", 297599258: "IFCEXTENDEDPROPERTIES", 4294318154: "IFCEXTERNALINFORMATION", 3200245327: "IFCEXTERNALREFERENCE", 1437805879: "IFCEXTERNALREFERENCERELATIONSHIP", 1209101575: "IFCEXTERNALSPATIALELEMENT", 2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT", 2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE", 1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE", 3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT", 477187591: "IFCEXTRUDEDAREASOLID", 2804161546: "IFCEXTRUDEDAREASOLIDTAPERED", 2556980723: "IFCFACE", 2047409740: "IFCFACEBASEDSURFACEMODEL", 1809719519: "IFCFACEBOUND", 803316827: "IFCFACEOUTERBOUND", 3008276851: "IFCFACESURFACE", 807026263: "IFCFACETEDBREP", 3737207727: "IFCFACETEDBREPWITHVOIDS", 24185140: "IFCFACILITY", 1310830890: "IFCFACILITYPART", 4219587988: "IFCFAILURECONNECTIONCONDITION", 3415622556: "IFCFAN", 346874300: "IFCFANTYPE", 647756555: "IFCFASTENER", 2489546625: "IFCFASTENERTYPE", 2827207264: "IFCFEATUREELEMENT", 2143335405: "IFCFEATUREELEMENTADDITION", 1287392070: "IFCFEATUREELEMENTSUBTRACTION", 738692330: "IFCFILLAREASTYLE", 374418227: "IFCFILLAREASTYLEHATCHING", 315944413: "IFCFILLAREASTYLETILES", 819412036: "IFCFILTER", 1810631287: "IFCFILTERTYPE", 1426591983: "IFCFIRESUPPRESSIONTERMINAL", 4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE", 2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID", 2058353004: "IFCFLOWCONTROLLER", 3907093117: "IFCFLOWCONTROLLERTYPE", 4278956645: "IFCFLOWFITTING", 3198132628: "IFCFLOWFITTINGTYPE", 182646315: "IFCFLOWINSTRUMENT", 4037862832: "IFCFLOWINSTRUMENTTYPE", 2188021234: "IFCFLOWMETER", 3815607619: "IFCFLOWMETERTYPE", 3132237377: "IFCFLOWMOVINGDEVICE", 1482959167: "IFCFLOWMOVINGDEVICETYPE", 987401354: "IFCFLOWSEGMENT", 1834744321: "IFCFLOWSEGMENTTYPE", 707683696: "IFCFLOWSTORAGEDEVICE", 1339347760: "IFCFLOWSTORAGEDEVICETYPE", 2223149337: "IFCFLOWTERMINAL", 2297155007: "IFCFLOWTERMINALTYPE", 3508470533: "IFCFLOWTREATMENTDEVICE", 3009222698: "IFCFLOWTREATMENTDEVICETYPE", 900683007: "IFCFOOTING", 1893162501: "IFCFOOTINGTYPE", 263784265: "IFCFURNISHINGELEMENT", 4238390223: "IFCFURNISHINGELEMENTTYPE", 1509553395: "IFCFURNITURE", 1268542332: "IFCFURNITURETYPE", 3493046030: "IFCGEOGRAPHICELEMENT", 4095422895: "IFCGEOGRAPHICELEMENTTYPE", 987898635: "IFCGEOMETRICCURVESET", 3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT", 2453401579: "IFCGEOMETRICREPRESENTATIONITEM", 4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT", 3590301190: "IFCGEOMETRICSET", 3009204131: "IFCGRID", 852622518: "IFCGRIDAXIS", 178086475: "IFCGRIDPLACEMENT", 2706460486: "IFCGROUP", 812098782: "IFCHALFSPACESOLID", 3319311131: "IFCHEATEXCHANGER", 1251058090: "IFCHEATEXCHANGERTYPE", 2068733104: "IFCHUMIDIFIER", 1806887404: "IFCHUMIDIFIERTYPE", 1484403080: "IFCISHAPEPROFILEDEF", 3905492369: "IFCIMAGETEXTURE", 3570813810: "IFCINDEXEDCOLOURMAP", 2571569899: "IFCINDEXEDPOLYCURVE", 178912537: "IFCINDEXEDPOLYGONALFACE", 2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS", 1437953363: "IFCINDEXEDTEXTUREMAP", 2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP", 4175244083: "IFCINTERCEPTOR", 3946677679: "IFCINTERCEPTORTYPE", 3113134337: "IFCINTERSECTIONCURVE", 2391368822: "IFCINVENTORY", 3741457305: "IFCIRREGULARTIMESERIES", 3020489413: "IFCIRREGULARTIMESERIESVALUE", 2176052936: "IFCJUNCTIONBOX", 4288270099: "IFCJUNCTIONBOXTYPE", 572779678: "IFCLSHAPEPROFILEDEF", 3827777499: "IFCLABORRESOURCE", 428585644: "IFCLABORRESOURCETYPE", 1585845231: "IFCLAGTIME", 76236018: "IFCLAMP", 1051575348: "IFCLAMPTYPE", 2655187982: "IFCLIBRARYINFORMATION", 3452421091: "IFCLIBRARYREFERENCE", 4162380809: "IFCLIGHTDISTRIBUTIONDATA", 629592764: "IFCLIGHTFIXTURE", 1161773419: "IFCLIGHTFIXTURETYPE", 1566485204: "IFCLIGHTINTENSITYDISTRIBUTION", 1402838566: "IFCLIGHTSOURCE", 125510826: "IFCLIGHTSOURCEAMBIENT", 2604431987: "IFCLIGHTSOURCEDIRECTIONAL", 4266656042: "IFCLIGHTSOURCEGONIOMETRIC", 1520743889: "IFCLIGHTSOURCEPOSITIONAL", 3422422726: "IFCLIGHTSOURCESPOT", 1281925730: "IFCLINE", 3092502836: "IFCLINESEGMENT2D", 388784114: "IFCLINEARPLACEMENT", 1154579445: "IFCLINEARPOSITIONINGELEMENT", 2624227202: "IFCLOCALPLACEMENT", 1008929658: "IFCLOOP", 1425443689: "IFCMANIFOLDSOLIDBREP", 3057273783: "IFCMAPCONVERSION", 2347385850: "IFCMAPPEDITEM", 1838606355: "IFCMATERIAL", 1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP", 3708119e3: "IFCMATERIALCONSTITUENT", 2852063980: "IFCMATERIALCONSTITUENTSET", 760658860: "IFCMATERIALDEFINITION", 2022407955: "IFCMATERIALDEFINITIONREPRESENTATION", 248100487: "IFCMATERIALLAYER", 3303938423: "IFCMATERIALLAYERSET", 1303795690: "IFCMATERIALLAYERSETUSAGE", 1847252529: "IFCMATERIALLAYERWITHOFFSETS", 2199411900: "IFCMATERIALLIST", 2235152071: "IFCMATERIALPROFILE", 164193824: "IFCMATERIALPROFILESET", 3079605661: "IFCMATERIALPROFILESETUSAGE", 3404854881: "IFCMATERIALPROFILESETUSAGETAPERING", 552965576: "IFCMATERIALPROFILEWITHOFFSETS", 3265635763: "IFCMATERIALPROPERTIES", 853536259: "IFCMATERIALRELATIONSHIP", 1507914824: "IFCMATERIALUSAGEDEFINITION", 2597039031: "IFCMEASUREWITHUNIT", 377706215: "IFCMECHANICALFASTENER", 2108223431: "IFCMECHANICALFASTENERTYPE", 1437502449: "IFCMEDICALDEVICE", 1114901282: "IFCMEDICALDEVICETYPE", 1073191201: "IFCMEMBER", 1911478936: "IFCMEMBERSTANDARDCASE", 3181161470: "IFCMEMBERTYPE", 3368373690: "IFCMETRIC", 2998442950: "IFCMIRROREDPROFILEDEF", 2706619895: "IFCMONETARYUNIT", 2474470126: "IFCMOTORCONNECTION", 977012517: "IFCMOTORCONNECTIONTYPE", 1918398963: "IFCNAMEDUNIT", 3888040117: "IFCOBJECT", 219451334: "IFCOBJECTDEFINITION", 3701648758: "IFCOBJECTPLACEMENT", 2251480897: "IFCOBJECTIVE", 4143007308: "IFCOCCUPANT", 590820931: "IFCOFFSETCURVE", 3388369263: "IFCOFFSETCURVE2D", 3505215534: "IFCOFFSETCURVE3D", 2485787929: "IFCOFFSETCURVEBYDISTANCES", 2665983363: "IFCOPENSHELL", 3588315303: "IFCOPENINGELEMENT", 3079942009: "IFCOPENINGSTANDARDCASE", 4251960020: "IFCORGANIZATION", 1411181986: "IFCORGANIZATIONRELATIONSHIP", 643959842: "IFCORIENTATIONEXPRESSION", 1029017970: "IFCORIENTEDEDGE", 144952367: "IFCOUTERBOUNDARYCURVE", 3694346114: "IFCOUTLET", 2837617999: "IFCOUTLETTYPE", 1207048766: "IFCOWNERHISTORY", 2529465313: "IFCPARAMETERIZEDPROFILEDEF", 2519244187: "IFCPATH", 1682466193: "IFCPCURVE", 2382730787: "IFCPERFORMANCEHISTORY", 3566463478: "IFCPERMEABLECOVERINGPROPERTIES", 3327091369: "IFCPERMIT", 2077209135: "IFCPERSON", 101040310: "IFCPERSONANDORGANIZATION", 3021840470: "IFCPHYSICALCOMPLEXQUANTITY", 2483315170: "IFCPHYSICALQUANTITY", 2226359599: "IFCPHYSICALSIMPLEQUANTITY", 1687234759: "IFCPILE", 1158309216: "IFCPILETYPE", 310824031: "IFCPIPEFITTING", 804291784: "IFCPIPEFITTINGTYPE", 3612865200: "IFCPIPESEGMENT", 4231323485: "IFCPIPESEGMENTTYPE", 597895409: "IFCPIXELTEXTURE", 2004835150: "IFCPLACEMENT", 603570806: "IFCPLANARBOX", 1663979128: "IFCPLANAREXTENT", 220341763: "IFCPLANE", 3171933400: "IFCPLATE", 1156407060: "IFCPLATESTANDARDCASE", 4017108033: "IFCPLATETYPE", 2067069095: "IFCPOINT", 4022376103: "IFCPOINTONCURVE", 1423911732: "IFCPOINTONSURFACE", 2924175390: "IFCPOLYLOOP", 2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE", 2839578677: "IFCPOLYGONALFACESET", 3724593414: "IFCPOLYLINE", 3740093272: "IFCPORT", 1946335990: "IFCPOSITIONINGELEMENT", 3355820592: "IFCPOSTALADDRESS", 759155922: "IFCPREDEFINEDCOLOUR", 2559016684: "IFCPREDEFINEDCURVEFONT", 3727388367: "IFCPREDEFINEDITEM", 3778827333: "IFCPREDEFINEDPROPERTIES", 3967405729: "IFCPREDEFINEDPROPERTYSET", 1775413392: "IFCPREDEFINEDTEXTFONT", 677532197: "IFCPRESENTATIONITEM", 2022622350: "IFCPRESENTATIONLAYERASSIGNMENT", 1304840413: "IFCPRESENTATIONLAYERWITHSTYLE", 3119450353: "IFCPRESENTATIONSTYLE", 2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT", 2744685151: "IFCPROCEDURE", 569719735: "IFCPROCEDURETYPE", 2945172077: "IFCPROCESS", 4208778838: "IFCPRODUCT", 673634403: "IFCPRODUCTDEFINITIONSHAPE", 2095639259: "IFCPRODUCTREPRESENTATION", 3958567839: "IFCPROFILEDEF", 2802850158: "IFCPROFILEPROPERTIES", 103090709: "IFCPROJECT", 653396225: "IFCPROJECTLIBRARY", 2904328755: "IFCPROJECTORDER", 3843373140: "IFCPROJECTEDCRS", 3651124850: "IFCPROJECTIONELEMENT", 2598011224: "IFCPROPERTY", 986844984: "IFCPROPERTYABSTRACTION", 871118103: "IFCPROPERTYBOUNDEDVALUE", 1680319473: "IFCPROPERTYDEFINITION", 148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP", 4166981789: "IFCPROPERTYENUMERATEDVALUE", 3710013099: "IFCPROPERTYENUMERATION", 2752243245: "IFCPROPERTYLISTVALUE", 941946838: "IFCPROPERTYREFERENCEVALUE", 1451395588: "IFCPROPERTYSET", 3357820518: "IFCPROPERTYSETDEFINITION", 492091185: "IFCPROPERTYSETTEMPLATE", 3650150729: "IFCPROPERTYSINGLEVALUE", 110355661: "IFCPROPERTYTABLEVALUE", 3521284610: "IFCPROPERTYTEMPLATE", 1482703590: "IFCPROPERTYTEMPLATEDEFINITION", 738039164: "IFCPROTECTIVEDEVICE", 2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT", 655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE", 1842657554: "IFCPROTECTIVEDEVICETYPE", 3219374653: "IFCPROXY", 90941305: "IFCPUMP", 2250791053: "IFCPUMPTYPE", 2044713172: "IFCQUANTITYAREA", 2093928680: "IFCQUANTITYCOUNT", 931644368: "IFCQUANTITYLENGTH", 2090586900: "IFCQUANTITYSET", 3252649465: "IFCQUANTITYTIME", 2405470396: "IFCQUANTITYVOLUME", 825690147: "IFCQUANTITYWEIGHT", 2262370178: "IFCRAILING", 2893384427: "IFCRAILINGTYPE", 3024970846: "IFCRAMP", 3283111854: "IFCRAMPFLIGHT", 2324767716: "IFCRAMPFLIGHTTYPE", 1469900589: "IFCRAMPTYPE", 1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS", 683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS", 2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF", 3615266464: "IFCRECTANGLEPROFILEDEF", 2798486643: "IFCRECTANGULARPYRAMID", 3454111270: "IFCRECTANGULARTRIMMEDSURFACE", 3915482550: "IFCRECURRENCEPATTERN", 2433181523: "IFCREFERENCE", 4021432810: "IFCREFERENT", 3413951693: "IFCREGULARTIMESERIES", 1580146022: "IFCREINFORCEMENTBARPROPERTIES", 3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES", 979691226: "IFCREINFORCINGBAR", 2572171363: "IFCREINFORCINGBARTYPE", 3027567501: "IFCREINFORCINGELEMENT", 964333572: "IFCREINFORCINGELEMENTTYPE", 2320036040: "IFCREINFORCINGMESH", 2310774935: "IFCREINFORCINGMESHTYPE", 160246688: "IFCRELAGGREGATES", 3939117080: "IFCRELASSIGNS", 1683148259: "IFCRELASSIGNSTOACTOR", 2495723537: "IFCRELASSIGNSTOCONTROL", 1307041759: "IFCRELASSIGNSTOGROUP", 1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR", 4278684876: "IFCRELASSIGNSTOPROCESS", 2857406711: "IFCRELASSIGNSTOPRODUCT", 205026976: "IFCRELASSIGNSTORESOURCE", 1865459582: "IFCRELASSOCIATES", 4095574036: "IFCRELASSOCIATESAPPROVAL", 919958153: "IFCRELASSOCIATESCLASSIFICATION", 2728634034: "IFCRELASSOCIATESCONSTRAINT", 982818633: "IFCRELASSOCIATESDOCUMENT", 3840914261: "IFCRELASSOCIATESLIBRARY", 2655215786: "IFCRELASSOCIATESMATERIAL", 826625072: "IFCRELCONNECTS", 1204542856: "IFCRELCONNECTSELEMENTS", 3945020480: "IFCRELCONNECTSPATHELEMENTS", 4201705270: "IFCRELCONNECTSPORTTOELEMENT", 3190031847: "IFCRELCONNECTSPORTS", 2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY", 1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER", 504942748: "IFCRELCONNECTSWITHECCENTRICITY", 3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS", 3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE", 886880790: "IFCRELCOVERSBLDGELEMENTS", 2802773753: "IFCRELCOVERSSPACES", 2565941209: "IFCRELDECLARES", 2551354335: "IFCRELDECOMPOSES", 693640335: "IFCRELDEFINES", 1462361463: "IFCRELDEFINESBYOBJECT", 4186316022: "IFCRELDEFINESBYPROPERTIES", 307848117: "IFCRELDEFINESBYTEMPLATE", 781010003: "IFCRELDEFINESBYTYPE", 3940055652: "IFCRELFILLSELEMENT", 279856033: "IFCRELFLOWCONTROLELEMENTS", 427948657: "IFCRELINTERFERESELEMENTS", 3268803585: "IFCRELNESTS", 1441486842: "IFCRELPOSITIONS", 750771296: "IFCRELPROJECTSELEMENT", 1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE", 4122056220: "IFCRELSEQUENCE", 366585022: "IFCRELSERVICESBUILDINGS", 3451746338: "IFCRELSPACEBOUNDARY", 3523091289: "IFCRELSPACEBOUNDARY1STLEVEL", 1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL", 1401173127: "IFCRELVOIDSELEMENT", 478536968: "IFCRELATIONSHIP", 816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT", 1076942058: "IFCREPRESENTATION", 3377609919: "IFCREPRESENTATIONCONTEXT", 3008791417: "IFCREPRESENTATIONITEM", 1660063152: "IFCREPRESENTATIONMAP", 2914609552: "IFCRESOURCE", 2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP", 1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP", 2439245199: "IFCRESOURCELEVELRELATIONSHIP", 1042787934: "IFCRESOURCETIME", 1856042241: "IFCREVOLVEDAREASOLID", 3243963512: "IFCREVOLVEDAREASOLIDTAPERED", 4158566097: "IFCRIGHTCIRCULARCONE", 3626867408: "IFCRIGHTCIRCULARCYLINDER", 2016517767: "IFCROOF", 2781568857: "IFCROOFTYPE", 2341007311: "IFCROOT", 2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF", 448429030: "IFCSIUNIT", 3053780830: "IFCSANITARYTERMINAL", 1768891740: "IFCSANITARYTERMINALTYPE", 1054537805: "IFCSCHEDULINGTIME", 2157484638: "IFCSEAMCURVE", 2042790032: "IFCSECTIONPROPERTIES", 4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES", 1862484736: "IFCSECTIONEDSOLID", 1290935644: "IFCSECTIONEDSOLIDHORIZONTAL", 1509187699: "IFCSECTIONEDSPINE", 4086658281: "IFCSENSOR", 1783015770: "IFCSENSORTYPE", 1329646415: "IFCSHADINGDEVICE", 4074543187: "IFCSHADINGDEVICETYPE", 867548509: "IFCSHAPEASPECT", 3982875396: "IFCSHAPEMODEL", 4240577450: "IFCSHAPEREPRESENTATION", 4124623270: "IFCSHELLBASEDSURFACEMODEL", 3692461612: "IFCSIMPLEPROPERTY", 3663146110: "IFCSIMPLEPROPERTYTEMPLATE", 4097777520: "IFCSITE", 1529196076: "IFCSLAB", 3127900445: "IFCSLABELEMENTEDCASE", 3027962421: "IFCSLABSTANDARDCASE", 2533589738: "IFCSLABTYPE", 2609359061: "IFCSLIPPAGECONNECTIONCONDITION", 3420628829: "IFCSOLARDEVICE", 1072016465: "IFCSOLARDEVICETYPE", 723233188: "IFCSOLIDMODEL", 3856911033: "IFCSPACE", 1999602285: "IFCSPACEHEATER", 1305183839: "IFCSPACEHEATERTYPE", 3812236995: "IFCSPACETYPE", 1412071761: "IFCSPATIALELEMENT", 710998568: "IFCSPATIALELEMENTTYPE", 2706606064: "IFCSPATIALSTRUCTUREELEMENT", 3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE", 463610769: "IFCSPATIALZONE", 2481509218: "IFCSPATIALZONETYPE", 451544542: "IFCSPHERE", 4015995234: "IFCSPHERICALSURFACE", 1404847402: "IFCSTACKTERMINAL", 3112655638: "IFCSTACKTERMINALTYPE", 331165859: "IFCSTAIR", 4252922144: "IFCSTAIRFLIGHT", 1039846685: "IFCSTAIRFLIGHTTYPE", 338393293: "IFCSTAIRTYPE", 682877961: "IFCSTRUCTURALACTION", 3544373492: "IFCSTRUCTURALACTIVITY", 2515109513: "IFCSTRUCTURALANALYSISMODEL", 1179482911: "IFCSTRUCTURALCONNECTION", 2273995522: "IFCSTRUCTURALCONNECTIONCONDITION", 1004757350: "IFCSTRUCTURALCURVEACTION", 4243806635: "IFCSTRUCTURALCURVECONNECTION", 214636428: "IFCSTRUCTURALCURVEMEMBER", 2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING", 2757150158: "IFCSTRUCTURALCURVEREACTION", 3136571912: "IFCSTRUCTURALITEM", 1807405624: "IFCSTRUCTURALLINEARACTION", 2162789131: "IFCSTRUCTURALLOAD", 385403989: "IFCSTRUCTURALLOADCASE", 3478079324: "IFCSTRUCTURALLOADCONFIGURATION", 1252848954: "IFCSTRUCTURALLOADGROUP", 1595516126: "IFCSTRUCTURALLOADLINEARFORCE", 609421318: "IFCSTRUCTURALLOADORRESULT", 2668620305: "IFCSTRUCTURALLOADPLANARFORCE", 2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT", 1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION", 1597423693: "IFCSTRUCTURALLOADSINGLEFORCE", 1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING", 2525727697: "IFCSTRUCTURALLOADSTATIC", 3408363356: "IFCSTRUCTURALLOADTEMPERATURE", 530289379: "IFCSTRUCTURALMEMBER", 1621171031: "IFCSTRUCTURALPLANARACTION", 2082059205: "IFCSTRUCTURALPOINTACTION", 734778138: "IFCSTRUCTURALPOINTCONNECTION", 1235345126: "IFCSTRUCTURALPOINTREACTION", 3689010777: "IFCSTRUCTURALREACTION", 2986769608: "IFCSTRUCTURALRESULTGROUP", 3657597509: "IFCSTRUCTURALSURFACEACTION", 1975003073: "IFCSTRUCTURALSURFACECONNECTION", 3979015343: "IFCSTRUCTURALSURFACEMEMBER", 2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING", 603775116: "IFCSTRUCTURALSURFACEREACTION", 2830218821: "IFCSTYLEMODEL", 3958052878: "IFCSTYLEDITEM", 3049322572: "IFCSTYLEDREPRESENTATION", 148013059: "IFCSUBCONTRACTRESOURCE", 4095615324: "IFCSUBCONTRACTRESOURCETYPE", 2233826070: "IFCSUBEDGE", 2513912981: "IFCSURFACE", 699246055: "IFCSURFACECURVE", 2028607225: "IFCSURFACECURVESWEPTAREASOLID", 3101698114: "IFCSURFACEFEATURE", 2809605785: "IFCSURFACEOFLINEAREXTRUSION", 4124788165: "IFCSURFACEOFREVOLUTION", 2934153892: "IFCSURFACEREINFORCEMENTAREA", 1300840506: "IFCSURFACESTYLE", 3303107099: "IFCSURFACESTYLELIGHTING", 1607154358: "IFCSURFACESTYLEREFRACTION", 1878645084: "IFCSURFACESTYLERENDERING", 846575682: "IFCSURFACESTYLESHADING", 1351298697: "IFCSURFACESTYLEWITHTEXTURES", 626085974: "IFCSURFACETEXTURE", 2247615214: "IFCSWEPTAREASOLID", 1260650574: "IFCSWEPTDISKSOLID", 1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL", 230924584: "IFCSWEPTSURFACE", 1162798199: "IFCSWITCHINGDEVICE", 2315554128: "IFCSWITCHINGDEVICETYPE", 2254336722: "IFCSYSTEM", 413509423: "IFCSYSTEMFURNITUREELEMENT", 1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE", 3071757647: "IFCTSHAPEPROFILEDEF", 985171141: "IFCTABLE", 2043862942: "IFCTABLECOLUMN", 531007025: "IFCTABLEROW", 812556717: "IFCTANK", 5716631: "IFCTANKTYPE", 3473067441: "IFCTASK", 1549132990: "IFCTASKTIME", 2771591690: "IFCTASKTIMERECURRING", 3206491090: "IFCTASKTYPE", 912023232: "IFCTELECOMADDRESS", 3824725483: "IFCTENDON", 2347447852: "IFCTENDONANCHOR", 3081323446: "IFCTENDONANCHORTYPE", 3663046924: "IFCTENDONCONDUIT", 2281632017: "IFCTENDONCONDUITTYPE", 2415094496: "IFCTENDONTYPE", 2387106220: "IFCTESSELLATEDFACESET", 901063453: "IFCTESSELLATEDITEM", 4282788508: "IFCTEXTLITERAL", 3124975700: "IFCTEXTLITERALWITHEXTENT", 1447204868: "IFCTEXTSTYLE", 1983826977: "IFCTEXTSTYLEFONTMODEL", 2636378356: "IFCTEXTSTYLEFORDEFINEDFONT", 1640371178: "IFCTEXTSTYLETEXTMODEL", 280115917: "IFCTEXTURECOORDINATE", 1742049831: "IFCTEXTURECOORDINATEGENERATOR", 2552916305: "IFCTEXTUREMAP", 1210645708: "IFCTEXTUREVERTEX", 3611470254: "IFCTEXTUREVERTEXLIST", 1199560280: "IFCTIMEPERIOD", 3101149627: "IFCTIMESERIES", 581633288: "IFCTIMESERIESVALUE", 1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM", 1735638870: "IFCTOPOLOGYREPRESENTATION", 1935646853: "IFCTOROIDALSURFACE", 3825984169: "IFCTRANSFORMER", 1692211062: "IFCTRANSFORMERTYPE", 2595432518: "IFCTRANSITIONCURVESEGMENT2D", 1620046519: "IFCTRANSPORTELEMENT", 2097647324: "IFCTRANSPORTELEMENTTYPE", 2715220739: "IFCTRAPEZIUMPROFILEDEF", 2916149573: "IFCTRIANGULATEDFACESET", 1229763772: "IFCTRIANGULATEDIRREGULARNETWORK", 3593883385: "IFCTRIMMEDCURVE", 3026737570: "IFCTUBEBUNDLE", 1600972822: "IFCTUBEBUNDLETYPE", 1628702193: "IFCTYPEOBJECT", 3736923433: "IFCTYPEPROCESS", 2347495698: "IFCTYPEPRODUCT", 3698973494: "IFCTYPERESOURCE", 427810014: "IFCUSHAPEPROFILEDEF", 180925521: "IFCUNITASSIGNMENT", 630975310: "IFCUNITARYCONTROLELEMENT", 3179687236: "IFCUNITARYCONTROLELEMENTTYPE", 4292641817: "IFCUNITARYEQUIPMENT", 1911125066: "IFCUNITARYEQUIPMENTTYPE", 4207607924: "IFCVALVE", 728799441: "IFCVALVETYPE", 1417489154: "IFCVECTOR", 2799835756: "IFCVERTEX", 2759199220: "IFCVERTEXLOOP", 1907098498: "IFCVERTEXPOINT", 1530820697: "IFCVIBRATIONDAMPER", 3956297820: "IFCVIBRATIONDAMPERTYPE", 2391383451: "IFCVIBRATIONISOLATOR", 3313531582: "IFCVIBRATIONISOLATORTYPE", 2769231204: "IFCVIRTUALELEMENT", 891718957: "IFCVIRTUALGRIDINTERSECTION", 926996030: "IFCVOIDINGFEATURE", 2391406946: "IFCWALL", 4156078855: "IFCWALLELEMENTEDCASE", 3512223829: "IFCWALLSTANDARDCASE", 1898987631: "IFCWALLTYPE", 4237592921: "IFCWASTETERMINAL", 1133259667: "IFCWASTETERMINALTYPE", 3304561284: "IFCWINDOW", 336235671: "IFCWINDOWLININGPROPERTIES", 512836454: "IFCWINDOWPANELPROPERTIES", 486154966: "IFCWINDOWSTANDARDCASE", 1299126871: "IFCWINDOWSTYLE", 4009809668: "IFCWINDOWTYPE", 4088093105: "IFCWORKCALENDAR", 1028945134: "IFCWORKCONTROL", 4218914973: "IFCWORKPLAN", 3342526732: "IFCWORKSCHEDULE", 1236880293: "IFCWORKTIME", 2543172580: "IFCZSHAPEPROFILEDEF", 1033361043: "IFCZONE" }, PropsNames = { aggregates: { name: IFCRELAGGREGATES, relating: "RelatingObject", related: "RelatedObjects", key: "children" }, spatial: { name: IFCRELCONTAINEDINSPATIALSTRUCTURE, relating: "RelatingStructure", related: "RelatedElements", key: "children" }, psets: { name: IFCRELDEFINESBYPROPERTIES, relating: "RelatingPropertyDefinition", related: "RelatedObjects", key: "hasPsets" }, materials: { name: IFCRELASSOCIATESMATERIAL, relating: "RelatingMaterial", related: "RelatedObjects", key: "hasMaterial" }, type: { name: IFCRELDEFINESBYTYPE, relating: "RelatingType", related: "RelatedObjects", key: "hasType" } }, Properties = class { constructor(e) { this.api = e } getIfcType(e) { return IfcTypesMap[e] } getItemProperties(e, t, i = !1) { return __async(this, null, (function* () { return this.api.GetLine(e, t, i) })) } getPropertySets(e, t, i = !1) { return __async(this, null, (function* () { return yield this.getProperty(e, t, i, PropsNames.psets) })) } getTypeProperties(e, t, i = !1) { return __async(this, null, (function* () { return yield this.getProperty(e, t, i, PropsNames.type) })) } getMaterialsProperties(e, t, i = !1) { return __async(this, null, (function* () { return yield this.getProperty(e, t, i, PropsNames.materials) })) } getSpatialStructure(e, t) { return __async(this, null, (function* () { yield this.getAllTypesOfModel(e); var i = yield this.getSpatialTreeChunks(e), s = (yield this.api.GetLineIDsWithType(e, IFCPROJECT)).get(0); s = Properties.newIfcProject(s); return yield this.getSpatialNode(e, s, i, t), this.cleanupTypes(), s })) } getAllItemsOfType(e, t, i) { return __async(this, null, (function* () { var s = [], r = yield this.api.GetLineIDsWithType(e, t); for (let e = 0; e < r.size(); e++)s.push(r.get(e)); if (!i) return s; var a = []; for (let t = 0; t < s.length; t++)a.push(yield this.api.GetLine(e, s[t])); return a })) } getProperty(e, t, i = !1, s) { return __async(this, null, (function* () { var r = yield this.getAllRelatedItemsOfType(e, t, s), a = []; for (let t = 0; t < r.length; t++)a.push(yield this.api.GetLine(e, r[t], i)); return a })) } getChunks(e, t, i) { return __async(this, null, (function* () { var s = yield this.api.GetLineIDsWithType(e, i.name); for (let a = 0; a < s.size(); a++) { var r = yield this.api.GetLine(e, s.get(a), !1); this.saveChunk(t, i, r) } })) } static isRelated(e, t, i) { return t = t[i.related], Array.isArray(t) ? t.map((e => e.value)).includes(e) : t.value === e } static newIfcProject(e) { return { expressID: e, type: "IFCPROJECT", children: [] } } getSpatialNode(e, t, i, s) { return __async(this, null, (function* () { yield this.getChildren(e, t, i, PropsNames.aggregates, s), yield this.getChildren(e, t, i, PropsNames.spatial, s) })) } getChildren(e, t, i, s, r) { return __async(this, null, (function* () { var a = i[t.expressID]; if (null != a) { var o = s.key, n = []; for (let t = 0; t < a.length; t++) { var h = a[t]; let s = this.newNode(h); r && (h = yield this.getItemProperties(e, s.expressID), s = __spreadValues(__spreadValues({}, h), s)), yield this.getSpatialNode(e, s, i, r), n.push(s) } t[o] = n } })) } newNode(e) { return { expressID: e, type: this.getNodeType(e), children: [] } } getNodeType(e) { return e = this.types[e], IfcElements2[e] } getSpatialTreeChunks(e) { return __async(this, null, (function* () { var t = {}; return yield this.getChunks(e, t, PropsNames.aggregates), yield this.getChunks(e, t, PropsNames.spatial), t })) } saveChunk(e, t, i) { var s = i[t.relating].value; i = i[t.related].map((e => e.value)); null == e[s] ? e[s] = i : e[s] = e[s].concat(i) } getRelated(e, t, i) { e = e[t.relating], Array.isArray(e) ? e.forEach((e => i.push(e.value))) : i.push(e.value) } getAllRelatedItemsOfType(e, t, i) { return __async(this, null, (function* () { var s = yield this.api.GetLineIDsWithType(e, i.name), r = []; for (let o = 0; o < s.size(); o++) { var a = yield this.api.GetLine(e, s.get(o)); Properties.isRelated(t, a, i) && this.getRelated(a, i, r) } return r })) } cleanupTypes() { this.types = {} } getAllTypesOfModel(e) { return __async(this, null, (function* () { var t = {}, i = Object.keys(IfcElements2).map((e => parseInt(e))); for (let o = 0; o < i.length; o++) { var s = i[o], r = yield this.api.GetLineIDsWithType(e, s), a = r.size(); for (let e = 0; e < a; e++)t[r.get(e)] = s } this.types = t })) } }, WebIFCWasm = ("undefined" != typeof self && self.crossOriginIsolated ? require_web_ifc_mt : require_web_ifc)(), IfcAPI2 = class { constructor() { this.wasmModule = void 0, this.fs = void 0, this.wasmPath = "", this.isWasmPathAbsolute = !1, this.ifcGuidMap = new Map, this.properties = new Properties(this) } Init(e) { return __async(this, null, (function* () { WebIFCWasm ? (this.wasmModule = yield WebIFCWasm({ noInitialRun: !0, locateFile: e || ((e, t) => e.endsWith(".wasm") ? this.isWasmPathAbsolute ? this.wasmPath + e : t + this.wasmPath + e : t + e) }), this.fs = this.wasmModule.FS) : console.error("Could not find wasm module at './web-ifc' from web-ifc-api.ts") })) } OpenModel(e, t) { t = __spreadValues({ COORDINATE_TO_ORIGIN: !1, USE_FAST_BOOLS: !1, CIRCLE_SEGMENTS_LOW: 5, CIRCLE_SEGMENTS_MEDIUM: 8, CIRCLE_SEGMENTS_HIGH: 12, BOOL_ABORT_THRESHOLD: 1e4 }, t); let i = 0; return this.wasmModule.OpenModel(t, ((t, s) => { var r = Math.min(e.byteLength - i, s); t = this.wasmModule.HEAPU8.subarray(t, t + s), s = e.subarray(i, i + r); return t.set(s), i += r, r })) } CreateModel(e) { return e = __spreadValues({ COORDINATE_TO_ORIGIN: !1, USE_FAST_BOOLS: !1, CIRCLE_SEGMENTS_LOW: 5, CIRCLE_SEGMENTS_MEDIUM: 8, CIRCLE_SEGMENTS_HIGH: 12, BOOL_ABORT_THRESHOLD: 1e4 }, e), this.wasmModule.CreateModel(e) } ExportFileAsIFC(e) { return this.wasmModule.ExportFileAsIFC(e), e = this.fs.readFile("/export.ifc"), this.wasmModule.FS_unlink("/export.ifc"), e } GetGeometry(e, t) { return this.wasmModule.GetGeometry(e, t) } GetLine(e, t, i = !1) { return t = this.GetRawLineData(e, t), t = FromRawLineData[t.type](t), i && this.FlattenLine(e, t), t } GetAndClearErrors(e) { return this.wasmModule.GetAndClearErrors(e) } WriteLine(e, t) { Object.keys(t).forEach((i => { var s = t[i]; if (s && void 0 !== s.expressID) this.WriteLine(e, s), t[i] = { type: 5, value: s.expressID }; else if (Array.isArray(s) && 0 < s.length) for (let r = 0; r < s.length; r++)void 0 !== s[r].expressID && (this.WriteLine(e, s[r]), t[i][r] = { type: 5, value: s[r].expressID }) })); var i = { ID: t.expressID, type: t.type, arguments: t.ToTape() }; this.WriteRawLineData(e, i) } FlattenLine(e, t) { Object.keys(t).forEach((i => { var s = t[i]; if (s && 5 === s.type) t[i] = this.GetLine(e, s.value, !0); else if (Array.isArray(s) && 0 < s.length && 5 === s[0].type) for (let r = 0; r < s.length; r++)t[i][r] = this.GetLine(e, s[r].value, !0) })) } GetRawLineData(e, t) { return this.wasmModule.GetLine(e, t) } WriteRawLineData(e, t) { return this.wasmModule.WriteLine(e, t.ID, t.type, t.arguments) } GetLineIDsWithType(e, t) { return this.wasmModule.GetLineIDsWithType(e, t) } GetAllLines(e) { return this.wasmModule.GetAllLines(e) } SetGeometryTransformation(e, t) { 16 != t.length ? console.log("Bad transformation matrix size: " + t.length) : this.wasmModule.SetGeometryTransformation(e, t) } GetCoordinationMatrix(e) { return this.wasmModule.GetCoordinationMatrix(e) } GetVertexArray(e, t) { return this.getSubArray(this.wasmModule.HEAPF32, e, t) } GetIndexArray(e, t) { return this.getSubArray(this.wasmModule.HEAPU32, e, t) } getSubArray(e, t, i) { return e.subarray(t / 4, t / 4 + i).slice(0) } CloseModel(e) { this.ifcGuidMap.delete(e), this.wasmModule.CloseModel(e) } StreamAllMeshes(e, t) { this.wasmModule.StreamAllMeshes(e, t) } StreamAllMeshesWithTypes(e, t, i) { this.wasmModule.StreamAllMeshesWithTypes(e, t, i) } IsModelOpen(e) { return this.wasmModule.IsModelOpen(e) } LoadAllGeometry(e) { return this.wasmModule.LoadAllGeometry(e) } GetFlatMesh(e, t) { return this.wasmModule.GetFlatMesh(e, t) } CreateIfcGuidToExpressIdMapping(e) { var t = new Map; for (let n = 0; n < IfcElements.length; n++) { var i = IfcElements[n], s = this.GetLineIDsWithType(e, i), r = s.size(); for (let i = 0; i < r; i++) { var a = s.get(i), o = this.GetLine(e, a).GlobalId.value; t.set(a, o), t.set(o, a) } } this.ifcGuidMap.set(e, t) } SetWasmPath(e, t = !1) { this.wasmPath = e, this.isWasmPathAbsolute = t } }; class WebIFCDefaultDataSource { constructor() { } getIFC(e, t, i) { var s = () => { }; if (t = t || s, i = i || s, s = e.match(/^data:(.*?)(;base64)?,(.*)$/)) { var r = !!s[2], a = s[3]; a = window.decodeURIComponent(a); r && (a = window.atob(a)); try { for (var o = new ArrayBuffer(a.length), n = new Uint8Array(o), h = 0; h < a.length; h++)n[h] = a.charCodeAt(h); t(o) } catch (e) { i(e) } } else { const s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onreadystatechange = function () { 4 === s.readyState && (200 === s.status ? t(s.response) : i("getXKT error : " + s.response)) }, s.send(null) } } } class WebIFCLoaderPlugin extends Plugin { constructor(e, t = {}) { super("ifcLoader", e, t), this.dataSource = t.dataSource, this.objectDefaults = t.objectDefaults, this.includeTypes = t.includeTypes, this.excludeTypes = t.excludeTypes, this.excludeUnclassifiedObjects = t.excludeUnclassifiedObjects, this._ifcAPI = new IfcAPI2, t.wasmPath && this._ifcAPI.SetWasmPath(t.wasmPath), this._ifcAPI.Init().then((() => { this.fire("initialized", !0, !1) })).catch((e => { this.error(e) })) } get supportedVersions() { return ["2x3", "4"] } get dataSource() { return this._dataSource } set dataSource(e) { this._dataSource = e || new WebIFCDefaultDataSource } get objectDefaults() { return this._objectDefaults } set objectDefaults(e) { this._objectDefaults = e || IFCObjectDefaults } get includeTypes() { return this._includeTypes } set includeTypes(e) { this._includeTypes = e } get excludeTypes() { return this._excludeTypes } set excludeTypes(e) { this._excludeTypes = e } get excludeUnclassifiedObjects() { return this._excludeUnclassifiedObjects } set excludeUnclassifiedObjects(e) { this._excludeUnclassifiedObjects = !!e } get globalizeObjectIds() { return this._globalizeObjectIds } set globalizeObjectIds(e) { this._globalizeObjectIds = !!e } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); const t = new VBOSceneModel(this.viewer.scene, utils.apply(e, { isModel: !0 })); if (e.src || e.ifc) { const a = { autoNormals: !0 }; if (!1 !== e.loadMetadata) { var i = e.includeTypes || this._includeTypes, s = e.excludeTypes || this._excludeTypes, r = e.objectDefaults || this._objectDefaults; if (i) { a.includeTypesMap = {}; for (let e = 0, t = i.length; e < t; e++)a.includeTypesMap[i[e]] = !0 } if (s) { a.excludeTypesMap = {}; for (let e = 0, t = s.length; e < t; e++)a.excludeTypesMap[s[e]] = !0 } r && (a.objectDefaults = r), a.excludeUnclassifiedObjects = void 0 !== e.excludeUnclassifiedObjects ? !!e.excludeUnclassifiedObjects : this._excludeUnclassifiedObjects, a.globalizeObjectIds = void 0 !== e.globalizeObjectIds ? !!e.globalizeObjectIds : this._globalizeObjectIds } this.on("initialized", (() => { e.src ? this._loadModel(e.src, e, a, t) : this._parseModel(e.ifc, e, a, t) })) } else this.error("load() param expected: src or IFC"); return t } _loadModel(e, t, i, s) { const r = this.viewer.scene.canvas.spinner; r.processes++, this._dataSource.getIFC(t.src, (e => { this._parseModel(e, t, i, s), r.processes-- }), (e => { r.processes--, this.error(e), s.fire("error", e) })) } _parseModel(e, t, i, s) { if (!s.destroyed) { var r = t.stats || {}, a = (e = (r.sourceFormat = "IFC", r.schemaVersion = "", r.title = "", r.author = "", r.created = "", r.numMetaObjects = 0, r.numPropertySets = 0, r.numObjects = 0, r.numGeometries = 0, r.numTriangles = 0, r.numVertices = 0, i.wasmPath && this._ifcAPI.SetWasmPath(i.wasmPath), new Uint8Array(e)), e = this._ifcAPI.OpenModel(e), this._ifcAPI.GetLineIDsWithType(e, IFCPROJECT).get(0)), o = (t = !1 !== t.loadMetadata, { modelID: e, sceneModel: s, loadMetadata: t, metadata: t ? { id: "", projectId: "" + a, author: "", createdAt: "", schema: "", creatingApplication: "", metaObjects: [], propertySets: [] } : null, metaObjects: {}, options: i, log: function (e) { }, nextId: 0, stats: r }); if (t) { if (i.includeTypes) { o.includeTypes = {}; for (let e = 0, t = i.includeTypes.length; e < t; e++)o.includeTypes[i.includeTypes[e]] = !0 } if (i.excludeTypes) { o.excludeTypes = {}; for (let e = 0, t = i.excludeTypes.length; e < t; e++)o.excludeTypes[i.excludeTypes[e]] = !0 } this._parseMetaObjects(o), this._parsePropertySets(o) } this._parseGeometry(o), s.finalize(), t && (e = s.id, this.viewer.metaScene.createMetaModel(e, o.metadata, i)), s.scene.once("tick", (() => { s.destroyed || (s.scene.fire("modelLoaded", s.id), s.fire("loaded", !0, !1)) })) } } _parseMetaObjects(e) { var t = this._ifcAPI.GetLineIDsWithType(e.modelID, IFCPROJECT).get(0); t = this._ifcAPI.GetLine(e.modelID, t); this._parseSpatialChildren(e, t) } _parseSpatialChildren(e, t, i) { var s = t.__proto__.constructor.name; e.includeTypes && !e.includeTypes[s] || e.excludeTypes && e.excludeTypes[s] || (this._createMetaObject(e, t, i), s = t.GlobalId.value, this._parseRelatedItemsOfType(e, t.expressID, "RelatingObject", "RelatedObjects", IFCRELAGGREGATES, s), this._parseRelatedItemsOfType(e, t.expressID, "RelatingStructure", "RelatedElements", IFCRELCONTAINEDINSPATIALSTRUCTURE, s)) } _createMetaObject(e, t, i) { var s = t.GlobalId.value, r = t.__proto__.constructor.name; t = { id: s, name: r, type: t.Name && "" !== t.Name.value ? t.Name.value : r, parent: i }; e.metadata.metaObjects.push(t), e.metaObjects[s] = t, e.stats.numMetaObjects++ } _parseRelatedItemsOfType(e, t, i, s, r, a) { var o = this._ifcAPI.GetLineIDsWithType(e.modelID, r); for (let r = 0; r < o.size(); r++) { var n = o.get(r), h = (n = this._ifcAPI.GetLine(e.modelID, n))[i]; (Array.isArray(h) ? h.map((e => e.value)).includes(t) : h.value === t) && (h = n[s], Array.isArray(h) ? h.forEach((t => { t = this._ifcAPI.GetLine(e.modelID, t.value), this._parseSpatialChildren(e, t, a) })) : (n = this._ifcAPI.GetLine(e.modelID, h.value), this._parseSpatialChildren(e, n, a))) } } _parsePropertySets(e) { var t = this._ifcAPI.GetLineIDsWithType(e.modelID, IFCRELDEFINESBYPROPERTIES); for (let p = 0; p < t.size(); p++) { var i = t.get(p); if ((i = this._ifcAPI.GetLine(e.modelID, i, !0)) && (a = i.RelatingPropertyDefinition)) { var s = a.GlobalId.value, r = a.HasProperties; if (r && 0 < r.length) { var a = a.Name.value, o = []; for (let e = 0, t = r.length; e < t; e++) { var n = r[e], h = n.Name, l = n.NominalValue; h && l && (h = { name: h.value, type: l.type, value: l.value, valueType: l.valueType }, n.Description ? h.description = n.Description.value : l.description && (h.description = l.description), o.push(h)) } e.metadata.propertySets.push({ id: s, type: "Default", name: a, properties: o }), e.stats.numPropertySets++; var c = i.RelatedObjects; if (!c || 0 === c.length) return; for (let t = 0, i = c.length; t < i; t++) { var u = c[t].GlobalId.value; (u = e.metaObjects[u]) && (u.propertySetIds || (u.propertySetIds = []), u.propertySetIds.push(s)) } } } } } _parseGeometry(e) { this._ifcAPI.StreamAllMeshes(e.modelID, (t => { var i = t.expressID, s = t.geometries, r = []; t = this._ifcAPI.GetLine(e.modelID, i).GlobalId.value; if (e.loadMetadata) { if (i = e.metaObjects[t], e.includeTypes && (!i || !e.includeTypes[i.type])) return; if (e.excludeTypes && (!i || e.excludeTypes[i.type])) return } var a = math.mat4(), o = math.vec3(); for (let t = 0, i = s.size(); t < i; t++) { var n = s.get(t), h = this._ifcAPI.GetGeometry(e.modelID, n.geometryExpressID), l = this._ifcAPI.GetVertexArray(h.GetVertexData(), h.GetVertexDataSize()), c = (h = this._ifcAPI.GetIndexArray(h.GetIndexData(), h.GetIndexDataSize()), new Float64Array(l.length / 2)), u = new Float32Array(l.length / 2); for (let e = 0, t = 0, i = l.length / 6; e < i; e++, t += 3)c[t + 0] = l[6 * e + 0], c[t + 1] = l[6 * e + 1], c[t + 2] = l[6 * e + 2]; a.set(n.flatTransformation), math.transformPositions3(a, c); var p = worldToRTCPositions(c, c, o); if (!e.options.autoNormals) for (let e = 0, t = 0, i = l.length / 6; e < i; e++, t += 3)u[t + 0] = l[6 * e + 3], u[t + 1] = l[6 * e + 4], u[t + 2] = l[6 * e + 5]; e.stats.numGeometries++, e.stats.numVertices += c.length / 3, e.stats.numTriangles += h.length / 3; var d = "mesh" + e.nextId++; e.sceneModel.createMesh({ id: d, primitive: "triangles", origin: p ? o : null, positions: c, normals: e.options.autoNormals ? null : u, indices: h, color: [n.color.x, n.color.y, n.color.z], opacity: n.color.w }), r.push(d) } i = e.options.globalizeObjectIds ? math.globalizeObjectId(e.sceneModel.id, t) : t, e.sceneModel.createEntity({ id: i, meshIds: r, isObject: !0 }), e.stats.numObjects++ })) } } class LASDefaultDataSource { constructor() { } getLAS(e, t, i) { var s = () => { }; if (t = t || s, i = i || s, s = e.match(/^data:(.*?)(;base64)?,(.*)$/)) { var r = !!s[2], a = s[3]; a = window.decodeURIComponent(a); r && (a = window.atob(a)); try { for (var o = new ArrayBuffer(a.length), n = new Uint8Array(o), h = 0; h < a.length; h++)n[h] = a.charCodeAt(h); t(o) } catch (e) { i(e) } } else { const s = new XMLHttpRequest; s.open("GET", e, !0), s.responseType = "arraybuffer", s.onreadystatechange = function () { 4 === s.readyState && (200 === s.status ? t(s.response) : i("getXKT error : " + s.response)) }, s.send(null) } } } const VERSION = "3.2.6", DEFAULT_LAS_OPTIONS = { las: { shape: "mesh", fp64: !1, skip: 1, colorDepth: 8 } }, LASLoader = { name: "LAS", id: "las", module: "las", version: "3.2.6", worker: !0, extensions: ["las", "laz"], mimeTypes: ["application/octet-stream"], text: !0, binary: !0, tests: ["LAS"], options: DEFAULT_LAS_OPTIONS }; class LASLoaderPlugin extends Plugin { constructor(e, t = {}) { super("lasLoader", e, t), this.dataSource = t.dataSource, this.skip = t.skip, this.fp64 = t.fp64, this.colorDepth = t.colorDepth } get dataSource() { return this._dataSource } set dataSource(e) { this._dataSource = e || new LASDefaultDataSource } get skip() { return this._skip } set skip(e) { this._skip = e || 1 } get fp64() { return this._fp64 } set fp64(e) { this._fp64 = !!e } get colorDepth() { return this._colorDepth } set colorDepth(e) { this._colorDepth = e || "auto" } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); const t = new VBOSceneModel(this.viewer.scene, utils.apply(e, { isModel: !0 })); if (e.src || e.las) { var i = { las: { skip: this._skip, fp64: this._fp64, colorDepth: this._colorDepth } }; if (e.src) this._loadModel(e.src, e, i, t); else { const s = this.viewer.scene.canvas.spinner; s.processes++, this._parseModel(e.las, e, i, t).then((() => { s.processes-- }), (e => { s.processes--, this.error(e), t.fire("error", e) })) } } else this.error("load() param expected: src or las"); return t } _loadModel(e, t, i, s) { const r = this.viewer.scene.canvas.spinner; r.processes++, this._dataSource.getLAS(t.src, (e => { this._parseModel(e, t, i, s).then((() => { r.processes-- }), (e => { r.processes--, this.error(e), s.fire("error", e) })) }), (e => { r.processes--, this.error(e), s.fire("error", e) })) } _parseModel(e, t, i, s) { function r(e) { var i = e.value; if (t.rotateX && i) for (let e = 0, t = i.length; e < t; e += 3) { var s = i[e + 1]; i[e + 1] = i[e + 2], i[e + 2] = s } return i } function a(e) { var t = e.intensity, i = (e = 4 * t.length, new Uint8Array(e)); for (let e = 0, s = 0, r = t.length; e < r; e++, s += 4)i[s + 0] = 0, i[s + 1] = 0, i[s + 2] = 0, i[s + 3] = Math.round(t[e] / 65536 * 255); return i } return new Promise(((o, n) => { if (s.destroyed) n(); else { var h = t.stats || {}; h.sourceFormat = "LAS", h.schemaVersion = "", h.title = "", h.author = "", h.created = "", h.numMetaObjects = 0, h.numPropertySets = 0, h.numObjects = 0, h.numGeometries = 0, h.numTriangles = 0, h.numVertices = 0; try { parse$3(e, LASLoader, i).then((e => { var h = e.attributes; e = void 0 !== (e = e.loaderData).pointsFormatId ? e.pointsFormatId : -1; if (h.POSITION) { let u, p; switch (e) { case 0: u = r(h.POSITION), p = a(h.intensity); break; case 1: if (!h.intensity) return s.finalize(), void n("No positions found in file"); u = r(h.POSITION), p = a(h.intensity); break; case 2: case 3: if (!h.intensity) return s.finalize(), void n("No positions found in file"); u = r(h.POSITION), p = function (e, t) { var i = e.value, s = e.size, r = t.value, a = (e = 4 * r.length, new Uint8Array(e)); for (let e = 0, t = 0, o = 0, n = r.length; e < n; e++, o += s, t += 4)a[t + 0] = i[o + 0], a[t + 1] = i[o + 1], a[t + 2] = i[o + 2], a[t + 3] = Math.round(r[e] / 65536 * 255); return a }(h.COLOR_0, h.intensity) }s.createMesh({ id: "pointsMesh", primitive: "points", positions: u, colorsCompressed: p }); var l, c; e = math.createUUID(); s.createEntity({ id: e, meshIds: ["pointsMesh"], isObject: !0 }), s.finalize(), !1 !== t.loadMetadata && (l = math.createUUID(), c = s.id, this.viewer.metaScene.createMetaModel(c, { projectId: "", author: "", createdAt: "", schema: "", creatingApplication: "", metaObjects: [{ id: l, name: "Model", type: "Model" }, { id: e, name: "PointCloud (LAS)", type: "PointCloud", parent: l }], propertySets: [] }, i)), s.scene.once("tick", (() => { s.destroyed || (s.scene.fire("modelLoaded", s.id), s.fire("loaded", !0, !1)) })), o() } else s.finalize(), n("No positions found in file") })) } catch (h) { s.finalize(), n(h) } } })) } } class CityJSONDefaultDataSource { constructor() { } getCityJSON(e, t, i) { utils.loadJSON(e, (e => { t(e) }), (function (e) { i(e) })) } } function earcut(e, t, i) { i = i || 2; var s, r, a, o, n, h = t && t.length, l = h ? t[0] * i : e.length, c = linkedList(e, 0, l, i, !0), u = []; if (c && c.next !== c.prev) { if (h && (c = eliminateHoles(e, t, c, i)), e.length > 80 * i) { for (var p = s = e[0], d = r = e[1], m = i; m < l; m += i)(a = e[m]) < p && (p = a), (o = e[m + 1]) < d && (d = o), s < a && (s = a), r < o && (r = o); n = 0 !== (n = Math.max(s - p, r - d)) ? 1 / n : 0 } earcutLinked(c, u, i, p, d, n) } return u } function linkedList(e, t, i, s, r) { var a, o; if (r === 0 < signedArea(e, t, i, s)) for (a = t; a < i; a += s)o = insertNode(a, e[a], e[a + 1], o); else for (a = i - s; t <= a; a -= s)o = insertNode(a, e[a], e[a + 1], o); return o && equals(o, o.next) && (removeNode(o), o = o.next), o } function filterPoints(e, t) { if (!e) return e; t = t || e; var i, s = e; do { if (i = !1, s.steiner || !equals(s, s.next) && 0 !== area(s.prev, s, s.next)) s = s.next; else { if (removeNode(s), (s = t = s.prev) === s.next) break; i = !0 } } while (i || s !== t); return t } function earcutLinked(e, t, i, s, r, a, o) { if (e) { !o && a && indexCurve(e, s, r, a); for (var n, h, l = e; e.prev !== e.next;)if (n = e.prev, h = e.next, a ? isEarHashed(e, s, r, a) : isEar(e)) t.push(n.i / i), t.push(e.i / i), t.push(h.i / i), removeNode(e), e = h.next, l = h.next; else if ((e = h) === l) { o ? 1 === o ? earcutLinked(e = cureLocalIntersections(filterPoints(e), t, i), t, i, s, r, a, 2) : 2 === o && splitEarcut(e, t, i, s, r, a) : earcutLinked(filterPoints(e), t, i, s, r, a, 1); break } } } function isEar(e) { var t = e.prev, i = e, s = e.next; if (0 <= area(t, i, s)) return !1; for (var r = e.next.next; r !== e.prev;) { if (pointInTriangle(t.x, t.y, i.x, i.y, s.x, s.y, r.x, r.y) && 0 <= area(r.prev, r, r.next)) return !1; r = r.next } return !0 } function isEarHashed(e, t, i, s) { var r = e.prev, a = e, o = e.next; if (0 <= area(r, a, o)) return !1; for (var n = (r.x < a.x ? r.x < o.x ? r : o : a.x < o.x ? a : o).x, h = (r.y < a.y ? r.y < o.y ? r : o : a.y < o.y ? a : o).y, l = (r.x > a.x ? r.x > o.x ? r : o : a.x > o.x ? a : o).x, c = (r.y > a.y ? r.y > o.y ? r : o : a.y > o.y ? a : o).y, u = zOrder(n, h, t, i, s), p = zOrder(l, c, t, i, s), d = e.prevZ, m = e.nextZ; d && d.z >= u && m && m.z <= p;) { if (d !== e.prev && d !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= area(d.prev, d, d.next)) return !1; if (d = d.prevZ, m !== e.prev && m !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, m.x, m.y) && 0 <= area(m.prev, m, m.next)) return !1; m = m.nextZ } for (; d && d.z >= u;) { if (d !== e.prev && d !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= area(d.prev, d, d.next)) return !1; d = d.prevZ } for (; m && m.z <= p;) { if (m !== e.prev && m !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, m.x, m.y) && 0 <= area(m.prev, m, m.next)) return !1; m = m.nextZ } return !0 } function cureLocalIntersections(e, t, i) { var s = e; do { var r = s.prev, a = s.next.next } while (!equals(r, a) && intersects(r, s, s.next, a) && locallyInside(r, a) && locallyInside(a, r) && (t.push(r.i / i), t.push(s.i / i), t.push(a.i / i), removeNode(s), removeNode(s.next), s = e = a), (s = s.next) !== e); return filterPoints(s) } function splitEarcut(e, t, i, s, r, a) { var o = e; do { for (var n, h = o.next.next; h !== o.prev;) { if (o.i !== h.i && isValidDiagonal(o, h)) return n = splitPolygon(o, h), o = filterPoints(o, o.next), n = filterPoints(n, n.next), earcutLinked(o, t, i, s, r, a), void earcutLinked(n, t, i, s, r, a); h = h.next } } while ((o = o.next) !== e) } function eliminateHoles(e, t, i, s) { for (var r, a = [], o = 0, n = t.length; o < n; o++)(r = linkedList(e, t[o] * s, o < n - 1 ? t[o + 1] * s : e.length, s, !1)) === r.next && (r.steiner = !0), a.push(getLeftmost(r)); for (a.sort(compareX), o = 0; o < a.length; o++)eliminateHole(a[o], i), i = filterPoints(i, i.next); return i } function compareX(e, t) { return e.x - t.x } function eliminateHole(e, t) { (t = findHoleBridge(e, t)) && (e = splitPolygon(t, e), filterPoints(t, t.next), filterPoints(e, e.next)) } function findHoleBridge(e, t) { var i, s = t, r = e.x, a = e.y, o = -1 / 0; do { if (a <= s.y && a >= s.next.y && s.next.y !== s.y) { var n = s.x + (a - s.y) * (s.next.x - s.x) / (s.next.y - s.y); if (n <= r && o < n) { if ((o = n) === r) { if (a === s.y) return s; if (a === s.next.y) return s.next } i = s.x < s.next.x ? s : s.next } } } while ((s = s.next) !== t); if (!i) return null; if (r !== o) { var h, l = i, c = i.x, u = i.y, p = 1 / 0; for (s = i; r >= s.x && s.x >= c && r !== s.x && pointInTriangle(a < u ? r : o, a, c, u, a < u ? o : r, a, s.x, s.y) && (h = Math.abs(a - s.y) / (r - s.x), locallyInside(s, e)) && (h < p || h === p && (s.x > i.x || s.x === i.x && sectorContainsSector(i, s))) && (i = s, p = h), (s = s.next) !== l;); } return i } function sectorContainsSector(e, t) { return area(e.prev, e, t.prev) < 0 && area(t.next, e, e.next) < 0 } function indexCurve(e, t, i, s) { for (var r = e; null === r.z && (r.z = zOrder(r.x, r.y, t, i, s)), r.prevZ = r.prev, r.nextZ = r.next, (r = r.next) !== e;); r.prevZ.nextZ = null, r.prevZ = null, sortLinked(r) } function sortLinked(e) { var t, i, s, r, a, o, n, h, l = 1; do { for (i = e, a = e = null, o = 0; i;) { for (o++, s = i, t = n = 0; t < l && (n++, s = s.nextZ); t++); for (h = l; 0 < n || 0 < h && s;)0 !== n && (0 === h || !s || i.z <= s.z) ? (i = (r = i).nextZ, n--) : (s = (r = s).nextZ, h--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r; i = s } } while (a.nextZ = null, l *= 2, 1 < o); return e } function zOrder(e, t, i, s, r) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - s) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function getLeftmost(e) { for (var t = e, i = e; (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), (t = t.next) !== e;); return i } function pointInTriangle(e, t, i, s, r, a, o, n) { return 0 <= (r - o) * (t - n) - (e - o) * (a - n) && 0 <= (e - o) * (s - n) - (i - o) * (t - n) && 0 <= (i - o) * (a - n) - (r - o) * (s - n) } function isValidDiagonal(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !intersectsPolygon(e, t) && (locallyInside(e, t) && locallyInside(t, e) && middleInside(e, t) && (area(e.prev, e, t.prev) || area(e, t.prev, t)) || equals(e, t) && 0 < area(e.prev, e, e.next) && 0 < area(t.prev, t, t.next)) } function area(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) } function equals(e, t) { return e.x === t.x && e.y === t.y } function intersects(e, t, i, s) { var r = sign(area(e, t, i)), a = sign(area(e, t, s)), o = sign(area(i, s, e)), n = sign(area(i, s, t)); return r !== a && o !== n || !!(0 === r && onSegment(e, i, t) || 0 === a && onSegment(e, s, t) || 0 === o && onSegment(i, e, s) || 0 === n && onSegment(i, t, s)) } function onSegment(e, t, i) { return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y) } function sign(e) { return 0 < e ? 1 : e < 0 ? -1 : 0 } function intersectsPolygon(e, t) { var i = e; do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && intersects(i, i.next, e, t)) return !0 } while ((i = i.next) !== e); return !1 } function locallyInside(e, t) { return area(e.prev, e, e.next) < 0 ? 0 <= area(e, t, e.next) && 0 <= area(e, e.prev, t) : area(e, t, e.prev) < 0 || area(e, e.next, t) < 0 } function middleInside(e, t) { for (var i = e, s = !1, r = (e.x + t.x) / 2, a = (e.y + t.y) / 2; i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (s = !s), (i = i.next) !== e;); return s } function splitPolygon(e, t) { var i = new Node(e.i, e.x, e.y), s = new Node(t.i, t.x, t.y), r = e.next, a = t.prev; return (e.next = t).prev = e, (i.next = r).prev = i, (s.next = i).prev = s, (a.next = s).prev = a, s } function insertNode(e, t, i, s) { return e = new Node(e, t, i), s ? (e.next = s.next, (e.prev = s).next.prev = e, s.next = e) : (e.prev = e).next = e, e } function removeNode(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function Node(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function signedArea(e, t, i, s) { for (var r = 0, a = t, o = i - s; a < i; a += s)r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a; return r } earcut.deviation = function (e, t, i, s) { var r = t && t.length, a = r ? t[0] * i : e.length, o = Math.abs(signedArea(e, 0, a, i)); if (r) for (var n = 0, h = t.length; n < h; n++) { var l = t[n] * i, c = n < h - 1 ? t[n + 1] * i : e.length; o -= Math.abs(signedArea(e, l, c, i)) } var u = 0; for (n = 0; n < s.length; n += 3) { var p = s[n] * i, d = s[n + 1] * i, m = s[n + 2] * i; u += Math.abs((e[p] - e[m]) * (e[1 + d] - e[1 + p]) - (e[p] - e[d]) * (e[1 + m] - e[1 + p])) } return 0 === o && 0 === u ? 0 : Math.abs((u - o) / o) }, earcut.flatten = function (e) { for (var t = e[0][0].length, i = { vertices: [], holes: [], dimensions: t }, s = 0, r = 0; r < e.length; r++) { for (var a = 0; a < e[r].length; a++)for (var o = 0; o < t; o++)i.vertices.push(e[r][a][o]); 0 < r && (s += e[r - 1].length, i.holes.push(s)) } return i }; const tempVec2a = math.vec2(), tempVec3a = math.vec3(), tempVec3b = math.vec3(), tempVec3c = math.vec3(); class CityJSONLoaderPlugin extends Plugin { constructor(e, t = {}) { super("cityJSONLoader", e, t), this.dataSource = t.dataSource } get dataSource() { return this._dataSource } set dataSource(e) { this._dataSource = e || new CityJSONDefaultDataSource } load(e = {}) { e.id && this.viewer.scene.components[e.id] && (this.error("Component with this ID already exists in viewer: " + e.id + " - will autogenerate this ID"), delete e.id); var t, i, s = new VBOSceneModel(this.viewer.scene, utils.apply(e, { isModel: !0 })); return e.src || e.cityJSON ? (t = {}, e.src ? this._loadModel(e.src, e, t, s) : ((i = this.viewer.scene.canvas.spinner).processes++, this._parseModel(e.cityJSON, e, t, s), i.processes--)) : this.error("load() param expected: src or cityJSON"), s } _loadModel(e, t, i, s) { const r = this.viewer.scene.canvas.spinner; r.processes++, this._dataSource.getCityJSON(t.src, (e => { this._parseModel(e, t, i, s), r.processes-- }), (e => { r.processes--, this.error(e), s.fire("error", e) })) } _parseModel(e, t, i, s) { var r, a, o, n; s.destroyed || (n = e.transform ? this._transformVertices(e.vertices, e.transform, i.rotateX) : e.vertices, (r = t.stats || {}).sourceFormat = e.type || "CityJSON", r.schemaVersion = e.version || "", r.title = "", r.author = "", r.created = "", r.numMetaObjects = 0, r.numPropertySets = 0, r.numObjects = 0, r.numGeometries = 0, r.numTriangles = 0, r.numVertices = 0, a = (t = !1 !== t.loadMetadata) ? { id: math.createUUID(), name: "Model", type: "Model" } : null, o = t ? { id: "", projectId: "", author: "", createdAt: "", schema: e.version || "", creatingApplication: "", metaObjects: [a], propertySets: [] } : null, this._parseCityJSON(e = { data: e, vertices: n, sceneModel: s, loadMetadata: t, metadata: o, rootMetaObject: a, nextId: 0, stats: r }), s.finalize(), t && (n = s.id, this.viewer.metaScene.createMetaModel(n, e.metadata, i)), s.scene.once("tick", (() => { s.destroyed || (s.scene.fire("modelLoaded", s.id), s.fire("loaded", !0, !1)) }))) } _transformVertices(e, t, i) { var s = [], r = t.scale || math.vec3([1, 1, 1]), a = t.translate || math.vec3([0, 0, 0]); for (let t = 0, l = 0; t < e.length; t++, l += 3) { var o = e[t][0] * r[0] + a[0], n = e[t][1] * r[1] + a[1], h = e[t][2] * r[2] + a[2]; s.push(i ? [o, h, n] : [o, n, h]) } return s } _parseCityJSON(e) { var t, i = e.data.CityObjects; for (const s in i) i.hasOwnProperty(s) && (t = i[s], this._parseCityObject(e, t, s)) } _parseCityObject(e, t, i) { var s, r, a = e.sceneModel, o = e.data; if (e.loadMetadata && (s = t.type, r = t.parents ? t.parents[0] : e.rootMetaObject.id, e.metadata.metaObjects.push({ id: i, name: s + " : " + i, type: s, parent: r })), e.stats.numMetaObjects++, t.geometry && 0 < t.geometry.length) { var n = []; for (let i = 0, s = t.geometry.length; i < s; i++) { var h = t.geometry[i]; let s, r; var l = o.appearance; if (l) { var c = l.materials; if (c && (l = h.material)) { var u = Object.keys(l); if (0 < u.length) if (void 0 !== (l = l[u[0]]).value) s = c[l.value]; else { var p = l.values; if (p) { r = []; for (let e = 0, t = p.length; e < t; e++) { var d = c[p[i]]; r.push(d) } } } } } r ? this._parseGeometrySurfacesWithOwnMaterials(e, h, r, n) : this._parseGeometrySurfacesWithSharedMaterial(e, h, s, n) } 0 < n.length && (a.createEntity({ id: i, meshIds: n, isObject: !0 }), e.stats.numObjects++) } } _parseGeometrySurfacesWithOwnMaterials(e, t, i, s) { switch (t.type) { case "MultiPoint": case "MultiLineString": break; case "MultiSurface": case "CompositeSurface": var r = t.boundaries; this._parseSurfacesWithOwnMaterials(e, i, r, s); break; case "Solid": var a = t.boundaries; for (let t = 0; t < a.length; t++) { var o = a[t]; this._parseSurfacesWithOwnMaterials(e, i, o, s) } break; case "MultiSolid": case "CompositeSolid": var n = t.boundaries; for (let t = 0; t < n.length; t++)for (let r = 0; r < n[t].length; r++) { var h = n[t][r]; this._parseSurfacesWithOwnMaterials(e, i, h, s) } } } _parseSurfacesWithOwnMaterials(e, t, i, s) { var r = e.vertices, a = e.sceneModel; for (let v = 0; v < i.length; v++) { var o = i[v], n = t[v] || { diffuseColor: [.8, .8, .8], transparency: 1 }, h = [], l = [], c = [], u = { positions: [], indices: [] }; for (let t = 0; t < o.length; t++) { 0 < h.length && l.push(h.length); var p = this._extractLocalIndices(e, o[t], c, u); h.push(...p) } if (3 === h.length) u.indices.push(h[0]), u.indices.push(h[1]), u.indices.push(h[2]); else if (3 < h.length) { var d = []; for (let e = 0; e < h.length; e++)d.push({ x: r[c[h[e]]][0], y: r[c[h[e]]][1], z: r[c[h[e]]][2] }); var m = this._getNormalOfPositions(d, math.vec3()), f = []; for (let e = 0; e < d.length; e++)this._to2D(d[e], m, tempVec2a), f.unshift(tempVec2a[0]), f.unshift(tempVec2a[1]); var g = earcut(f, l, 2); for (let e = 0; e < g.length; e += 3)u.indices.unshift(h[g[e]]), u.indices.unshift(h[g[e + 1]]), u.indices.unshift(h[g[e + 2]]) } var _ = "" + e.nextId++; a.createMesh({ id: _, primitive: "triangles", positions: u.positions, indices: u.indices, color: n && n.diffuseColor ? n.diffuseColor : [.8, .8, .8], opacity: n && void 0 !== n.transparency ? 1 - n.transparency : 1 }), s.push(_), e.stats.numGeometries++, e.stats.numVertices += u.positions.length / 3, e.stats.numTriangles += u.indices.length / 3 } } _parseGeometrySurfacesWithSharedMaterial(e, t, i, s) { var r, a = e.sceneModel, o = [], n = { positions: [], indices: [] }; switch (t.type) { case "MultiPoint": case "MultiLineString": break; case "MultiSurface": case "CompositeSurface": var h = t.boundaries; this._parseSurfacesWithSharedMaterial(e, h, o, n); break; case "Solid": var l = t.boundaries; for (let t = 0; t < l.length; t++) { var c = l[t]; this._parseSurfacesWithSharedMaterial(e, c, o, n) } break; case "MultiSolid": case "CompositeSolid": var u = t.boundaries; for (let t = 0; t < u.length; t++)for (let i = 0; i < u[t].length; i++) { var p = u[t][i]; this._parseSurfacesWithSharedMaterial(e, p, o, n) } }0 < n.positions.length && 0 < n.indices.length && (r = "" + e.nextId++, a.createMesh({ id: r, primitive: "triangles", positions: n.positions, indices: n.indices, color: i && i.diffuseColor ? i.diffuseColor : [.8, .8, .8], opacity: 1 }), s.push(r), e.stats.numGeometries++, e.stats.numVertices += n.positions.length / 3, e.stats.numTriangles += n.indices.length / 3) } _parseSurfacesWithSharedMaterial(e, t, i, s) { var r = e.vertices; for (let p = 0; p < t.length; p++) { var a = [], o = []; for (let r = 0; r < t[p].length; r++) { 0 < a.length && o.push(a.length); var n = this._extractLocalIndices(e, t[p][r], i, s); a.push(...n) } if (3 === a.length) s.indices.push(a[0]), s.indices.push(a[1]), s.indices.push(a[2]); else if (3 < a.length) { var h = []; for (let e = 0; e < a.length; e++)h.push({ x: r[i[a[e]]][0], y: r[i[a[e]]][1], z: r[i[a[e]]][2] }); var l = this._getNormalOfPositions(h, math.vec3()), c = []; for (let e = 0; e < h.length; e++)this._to2D(h[e], l, tempVec2a), c.unshift(tempVec2a[0]), c.unshift(tempVec2a[1]); var u = earcut(c, o, 2); for (let e = 0; e < u.length; e += 3)s.indices.unshift(a[u[e]]), s.indices.unshift(a[u[e + 1]]), s.indices.unshift(a[u[e + 2]]) } } } _extractLocalIndices(e, t, i, s) { var r = e.vertices, a = []; for (let e = 0, h = t.length; e < h; e++) { var o, n = t[e]; i.includes(n) ? (o = i.indexOf(n), a.push(o)) : (s.positions.push(r[n][0]), s.positions.push(r[n][1]), s.positions.push(r[n][2]), a.push(i.length), i.push(n)) } return a } _getNormalOfPositions(e, t) { for (let i = 0; i < e.length; i++) { let s = i + 1; s === e.length && (s = 0), t[0] += (e[i].y - e[s].y) * (e[i].z + e[s].z), t[1] += (e[i].z - e[s].z) * (e[i].x + e[s].x), t[2] += (e[i].x - e[s].x) * (e[i].y + e[s].y) } return math.normalizeVec3(t) } _to2D(e, t, i) { var s = tempVec3a, r = tempVec3b, a = tempVec3c; s[0] = e.x, s[1] = e.y, s[2] = e.z, r[0] = t.x, r[1] = t.y, r[2] = t.z, a[0] = 1.1, a[1] = 1.1, a[2] = 1.1, (e = math.lenVec3(math.subVec3(a, r))) < .01 && (a[0] += 1, a[1] += 2, a[2] += 3), t = math.dotVec3(a, r), e = math.mulVec3Scalar(r, t, math.vec3()), a[0] -= e[0], a[1] -= e[1], a[2] -= e[2], math.normalizeVec3(a), t = math.cross3Vec3(r, a, math.vec3()), e = math.dotVec3(s, a), r = math.dotVec3(s, t), i[0] = e, i[1] = r } } 

export { AlphaFormat, AmbientLight, AngleMeasurementsPlugin, AnnotationsPlugin, AxisGizmoPlugin, BCFViewpointsPlugin, Bitmap, ByteType, CameraMemento, CameraPath, CameraPathAnimation, CityJSONLoaderPlugin, ClampToEdgeWrapping, Component, CompressedMediaType, Configs, ContextMenu, CubicBezierCurve, Curve, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DirLight, DistanceMeasurementsPlugin, EdgeMaterial, EmphasisMaterial, FastNavPlugin, FloatType, Fresnel, GIFMediaType, GLTFDefaultDataSource, GLTFLoaderPlugin, HalfFloatType, ImagePlane, IntType, JPEGMediaType, KTX2TextureTranscoder, LASLoaderPlugin, LambertMaterial, LightMap, LineSet, LinearEncoding, LinearFilter, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, Loader, LoadingManager, LocaleService, LuminanceAlphaFormat, LuminanceFormat, Map$1 as Map, Marker, Mesh, MetallicMaterial, MirroredRepeatWrapping, ModelMemento, NavCubePlugin, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, Node$1 as Node, OBJLoaderPlugin, ObjectsMemento, PNGMediaType, Path, PerformanceModel, PhongMaterial, Plugin, PointLight, QuadraticBezierCurve, Queue, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, ReadableGeometry, RedFormat, RedIntegerFormat, ReflectionMap, RepeatWrapping, STLDefaultDataSource, STLLoaderPlugin, SceneModel, SectionPlane, SectionPlanesPlugin, ShortType, Skybox, SkyboxesPlugin, SpecularMaterial, SplineCurve, SpriteMarker, StoreyViewsPlugin, Texture, TextureTranscoder, TreeViewPlugin, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VBOGeometry, VBOSceneModel, ViewCullPlugin, Viewer, WebIFCLoaderPlugin, WorkerPool$1 as WorkerPool, XKTDefaultDataSource, XKTLoaderPlugin, XML3DLoaderPlugin, buildBoxGeometry, buildBoxLinesGeometry, buildCylinderGeometry, buildGridGeometry, buildPlaneGeometry, buildSphereGeometry, buildTorusGeometry, buildVectorTextGeometry, getKTX2TextureTranscoder, load3DSGeometry, loadOBJGeometry, math, sRGBEncoding, stats, utils };